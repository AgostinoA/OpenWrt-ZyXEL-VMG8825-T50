diff -Naur net-snmp-5.7.2-orig/agent/helpers/Makefile.in net-snmp-5.7.2/agent/helpers/Makefile.in
--- net-snmp-5.7.2-orig/agent/helpers/Makefile.in	2012-10-10 06:28:58.000000000 +0800
+++ net-snmp-5.7.2/agent/helpers/Makefile.in	2014-01-20 14:57:24.095236954 +0800
@@ -35,4 +35,4 @@
 
 libnetsnmphelpers.$(LIB_EXTENSION)$(LIB_VERSION):    $(LOBJS)
 	$(LIB_LD_CMD) $@ $(LOBJS) @LD_NO_UNDEFINED@ $(LDFLAGS) $(LIB_LD_LIBS)
-	$(RANLIB) $@
+#	$(RANLIB) $@
diff -Naur net-snmp-5.7.2-orig/agent/Makefile.in net-snmp-5.7.2/agent/Makefile.in
--- net-snmp-5.7.2-orig/agent/Makefile.in	2012-10-10 06:28:58.000000000 +0800
+++ net-snmp-5.7.2/agent/Makefile.in	2014-01-20 14:52:07.183238068 +0800
@@ -298,11 +298,11 @@
 
 libnetsnmpagent.$(LIB_EXTENSION)$(LIB_VERSION):    ${LLIBAGENTOBJS} $(USELIBS)
 	$(LIB_LD_CMD) $(AGENTLIB) ${LLIBAGENTOBJS} $(USELIBS) ${LAGENTLIBS} @LD_NO_UNDEFINED@ $(LDFLAGS) $(PERLLDOPTS_FOR_LIBS) $(LIB_LD_LIBS) @AGENTLIBS@
-	$(RANLIB) $(AGENTLIB)
+#	$(RANLIB) $(AGENTLIB)
 
 libnetsnmpmibs.$(LIB_EXTENSION)$(LIB_VERSION): ${LMIBOBJS} $(AGENTLIB) $(USELIBS)
 	$(LIB_LD_CMD) $(MIBLIB) ${LMIBOBJS} $(AGENTLIB) $(USELIBS) @LD_NO_UNDEFINED@ $(LDFLAGS) ${LMIBLIBS} $(PERLLDOPTS_FOR_LIBS) $(LIB_LD_LIBS) @AGENTLIBS@
-	$(RANLIB) $(MIBLIB)
+#	$(RANLIB) $(MIBLIB)
 
 agentlib: $(AGENTLIB)
 
diff -Naur net-snmp-5.7.2-orig/agent/mibgroup/disman/mteTriggerTable.c net-snmp-5.7.2/agent/mibgroup/disman/mteTriggerTable.c
--- net-snmp-5.7.2-orig/agent/mibgroup/disman/mteTriggerTable.c	2012-10-10 06:28:58.000000000 +0800
+++ net-snmp-5.7.2/agent/mibgroup/disman/mteTriggerTable.c	2013-11-26 14:01:45.122817000 +0800
@@ -469,7 +469,7 @@
                      */
                     return;
                 }
-                StorageNew->mteTriggerFrequency = (unsigend long) freq;
+                StorageNew->mteTriggerFrequency = (unsigned long) freq;
             } else {
                 config_perror("No parameter after -r given\n");
                 /*
diff -Naur net-snmp-5.7.2-orig/agent/mibgroup/if-mib/data_access/interface_ioctl.c net-snmp-5.7.2/agent/mibgroup/if-mib/data_access/interface_ioctl.c
--- net-snmp-5.7.2-orig/agent/mibgroup/if-mib/data_access/interface_ioctl.c	2012-10-10 06:28:58.000000000 +0800
+++ net-snmp-5.7.2/agent/mibgroup/if-mib/data_access/interface_ioctl.c	2013-11-26 14:01:45.122817000 +0800
@@ -137,6 +137,28 @@
             /*
              * arphrd defines vary greatly. ETHER seems to be the only common one
              */
+#if defined(BROADCOM) //__ZYXEL__, Mark
+			typedef struct _match_if {
+               int             mi_type;
+               const char     *mi_name;
+            } *pmatch_if, match_if;
+            
+            static match_if lmatch_if[] = {
+                {IANAIFTYPE_VDSL, "ptm"},
+				{IANAIFTYPE_ADSL, "atm"},
+				{IANAIFTYPE_IEEE80211, "wl"},
+				{IANAIFTYPE_BRIDGE, "br"},
+                {0, NULL}                  /* end of list */
+            };
+			pmatch_if pm;
+			for (pm = lmatch_if; pm->mi_name; pm++) {
+                if (0 == strncmp(ifentry->name, pm->mi_name, strlen(pm->mi_name))) {
+                    ifentry->type = pm->mi_type;
+                    break;
+                }
+            }
+            if(NULL == pm->mi_name)
+#endif
 #ifdef ARPHRD_ETHER
             switch (ifrq.ifr_hwaddr.sa_family) {
             case ARPHRD_ETHER:
@@ -221,6 +243,29 @@
 }
 #endif /* SIOCGIFHWADDR */
 
+#if defined(BROADCOM) //__ZYXEL__, Mark
+char *baseIfName(char *_if, char *name){
+	if(_if == NULL) return NULL;
+	char *tmp, len;
+
+	if((tmp = strchr(_if, ':')) != NULL) ;
+	else if((tmp = strchr(_if, '.')) != NULL) ;
+
+	if(name != NULL){
+		if(tmp != NULL) len = tmp - _if;
+		else len = strlen(_if);
+		
+		strncpy(name, _if, len);
+		*(name+len) = '\0';
+		return name;
+	}
+	else{
+		if(tmp != NULL)
+			*tmp = '\0';
+		return _if;
+	}	
+}
+#endif
 
 #ifdef SIOCGIFFLAGS
 /**
@@ -242,6 +287,10 @@
     int rc = 0;
 
     DEBUGMSGTL(("access:interface:ioctl", "flags_get\n"));
+#if defined(BROADCOM) //__ZYXEL__, Mark
+	char cmd[256], ifname[50];
+	FILE *pfd;
+#endif	
 
     rc = _ioctl_get(fd, SIOCGIFFLAGS, &ifrq, ifentry->name);
     if (rc < 0) {
@@ -258,6 +307,41 @@
          */
         if(ifentry->os_flags & IFF_UP) {
             ifentry->admin_status = IFADMINSTATUS_UP;
+#if defined(BROADCOM) //__ZYXEL__, Mark
+			if(strncmp(ifentry->name, "eth", 3) == 0){
+				strncpy(ifname, ifentry->name, sizeof(ifname));
+				ifentry->oper_status = IFOPERSTATUS_DOWN;
+				ifentry->os_flags &= ~IFF_RUNNING;
+				sprintf(cmd, "ethctl %s media-type", baseIfName(ifname, NULL));
+				pfd = popen(cmd, "r");
+				while((fgets(cmd, sizeof(cmd), pfd)) != NULL) {
+					if(strstr(cmd, "Link is up") != NULL ){
+						ifentry->oper_status = IFOPERSTATUS_UP;
+						ifentry->os_flags |= IFF_RUNNING;
+					}
+				}
+				pclose(pfd);
+			}
+			else if(strncmp(ifentry->name, "wl", 2) == 0){
+				sprintf(ifname, "%s_bss_enabled", ifentry->name);
+				sprintf(cmd, "nvram show | grep %s", ifname);
+				pfd = popen(cmd, "r");
+				ifentry->oper_status = IFOPERSTATUS_DOWN;
+				ifentry->os_flags &= ~IFF_RUNNING;
+				if(fgets(cmd, sizeof(cmd), pfd) != NULL){
+					char wl_up;
+					if(strstr(cmd, ifname) != NULL ){
+						wl_up = *(cmd + strlen(ifname) + 1);
+						if(wl_up == '1'){
+							ifentry->oper_status = IFOPERSTATUS_UP;
+							ifentry->os_flags |= IFF_RUNNING;
+						}
+					}
+				}
+				pclose(pfd);
+			}
+			else
+#endif
             if(ifentry->os_flags & IFF_RUNNING)
                 ifentry->oper_status = IFOPERSTATUS_UP;
             else
@@ -281,7 +365,6 @@
             ifentry->connector_present = 1;
         }
     }
-    
     return rc;
 }
 
diff -Naur net-snmp-5.7.2-orig/agent/mibgroup/if-mib/data_access/interface_ioctl.h net-snmp-5.7.2/agent/mibgroup/if-mib/data_access/interface_ioctl.h
--- net-snmp-5.7.2-orig/agent/mibgroup/if-mib/data_access/interface_ioctl.h	2012-10-10 06:28:58.000000000 +0800
+++ net-snmp-5.7.2/agent/mibgroup/if-mib/data_access/interface_ioctl.h	2013-11-26 14:01:45.122817000 +0800
@@ -44,7 +44,9 @@
                                         int if_index, u_int *flags);
 
 /**---------------------------------------------------------------------*/
-
+#if defined(BROADCOM) //__ZYXEL__, Mark
+char *baseIfName(char *_if, char *name);
+#endif
 # ifdef __cplusplus
 }
 #endif
diff -Naur net-snmp-5.7.2-orig/agent/mibgroup/if-mib/data_access/interface_linux.c net-snmp-5.7.2/agent/mibgroup/if-mib/data_access/interface_linux.c
--- net-snmp-5.7.2-orig/agent/mibgroup/if-mib/data_access/interface_linux.c	2012-10-10 06:28:58.000000000 +0800
+++ net-snmp-5.7.2/agent/mibgroup/if-mib/data_access/interface_linux.c	2013-11-26 18:59:34.584964000 +0800
@@ -81,11 +81,16 @@
 unsigned long long
 netsnmp_linux_interface_get_if_speed(int fd, const char *name,
         unsigned long long defaultspeed);
+#if defined(BROADCOM)
+unsigned long long
+netsnmp_linux_interface_get_if_speed_linux(int fd, const char *name,
+        unsigned long long defaultspeed);
 #ifdef HAVE_LINUX_ETHTOOL_H
 unsigned long long
 netsnmp_linux_interface_get_if_speed_mii(int fd, const char *name,
         unsigned long long defaultspeed);
 #endif
+#endif
 
 #define PROC_SYS_NET_IPVx_NEIGH_RETRANS_TIME_MS "/proc/sys/net/ipv%d/neigh/%s/retrans_time_ms"
 #define PROC_SYS_NET_IPVx_NEIGH_RETRANS_TIME    "/proc/sys/net/ipv%d/neigh/%s/retrans_time"
@@ -418,6 +423,43 @@
 static int
 _parse_stats(netsnmp_interface_entry *entry, char *stats, int expected)
 {
+#if defined(BROADCOM) //__ZYXEL__, Mark
+	/*
+     * scanline_2_2:
+	 *  {                                    Basic Statistics                                         }|{              Extended Statistics                      }
+     *  [               IN                        ]|[               OUT                               ]|[       multicast    ]|[ unicast ]|[ broadcast ]|[ unkn ]
+     *   byte pkts errs drop fifo frame cmprs mcst | byte pkts errs drop fifo colls carrier compressed | txpckt rxbyte txbyte | rx   tx   | rx    tx    | rxerr
+	 *   
+     */
+#ifdef SCNuMAX
+	uintmax_t   rec_pkt, rec_oct, rec_err, rec_drop, rec_mcast;
+    uintmax_t   snd_pkt, snd_oct, snd_err, snd_drop, coll;
+	uintmax_t   snd_mcast, rec_mcast_byte, snd_mcast_byte;
+	uintmax_t   rec_ucast, snd_ucast;
+	uintmax_t   rec_bcast, snd_bcast;
+    const char     *scan_line_2_2 =
+		"%"   SCNuMAX " %"  SCNuMAX " %"  SCNuMAX " %"  SCNuMAX
+        " %*" SCNuMAX " %*" SCNuMAX " %*" SCNuMAX " %"  SCNuMAX
+        " %"  SCNuMAX " %"  SCNuMAX " %"  SCNuMAX " %"  SCNuMAX
+        " %*" SCNuMAX " %"  SCNuMAX " %*" SCNuMAX " %*" SCNuMAX
+		" %"  SCNuMAX " %"  SCNuMAX " %"  SCNuMAX " %"  SCNuMAX
+		" %"  SCNuMAX " %"  SCNuMAX " %"  SCNuMAX;
+    const char     *scan_line_2_0 =
+        "%"   SCNuMAX " %"  SCNuMAX " %*" SCNuMAX " %*" SCNuMAX
+        " %*" SCNuMAX " %"  SCNuMAX " %"  SCNuMAX " %*" SCNuMAX
+        " %*" SCNuMAX " %"  SCNuMAX;
+#else
+	unsigned long   rec_pkt, rec_oct, rec_err, rec_drop, rec_mcast;
+    unsigned long   snd_pkt, snd_oct, snd_err, snd_drop, coll;
+	unsigned long   snd_mcast, rec_mcast_byte, snd_mcast_byte;
+	unsigned long 	rec_ucast, snd_ucast;
+	unsigned long   rec_bcast, snd_bcast;
+    const char     *scan_line_2_2 =
+        "%lu %lu %lu %lu %*lu %*lu %*lu %lu %lu %lu %lu %lu %*lu %lu %*lu %*lu %lu %lu %lu %lu %lu %lu %lu";
+    const char     *scan_line_2_0 =
+        "%lu %lu %*lu %*lu %*lu %lu %lu %*lu %*lu %lu";
+#endif
+#else
     /*
      * scanline_2_2:
      *  [               IN                        ]
@@ -445,9 +487,15 @@
     const char     *scan_line_2_0 =
         "%lu %lu %*lu %*lu %*lu %lu %lu %*lu %*lu %lu";
 #endif
+#endif
     static const char     *scan_line_to_use = NULL;
     int             scan_count;
 
+#if defined(BROADCOM) //__ZYXEL__, Mark
+	if (17 == expected)
+        scan_line_to_use = scan_line_2_2;
+	else
+#endif
     if (10 == expected)
         scan_line_to_use = scan_line_2_2;
     else {
@@ -455,6 +503,7 @@
         scan_line_to_use = scan_line_2_0;
     }
 
+
     while (*stats == ' ')
         stats++;
 
@@ -471,11 +520,23 @@
      */
     rec_pkt = rec_oct = rec_err = rec_drop = rec_mcast = 0;
     snd_pkt = snd_oct = snd_err = snd_drop = coll = 0;
+#if defined(BROADCOM) //__ZYXEL__, Mark
+	snd_mcast = rec_mcast_byte = snd_mcast_byte = rec_ucast = snd_ucast = rec_bcast = snd_bcast = 0;
+#endif	
     if (scan_line_to_use == scan_line_2_2) {
+#if defined(BROADCOM) //__ZYXEL__, Mark
+		scan_count = sscanf(stats, scan_line_to_use,
+                            &rec_oct, &rec_pkt, &rec_err, &rec_drop, &rec_mcast,
+                            &snd_oct, &snd_pkt, &snd_err, &snd_drop, &coll, 
+							&snd_mcast, &rec_mcast_byte, &snd_mcast_byte,
+							&rec_ucast, &snd_ucast,
+							&rec_bcast, &snd_bcast);
+#else
         scan_count = sscanf(stats, scan_line_to_use,
                             &rec_oct, &rec_pkt, &rec_err, &rec_drop, &rec_mcast,
                             &snd_oct, &snd_pkt, &snd_err, &snd_drop,
                             &coll);
+#endif
         if (scan_count == expected) {
             entry->ns_flags |= NETSNMP_INTERFACE_FLAGS_HAS_BYTES;
             entry->ns_flags |= NETSNMP_INTERFACE_FLAGS_HAS_DROPS;
@@ -523,12 +584,27 @@
     entry->stats.imcast.low = rec_mcast & 0xffffffff;
     entry->stats.obytes.low = snd_oct & 0xffffffff;
     entry->stats.oucast.low = snd_pkt & 0xffffffff;
+#if defined(BROADCOM) //__ZYXEL__, Mark	
+	entry->stats.ibcast.low = rec_bcast & 0xffffffff;
+	entry->stats.omcast.low = snd_mcast & 0xffffffff;
+	entry->stats.obcast.low = snd_bcast & 0xffffffff;
+	entry->stats.iucast.low = rec_ucast & 0xffffffff;
+	entry->stats.oucast.low = snd_ucast & 0xffffffff;
+#endif
+
 #ifdef SCNuMAX   /* XXX - should be flag for 64-bit variables */
     entry->stats.ibytes.high = rec_oct >> 32;
     entry->stats.iall.high = rec_pkt >> 32;
     entry->stats.imcast.high = rec_mcast >> 32;
     entry->stats.obytes.high = snd_oct >> 32;
     entry->stats.oucast.high = snd_pkt >> 32;
+#if defined(BROADCOM) //__ZYXEL__, Mark
+	entry->stats.ibcast.high = rec_bcast >> 32;
+	entry->stats.omcast.high = snd_mcast >> 32;
+	entry->stats.obcast.high = snd_bcast >> 32;
+	entry->stats.iucast.high = rec_ucast >> 32;
+	entry->stats.oucast.high = snd_ucast >> 32;
+#endif
 #endif
     entry->stats.ierrors   = rec_err;
     entry->stats.idiscards = rec_drop;
@@ -612,8 +688,16 @@
      */
     fgets(line, sizeof(line), devin);
     fgets(line, sizeof(line), devin);
+#if defined(BROADCOM) //__ZYXEL__, Mark
+	 fgets(line, sizeof(line), devin);
+#endif
 
     if( 0 == scan_expected ) {
+#if defined(BROADCOM) //__ZYXEL__, Mark
+		scan_expected = 17;
+		DEBUGMSGTL(("access:interface",
+					"using linux 2.6 kernel(Broadcom) /proc/net/dev \n"));
+#else
         if (strstr(line, "compressed")) {
             scan_expected = 10;
             DEBUGMSGTL(("access:interface",
@@ -623,6 +707,7 @@
             DEBUGMSGTL(("access:interface",
                         "using linux 2.0 kernel /proc/net/dev\n"));
         }
+#endif
     }
 
     /*
@@ -647,7 +732,11 @@
                      "interface data format error 1, line ==|%s|\n", line);
             continue;
         }
+#if defined(BROADCOM) //__ZYXEL__, Mark
+		if ((scan_expected == 17) && ((stats - line) < 6)) {
+#else
         if ((scan_expected == 10) && ((stats - line) < 6)) {
+#endif
             snmp_log(LOG_ERR,
                      "interface data format error 2 (%d < 6), line ==|%s|\n",
                      (int)(stats - line), line);
@@ -699,6 +788,19 @@
             close(fd);
             return -3;
         }
+#if defined(BROADCOM) //__ZYXEL__, Mark
+		static char *_notShown_if[] = {"bcmsw", "ifb", "dsl0", "sit", "ip6tnl"};
+		int nif;
+		for(nif = 0; nif < (sizeof(_notShown_if)/sizeof(char*)); nif++){
+			if (0 == strncmp(entry->name, _notShown_if[nif], strlen(_notShown_if[nif]))) {
+				break;
+			}
+		}
+		if(nif < (sizeof(_notShown_if)/sizeof(char*))){
+			netsnmp_access_interface_entry_free(entry);
+			continue;
+		}
+#endif
         entry->ns_flags = flags; /* initial flags; we'll set more later */
 
 #ifdef HAVE_PCI_LOOKUP_NAME
@@ -757,6 +859,12 @@
          * interface identifier is specified based on physaddr and type
          */
         switch (entry->type) {
+#if defined(BROADCOM) //__ZYXEL__, Mark
+		case IANAIFTYPE_ADSL:
+		case IANAIFTYPE_VDSL:
+		case IANAIFTYPE_IEEE80211:
+		case IANAIFTYPE_BRIDGE:
+#endif
         case IANAIFTYPE_ETHERNETCSMACD:
         case IANAIFTYPE_ETHERNET3MBIT:
         case IANAIFTYPE_FASTETHER:
@@ -783,23 +891,32 @@
             break;
         }
 
+		netsnmp_access_interface_ioctl_flags_get(fd, entry);
+		
+#if defined(BROADCOM) //__ZYXEL__, Mark
+		if (IANAIFTYPE_ETHERNETCSMACD == entry->type || IANAIFTYPE_VDSL == entry->type ||
+			IANAIFTYPE_ADSL == entry->type || IANAIFTYPE_IEEE80211 == entry->type || 
+			IANAIFTYPE_BRIDGE == entry->type
+		) {
+#else
         if (IANAIFTYPE_ETHERNETCSMACD == entry->type) {
+#endif
             unsigned long long speed;
             unsigned long long defaultspeed = NOMINAL_LINK_SPEED;
-            if (!(entry->os_flags & IFF_RUNNING)) {
-                /*
-                 * use speed 0 if the if speed cannot be determined *and* the
-                 * interface is down
-                 */
+			if (!(entry->os_flags & IFF_RUNNING)) {
+                entry->speed = 0;
+				entry->speed_high = 0;
+            } 
+			else{
                 defaultspeed = 0;
+				speed = netsnmp_linux_interface_get_if_speed(fd,
+						entry->name, defaultspeed);
+				if (speed > 0xffffffffL) {
+					entry->speed = 0xffffffff;
+				} else
+					entry->speed = speed;
+				entry->speed_high = speed / 1000000LL;
             }
-            speed = netsnmp_linux_interface_get_if_speed(fd,
-                    entry->name, defaultspeed);
-            if (speed > 0xffffffffL) {
-                entry->speed = 0xffffffff;
-            } else
-                entry->speed = speed;
-            entry->speed_high = speed / 1000000LL;
         }
 #ifdef APPLIED_PATCH_836390   /* xxx-rks ifspeed fixes */
         else if (IANAIFTYPE_PROPVIRTUAL == entry->type)
@@ -807,8 +924,6 @@
 #endif
         else
             netsnmp_access_interface_entry_guess_speed(entry);
-        
-        netsnmp_access_interface_ioctl_flags_get(fd, entry);
 
         netsnmp_access_interface_ioctl_mtu_get(fd, entry);
 
@@ -886,13 +1001,73 @@
 }
 #endif /* NETSNMP_FEATURE_REMOVE_INTERFACE_ARCH_SET_ADMIN_STATUS */
 
+#if defined(BROADCOM) //__ZYXEL__, Mark
+unsigned long long
+netsnmp_linux_interface_get_if_speed(int fd, const char *name,
+            unsigned long long defaultspeed)
+{
+	char cmd[256], ifname[50];
+	FILE *pfd;
+	unsigned long long speed = defaultspeed;
+
+	if(strncmp(name, "eth", 3) == 0){
+		strncpy(ifname, name, sizeof(ifname));
+		sprintf(cmd, "ethctl %s media-type", baseIfName(ifname, NULL));
+		pfd = popen(cmd, "r");
+		while((fgets(cmd, sizeof(cmd), pfd)) != NULL) {
+			if(strstr(cmd, " Speed fixed at") != NULL ){
+				sscanf(cmd," Speed fixed at %d%*s", &speed);
+				break;
+			}
+			else if(strstr(cmd, "The autonegotiated media type is") != NULL ){
+				sscanf(cmd, "The autonegotiated media type is %llu%*s", &speed);
+				break;
+			}
+		}
+		pclose(pfd);
+		return speed * 1000LL * 1000LL;
+	}
+	else if(strncmp(name, "ptm", 3) == 0 || strncmp(name, "atm", 3) == 0){
+		sprintf(cmd, "xdslctl info");
+		pfd = popen(cmd, "r");
+		while((fgets(cmd, sizeof(cmd), pfd)) != NULL) {
+			if(strstr(cmd, "Bearer:") != NULL ){
+				sscanf(cmd, "Bearer: %*d, Upstream rate = %*d Kbps, Downstream rate = %llu Kbps", &speed);
+				break;
+			}
+		}
+		pclose(pfd);
+		return speed * 1000LL;;
+	}
+	else if(strncmp(name, "wl", 2) == 0){
+		sprintf(cmd, "wl rate");
+		pfd = popen(cmd, "r");
+		if(fgets(cmd, sizeof(cmd), pfd) != NULL){
+			sscanf(cmd, "%llu Mbps", &speed);
+		}
+		pclose(pfd);
+		return speed * 1000LL * 1000LL;
+	}
+	else if(strncmp(name, "br", 2) == 0){
+		speed = 1000;
+		return speed * 1000LL * 1000LL;
+	}
+	else return netsnmp_linux_interface_get_if_speed_linux(fd, name, defaultspeed);
+}
+#endif
 #ifdef HAVE_LINUX_ETHTOOL_H
 /**
  * Determines network interface speed from ETHTOOL_GSET
  */
+#if defined(BROADCOM)
+unsigned long long
+netsnmp_linux_interface_get_if_speed_linux(int fd, const char *name,
+            unsigned long long defaultspeed)
+#else
 unsigned long long
 netsnmp_linux_interface_get_if_speed(int fd, const char *name,
             unsigned long long defaultspeed)
+#endif
 {
     int ret;
     struct ifreq ifr;
@@ -937,9 +1112,15 @@
 netsnmp_linux_interface_get_if_speed_mii(int fd, const char *name,
         unsigned long long  defaultspeed)
 #else
+#if defined(BROADCOM)
+unsigned long long
+netsnmp_linux_interface_get_if_speed_linux(int fd, const char *name,
+            unsigned long long defaultspeed)
+#else
 netsnmp_linux_interface_get_if_speed(int fd, const char *name,
         unsigned long long defaultspeed)
 #endif
+#endif
 {
     unsigned long long retspeed = defaultspeed;
     struct ifreq ifr;
@@ -1024,6 +1205,7 @@
     }
     return retspeed;
 }
+
 #ifdef SUPPORT_PREFIX_FLAGS
 void netsnmp_prefix_process(int fd, void *data);
 
diff -Naur net-snmp-5.7.2-orig/agent/mibgroup/ZYXEL-PRESTIGE-MIB/deviceConfig.c net-snmp-5.7.2/agent/mibgroup/ZYXEL-PRESTIGE-MIB/deviceConfig.c
--- net-snmp-5.7.2-orig/agent/mibgroup/ZYXEL-PRESTIGE-MIB/deviceConfig.c	1970-01-01 08:00:00.000000000 +0800
+++ net-snmp-5.7.2/agent/mibgroup/ZYXEL-PRESTIGE-MIB/deviceConfig.c	2013-10-08 09:35:17.626117000 +0800
@@ -0,0 +1,88 @@
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *        : mib2c.scalar.conf 11805 2005-01-07 09:37:18Z dts12 $
+ */
+
+#include <net-snmp/net-snmp-config.h>
+#include <net-snmp/net-snmp-includes.h>
+#include <net-snmp/agent/net-snmp-agent-includes.h>
+#include "deviceConfig.h"
+
+/** Initializes the deviceConfig module */
+void
+init_deviceConfig(void)
+{
+    static oid persistentData_oid[] = { PRESTIGE_DEVCONF_OID, 1 };
+
+	DEBUGMSGTL(("deviceConfig", "Initializing\n"));
+
+	netsnmp_register_scalar(
+		netsnmp_create_handler_registration("persistentData", handle_persistentData,
+							   persistentData_oid, OID_LENGTH(persistentData_oid),
+							   HANDLER_CAN_RWRITE
+		));
+}
+
+int
+handle_persistentData(netsnmp_mib_handler *handler,
+                          netsnmp_handler_registration *reginfo,
+                          netsnmp_agent_request_info   *reqinfo,
+                          netsnmp_request_info         *requests)
+{  
+    int ret=SNMP_ERR_NOERROR;
+	switch(reqinfo->mode) {
+		case MODE_GET:
+		case MODE_GETBULK:
+			ret=handleOfGetParameter(IGD_Device, "DeviceSummary", requests,ASN_OCTET_STR);
+			break;
+#if 1
+        /*
+         * SET REQUEST
+         *
+         * multiple states in the transaction.  See:
+         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
+         */
+        case MODE_SET_RESERVE1:
+                /* or you could use netsnmp_check_vb_type_and_size instead */
+            ret = netsnmp_check_vb_type(requests->requestvb, ASN_OCTET_STR);
+            if ( ret != SNMP_ERR_NOERROR ) {
+                netsnmp_set_request_error(reqinfo, requests, ret );
+            }
+            break;
+
+        case MODE_SET_RESERVE2:
+            /* XXX malloc "undo" storage buffer */
+            
+            break;
+
+        case MODE_SET_FREE:
+            /* XXX: free resources allocated in RESERVE1 and/or
+               RESERVE2.  Something failed somewhere, and the states
+               below won't be called. */
+            break;
+
+        case MODE_SET_ACTION:
+            /* XXX: perform the value change here */
+			ret=handleOfSetParameter(IGD_Device, "DeviceSummary", requests);
+            if (ret) {
+                netsnmp_set_request_error(reqinfo, requests,ret /* some error */);
+            }
+            break;
+
+        case MODE_SET_COMMIT:
+            /* XXX: delete temporary storage */
+            break;
+
+        case MODE_SET_UNDO:
+            /* XXX: UNDO and return to previous value for the object */
+            
+            break;
+#endif
+        default:
+            /* we should never get here, so this is a really bad error */
+            snmp_log(LOG_ERR, "unknown mode (%d) in handle_persistentData\n", reqinfo->mode );
+            return SNMP_ERR_GENERR;
+    }
+
+    return ret;
+}
diff -Naur net-snmp-5.7.2-orig/agent/mibgroup/ZYXEL-PRESTIGE-MIB/deviceConfig.h net-snmp-5.7.2/agent/mibgroup/ZYXEL-PRESTIGE-MIB/deviceConfig.h
--- net-snmp-5.7.2-orig/agent/mibgroup/ZYXEL-PRESTIGE-MIB/deviceConfig.h	1970-01-01 08:00:00.000000000 +0800
+++ net-snmp-5.7.2/agent/mibgroup/ZYXEL-PRESTIGE-MIB/deviceConfig.h	2013-10-08 09:35:17.626117000 +0800
@@ -0,0 +1,16 @@
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *        : mib2c.scalar.conf 11805 2005-01-07 09:37:18Z dts12 $
+ */
+#ifndef DEVICECONFIG_H
+#define DEVICECONFIG_H
+#include "zylib.h"
+
+/* function declarations */
+void init_deviceConfig(void);
+Netsnmp_Node_Handler handle_persistentData;
+config_require(ZYXEL-PRESTIGE-MIB/zylib);
+
+#define PRESTIGE_DEVCONF_OID PRESTIGE_COMM_OID, 7
+
+#endif /* DEVICECONFIG_H */
diff -Naur net-snmp-5.7.2-orig/agent/mibgroup/ZYXEL-PRESTIGE-MIB/deviceSummary.c net-snmp-5.7.2/agent/mibgroup/ZYXEL-PRESTIGE-MIB/deviceSummary.c
--- net-snmp-5.7.2-orig/agent/mibgroup/ZYXEL-PRESTIGE-MIB/deviceSummary.c	1970-01-01 08:00:00.000000000 +0800
+++ net-snmp-5.7.2/agent/mibgroup/ZYXEL-PRESTIGE-MIB/deviceSummary.c	2013-10-08 09:35:17.626117000 +0800
@@ -0,0 +1,42 @@
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *        : mib2c.scalar.conf 11805 2005-01-07 09:37:18Z dts12 $
+ */
+
+#include <net-snmp/net-snmp-config.h>
+#include <net-snmp/net-snmp-includes.h>
+#include <net-snmp/agent/net-snmp-agent-includes.h>
+#include "deviceSummary.h"
+
+/** Initializes the deviceSummary module */
+void
+init_deviceSummary(void)
+{
+    static oid deviceSummary_oid[] = { PRESTIGE_DEVSUM_OID};
+	DEBUGMSGTL(("deviceSummary", "Initializing\n"));
+	netsnmp_register_scalar(
+		netsnmp_create_handler_registration("deviceSummary", handle_deviceSummary,
+							   deviceSummary_oid, OID_LENGTH(deviceSummary_oid),
+							   HANDLER_CAN_RONLY
+		));
+}
+
+int
+handle_deviceSummary(netsnmp_mib_handler *handler,
+                          netsnmp_handler_registration *reginfo,
+                          netsnmp_agent_request_info   *reqinfo,
+                          netsnmp_request_info         *requests)
+{
+	int ret=SNMP_ERR_NOERROR;
+	switch(reqinfo->mode) {
+		case MODE_GET:
+		case MODE_GETBULK:
+			ret=handleOfGetParameter(IGD_Device, "DeviceSummary", requests,ASN_OCTET_STR);
+			break;
+		default:
+			snmp_log(LOG_ERR, "unknown mode (%d) in %s\n", reqinfo->mode,__FUNCTION__ );
+			return SNMP_ERR_GENERR;
+	}
+	
+	return ret;
+}
diff -Naur net-snmp-5.7.2-orig/agent/mibgroup/ZYXEL-PRESTIGE-MIB/deviceSummary.h net-snmp-5.7.2/agent/mibgroup/ZYXEL-PRESTIGE-MIB/deviceSummary.h
--- net-snmp-5.7.2-orig/agent/mibgroup/ZYXEL-PRESTIGE-MIB/deviceSummary.h	1970-01-01 08:00:00.000000000 +0800
+++ net-snmp-5.7.2/agent/mibgroup/ZYXEL-PRESTIGE-MIB/deviceSummary.h	2013-10-08 09:35:17.626117000 +0800
@@ -0,0 +1,16 @@
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *        : mib2c.scalar.conf 11805 2005-01-07 09:37:18Z dts12 $
+ */
+#ifndef DEVICESUMMARY_H
+#define DEVICESUMMARY_H
+
+#include "zylib.h"
+/* function declarations */
+void init_deviceSummary(void);
+Netsnmp_Node_Handler handle_deviceSummary;
+config_require(ZYXEL-PRESTIGE-MIB/zylib);
+
+#define PRESTIGE_DEVSUM_OID PRESTIGE_COMM_OID, 9
+
+#endif /* DEVICESUMMARY_H */
diff -Naur net-snmp-5.7.2-orig/agent/mibgroup/ZYXEL-PRESTIGE-MIB/filterRuleTable_access.c net-snmp-5.7.2/agent/mibgroup/ZYXEL-PRESTIGE-MIB/filterRuleTable_access.c
--- net-snmp-5.7.2-orig/agent/mibgroup/ZYXEL-PRESTIGE-MIB/filterRuleTable_access.c	1970-01-01 08:00:00.000000000 +0800
+++ net-snmp-5.7.2/agent/mibgroup/ZYXEL-PRESTIGE-MIB/filterRuleTable_access.c	2013-10-08 09:35:17.626117000 +0800
@@ -0,0 +1,869 @@
+
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *        : mib2c.access_functions.conf 11358 2004-10-14 12:57:34Z dts12 $
+ */
+
+#include <net-snmp/net-snmp-config.h>
+#include <net-snmp/net-snmp-includes.h>
+#include <net-snmp/agent/net-snmp-agent-includes.h>
+#include "filterRuleTable_access.h"
+#include "filterRuleTable_enums.h"
+
+
+
+/***************************************
+*******
+*			BEGIN brian add structure and some needed funtions
+*******
+***************************************/
+
+
+#include "ccclib.h"
+
+typedef struct filterRuleTable_entry{
+	/* Index values */
+   
+
+    /* Column values */
+    long filterRuleIndex;
+    long filterKey;
+    long filterEnable;
+    long filterBridgeReference;
+    long exclusivityOrder;
+    char filterInterface[17];
+    long vlanIDFilter;
+    long admitOnlyVLANTagged;
+    char ethertypeFilterList[257];
+    long ethertypeFilterExclude;
+    char sourceMACAddressFilterList[513];
+    long sourceMACAddressFilterExclude;
+    char destMACAddressFilterList[513];
+    long destMACAddressFilterExclude;
+    char srcMACFromVendorClassIDFilter[257];
+    long srcMACFromVendorClassIDFilterExclude;
+    char destMACFromVendorClassIDFilter[257];
+    long destMACFromVendorClassIDFilterExclude;
+    char srcMACFromClientIDFilter[257];
+    long srcMACFromClientIDFilterExclude;
+    char destMACFromClientIDFilter[257];
+    long destMACFromClientIDFilterExclude;
+    char srcMACFromUserClassIDFilter[257];
+    long srcMACFromUserClassIDFilterExclude;
+    char destMACFromUserClassIDFilter[257];
+    long destMACFromUserClassIDFilterExclude;
+    /* Illustrate using a simple linked list */
+    struct filterRuleTable_entry *next;
+}filterRuleTable_entry_t;
+
+
+
+struct filterRuleTable_entry  *filterRuleTable_head;
+
+/* create a new row in the (unsorted) table */
+struct filterRuleTable_entry *
+filterRuleTable_createEntry(
+                 long  filterRuleIndex,
+                 long filterKey,
+    long filterEnable,
+    long filterBridgeReference,
+    long exclusivityOrder,
+    char filterInterface[17],
+    long vlanIDFilter,
+    long admitOnlyVLANTagged,
+    char ethertypeFilterList[257],
+    long ethertypeFilterExclude,
+    char sourceMACAddressFilterList[513],
+    long sourceMACAddressFilterExclude,
+    char destMACAddressFilterList[513],
+    long destMACAddressFilterExclude,
+    char srcMACFromVendorClassIDFilter[257],
+    long srcMACFromVendorClassIDFilterExclude,
+    char destMACFromVendorClassIDFilter[257],
+    long destMACFromVendorClassIDFilterExclude,
+    char srcMACFromClientIDFilter[257],
+    long srcMACFromClientIDFilterExclude,
+    char destMACFromClientIDFilter[257],
+    long destMACFromClientIDFilterExclude,
+    char srcMACFromUserClassIDFilter[257],
+    long srcMACFromUserClassIDFilterExclude,
+    char destMACFromUserClassIDFilter[257],
+    long destMACFromUserClassIDFilterExclude
+                 
+                ) {
+    struct filterRuleTable_entry *entry;
+
+    entry = SNMP_MALLOC_TYPEDEF(struct filterRuleTable_entry);
+    if (!entry)
+        return NULL;
+
+    entry->filterRuleIndex = filterRuleIndex;
+entry->filterKey=filterKey;
+entry->filterEnable=filterEnable;
+entry->filterBridgeReference=filterBridgeReference;
+entry->exclusivityOrder=exclusivityOrder;
+strcpy(entry->filterInterface,filterInterface);
+entry->vlanIDFilter=vlanIDFilter;
+entry->admitOnlyVLANTagged=admitOnlyVLANTagged;
+strcpy(entry->ethertypeFilterList,ethertypeFilterList);
+entry->sourceMACAddressFilterExclude=sourceMACAddressFilterExclude;
+strcpy(entry->destMACAddressFilterList,destMACAddressFilterList);
+entry->destMACAddressFilterExclude=destMACAddressFilterExclude;
+strcpy(entry->srcMACFromVendorClassIDFilter,srcMACFromVendorClassIDFilter);
+entry->srcMACFromVendorClassIDFilterExclude=srcMACFromVendorClassIDFilterExclude;
+strcpy(entry->destMACFromVendorClassIDFilter,destMACFromVendorClassIDFilter);
+entry->destMACFromVendorClassIDFilterExclude=destMACFromVendorClassIDFilterExclude;
+strcpy(entry->srcMACFromClientIDFilter,srcMACFromClientIDFilter);
+entry->srcMACFromClientIDFilterExclude=srcMACFromClientIDFilterExclude;
+strcpy(entry->destMACFromClientIDFilter,destMACFromClientIDFilter);
+entry->destMACFromClientIDFilterExclude=destMACFromClientIDFilterExclude;
+strcpy(entry->srcMACFromUserClassIDFilter,srcMACFromUserClassIDFilter);
+entry->srcMACFromUserClassIDFilterExclude=srcMACFromUserClassIDFilterExclude;
+strcpy(entry->destMACFromUserClassIDFilter,destMACFromUserClassIDFilter);
+entry->destMACFromUserClassIDFilterExclude=destMACFromUserClassIDFilterExclude;
+strcpy(entry->sourceMACAddressFilterList,sourceMACAddressFilterList);
+entry->ethertypeFilterExclude=ethertypeFilterExclude;
+
+
+
+
+    entry->next = filterRuleTable_head;
+    filterRuleTable_head = entry;
+    return entry;
+}
+
+
+/* remove a row from the table */
+void
+filterRuleTable_removeEntry( struct filterRuleTable_entry *entry ) {
+    struct filterRuleTable_entry *ptr, *prev;
+
+    if (!entry)
+        return;    /* Nothing to remove */
+
+    for ( ptr  = filterRuleTable_head, prev = NULL;
+          ptr != NULL;
+          prev = ptr, ptr = ptr->next ) {
+        if ( ptr == entry )
+            break;
+    }
+    if ( !ptr )
+        return;    /* Can't find it */
+
+    if ( prev == NULL )
+        filterRuleTable_head = ptr->next;
+    else
+        prev->next = ptr->next;
+
+    SNMP_FREE( entry );   /* XXX - release any other internal resources */
+}
+
+/*read data to structure from rdm*/
+int data_read_filter(void)
+
+{
+int ret=0;
+     rdmCB_t *rdmCB=NULL;
+	 rdmObj_InternetGatewayDevice_Layer2Bridging_t* forward=NULL;
+	rdmObj_InternetGatewayDevice_Layer2Bridging_Filter_i_t* entry=NULL;
+int count=0;
+  int i;
+
+  struct  ipStaticRouteTable_entry *temp;
+
+  rdmCB=RDMINIT(RDMNAME);
+	if(rdmCB==NULL){
+		ret=-1;
+		return ret;
+	}
+forward=rdmGetObjectByID(rdmCB, InternetGatewayDevice_Layer2Bridging);
+	if(forward==NULL){
+		goto fail;
+	}
+	count=forward->FilterNumberOfEntries;
+	
+      while (filterRuleTable_head)/*clean link list begin*/
+
+              {
+
+                     temp=filterRuleTable_head->next;
+
+                     filterRuleTable_removeEntry(filterRuleTable_head);
+
+                     filterRuleTable_head=temp;
+
+              }/*clean link list end*/
+
+	for(i=0;i<count;i++){
+		entry=rdmGetObjectByID(rdmCB,InternetGatewayDevice_Layer2Bridging_Filter_(i+1) );
+		if(entry==NULL){
+			goto fail;
+		}
+		filterRuleTable_createEntry(i+1, entry->FilterKey, entry->FilterEnable, entry->FilterBridgeReference, 
+			entry->ExclusivityOrder, entry->FilterInterface, entry->VLANIDFilter, entry->AdmitOnlyVLANTagged, 
+			entry->EthertypeFilterList,entry->EthertypeFilterExclude,entry->SourceMACAddressFilterList,entry->SourceMACAddressFilterExclude,
+			entry->DestMACAddressFilterList,entry->DestMACAddressFilterExclude,entry->SourceMACFromVendorClassIDFilter,
+			entry->SourceMACFromVendorClassIDFilterExclude,entry->DestMACFromVendorClassIDFilter,entry->DestMACFromVendorClassIDFilterExclude,
+			entry->SourceMACFromClientIDFilter,entry->SourceMACFromClientIDFilterExclude,entry->DestMACFromClientIDFilter,
+			entry->DestMACFromClientIDFilterExclude,entry->SourceMACFromUserClassIDFilter,entry->SourceMACFromUserClassIDFilterExclude,
+			entry->DestMACFromUserClassIDFilter,entry->DestMACFromUserClassIDFilterExclude);
+		
+
+	}
+
+
+	
+	   fail:
+		if(rdmCB!=NULL){
+			RDMDEINIT(rdmCB);
+			return ret;
+		}
+
+}
+
+
+static u_long long_ret;
+
+/********************
+*
+		END brian add 
+*
+**********************/
+
+
+
+/** returns the first data point within the filterRuleTable table data.
+
+    Set the my_loop_context variable to the first data point structure
+    of your choice (from which you can find the next one).  This could
+    be anything from the first node in a linked list, to an integer
+    pointer containing the beginning of an array variable.
+
+    Set the my_data_context variable to something to be returned to
+    you later that will provide you with the data to return in a given
+    row.  This could be the same pointer as what my_loop_context is
+    set to, or something different.
+
+    The put_index_data variable contains a list of snmp variable
+    bindings, one for each index in your table.  Set the values of
+    each appropriately according to the data matching the first row
+    and return the put_index_data variable at the end of the function.
+*/
+netsnmp_variable_list *
+filterRuleTable_get_first_data_point(void **my_loop_context, void **my_data_context,
+                          netsnmp_variable_list *put_index_data,
+                          netsnmp_iterator_info *mydata)
+{
+
+    //netsnmp_variable_list *vptr;
+data_read_filter();
+    *my_loop_context = filterRuleTable_head/** XXX */;
+    *my_data_context =filterRuleTable_head /** XXX */;
+
+    //vptr = put_index_data;
+    
+    //snmp_set_var_value(vptr, (u_char *) /** XXX: filterRuleIndex data */, /** XXX: length of filterRuleIndex data */);
+   // vptr = vptr->next_variable;
+
+    //return put_index_data;
+    return filterRuleTable_get_next_data_point(my_loop_context, my_data_context,
+                                    put_index_data,  mydata );
+}
+
+/** functionally the same as filterRuleTable_get_first_data_point, but
+   my_loop_context has already been set to a previous value and should
+   be updated to the next in the list.  For example, if it was a
+   linked list, you might want to cast it to your local data type and
+   then return my_loop_context->next.  The my_data_context pointer
+   should be set to something you need later and the indexes in
+   put_index_data updated again. */
+netsnmp_variable_list *
+filterRuleTable_get_next_data_point(void **my_loop_context, void **my_data_context,
+                         netsnmp_variable_list *put_index_data,
+                         netsnmp_iterator_info *mydata)
+{
+
+
+	struct filterRuleTable_entry* entry = (struct filterRuleTable_entry *)*my_loop_context;
+
+    netsnmp_variable_list *idx = put_index_data;
+
+ 
+
+    if ( entry )
+
+           {
+
+        snmp_set_var_value(idx, (u_char *)&entry->filterRuleIndex, sizeof(entry->filterRuleIndex));
+
+        idx = idx->next_variable;
+
+        *my_data_context = (void *)entry;
+
+        *my_loop_context = (struct filterRuleTable_entry *)entry->next;
+
+           }
+
+           else
+
+                  {
+
+        return NULL;
+
+                  }
+
+    return put_index_data;
+
+}
+
+/** Create a data_context for non-existent rows that SETs are performed on.
+ *  return a void * pointer which will be passed to subsequent get_XXX
+ *  and set_XXX functions for data retrival and modification during
+ *  this SET request.
+ *
+ *  The indexes are encoded (in order) into the index_data pointer,
+ *  and the column object which triggered the row creation is available
+ *  via the column parameter, if it would be helpful to use that information.
+ */
+void *
+filterRuleTable_create_data_context(netsnmp_variable_list *index_data, int column) {
+    return NULL; /* XXX: you likely want to return a real pointer */
+}
+
+/** If the implemented set_* functions don't operate directly on the
+   real-live data (which is actually recommended), then this function
+   can be used to take a given my_data_context pointer and "commit" it
+   to whereever the modified data needs to be put back to.  For
+   example, if this was a routing table you could publish the modified
+   routes back into the kernel at this point.
+
+   new_or_del will be set to 1 if new, or -1 if it should be deleted
+   or 0 if it is just a modification of an existing row.
+
+   If you free the data yourself, make sure to *my_data_context = NULL */
+int
+filterRuleTable_commit_row(void **my_data_context, int new_or_del)
+{
+    /** Add any necessary commit code here */
+    /*  */
+
+    /* return no errors.  And there shouldn't be any!!!  Ever!!!  You
+    should have checked the values long before this. */
+    return SNMP_ERR_NOERROR;
+}
+
+
+/* User-defined data access functions (per column) for data in table filterRuleTable */
+/*
+ * NOTE:
+ * - these get_ routines MUST return data that will not be freed (ie,
+ *   use static variables or persistent data).  It will be copied, if
+ *   needed, immediately after the get_ routine has been called.
+ * - these SET routines must copy the incoming data and can not take
+ *   ownership of the memory passed in by the val pointer.
+ */
+/** XXX: return a data pointer to the data for the filterRuleIndex column and set
+         ret_len to its proper size in bytes. */
+      long *get_filterRuleIndex(void *data_context, size_t *ret_len) {
+      struct filterRuleTable_entry *entry=(struct filterRuleTable_entry *)data_context;
+	  long_ret=entry->filterRuleIndex;
+	  *ret_len=sizeof(long_ret);
+      return &long_ret; /** XXX: replace this with a pointer to a real value */
+      }
+/** XXX: return a data pointer to the data for the filterKey column and set
+         ret_len to its proper size in bytes. */
+      long *get_filterKey(void *data_context, size_t *ret_len) {
+      struct filterRuleTable_entry *entry=(struct filterRuleTable_entry *)data_context;
+	  long_ret=entry->filterKey;
+	  *ret_len=sizeof(long_ret);
+      return &long_ret; /** XXX: replace this with a pointer to a real value */
+      }
+/** XXX: Set the value of the filterKey column and return
+         SNMP_ERR_NOERROR on success
+         SNMP_ERR_XXX     for SNMP deterministic error codes
+         SNMP_ERR_GENERR  on generic failures (a last result response). */
+      
+   
+/** XXX: return a data pointer to the data for the filterEnable column and set
+         ret_len to its proper size in bytes. */
+      long *get_filterEnable(void *data_context, size_t *ret_len) {
+     struct filterRuleTable_entry *entry=(struct filterRuleTable_entry *)data_context;
+	  long_ret=entry->filterEnable;
+	  *ret_len=sizeof(long_ret);
+      return &long_ret; /** XXX: replace this with a pointer to a real value */
+      }
+/** XXX: Set the value of the filterEnable column and return
+         SNMP_ERR_NOERROR on success
+         SNMP_ERR_XXX     for SNMP deterministic error codes
+         SNMP_ERR_GENERR  on generic failures (a last result response). */
+      int set_filterEnable(void *data_context, long *val, size_t val_len) {
+      struct filterRuleTable_entry *entry=(struct filterRuleTable_entry *)data_context;
+	  long buf;
+	  memcpy(&buf,val,val_len);
+	  handleOfSetParameterSpecForTable(InternetGatewayDevice_Layer2Bridging_Filter_(entry->filterRuleIndex),
+	  	"FilterEnable", &buf);
+        return SNMP_ERR_NOERROR;  /** XXX: change if an error occurs */
+      }
+/** XXX: return a data pointer to the data for the filterBridgeReference column and set
+         ret_len to its proper size in bytes. */
+      long *get_filterBridgeReference(void *data_context, size_t *ret_len) {
+      struct filterRuleTable_entry *entry=(struct filterRuleTable_entry *)data_context;
+	  long_ret=entry->filterBridgeReference;
+	  *ret_len=sizeof(long_ret);
+      return &long_ret; /** XXX: replace this with a pointer to a real value */
+      }
+/** XXX: Set the value of the filterBridgeReference column and return
+         SNMP_ERR_NOERROR on success
+         SNMP_ERR_XXX     for SNMP deterministic error codes
+         SNMP_ERR_GENERR  on generic failures (a last result response). */
+      int set_filterBridgeReference(void *data_context, long *val, size_t val_len) {
+      struct filterRuleTable_entry *entry=(struct filterRuleTable_entry *)data_context;
+	  long buf;
+	  memcpy(&buf,val,val_len);
+	  handleOfSetParameterSpecForTable(InternetGatewayDevice_Layer2Bridging_Filter_(entry->filterRuleIndex),
+	  	"FilterBridgeReference", &buf);
+        return SNMP_ERR_NOERROR;  /** XXX: change if an error occurs */
+      }
+/** XXX: return a data pointer to the data for the exclusivityOrder column and set
+         ret_len to its proper size in bytes. */
+      long *get_exclusivityOrder(void *data_context, size_t *ret_len) {
+      struct filterRuleTable_entry *entry=(struct filterRuleTable_entry *)data_context;
+	  long_ret=entry->exclusivityOrder;
+	  *ret_len=sizeof(long_ret);
+      return &long_ret; /** XXX: replace this with a pointer to a real value */
+      }
+/** XXX: Set the value of the exclusivityOrder column and return
+         SNMP_ERR_NOERROR on success
+         SNMP_ERR_XXX     for SNMP deterministic error codes
+         SNMP_ERR_GENERR  on generic failures (a last result response). */
+      int set_exclusivityOrder(void *data_context, long *val, size_t val_len) {
+      struct filterRuleTable_entry *entry=(struct filterRuleTable_entry *)data_context;
+	  long buf;
+	  memcpy(&buf,val,val_len);
+	  handleOfSetParameterSpecForTable(InternetGatewayDevice_Layer2Bridging_Filter_(entry->filterRuleIndex),
+	  	"ExclusivityOrder", &buf);
+        return SNMP_ERR_NOERROR;  /** XXX: change if an error occurs */
+      }
+/** XXX: return a data pointer to the data for the filterInterface column and set
+         ret_len to its proper size in bytes. */
+      char *get_filterInterface(void *data_context, size_t *ret_len) {
+      struct filterRuleTable_entry *entry=(struct filterRuleTable_entry *)data_context;
+	  *ret_len=strlen(entry->filterInterface);
+      return entry->filterInterface; /** XXX: replace this with a pointer to a real value */
+      }
+/** XXX: Set the value of the filterInterface column and return
+         SNMP_ERR_NOERROR on success
+         SNMP_ERR_XXX     for SNMP deterministic error codes
+         SNMP_ERR_GENERR  on generic failures (a last result response). */
+      int set_filterInterface(void *data_context, char *val, size_t val_len) {
+      struct filterRuleTable_entry *entry=(struct filterRuleTable_entry *)data_context;
+	 char buf[17];
+	  memcpy(buf,val,val_len);
+	  buf[val_len]='\0';
+	  handleOfSetParameterSpecForTable(InternetGatewayDevice_Layer2Bridging_Filter_(entry->filterRuleIndex),
+	  	"FilterInterface", buf);
+        return SNMP_ERR_NOERROR;  /** XXX: change if an error occurs */
+      }
+/** XXX: return a data pointer to the data for the vlanIDFilter column and set
+         ret_len to its proper size in bytes. */
+      long *get_vlanIDFilter(void *data_context, size_t *ret_len) {
+      struct filterRuleTable_entry *entry=(struct filterRuleTable_entry *)data_context;
+	  long_ret=entry->vlanIDFilter;
+	  *ret_len=sizeof(long_ret);
+      return &long_ret; /** XXX: replace this with a pointer to a real value */
+      }
+/** XXX: Set the value of the vlanIDFilter column and return
+         SNMP_ERR_NOERROR on success
+         SNMP_ERR_XXX     for SNMP deterministic error codes
+         SNMP_ERR_GENERR  on generic failures (a last result response). */
+      int set_vlanIDFilter(void *data_context, long *val, size_t val_len) {
+      struct filterRuleTable_entry *entry=(struct filterRuleTable_entry *)data_context;
+	  long buf;
+	  memcpy(&buf,val,val_len);
+	  handleOfSetParameterSpecForTable(InternetGatewayDevice_Layer2Bridging_Filter_(entry->filterRuleIndex),
+	  	"VLANIDFilter", &buf);
+        return SNMP_ERR_NOERROR;  /** XXX: change if an error occurs */
+      }
+/** XXX: return a data pointer to the data for the admitOnlyVLANTagged column and set
+         ret_len to its proper size in bytes. */
+      long *get_admitOnlyVLANTagged(void *data_context, size_t *ret_len) {
+      struct filterRuleTable_entry *entry=(struct filterRuleTable_entry *)data_context;
+	  long_ret=entry->admitOnlyVLANTagged;
+	  *ret_len=sizeof(long_ret);
+      return &long_ret; /** XXX: replace this with a pointer to a real value */
+      }
+/** XXX: Set the value of the admitOnlyVLANTagged column and return
+         SNMP_ERR_NOERROR on success
+         SNMP_ERR_XXX     for SNMP deterministic error codes
+         SNMP_ERR_GENERR  on generic failures (a last result response). */
+      int set_admitOnlyVLANTagged(void *data_context, long *val, size_t val_len) {
+      struct filterRuleTable_entry *entry=(struct filterRuleTable_entry *)data_context;
+	  long buf;
+	  memcpy(&buf,val,val_len);
+	  handleOfSetParameterSpecForTable(InternetGatewayDevice_Layer2Bridging_Filter_(entry->filterRuleIndex),
+	  	"AdmitOnlyVLANTagged", &buf);
+        return SNMP_ERR_NOERROR;  /** XXX: change if an error occurs */
+      }
+/** XXX: return a data pointer to the data for the ethertypeFilterList column and set
+         ret_len to its proper size in bytes. */
+      char *get_ethertypeFilterList(void *data_context, size_t *ret_len) {
+      struct filterRuleTable_entry *entry=(struct filterRuleTable_entry *)data_context;
+	  *ret_len=strlen(entry->ethertypeFilterList);
+      return entry->ethertypeFilterList; /** XXX: replace this with a pointer to a real value */
+      }
+/** XXX: Set the value of the ethertypeFilterList column and return
+         SNMP_ERR_NOERROR on success
+         SNMP_ERR_XXX     for SNMP deterministic error codes
+         SNMP_ERR_GENERR  on generic failures (a last result response). */
+      int set_ethertypeFilterList(void *data_context, char *val, size_t val_len) {
+      struct filterRuleTable_entry *entry=(struct filterRuleTable_entry *)data_context;
+	 char buf[257];
+	  memcpy(buf,val,val_len);
+	  buf[val_len]='\0';
+	  handleOfSetParameterSpecForTable(InternetGatewayDevice_Layer2Bridging_Filter_(entry->filterRuleIndex),
+	  	"EthertypeFilterList", buf);
+        return SNMP_ERR_NOERROR;  /** XXX: change if an error occurs */
+      }
+/** XXX: return a data pointer to the data for the ethertypeFilterExclude column and set
+         ret_len to its proper size in bytes. */
+      long *get_ethertypeFilterExclude(void *data_context, size_t *ret_len) {
+      struct filterRuleTable_entry *entry=(struct filterRuleTable_entry *)data_context;
+	  long_ret=entry->ethertypeFilterExclude;
+	  *ret_len=sizeof(long_ret);
+      return &long_ret; /** XXX: replace this with a pointer to a real value */
+      }
+/** XXX: Set the value of the ethertypeFilterExclude column and return
+         SNMP_ERR_NOERROR on success
+         SNMP_ERR_XXX     for SNMP deterministic error codes
+         SNMP_ERR_GENERR  on generic failures (a last result response). */
+      int set_ethertypeFilterExclude(void *data_context, long *val, size_t val_len) {
+      struct filterRuleTable_entry *entry=(struct filterRuleTable_entry *)data_context;
+	  long buf;
+	  memcpy(&buf,val,val_len);
+	  handleOfSetParameterSpecForTable(InternetGatewayDevice_Layer2Bridging_Filter_(entry->filterRuleIndex),
+	  	"EthertypeFilterExclude", &buf);
+        return SNMP_ERR_NOERROR;  /** XXX: change if an error occurs */
+      }
+/** XXX: return a data pointer to the data for the sourceMACAddressFilterList column and set
+         ret_len to its proper size in bytes. */
+      char *get_sourceMACAddressFilterList(void *data_context, size_t *ret_len) {
+      struct filterRuleTable_entry *entry=(struct filterRuleTable_entry *)data_context;
+	  *ret_len=strlen(entry->sourceMACAddressFilterList);
+      return entry->sourceMACAddressFilterList; /** XXX: replace this with a pointer to a real value */
+      }
+/** XXX: Set the value of the sourceMACAddressFilterList column and return
+         SNMP_ERR_NOERROR on success
+         SNMP_ERR_XXX     for SNMP deterministic error codes
+         SNMP_ERR_GENERR  on generic failures (a last result response). */
+      int set_sourceMACAddressFilterList(void *data_context, char *val, size_t val_len) {
+      struct filterRuleTable_entry *entry=(struct filterRuleTable_entry *)data_context;
+	 char buf[513];
+	  memcpy(buf,val,val_len);
+	  buf[val_len]='\0';
+	  handleOfSetParameterSpecForTable(InternetGatewayDevice_Layer2Bridging_Filter_(entry->filterRuleIndex),
+	  	"SourceMACAddressFilterList", buf);
+        return SNMP_ERR_NOERROR;  /** XXX: change if an error occurs */
+      }
+/** XXX: return a data pointer to the data for the sourceMACAddressFilterExclude column and set
+         ret_len to its proper size in bytes. */
+      long *get_sourceMACAddressFilterExclude(void *data_context, size_t *ret_len) {
+      struct filterRuleTable_entry *entry=(struct filterRuleTable_entry *)data_context;
+	  long_ret=entry->sourceMACAddressFilterExclude;
+	  *ret_len=sizeof(long_ret);
+      return &long_ret; /** XXX: replace this with a pointer to a real value */
+      }
+/** XXX: Set the value of the sourceMACAddressFilterExclude column and return
+         SNMP_ERR_NOERROR on success
+         SNMP_ERR_XXX     for SNMP deterministic error codes
+         SNMP_ERR_GENERR  on generic failures (a last result response). */
+      int set_sourceMACAddressFilterExclude(void *data_context, long *val, size_t val_len) {
+      struct filterRuleTable_entry *entry=(struct filterRuleTable_entry *)data_context;
+	  long buf;
+	  memcpy(&buf,val,val_len);
+	  handleOfSetParameterSpecForTable(InternetGatewayDevice_Layer2Bridging_Filter_(entry->filterRuleIndex),
+	  	"SourceMACAddressFilterExclude", &buf);
+        return SNMP_ERR_NOERROR;  /** XXX: change if an error occurs */
+      }
+/** XXX: return a data pointer to the data for the destMACAddressFilterList column and set
+         ret_len to its proper size in bytes. */
+      char *get_destMACAddressFilterList(void *data_context, size_t *ret_len) {
+      struct filterRuleTable_entry *entry=(struct filterRuleTable_entry *)data_context;
+	  *ret_len=strlen(entry->destMACAddressFilterList);
+      return entry->destMACAddressFilterList; /** XXX: replace this with a pointer to a real value */
+      }
+/** XXX: Set the value of the destMACAddressFilterList column and return
+         SNMP_ERR_NOERROR on success
+         SNMP_ERR_XXX     for SNMP deterministic error codes
+         SNMP_ERR_GENERR  on generic failures (a last result response). */
+      int set_destMACAddressFilterList(void *data_context, char *val, size_t val_len) {
+      struct filterRuleTable_entry *entry=(struct filterRuleTable_entry *)data_context;
+	 char buf[513];
+	  memcpy(buf,val,val_len);
+	  buf[val_len]='\0';
+	  handleOfSetParameterSpecForTable(InternetGatewayDevice_Layer2Bridging_Filter_(entry->filterRuleIndex),
+	  	"DestMACAddressFilterList", buf);
+        return SNMP_ERR_NOERROR;  /** XXX: change if an error occurs */
+      }
+/** XXX: return a data pointer to the data for the destMACAddressFilterExclude column and set
+         ret_len to its proper size in bytes. */
+      long *get_destMACAddressFilterExclude(void *data_context, size_t *ret_len) {
+     struct filterRuleTable_entry *entry=(struct filterRuleTable_entry *)data_context;
+	  long_ret=entry->destMACAddressFilterExclude;
+	  *ret_len=sizeof(long_ret);
+      return &long_ret; /** XXX: replace this with a pointer to a real value */
+      }
+/** XXX: Set the value of the destMACAddressFilterExclude column and return
+         SNMP_ERR_NOERROR on success
+         SNMP_ERR_XXX     for SNMP deterministic error codes
+         SNMP_ERR_GENERR  on generic failures (a last result response). */
+      int set_destMACAddressFilterExclude(void *data_context, long *val, size_t val_len) {
+      struct filterRuleTable_entry *entry=(struct filterRuleTable_entry *)data_context;
+	  long buf;
+	  memcpy(&buf,val,val_len);
+	  handleOfSetParameterSpecForTable(InternetGatewayDevice_Layer2Bridging_Filter_(entry->filterRuleIndex),
+	  	"DestMACAddressFilterExclude", &buf);
+        return SNMP_ERR_NOERROR;  /** XXX: change if an error occurs */
+      }
+/** XXX: return a data pointer to the data for the srcMACFromVendorClassIDFilter column and set
+         ret_len to its proper size in bytes. */
+      char *get_srcMACFromVendorClassIDFilter(void *data_context, size_t *ret_len) {
+      struct filterRuleTable_entry *entry=(struct filterRuleTable_entry *)data_context;
+	  *ret_len=strlen(entry->srcMACFromVendorClassIDFilter);
+      return entry->srcMACFromVendorClassIDFilter; /** XXX: replace this with a pointer to a real value */
+      }
+/** XXX: Set the value of the srcMACFromVendorClassIDFilter column and return
+         SNMP_ERR_NOERROR on success
+         SNMP_ERR_XXX     for SNMP deterministic error codes
+         SNMP_ERR_GENERR  on generic failures (a last result response). */
+      int set_srcMACFromVendorClassIDFilter(void *data_context, char *val, size_t val_len) {
+      struct filterRuleTable_entry *entry=(struct filterRuleTable_entry *)data_context;
+      char buf[257];
+	  memcpy(buf,val,val_len);
+	  buf[val_len]='\0';
+	  handleOfSetParameterSpecForTable(InternetGatewayDevice_Layer2Bridging_Filter_(entry->filterRuleIndex),
+	  	"SourceMACFromVendorClassIDFilter", buf);
+        return SNMP_ERR_NOERROR;  /** XXX: change if an error occurs */
+      }
+       
+/** XXX: return a data pointer to the data for the srcMACFromVendorClassIDFilterExclude column and set
+         ret_len to its proper size in bytes. */
+      long *get_srcMACFromVendorClassIDFilterExclude(void *data_context, size_t *ret_len) {
+      struct filterRuleTable_entry *entry=(struct filterRuleTable_entry *)data_context;
+	  long_ret=entry->srcMACFromVendorClassIDFilterExclude;
+	  *ret_len=sizeof(long_ret);
+      return &long_ret; /** XXX: replace this with a pointer to a real value */
+      }
+/** XXX: Set the value of the srcMACFromVendorClassIDFilterExclude column and return
+         SNMP_ERR_NOERROR on success
+         SNMP_ERR_XXX     for SNMP deterministic error codes
+         SNMP_ERR_GENERR  on generic failures (a last result response). */
+      int set_srcMACFromVendorClassIDFilterExclude(void *data_context, long *val, size_t val_len) {
+      struct filterRuleTable_entry *entry=(struct filterRuleTable_entry *)data_context;
+	  long buf;
+	  memcpy(&buf,val,val_len);
+	  handleOfSetParameterSpecForTable(InternetGatewayDevice_Layer2Bridging_Filter_(entry->filterRuleIndex),
+	  	"SourceMACFromVendorClassIDFilterExclude", &buf);
+        return SNMP_ERR_NOERROR;  /** XXX: change if an error occurs */
+      }
+/** XXX: return a data pointer to the data for the destMACFromVendorClassIDFilter column and set
+         ret_len to its proper size in bytes. */
+      char *get_destMACFromVendorClassIDFilter(void *data_context, size_t *ret_len) {
+      struct filterRuleTable_entry *entry=(struct filterRuleTable_entry *)data_context;
+	  *ret_len=strlen(entry->destMACFromVendorClassIDFilter);
+      return entry->destMACFromVendorClassIDFilter; /** XXX: replace this with a pointer to a real value */
+      }
+/** XXX: Set the value of the destMACFromVendorClassIDFilter column and return
+         SNMP_ERR_NOERROR on success
+         SNMP_ERR_XXX     for SNMP deterministic error codes
+         SNMP_ERR_GENERR  on generic failures (a last result response). */
+      int set_destMACFromVendorClassIDFilter(void *data_context, char *val, size_t val_len) {
+      struct filterRuleTable_entry *entry=(struct filterRuleTable_entry *)data_context;
+      char buf[257];
+	  memcpy(buf,val,val_len);
+	  buf[val_len]='\0';
+	  handleOfSetParameterSpecForTable(InternetGatewayDevice_Layer2Bridging_Filter_(entry->filterRuleIndex),
+	  	"DestMACFromVendorClassIDFilter", buf);
+        return SNMP_ERR_NOERROR;  /** XXX: change if an error occurs */
+      }
+/** XXX: return a data pointer to the data for the destMACFromVendorClassIDFilterExclude column and set
+         ret_len to its proper size in bytes. */
+      long *get_destMACFromVendorClassIDFilterExclude(void *data_context, size_t *ret_len) {
+      struct filterRuleTable_entry *entry=(struct filterRuleTable_entry *)data_context;
+	  long_ret=entry->destMACFromVendorClassIDFilterExclude;
+	  *ret_len=sizeof(long_ret);
+      return &long_ret; /** XXX: replace this with a pointer to a real value */
+      }
+/** XXX: Set the value of the destMACFromVendorClassIDFilterExclude column and return
+         SNMP_ERR_NOERROR on success
+         SNMP_ERR_XXX     for SNMP deterministic error codes
+         SNMP_ERR_GENERR  on generic failures (a last result response). */
+      int set_destMACFromVendorClassIDFilterExclude(void *data_context, long *val, size_t val_len) {
+      struct filterRuleTable_entry *entry=(struct filterRuleTable_entry *)data_context;
+	  long buf;
+	  memcpy(&buf,val,val_len);
+	  handleOfSetParameterSpecForTable(InternetGatewayDevice_Layer2Bridging_Filter_(entry->filterRuleIndex),
+	  	"DestMACFromVendorClassIDFilterExclude", &buf);
+        return SNMP_ERR_NOERROR;  /** XXX: change if an error occurs */
+      }
+/** XXX: return a data pointer to the data for the srcMACFromClientIDFilter column and set
+         ret_len to its proper size in bytes. */
+      char *get_srcMACFromClientIDFilter(void *data_context, size_t *ret_len) {
+      struct filterRuleTable_entry *entry=(struct filterRuleTable_entry *)data_context;
+	  *ret_len=strlen(entry->srcMACFromClientIDFilter);
+      return entry->srcMACFromClientIDFilter; /** XXX: replace this with a pointer to a real value */
+      }
+/** XXX: Set the value of the srcMACFromClientIDFilter column and return
+         SNMP_ERR_NOERROR on success
+         SNMP_ERR_XXX     for SNMP deterministic error codes
+         SNMP_ERR_GENERR  on generic failures (a last result response). */
+      int set_srcMACFromClientIDFilter(void *data_context, char *val, size_t val_len) {
+      struct filterRuleTable_entry *entry=(struct filterRuleTable_entry *)data_context;
+      char buf[257];
+	  memcpy(buf,val,val_len);
+	  buf[val_len]='\0';
+	  handleOfSetParameterSpecForTable(InternetGatewayDevice_Layer2Bridging_Filter_(entry->filterRuleIndex),
+	  	"SourceMACFromClientIDFilter", buf);
+        return SNMP_ERR_NOERROR;  /** XXX: change if an error occurs */
+      }
+/** XXX: return a data pointer to the data for the srcMACFromClientIDFilterExclude column and set
+         ret_len to its proper size in bytes. */
+      long *get_srcMACFromClientIDFilterExclude(void *data_context, size_t *ret_len) {
+      struct filterRuleTable_entry *entry=(struct filterRuleTable_entry *)data_context;
+	  long_ret=entry->srcMACFromClientIDFilterExclude;
+	  *ret_len=sizeof(long_ret);
+      return &long_ret; /** XXX: replace this with a pointer to a real value */
+      }
+/** XXX: Set the value of the srcMACFromClientIDFilterExclude column and return
+         SNMP_ERR_NOERROR on success
+         SNMP_ERR_XXX     for SNMP deterministic error codes
+         SNMP_ERR_GENERR  on generic failures (a last result response). */
+      int set_srcMACFromClientIDFilterExclude(void *data_context, long *val, size_t val_len) {
+      struct filterRuleTable_entry *entry=(struct filterRuleTable_entry *)data_context;
+	  long buf;
+	  memcpy(&buf,val,val_len);
+	  handleOfSetParameterSpecForTable(InternetGatewayDevice_Layer2Bridging_Filter_(entry->filterRuleIndex),
+	  	"SourceMACFromClientIDFilterExclude", &buf);
+        return SNMP_ERR_NOERROR;  /** XXX: change if an error occurs */
+      }
+/** XXX: return a data pointer to the data for the estMACFromClientIDFilter column and set
+         ret_len to its proper size in bytes. */
+      char *get_destMACFromClientIDFilter(void *data_context, size_t *ret_len) {
+      struct filterRuleTable_entry *entry=(struct filterRuleTable_entry *)data_context;
+	  *ret_len=strlen(entry->destMACFromClientIDFilter);
+      return entry->destMACFromClientIDFilter; /** XXX: replace this with a pointer to a real value */
+      }
+/** XXX: Set the value of the estMACFromClientIDFilter column and return
+         SNMP_ERR_NOERROR on success
+         SNMP_ERR_XXX     for SNMP deterministic error codes
+         SNMP_ERR_GENERR  on generic failures (a last result response). */
+      int set_destMACFromClientIDFilter(void *data_context, char *val, size_t val_len) {
+      struct filterRuleTable_entry *entry=(struct filterRuleTable_entry *)data_context;
+      char buf[257];
+	  memcpy(buf,val,val_len);
+	  buf[val_len]='\0';
+	  handleOfSetParameterSpecForTable(InternetGatewayDevice_Layer2Bridging_Filter_(entry->filterRuleIndex),
+	  	"DestMACFromClientIDFilter", buf);
+        return SNMP_ERR_NOERROR;  /** XXX: change if an error occurs */
+      }
+/** XXX: return a data pointer to the data for the estMACFromClientIDFilterExclude column and set
+         ret_len to its proper size in bytes. */
+      long *get_destMACFromClientIDFilterExclude(void *data_context, size_t *ret_len) {
+      struct filterRuleTable_entry *entry=(struct filterRuleTable_entry *)data_context;
+	  long_ret=entry->destMACFromClientIDFilterExclude;
+	  *ret_len=sizeof(long_ret);
+      return &long_ret; /** XXX: replace this with a pointer to a real value */
+      }
+/** XXX: Set the value of the estMACFromClientIDFilterExclude column and return
+         SNMP_ERR_NOERROR on success
+         SNMP_ERR_XXX     for SNMP deterministic error codes
+         SNMP_ERR_GENERR  on generic failures (a last result response). */
+      int set_destMACFromClientIDFilterExclude(void *data_context, long *val, size_t val_len) {
+      struct filterRuleTable_entry *entry=(struct filterRuleTable_entry *)data_context;
+	  long buf;
+	  memcpy(&buf,val,val_len);
+	  handleOfSetParameterSpecForTable(InternetGatewayDevice_Layer2Bridging_Filter_(entry->filterRuleIndex),
+	  	"DestMACFromClientIDFilterExclude", &buf);
+        return SNMP_ERR_NOERROR;  /** XXX: change if an error occurs */
+      }
+/** XXX: return a data pointer to the data for the srcMACFromUserClassIDFilter column and set
+         ret_len to its proper size in bytes. */
+      char *get_srcMACFromUserClassIDFilter(void *data_context, size_t *ret_len) {
+     struct filterRuleTable_entry *entry=(struct filterRuleTable_entry *)data_context;
+	  *ret_len=strlen(entry->srcMACFromUserClassIDFilter);
+      return entry->srcMACFromUserClassIDFilter; /** XXX: replace this with a pointer to a real value */
+      }
+/** XXX: Set the value of the srcMACFromUserClassIDFilter column and return
+         SNMP_ERR_NOERROR on success
+         SNMP_ERR_XXX     for SNMP deterministic error codes
+         SNMP_ERR_GENERR  on generic failures (a last result response). */
+      int set_srcMACFromUserClassIDFilter(void *data_context, char *val, size_t val_len) {
+      struct filterRuleTable_entry *entry=(struct filterRuleTable_entry *)data_context;
+      char buf[257];
+	  memcpy(buf,val,val_len);
+	  buf[val_len]='\0';
+	  handleOfSetParameterSpecForTable(InternetGatewayDevice_Layer2Bridging_Filter_(entry->filterRuleIndex),
+	  	"SourceMACFromUserClassIDFilter", buf);
+        return SNMP_ERR_NOERROR;  /** XXX: change if an error occurs */
+      }
+/** XXX: return a data pointer to the data for the srcMACFromUserClassIDFilterExclude column and set
+         ret_len to its proper size in bytes. */
+      long *get_srcMACFromUserClassIDFilterExclude(void *data_context, size_t *ret_len) {
+      struct filterRuleTable_entry *entry=(struct filterRuleTable_entry *)data_context;
+	  long_ret=entry->srcMACFromUserClassIDFilterExclude;
+	  *ret_len=sizeof(long_ret);
+      return &long_ret; /** XXX: replace this with a pointer to a real value */
+      }
+/** XXX: Set the value of the srcMACFromUserClassIDFilterExclude column and return
+         SNMP_ERR_NOERROR on success
+         SNMP_ERR_XXX     for SNMP deterministic error codes
+         SNMP_ERR_GENERR  on generic failures (a last result response). */
+      int set_srcMACFromUserClassIDFilterExclude(void *data_context, long *val, size_t val_len) {
+      struct filterRuleTable_entry *entry=(struct filterRuleTable_entry *)data_context;
+	  long buf;
+	  memcpy(&buf,val,val_len);
+	  handleOfSetParameterSpecForTable(InternetGatewayDevice_Layer2Bridging_Filter_(entry->filterRuleIndex),
+	  	"SourceMACFromUserClassIDFilterExclude", &buf);
+        return SNMP_ERR_NOERROR;  /** XXX: change if an error occurs */
+      }
+/** XXX: return a data pointer to the data for the destMACFromUserClassIDFilter column and set
+         ret_len to its proper size in bytes. */
+      char *get_destMACFromUserClassIDFilter(void *data_context, size_t *ret_len) {
+      struct filterRuleTable_entry *entry=(struct filterRuleTable_entry *)data_context;
+	  *ret_len=strlen(entry->destMACFromUserClassIDFilter);
+      return entry->destMACFromUserClassIDFilter; /** XXX: replace this with a pointer to a real value */
+      }
+/** XXX: Set the value of the destMACFromUserClassIDFilter column and return
+         SNMP_ERR_NOERROR on success
+         SNMP_ERR_XXX     for SNMP deterministic error codes
+         SNMP_ERR_GENERR  on generic failures (a last result response). */
+      int set_destMACFromUserClassIDFilter(void *data_context, char *val, size_t val_len) {
+      struct filterRuleTable_entry *entry=(struct filterRuleTable_entry *)data_context;
+      char buf[257];
+	  memcpy(buf,val,val_len);
+	  buf[val_len]='\0';
+	  handleOfSetParameterSpecForTable(InternetGatewayDevice_Layer2Bridging_Filter_(entry->filterRuleIndex),
+	  	"DestMACFromUserClassIDFilter", buf);
+        return SNMP_ERR_NOERROR;  /** XXX: change if an error occurs */
+      }
+/** XXX: return a data pointer to the data for the destMACFromUserClassIDFilterExclude column and set
+         ret_len to its proper size in bytes. */
+      long *get_destMACFromUserClassIDFilterExclude(void *data_context, size_t *ret_len) {
+      struct filterRuleTable_entry *entry=(struct filterRuleTable_entry *)data_context;
+	  long_ret=entry->destMACFromUserClassIDFilterExclude;
+	  *ret_len=sizeof(long_ret);
+      return &long_ret; /** XXX: replace this with a pointer to a real value */
+      }
+/** XXX: Set the value of the destMACFromUserClassIDFilterExclude column and return
+         SNMP_ERR_NOERROR on success
+         SNMP_ERR_XXX     for SNMP deterministic error codes
+         SNMP_ERR_GENERR  on generic failures (a last result response). */
+      int set_destMACFromUserClassIDFilterExclude(void *data_context, long *val, size_t val_len) {
+      struct filterRuleTable_entry *entry=(struct filterRuleTable_entry *)data_context;
+	  long buf;
+	  memcpy(&buf,val,val_len);
+	  handleOfSetParameterSpecForTable(InternetGatewayDevice_Layer2Bridging_Filter_(entry->filterRuleIndex),
+	  	"DestMACFromUserClassIDFilterExclude", &buf);
+        return SNMP_ERR_NOERROR;  /** XXX: change if an error occurs */
+      }
+    
+
diff -Naur net-snmp-5.7.2-orig/agent/mibgroup/ZYXEL-PRESTIGE-MIB/filterRuleTable_access.h net-snmp-5.7.2/agent/mibgroup/ZYXEL-PRESTIGE-MIB/filterRuleTable_access.h
--- net-snmp-5.7.2-orig/agent/mibgroup/ZYXEL-PRESTIGE-MIB/filterRuleTable_access.h	1970-01-01 08:00:00.000000000 +0800
+++ net-snmp-5.7.2/agent/mibgroup/ZYXEL-PRESTIGE-MIB/filterRuleTable_access.h	2013-10-08 09:35:17.626117000 +0800
@@ -0,0 +1,67 @@
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *        : mib2c.access_functions.conf 11358 2004-10-14 12:57:34Z dts12 $
+ */
+#ifndef FILTERRULETABLE_ACCESS_H
+#define FILTERRULETABLE_ACCESS_H
+
+/** User-defined data access functions for data in table filterRuleTable */
+/** row level accessors */
+Netsnmp_First_Data_Point  filterRuleTable_get_first_data_point;
+Netsnmp_Next_Data_Point   filterRuleTable_get_next_data_point;
+int filterRuleTable_commit_row(void **my_data_context, int new_or_del);
+void * filterRuleTable_create_data_context(netsnmp_variable_list *index_data, int column);
+
+/** column accessors */
+      long *get_filterRuleIndex(void *data_context, size_t *ret_len);
+      long *get_filterKey(void *data_context, size_t *ret_len);
+      long *get_filterEnable(void *data_context, size_t *ret_len);
+      int set_filterEnable(void *data_context, long *val, size_t val_len);
+      long *get_filterBridgeReference(void *data_context, size_t *ret_len);
+      int set_filterBridgeReference(void *data_context, long *val, size_t val_len);
+      long *get_exclusivityOrder(void *data_context, size_t *ret_len);
+      int set_exclusivityOrder(void *data_context, long *val, size_t val_len);
+      char *get_filterInterface(void *data_context, size_t *ret_len);
+      int set_filterInterface(void *data_context, char *val, size_t val_len);
+      long *get_vlanIDFilter(void *data_context, size_t *ret_len);
+      int set_vlanIDFilter(void *data_context, long *val, size_t val_len);
+      long *get_admitOnlyVLANTagged(void *data_context, size_t *ret_len);
+      int set_admitOnlyVLANTagged(void *data_context, long *val, size_t val_len);
+      char *get_ethertypeFilterList(void *data_context, size_t *ret_len);
+      int set_ethertypeFilterList(void *data_context, char *val, size_t val_len);
+      long *get_ethertypeFilterExclude(void *data_context, size_t *ret_len);
+      int set_ethertypeFilterExclude(void *data_context, long *val, size_t val_len);
+      char *get_sourceMACAddressFilterList(void *data_context, size_t *ret_len);
+      int set_sourceMACAddressFilterList(void *data_context, char *val, size_t val_len);
+      long *get_sourceMACAddressFilterExclude(void *data_context, size_t *ret_len);
+      int set_sourceMACAddressFilterExclude(void *data_context, long *val, size_t val_len);
+      char *get_destMACAddressFilterList(void *data_context, size_t *ret_len);
+      int set_destMACAddressFilterList(void *data_context, char *val, size_t val_len);
+      long *get_destMACAddressFilterExclude(void *data_context, size_t *ret_len);
+      int set_destMACAddressFilterExclude(void *data_context, long *val, size_t val_len);
+      char *get_srcMACFromVendorClassIDFilter(void *data_context, size_t *ret_len);
+      int set_srcMACFromVendorClassIDFilter(void *data_context, char *val, size_t val_len);
+      long *get_srcMACFromVendorClassIDFilterExclude(void *data_context, size_t *ret_len);
+      int set_srcMACFromVendorClassIDFilterExclude(void *data_context, long *val, size_t val_len);
+      char *get_destMACFromVendorClassIDFilter(void *data_context, size_t *ret_len);
+      int set_destMACFromVendorClassIDFilter(void *data_context, char *val, size_t val_len);
+      long *get_destMACFromVendorClassIDFilterExclude(void *data_context, size_t *ret_len);
+      int set_destMACFromVendorClassIDFilterExclude(void *data_context, long *val, size_t val_len);
+      char *get_srcMACFromClientIDFilter(void *data_context, size_t *ret_len);
+      int set_srcMACFromClientIDFilter(void *data_context, char *val, size_t val_len);
+      long *get_srcMACFromClientIDFilterExclude(void *data_context, size_t *ret_len);
+      int set_srcMACFromClientIDFilterExclude(void *data_context, long *val, size_t val_len);
+      char *get_destMACFromClientIDFilter(void *data_context, size_t *ret_len);
+      int set_destMACFromClientIDFilter(void *data_context, char *val, size_t val_len);
+      long *get_destMACFromClientIDFilterExclude(void *data_context, size_t *ret_len);
+      int set_destMACFromClientIDFilterExclude(void *data_context, long *val, size_t val_len);
+      char *get_srcMACFromUserClassIDFilter(void *data_context, size_t *ret_len);
+      int set_srcMACFromUserClassIDFilter(void *data_context, char *val, size_t val_len);
+      long *get_srcMACFromUserClassIDFilterExclude(void *data_context, size_t *ret_len);
+      int set_srcMACFromUserClassIDFilterExclude(void *data_context, long *val, size_t val_len);
+      char *get_destMACFromUserClassIDFilter(void *data_context, size_t *ret_len);
+      int set_destMACFromUserClassIDFilter(void *data_context, char *val, size_t val_len);
+      long *get_destMACFromUserClassIDFilterExclude(void *data_context, size_t *ret_len);
+      int set_destMACFromUserClassIDFilterExclude(void *data_context, long *val, size_t val_len);
+
+#endif /* FILTERRULETABLE_ACCESS_H */
diff -Naur net-snmp-5.7.2-orig/agent/mibgroup/ZYXEL-PRESTIGE-MIB/filterRuleTable.c net-snmp-5.7.2/agent/mibgroup/ZYXEL-PRESTIGE-MIB/filterRuleTable.c
--- net-snmp-5.7.2-orig/agent/mibgroup/ZYXEL-PRESTIGE-MIB/filterRuleTable.c	1970-01-01 08:00:00.000000000 +0800
+++ net-snmp-5.7.2/agent/mibgroup/ZYXEL-PRESTIGE-MIB/filterRuleTable.c	2013-10-08 09:35:17.626117000 +0800
@@ -0,0 +1,2098 @@
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *        : mib2c.iterate_access.conf 15179 2006-09-08 15:44:37Z dts12 $
+ */
+
+#include <net-snmp/net-snmp-config.h>
+#include <net-snmp/net-snmp-includes.h>
+#include <net-snmp/agent/net-snmp-agent-includes.h>
+#include "filterRuleTable.h"
+#include "filterRuleTable_checkfns.h"
+#include "filterRuleTable_access.h"
+
+static netsnmp_oid_stash_node *undoStorage = NULL;
+static netsnmp_oid_stash_node *commitStorage = NULL;
+
+struct undoInfo {
+   void *ptr;
+   size_t len;
+};
+
+struct commitInfo {
+   void *data_context;
+   int have_committed;
+   int new_row;
+};
+
+void
+filterRuleTable_free_undoInfo(void *vptr) {
+    struct undoInfo *ui = vptr;
+    if (!ui)
+        return;
+    SNMP_FREE(ui->ptr);
+    SNMP_FREE(ui);
+}
+
+/** Initialize the filterRuleTable table by defining its contents and how it's structured */
+void
+initialize_table_filterRuleTable(void)
+{
+    static oid filterRuleTable_oid[] = {1,3,6,1,4,1,890,1,2,1,5,1};
+    netsnmp_table_registration_info *table_info;
+    netsnmp_handler_registration *my_handler;
+    netsnmp_iterator_info *iinfo;
+
+    /** create the table registration information structures */
+    table_info = SNMP_MALLOC_TYPEDEF(netsnmp_table_registration_info);
+    iinfo = SNMP_MALLOC_TYPEDEF(netsnmp_iterator_info);
+
+    my_handler = netsnmp_create_handler_registration("filterRuleTable",
+                                             filterRuleTable_handler,
+                                             filterRuleTable_oid,
+                                             OID_LENGTH(filterRuleTable_oid),
+                                             HANDLER_CAN_RWRITE
+                                             );
+            
+    if (!my_handler || !table_info || !iinfo) {
+        snmp_log(LOG_ERR, "malloc failed in initialize_table_filterRuleTable");
+        return; /** Serious error. */
+    }
+
+    /***************************************************
+     * Setting up the table's definition
+     */
+    netsnmp_table_helper_add_indexes(table_info,
+                                  ASN_INTEGER, /** index: filterRuleIndex */
+                             0);
+
+    /** Define the minimum and maximum accessible columns.  This
+        optimizes retrival. */
+    table_info->min_column = 1;
+    table_info->max_column = 26;
+
+    /** iterator access routines */
+    iinfo->get_first_data_point = filterRuleTable_get_first_data_point;
+    iinfo->get_next_data_point = filterRuleTable_get_next_data_point;
+
+    /** you may wish to set these as well */
+#ifdef MAYBE_USE_THESE
+    iinfo->make_data_context = filterRuleTable_context_convert_function;
+    iinfo->free_data_context = filterRuleTable_data_free;
+
+    /** pick *only* one of these if you use them */
+    iinfo->free_loop_context = filterRuleTable_loop_free;
+    iinfo->free_loop_context_at_end = filterRuleTable_loop_free;
+#endif
+
+    /** tie the two structures together */
+    iinfo->table_reginfo = table_info;
+
+    /***************************************************
+     * registering the table with the master agent
+     */
+    DEBUGMSGTL(("initialize_table_filterRuleTable",
+                "Registering table filterRuleTable as a table iterator\n"));		 
+    netsnmp_register_table_iterator(my_handler, iinfo);
+}
+
+/** Initializes the filterRuleTable module */
+void
+init_filterRuleTable(void)
+{
+
+  /** here we initialize all the tables we're planning on supporting */
+    initialize_table_filterRuleTable();
+}
+
+/** handles requests for the filterRuleTable table, if anything else needs to be done */
+int
+filterRuleTable_handler(
+    netsnmp_mib_handler               *handler,
+    netsnmp_handler_registration      *reginfo,
+    netsnmp_agent_request_info        *reqinfo,
+    netsnmp_request_info              *requests) {
+
+    netsnmp_request_info *request;
+    netsnmp_table_request_info *table_info;
+    netsnmp_variable_list *var;
+    struct commitInfo *ci = NULL;
+
+    void *data_context = NULL;
+
+    oid *suffix;
+    size_t suffix_len;
+
+    /** column and row index encoded portion */
+    suffix = requests->requestvb->name + reginfo->rootoid_len + 1;
+    suffix_len = requests->requestvb->name_length -
+        (reginfo->rootoid_len + 1);
+    
+    for(request = requests; request; request = request->next) {
+        var = request->requestvb;
+        if (request->processed != 0)
+            continue;
+
+        switch (reqinfo->mode) {
+        case MODE_GET:
+            data_context =  netsnmp_extract_iterator_context(request);
+            if (data_context == NULL) {
+                netsnmp_set_request_error(reqinfo, request,
+                                          SNMP_NOSUCHINSTANCE);
+                continue;
+            }
+            break;
+
+        case MODE_SET_RESERVE1:
+            data_context =  netsnmp_extract_iterator_context(request);
+            if (data_context == NULL) {
+                netsnmp_set_request_error(reqinfo, request,
+                                          SNMP_ERR_NOCREATION);
+                continue;
+            }
+            break;
+
+        default: /* == the other SET modes */
+            ci = netsnmp_oid_stash_get_data(commitStorage,
+                                            suffix+1, suffix_len-1);
+            break;
+        }
+
+        /** extracts the information about the table from the request */
+        table_info = netsnmp_extract_table_info(request);
+        /** table_info->colnum contains the column number requested */
+        /** table_info->indexes contains a linked list of snmp variable
+           bindings for the indexes of the table.  Values in the list
+           have been set corresponding to the indexes of the
+           request */
+        if (table_info == NULL) {
+            continue;
+        }
+
+        switch(reqinfo->mode) {
+            case MODE_GET:
+                switch(table_info->colnum) {
+                    case COLUMN_FILTERRULEINDEX:
+                            {
+                                long *retval;
+                                size_t retval_len = 0;
+                                retval = get_filterRuleIndex(data_context, &retval_len);
+                                if (retval)
+                                    snmp_set_var_typed_value(var, ASN_INTEGER,
+                                                         (const u_char *) retval,
+                                                         retval_len);
+                            }
+                        break;
+
+                    case COLUMN_FILTERKEY:
+                            {
+                                long *retval;
+                                size_t retval_len = 0;
+                                retval = get_filterKey(data_context, &retval_len);
+                                if (retval)
+                                    snmp_set_var_typed_value(var, ASN_INTEGER,
+                                                         (const u_char *) retval,
+                                                         retval_len);
+                            }
+                        break;
+
+                    case COLUMN_FILTERENABLE:
+                            {
+                                long *retval;
+                                size_t retval_len = 0;
+                                retval = get_filterEnable(data_context, &retval_len);
+                                if (retval)
+                                    snmp_set_var_typed_value(var, ASN_INTEGER,
+                                                         (const u_char *) retval,
+                                                         retval_len);
+                            }
+                        break;
+
+                    case COLUMN_FILTERBRIDGEREFERENCE:
+                            {
+                                long *retval;
+                                size_t retval_len = 0;
+                                retval = get_filterBridgeReference(data_context, &retval_len);
+                                if (retval)
+                                    snmp_set_var_typed_value(var, ASN_INTEGER,
+                                                         (const u_char *) retval,
+                                                         retval_len);
+                            }
+                        break;
+
+                    case COLUMN_EXCLUSIVITYORDER:
+                            {
+                                long *retval;
+                                size_t retval_len = 0;
+                                retval = get_exclusivityOrder(data_context, &retval_len);
+                                if (retval)
+                                    snmp_set_var_typed_value(var, ASN_INTEGER,
+                                                         (const u_char *) retval,
+                                                         retval_len);
+                            }
+                        break;
+
+                    case COLUMN_FILTERINTERFACE:
+                            {
+                                char *retval;
+                                size_t retval_len = 0;
+                                retval = get_filterInterface(data_context, &retval_len);
+                                if (retval)
+                                    snmp_set_var_typed_value(var, ASN_OCTET_STR,
+                                                         (const u_char *) retval,
+                                                         retval_len);
+                            }
+                        break;
+
+                    case COLUMN_VLANIDFILTER:
+                            {
+                                long *retval;
+                                size_t retval_len = 0;
+                                retval = get_vlanIDFilter(data_context, &retval_len);
+                                if (retval)
+                                    snmp_set_var_typed_value(var, ASN_INTEGER,
+                                                         (const u_char *) retval,
+                                                         retval_len);
+                            }
+                        break;
+
+                    case COLUMN_ADMITONLYVLANTAGGED:
+                            {
+                                long *retval;
+                                size_t retval_len = 0;
+                                retval = get_admitOnlyVLANTagged(data_context, &retval_len);
+                                if (retval)
+                                    snmp_set_var_typed_value(var, ASN_INTEGER,
+                                                         (const u_char *) retval,
+                                                         retval_len);
+                            }
+                        break;
+
+                    case COLUMN_ETHERTYPEFILTERLIST:
+                            {
+                                char *retval;
+                                size_t retval_len = 0;
+                                retval = get_ethertypeFilterList(data_context, &retval_len);
+                                if (retval)
+                                    snmp_set_var_typed_value(var, ASN_OCTET_STR,
+                                                         (const u_char *) retval,
+                                                         retval_len);
+                            }
+                        break;
+
+                    case COLUMN_ETHERTYPEFILTEREXCLUDE:
+                            {
+                                long *retval;
+                                size_t retval_len = 0;
+                                retval = get_ethertypeFilterExclude(data_context, &retval_len);
+                                if (retval)
+                                    snmp_set_var_typed_value(var, ASN_INTEGER,
+                                                         (const u_char *) retval,
+                                                         retval_len);
+                            }
+                        break;
+
+                    case COLUMN_SOURCEMACADDRESSFILTERLIST:
+                            {
+                                char *retval;
+                                size_t retval_len = 0;
+                                retval = get_sourceMACAddressFilterList(data_context, &retval_len);
+                                if (retval)
+                                    snmp_set_var_typed_value(var, ASN_OCTET_STR,
+                                                         (const u_char *) retval,
+                                                         retval_len);
+                            }
+                        break;
+
+                    case COLUMN_SOURCEMACADDRESSFILTEREXCLUDE:
+                            {
+                                long *retval;
+                                size_t retval_len = 0;
+                                retval = get_sourceMACAddressFilterExclude(data_context, &retval_len);
+                                if (retval)
+                                    snmp_set_var_typed_value(var, ASN_INTEGER,
+                                                         (const u_char *) retval,
+                                                         retval_len);
+                            }
+                        break;
+
+                    case COLUMN_DESTMACADDRESSFILTERLIST:
+                            {
+                                char *retval;
+                                size_t retval_len = 0;
+                                retval = get_destMACAddressFilterList(data_context, &retval_len);
+                                if (retval)
+                                    snmp_set_var_typed_value(var, ASN_OCTET_STR,
+                                                         (const u_char *) retval,
+                                                         retval_len);
+                            }
+                        break;
+
+                    case COLUMN_DESTMACADDRESSFILTEREXCLUDE:
+                            {
+                                long *retval;
+                                size_t retval_len = 0;
+                                retval = get_destMACAddressFilterExclude(data_context, &retval_len);
+                                if (retval)
+                                    snmp_set_var_typed_value(var, ASN_INTEGER,
+                                                         (const u_char *) retval,
+                                                         retval_len);
+                            }
+                        break;
+
+                    case COLUMN_SRCMACFROMVENDORCLASSIDFILTER:
+                            {
+                                char *retval;
+                                size_t retval_len = 0;
+                                retval = get_srcMACFromVendorClassIDFilter(data_context, &retval_len);
+                                if (retval)
+                                    snmp_set_var_typed_value(var, ASN_OCTET_STR,
+                                                         (const u_char *) retval,
+                                                         retval_len);
+                            }
+                        break;
+
+                    case COLUMN_SRCMACFROMVENDORCLASSIDFILTEREXCLUDE:
+                            {
+                                long *retval;
+                                size_t retval_len = 0;
+                                retval = get_srcMACFromVendorClassIDFilterExclude(data_context, &retval_len);
+                                if (retval)
+                                    snmp_set_var_typed_value(var, ASN_INTEGER,
+                                                         (const u_char *) retval,
+                                                         retval_len);
+                            }
+                        break;
+
+                    case COLUMN_DESTMACFROMVENDORCLASSIDFILTER:
+                            {
+                                char *retval;
+                                size_t retval_len = 0;
+                                retval = get_destMACFromVendorClassIDFilter(data_context, &retval_len);
+                                if (retval)
+                                    snmp_set_var_typed_value(var, ASN_OCTET_STR,
+                                                         (const u_char *) retval,
+                                                         retval_len);
+                            }
+                        break;
+
+                    case COLUMN_DESTMACFROMVENDORCLASSIDFILTEREXCLUDE:
+                            {
+                                long *retval;
+                                size_t retval_len = 0;
+                                retval = get_destMACFromVendorClassIDFilterExclude(data_context, &retval_len);
+                                if (retval)
+                                    snmp_set_var_typed_value(var, ASN_INTEGER,
+                                                         (const u_char *) retval,
+                                                         retval_len);
+                            }
+                        break;
+
+                    case COLUMN_SRCMACFROMCLIENTIDFILTER:
+                            {
+                                char *retval;
+                                size_t retval_len = 0;
+                                retval = get_srcMACFromClientIDFilter(data_context, &retval_len);
+                                if (retval)
+                                    snmp_set_var_typed_value(var, ASN_OCTET_STR,
+                                                         (const u_char *) retval,
+                                                         retval_len);
+                            }
+                        break;
+
+                    case COLUMN_SRCMACFROMCLIENTIDFILTEREXCLUDE:
+                            {
+                                long *retval;
+                                size_t retval_len = 0;
+                                retval = get_srcMACFromClientIDFilterExclude(data_context, &retval_len);
+                                if (retval)
+                                    snmp_set_var_typed_value(var, ASN_INTEGER,
+                                                         (const u_char *) retval,
+                                                         retval_len);
+                            }
+                        break;
+
+                    case COLUMN_DESTMACFROMCLIENTIDFILTER:
+                            {
+                                char *retval;
+                                size_t retval_len = 0;
+                                retval = get_destMACFromClientIDFilter(data_context, &retval_len);
+                                if (retval)
+                                    snmp_set_var_typed_value(var, ASN_OCTET_STR,
+                                                         (const u_char *) retval,
+                                                         retval_len);
+                            }
+                        break;
+
+                    case COLUMN_DESTMACFROMCLIENTIDFILTEREXCLUDE:
+                            {
+                                long *retval;
+                                size_t retval_len = 0;
+                                retval = get_destMACFromClientIDFilterExclude(data_context, &retval_len);
+                                if (retval)
+                                    snmp_set_var_typed_value(var, ASN_INTEGER,
+                                                         (const u_char *) retval,
+                                                         retval_len);
+                            }
+                        break;
+
+                    case COLUMN_SRCMACFROMUSERCLASSIDFILTER:
+                            {
+                                char *retval;
+                                size_t retval_len = 0;
+                                retval = get_srcMACFromUserClassIDFilter(data_context, &retval_len);
+                                if (retval)
+                                    snmp_set_var_typed_value(var, ASN_OCTET_STR,
+                                                         (const u_char *) retval,
+                                                         retval_len);
+                            }
+                        break;
+
+                    case COLUMN_SRCMACFROMUSERCLASSIDFILTEREXCLUDE:
+                            {
+                                long *retval;
+                                size_t retval_len = 0;
+                                retval = get_srcMACFromUserClassIDFilterExclude(data_context, &retval_len);
+                                if (retval)
+                                    snmp_set_var_typed_value(var, ASN_INTEGER,
+                                                         (const u_char *) retval,
+                                                         retval_len);
+                            }
+                        break;
+
+                    case COLUMN_DESTMACFROMUSERCLASSIDFILTER:
+                            {
+                                char *retval;
+                                size_t retval_len = 0;
+                                retval = get_destMACFromUserClassIDFilter(data_context, &retval_len);
+                                if (retval)
+                                    snmp_set_var_typed_value(var, ASN_OCTET_STR,
+                                                         (const u_char *) retval,
+                                                         retval_len);
+                            }
+                        break;
+
+                    case COLUMN_DESTMACFROMUSERCLASSIDFILTEREXCLUDE:
+                            {
+                                long *retval;
+                                size_t retval_len = 0;
+                                retval = get_destMACFromUserClassIDFilterExclude(data_context, &retval_len);
+                                if (retval)
+                                    snmp_set_var_typed_value(var, ASN_INTEGER,
+                                                         (const u_char *) retval,
+                                                         retval_len);
+                            }
+                        break;
+
+                    default:
+                /** We shouldn't get here */
+                        snmp_log(LOG_ERR, "problem encountered in filterRuleTable_handler: unknown column\n");
+                }
+                break;
+
+            case MODE_SET_RESERVE1:
+                ci = netsnmp_oid_stash_get_data(commitStorage,
+                                                suffix+1, suffix_len-1);
+                
+                if (!ci) {
+                    /** create the commit storage info */
+                    ci = SNMP_MALLOC_STRUCT(commitInfo);
+                    if (!data_context) {
+                        //ci->data_context = filterRuleTable_create_data_context(table_info->indexes, COLUMN_):
+                        ci->new_row = 1;
+						ci->data_context=data_context;
+                    } else {
+                        ci->data_context = data_context;
+                    }
+                    netsnmp_oid_stash_add_data(&commitStorage,
+                                               suffix+1, suffix_len-1, ci);
+                }
+            break;
+                
+            case MODE_SET_RESERVE2:
+                switch(table_info->colnum) {
+                          
+                          case COLUMN_FILTERENABLE:
+                            {
+                                long *retval;
+                                size_t retval_len = 0;
+                                struct undoInfo *ui = NULL;
+                                int ret;
+                                
+                    /** first, get the old value */
+                                retval = get_filterEnable(ci->data_context, &retval_len);
+                                if (retval) {
+                                    ui = SNMP_MALLOC_STRUCT(undoInfo);
+                                    ui->len = retval_len;
+                                    memdup((u_char **) &ui->ptr,
+                                           (u_char *) retval,
+                                           ui->len);
+                                }
+
+                    /** check the new value, possibly against the
+                        older value for a valid state transition */
+                                ret = check_filterEnable(request->requestvb->type,
+                                                   (long *) request->requestvb->val.string,
+                                                   request->requestvb->val_len,
+                                                   retval, retval_len);
+                                if (ret != 0) {
+                                    netsnmp_set_request_error(reqinfo, request,
+                                                              ret);
+                                    filterRuleTable_free_undoInfo(ui);
+                                } else if (ui) {
+                        /** remember information for undo purposes later */
+                                    netsnmp_oid_stash_add_data(&undoStorage,
+                                                               suffix,
+                                                               suffix_len,
+                                                               ui);
+                                }
+                                
+                            }
+                            break;
+                          case COLUMN_FILTERBRIDGEREFERENCE:
+                            {
+                                long *retval;
+                                size_t retval_len = 0;
+                                struct undoInfo *ui = NULL;
+                                int ret;
+                                
+                    /** first, get the old value */
+                                retval = get_filterBridgeReference(ci->data_context, &retval_len);
+                                if (retval) {
+                                    ui = SNMP_MALLOC_STRUCT(undoInfo);
+                                    ui->len = retval_len;
+                                    memdup((u_char **) &ui->ptr,
+                                           (u_char *) retval,
+                                           ui->len);
+                                }
+
+                    /** check the new value, possibly against the
+                        older value for a valid state transition */
+                                ret = check_filterBridgeReference(request->requestvb->type,
+                                                   (long *) request->requestvb->val.string,
+                                                   request->requestvb->val_len,
+                                                   retval, retval_len);
+                                if (ret != 0) {
+                                    netsnmp_set_request_error(reqinfo, request,
+                                                              ret);
+                                    filterRuleTable_free_undoInfo(ui);
+                                } else if (ui) {
+                        /** remember information for undo purposes later */
+                                    netsnmp_oid_stash_add_data(&undoStorage,
+                                                               suffix,
+                                                               suffix_len,
+                                                               ui);
+                                }
+                                
+                            }
+                            break;
+                          case COLUMN_EXCLUSIVITYORDER:
+                            {
+                                long *retval;
+                                size_t retval_len = 0;
+                                struct undoInfo *ui = NULL;
+                                int ret;
+                                
+                    /** first, get the old value */
+                                retval = get_exclusivityOrder(ci->data_context, &retval_len);
+                                if (retval) {
+                                    ui = SNMP_MALLOC_STRUCT(undoInfo);
+                                    ui->len = retval_len;
+                                    memdup((u_char **) &ui->ptr,
+                                           (u_char *) retval,
+                                           ui->len);
+                                }
+
+                    /** check the new value, possibly against the
+                        older value for a valid state transition */
+                                ret = check_exclusivityOrder(request->requestvb->type,
+                                                   (long *) request->requestvb->val.string,
+                                                   request->requestvb->val_len,
+                                                   retval, retval_len);
+                                if (ret != 0) {
+                                    netsnmp_set_request_error(reqinfo, request,
+                                                              ret);
+                                    filterRuleTable_free_undoInfo(ui);
+                                } else if (ui) {
+                        /** remember information for undo purposes later */
+                                    netsnmp_oid_stash_add_data(&undoStorage,
+                                                               suffix,
+                                                               suffix_len,
+                                                               ui);
+                                }
+                                
+                            }
+                            break;
+                          case COLUMN_FILTERINTERFACE:
+                            {
+                                char *retval;
+                                size_t retval_len = 0;
+                                struct undoInfo *ui = NULL;
+                                int ret;
+                                
+                    /** first, get the old value */
+                                retval = get_filterInterface(ci->data_context, &retval_len);
+                                if (retval) {
+                                    ui = SNMP_MALLOC_STRUCT(undoInfo);
+                                    ui->len = retval_len;
+                                    memdup((u_char **) &ui->ptr,
+                                           (u_char *) retval,
+                                           ui->len);
+                                }
+
+                    /** check the new value, possibly against the
+                        older value for a valid state transition */
+                                ret = check_filterInterface(request->requestvb->type,
+                                                   (char *) request->requestvb->val.string,
+                                                   request->requestvb->val_len,
+                                                   retval, retval_len);
+                                if (ret != 0) {
+                                    netsnmp_set_request_error(reqinfo, request,
+                                                              ret);
+                                    filterRuleTable_free_undoInfo(ui);
+                                } else if (ui) {
+                        /** remember information for undo purposes later */
+                                    netsnmp_oid_stash_add_data(&undoStorage,
+                                                               suffix,
+                                                               suffix_len,
+                                                               ui);
+                                }
+                                
+                            }
+                            break;
+                          case COLUMN_VLANIDFILTER:
+                            {
+                                long *retval;
+                                size_t retval_len = 0;
+                                struct undoInfo *ui = NULL;
+                                int ret;
+                                
+                    /** first, get the old value */
+                                retval = get_vlanIDFilter(ci->data_context, &retval_len);
+                                if (retval) {
+                                    ui = SNMP_MALLOC_STRUCT(undoInfo);
+                                    ui->len = retval_len;
+                                    memdup((u_char **) &ui->ptr,
+                                           (u_char *) retval,
+                                           ui->len);
+                                }
+
+                    /** check the new value, possibly against the
+                        older value for a valid state transition */
+                                ret = check_vlanIDFilter(request->requestvb->type,
+                                                   (long *) request->requestvb->val.string,
+                                                   request->requestvb->val_len,
+                                                   retval, retval_len);
+                                if (ret != 0) {
+                                    netsnmp_set_request_error(reqinfo, request,
+                                                              ret);
+                                    filterRuleTable_free_undoInfo(ui);
+                                } else if (ui) {
+                        /** remember information for undo purposes later */
+                                    netsnmp_oid_stash_add_data(&undoStorage,
+                                                               suffix,
+                                                               suffix_len,
+                                                               ui);
+                                }
+                                
+                            }
+                            break;
+                          case COLUMN_ADMITONLYVLANTAGGED:
+                            {
+                                long *retval;
+                                size_t retval_len = 0;
+                                struct undoInfo *ui = NULL;
+                                int ret;
+                                
+                    /** first, get the old value */
+                                retval = get_admitOnlyVLANTagged(ci->data_context, &retval_len);
+                                if (retval) {
+                                    ui = SNMP_MALLOC_STRUCT(undoInfo);
+                                    ui->len = retval_len;
+                                    memdup((u_char **) &ui->ptr,
+                                           (u_char *) retval,
+                                           ui->len);
+                                }
+
+                    /** check the new value, possibly against the
+                        older value for a valid state transition */
+                                ret = check_admitOnlyVLANTagged(request->requestvb->type,
+                                                   (long *) request->requestvb->val.string,
+                                                   request->requestvb->val_len,
+                                                   retval, retval_len);
+                                if (ret != 0) {
+                                    netsnmp_set_request_error(reqinfo, request,
+                                                              ret);
+                                    filterRuleTable_free_undoInfo(ui);
+                                } else if (ui) {
+                        /** remember information for undo purposes later */
+                                    netsnmp_oid_stash_add_data(&undoStorage,
+                                                               suffix,
+                                                               suffix_len,
+                                                               ui);
+                                }
+                                
+                            }
+                            break;
+                          case COLUMN_ETHERTYPEFILTERLIST:
+                            {
+                                char *retval;
+                                size_t retval_len = 0;
+                                struct undoInfo *ui = NULL;
+                                int ret;
+                                
+                    /** first, get the old value */
+                                retval = get_ethertypeFilterList(ci->data_context, &retval_len);
+                                if (retval) {
+                                    ui = SNMP_MALLOC_STRUCT(undoInfo);
+                                    ui->len = retval_len;
+                                    memdup((u_char **) &ui->ptr,
+                                           (u_char *) retval,
+                                           ui->len);
+                                }
+
+                    /** check the new value, possibly against the
+                        older value for a valid state transition */
+                                ret = check_ethertypeFilterList(request->requestvb->type,
+                                                   (char *) request->requestvb->val.string,
+                                                   request->requestvb->val_len,
+                                                   retval, retval_len);
+                                if (ret != 0) {
+                                    netsnmp_set_request_error(reqinfo, request,
+                                                              ret);
+                                    filterRuleTable_free_undoInfo(ui);
+                                } else if (ui) {
+                        /** remember information for undo purposes later */
+                                    netsnmp_oid_stash_add_data(&undoStorage,
+                                                               suffix,
+                                                               suffix_len,
+                                                               ui);
+                                }
+                                
+                            }
+                            break;
+                          case COLUMN_ETHERTYPEFILTEREXCLUDE:
+                            {
+                                long *retval;
+                                size_t retval_len = 0;
+                                struct undoInfo *ui = NULL;
+                                int ret;
+                                
+                    /** first, get the old value */
+                                retval = get_ethertypeFilterExclude(ci->data_context, &retval_len);
+                                if (retval) {
+                                    ui = SNMP_MALLOC_STRUCT(undoInfo);
+                                    ui->len = retval_len;
+                                    memdup((u_char **) &ui->ptr,
+                                           (u_char *) retval,
+                                           ui->len);
+                                }
+
+                    /** check the new value, possibly against the
+                        older value for a valid state transition */
+                                ret = check_ethertypeFilterExclude(request->requestvb->type,
+                                                   (long *) request->requestvb->val.string,
+                                                   request->requestvb->val_len,
+                                                   retval, retval_len);
+                                if (ret != 0) {
+                                    netsnmp_set_request_error(reqinfo, request,
+                                                              ret);
+                                    filterRuleTable_free_undoInfo(ui);
+                                } else if (ui) {
+                        /** remember information for undo purposes later */
+                                    netsnmp_oid_stash_add_data(&undoStorage,
+                                                               suffix,
+                                                               suffix_len,
+                                                               ui);
+                                }
+                                
+                            }
+                            break;
+                          case COLUMN_SOURCEMACADDRESSFILTERLIST:
+                            {
+                                char *retval;
+                                size_t retval_len = 0;
+                                struct undoInfo *ui = NULL;
+                                int ret;
+                                
+                    /** first, get the old value */
+                                retval = get_sourceMACAddressFilterList(ci->data_context, &retval_len);
+                                if (retval) {
+                                    ui = SNMP_MALLOC_STRUCT(undoInfo);
+                                    ui->len = retval_len;
+                                    memdup((u_char **) &ui->ptr,
+                                           (u_char *) retval,
+                                           ui->len);
+                                }
+
+                    /** check the new value, possibly against the
+                        older value for a valid state transition */
+                                ret = check_sourceMACAddressFilterList(request->requestvb->type,
+                                                   (char *) request->requestvb->val.string,
+                                                   request->requestvb->val_len,
+                                                   retval, retval_len);
+                                if (ret != 0) {
+                                    netsnmp_set_request_error(reqinfo, request,
+                                                              ret);
+                                    filterRuleTable_free_undoInfo(ui);
+                                } else if (ui) {
+                        /** remember information for undo purposes later */
+                                    netsnmp_oid_stash_add_data(&undoStorage,
+                                                               suffix,
+                                                               suffix_len,
+                                                               ui);
+                                }
+                                
+                            }
+                            break;
+                          case COLUMN_SOURCEMACADDRESSFILTEREXCLUDE:
+                            {
+                                long *retval;
+                                size_t retval_len = 0;
+                                struct undoInfo *ui = NULL;
+                                int ret;
+                                
+                    /** first, get the old value */
+                                retval = get_sourceMACAddressFilterExclude(ci->data_context, &retval_len);
+                                if (retval) {
+                                    ui = SNMP_MALLOC_STRUCT(undoInfo);
+                                    ui->len = retval_len;
+                                    memdup((u_char **) &ui->ptr,
+                                           (u_char *) retval,
+                                           ui->len);
+                                }
+
+                    /** check the new value, possibly against the
+                        older value for a valid state transition */
+                                ret = check_sourceMACAddressFilterExclude(request->requestvb->type,
+                                                   (long *) request->requestvb->val.string,
+                                                   request->requestvb->val_len,
+                                                   retval, retval_len);
+                                if (ret != 0) {
+                                    netsnmp_set_request_error(reqinfo, request,
+                                                              ret);
+                                    filterRuleTable_free_undoInfo(ui);
+                                } else if (ui) {
+                        /** remember information for undo purposes later */
+                                    netsnmp_oid_stash_add_data(&undoStorage,
+                                                               suffix,
+                                                               suffix_len,
+                                                               ui);
+                                }
+                                
+                            }
+                            break;
+                          case COLUMN_DESTMACADDRESSFILTERLIST:
+                            {
+                                char *retval;
+                                size_t retval_len = 0;
+                                struct undoInfo *ui = NULL;
+                                int ret;
+                                
+                    /** first, get the old value */
+                                retval = get_destMACAddressFilterList(ci->data_context, &retval_len);
+                                if (retval) {
+                                    ui = SNMP_MALLOC_STRUCT(undoInfo);
+                                    ui->len = retval_len;
+                                    memdup((u_char **) &ui->ptr,
+                                           (u_char *) retval,
+                                           ui->len);
+                                }
+
+                    /** check the new value, possibly against the
+                        older value for a valid state transition */
+                                ret = check_destMACAddressFilterList(request->requestvb->type,
+                                                   (char *) request->requestvb->val.string,
+                                                   request->requestvb->val_len,
+                                                   retval, retval_len);
+                                if (ret != 0) {
+                                    netsnmp_set_request_error(reqinfo, request,
+                                                              ret);
+                                    filterRuleTable_free_undoInfo(ui);
+                                } else if (ui) {
+                        /** remember information for undo purposes later */
+                                    netsnmp_oid_stash_add_data(&undoStorage,
+                                                               suffix,
+                                                               suffix_len,
+                                                               ui);
+                                }
+                                
+                            }
+                            break;
+                          case COLUMN_DESTMACADDRESSFILTEREXCLUDE:
+                            {
+                                long *retval;
+                                size_t retval_len = 0;
+                                struct undoInfo *ui = NULL;
+                                int ret;
+                                
+                    /** first, get the old value */
+                                retval = get_destMACAddressFilterExclude(ci->data_context, &retval_len);
+                                if (retval) {
+                                    ui = SNMP_MALLOC_STRUCT(undoInfo);
+                                    ui->len = retval_len;
+                                    memdup((u_char **) &ui->ptr,
+                                           (u_char *) retval,
+                                           ui->len);
+                                }
+
+                    /** check the new value, possibly against the
+                        older value for a valid state transition */
+                                ret = check_destMACAddressFilterExclude(request->requestvb->type,
+                                                   (long *) request->requestvb->val.string,
+                                                   request->requestvb->val_len,
+                                                   retval, retval_len);
+                                if (ret != 0) {
+                                    netsnmp_set_request_error(reqinfo, request,
+                                                              ret);
+                                    filterRuleTable_free_undoInfo(ui);
+                                } else if (ui) {
+                        /** remember information for undo purposes later */
+                                    netsnmp_oid_stash_add_data(&undoStorage,
+                                                               suffix,
+                                                               suffix_len,
+                                                               ui);
+                                }
+                                
+                            }
+                            break;
+                          case COLUMN_SRCMACFROMVENDORCLASSIDFILTER:
+                            {
+                                char *retval;
+                                size_t retval_len = 0;
+                                struct undoInfo *ui = NULL;
+                                int ret;
+                                
+                    /** first, get the old value */
+                                retval = get_srcMACFromVendorClassIDFilter(ci->data_context, &retval_len);
+                                if (retval) {
+                                    ui = SNMP_MALLOC_STRUCT(undoInfo);
+                                    ui->len = retval_len;
+                                    memdup((u_char **) &ui->ptr,
+                                           (u_char *) retval,
+                                           ui->len);
+                                }
+
+                    /** check the new value, possibly against the
+                        older value for a valid state transition */
+                                ret = check_srcMACFromVendorClassIDFilter(request->requestvb->type,
+                                                   (char *) request->requestvb->val.string,
+                                                   request->requestvb->val_len,
+                                                   retval, retval_len);
+                                if (ret != 0) {
+                                    netsnmp_set_request_error(reqinfo, request,
+                                                              ret);
+                                    filterRuleTable_free_undoInfo(ui);
+                                } else if (ui) {
+                        /** remember information for undo purposes later */
+                                    netsnmp_oid_stash_add_data(&undoStorage,
+                                                               suffix,
+                                                               suffix_len,
+                                                               ui);
+                                }
+                                
+                            }
+                            break;
+                          case COLUMN_SRCMACFROMVENDORCLASSIDFILTEREXCLUDE:
+                            {
+                                long *retval;
+                                size_t retval_len = 0;
+                                struct undoInfo *ui = NULL;
+                                int ret;
+                                
+                    /** first, get the old value */
+                                retval = get_srcMACFromVendorClassIDFilterExclude(ci->data_context, &retval_len);
+                                if (retval) {
+                                    ui = SNMP_MALLOC_STRUCT(undoInfo);
+                                    ui->len = retval_len;
+                                    memdup((u_char **) &ui->ptr,
+                                           (u_char *) retval,
+                                           ui->len);
+                                }
+
+                    /** check the new value, possibly against the
+                        older value for a valid state transition */
+                                ret = check_srcMACFromVendorClassIDFilterExclude(request->requestvb->type,
+                                                   (long *) request->requestvb->val.string,
+                                                   request->requestvb->val_len,
+                                                   retval, retval_len);
+                                if (ret != 0) {
+                                    netsnmp_set_request_error(reqinfo, request,
+                                                              ret);
+                                    filterRuleTable_free_undoInfo(ui);
+                                } else if (ui) {
+                        /** remember information for undo purposes later */
+                                    netsnmp_oid_stash_add_data(&undoStorage,
+                                                               suffix,
+                                                               suffix_len,
+                                                               ui);
+                                }
+                                
+                            }
+                            break;
+                          case COLUMN_DESTMACFROMVENDORCLASSIDFILTER:
+                            {
+                                char *retval;
+                                size_t retval_len = 0;
+                                struct undoInfo *ui = NULL;
+                                int ret;
+                                
+                    /** first, get the old value */
+                                retval = get_destMACFromVendorClassIDFilter(ci->data_context, &retval_len);
+                                if (retval) {
+                                    ui = SNMP_MALLOC_STRUCT(undoInfo);
+                                    ui->len = retval_len;
+                                    memdup((u_char **) &ui->ptr,
+                                           (u_char *) retval,
+                                           ui->len);
+                                }
+
+                    /** check the new value, possibly against the
+                        older value for a valid state transition */
+                                ret = check_destMACFromVendorClassIDFilter(request->requestvb->type,
+                                                   (char *) request->requestvb->val.string,
+                                                   request->requestvb->val_len,
+                                                   retval, retval_len);
+                                if (ret != 0) {
+                                    netsnmp_set_request_error(reqinfo, request,
+                                                              ret);
+                                    filterRuleTable_free_undoInfo(ui);
+                                } else if (ui) {
+                        /** remember information for undo purposes later */
+                                    netsnmp_oid_stash_add_data(&undoStorage,
+                                                               suffix,
+                                                               suffix_len,
+                                                               ui);
+                                }
+                                
+                            }
+                            break;
+                          case COLUMN_DESTMACFROMVENDORCLASSIDFILTEREXCLUDE:
+                            {
+                                long *retval;
+                                size_t retval_len = 0;
+                                struct undoInfo *ui = NULL;
+                                int ret;
+                                
+                    /** first, get the old value */
+                                retval = get_destMACFromVendorClassIDFilterExclude(ci->data_context, &retval_len);
+                                if (retval) {
+                                    ui = SNMP_MALLOC_STRUCT(undoInfo);
+                                    ui->len = retval_len;
+                                    memdup((u_char **) &ui->ptr,
+                                           (u_char *) retval,
+                                           ui->len);
+                                }
+
+                    /** check the new value, possibly against the
+                        older value for a valid state transition */
+                                ret = check_destMACFromVendorClassIDFilterExclude(request->requestvb->type,
+                                                   (long *) request->requestvb->val.string,
+                                                   request->requestvb->val_len,
+                                                   retval, retval_len);
+                                if (ret != 0) {
+                                    netsnmp_set_request_error(reqinfo, request,
+                                                              ret);
+                                    filterRuleTable_free_undoInfo(ui);
+                                } else if (ui) {
+                        /** remember information for undo purposes later */
+                                    netsnmp_oid_stash_add_data(&undoStorage,
+                                                               suffix,
+                                                               suffix_len,
+                                                               ui);
+                                }
+                                
+                            }
+                            break;
+                          case COLUMN_SRCMACFROMCLIENTIDFILTER:
+                            {
+                                char *retval;
+                                size_t retval_len = 0;
+                                struct undoInfo *ui = NULL;
+                                int ret;
+                                
+                    /** first, get the old value */
+                                retval = get_srcMACFromClientIDFilter(ci->data_context, &retval_len);
+                                if (retval) {
+                                    ui = SNMP_MALLOC_STRUCT(undoInfo);
+                                    ui->len = retval_len;
+                                    memdup((u_char **) &ui->ptr,
+                                           (u_char *) retval,
+                                           ui->len);
+                                }
+
+                    /** check the new value, possibly against the
+                        older value for a valid state transition */
+                                ret = check_srcMACFromClientIDFilter(request->requestvb->type,
+                                                   (char *) request->requestvb->val.string,
+                                                   request->requestvb->val_len,
+                                                   retval, retval_len);
+                                if (ret != 0) {
+                                    netsnmp_set_request_error(reqinfo, request,
+                                                              ret);
+                                    filterRuleTable_free_undoInfo(ui);
+                                } else if (ui) {
+                        /** remember information for undo purposes later */
+                                    netsnmp_oid_stash_add_data(&undoStorage,
+                                                               suffix,
+                                                               suffix_len,
+                                                               ui);
+                                }
+                                
+                            }
+                            break;
+                          case COLUMN_SRCMACFROMCLIENTIDFILTEREXCLUDE:
+                            {
+                                long *retval;
+                                size_t retval_len = 0;
+                                struct undoInfo *ui = NULL;
+                                int ret;
+                                
+                    /** first, get the old value */
+                                retval = get_srcMACFromClientIDFilterExclude(ci->data_context, &retval_len);
+                                if (retval) {
+                                    ui = SNMP_MALLOC_STRUCT(undoInfo);
+                                    ui->len = retval_len;
+                                    memdup((u_char **) &ui->ptr,
+                                           (u_char *) retval,
+                                           ui->len);
+                                }
+
+                    /** check the new value, possibly against the
+                        older value for a valid state transition */
+                                ret = check_srcMACFromClientIDFilterExclude(request->requestvb->type,
+                                                   (long *) request->requestvb->val.string,
+                                                   request->requestvb->val_len,
+                                                   retval, retval_len);
+                                if (ret != 0) {
+                                    netsnmp_set_request_error(reqinfo, request,
+                                                              ret);
+                                    filterRuleTable_free_undoInfo(ui);
+                                } else if (ui) {
+                        /** remember information for undo purposes later */
+                                    netsnmp_oid_stash_add_data(&undoStorage,
+                                                               suffix,
+                                                               suffix_len,
+                                                               ui);
+                                }
+                                
+                            }
+                            break;
+                          case COLUMN_DESTMACFROMCLIENTIDFILTER:
+                            {
+                                char *retval;
+                                size_t retval_len = 0;
+                                struct undoInfo *ui = NULL;
+                                int ret;
+                                
+                    /** first, get the old value */
+                                retval = get_destMACFromClientIDFilter(ci->data_context, &retval_len);
+                                if (retval) {
+                                    ui = SNMP_MALLOC_STRUCT(undoInfo);
+                                    ui->len = retval_len;
+                                    memdup((u_char **) &ui->ptr,
+                                           (u_char *) retval,
+                                           ui->len);
+                                }
+
+                    /** check the new value, possibly against the
+                        older value for a valid state transition */
+                                ret = check_destMACFromClientIDFilter(request->requestvb->type,
+                                                   (char *) request->requestvb->val.string,
+                                                   request->requestvb->val_len,
+                                                   retval, retval_len);
+                                if (ret != 0) {
+                                    netsnmp_set_request_error(reqinfo, request,
+                                                              ret);
+                                    filterRuleTable_free_undoInfo(ui);
+                                } else if (ui) {
+                        /** remember information for undo purposes later */
+                                    netsnmp_oid_stash_add_data(&undoStorage,
+                                                               suffix,
+                                                               suffix_len,
+                                                               ui);
+                                }
+                                
+                            }
+                            break;
+                          case COLUMN_DESTMACFROMCLIENTIDFILTEREXCLUDE:
+                            {
+                                long *retval;
+                                size_t retval_len = 0;
+                                struct undoInfo *ui = NULL;
+                                int ret;
+                                
+                    /** first, get the old value */
+                                retval = get_destMACFromClientIDFilterExclude(ci->data_context, &retval_len);
+                                if (retval) {
+                                    ui = SNMP_MALLOC_STRUCT(undoInfo);
+                                    ui->len = retval_len;
+                                    memdup((u_char **) &ui->ptr,
+                                           (u_char *) retval,
+                                           ui->len);
+                                }
+
+                    /** check the new value, possibly against the
+                        older value for a valid state transition */
+                                ret = check_destMACFromClientIDFilterExclude(request->requestvb->type,
+                                                   (long *) request->requestvb->val.string,
+                                                   request->requestvb->val_len,
+                                                   retval, retval_len);
+                                if (ret != 0) {
+                                    netsnmp_set_request_error(reqinfo, request,
+                                                              ret);
+                                    filterRuleTable_free_undoInfo(ui);
+                                } else if (ui) {
+                        /** remember information for undo purposes later */
+                                    netsnmp_oid_stash_add_data(&undoStorage,
+                                                               suffix,
+                                                               suffix_len,
+                                                               ui);
+                                }
+                                
+                            }
+                            break;
+                          case COLUMN_SRCMACFROMUSERCLASSIDFILTER:
+                            {
+                                char *retval;
+                                size_t retval_len = 0;
+                                struct undoInfo *ui = NULL;
+                                int ret;
+                                
+                    /** first, get the old value */
+                                retval = get_srcMACFromUserClassIDFilter(ci->data_context, &retval_len);
+                                if (retval) {
+                                    ui = SNMP_MALLOC_STRUCT(undoInfo);
+                                    ui->len = retval_len;
+                                    memdup((u_char **) &ui->ptr,
+                                           (u_char *) retval,
+                                           ui->len);
+                                }
+
+                    /** check the new value, possibly against the
+                        older value for a valid state transition */
+                                ret = check_srcMACFromUserClassIDFilter(request->requestvb->type,
+                                                   (char *) request->requestvb->val.string,
+                                                   request->requestvb->val_len,
+                                                   retval, retval_len);
+                                if (ret != 0) {
+                                    netsnmp_set_request_error(reqinfo, request,
+                                                              ret);
+                                    filterRuleTable_free_undoInfo(ui);
+                                } else if (ui) {
+                        /** remember information for undo purposes later */
+                                    netsnmp_oid_stash_add_data(&undoStorage,
+                                                               suffix,
+                                                               suffix_len,
+                                                               ui);
+                                }
+                                
+                            }
+                            break;
+                          case COLUMN_SRCMACFROMUSERCLASSIDFILTEREXCLUDE:
+                            {
+                                long *retval;
+                                size_t retval_len = 0;
+                                struct undoInfo *ui = NULL;
+                                int ret;
+                                
+                    /** first, get the old value */
+                                retval = get_srcMACFromUserClassIDFilterExclude(ci->data_context, &retval_len);
+                                if (retval) {
+                                    ui = SNMP_MALLOC_STRUCT(undoInfo);
+                                    ui->len = retval_len;
+                                    memdup((u_char **) &ui->ptr,
+                                           (u_char *) retval,
+                                           ui->len);
+                                }
+
+                    /** check the new value, possibly against the
+                        older value for a valid state transition */
+                                ret = check_srcMACFromUserClassIDFilterExclude(request->requestvb->type,
+                                                   (long *) request->requestvb->val.string,
+                                                   request->requestvb->val_len,
+                                                   retval, retval_len);
+                                if (ret != 0) {
+                                    netsnmp_set_request_error(reqinfo, request,
+                                                              ret);
+                                    filterRuleTable_free_undoInfo(ui);
+                                } else if (ui) {
+                        /** remember information for undo purposes later */
+                                    netsnmp_oid_stash_add_data(&undoStorage,
+                                                               suffix,
+                                                               suffix_len,
+                                                               ui);
+                                }
+                                
+                            }
+                            break;
+                          case COLUMN_DESTMACFROMUSERCLASSIDFILTER:
+                            {
+                                char *retval;
+                                size_t retval_len = 0;
+                                struct undoInfo *ui = NULL;
+                                int ret;
+                                
+                    /** first, get the old value */
+                                retval = get_destMACFromUserClassIDFilter(ci->data_context, &retval_len);
+                                if (retval) {
+                                    ui = SNMP_MALLOC_STRUCT(undoInfo);
+                                    ui->len = retval_len;
+                                    memdup((u_char **) &ui->ptr,
+                                           (u_char *) retval,
+                                           ui->len);
+                                }
+
+                    /** check the new value, possibly against the
+                        older value for a valid state transition */
+                                ret = check_destMACFromUserClassIDFilter(request->requestvb->type,
+                                                   (char *) request->requestvb->val.string,
+                                                   request->requestvb->val_len,
+                                                   retval, retval_len);
+                                if (ret != 0) {
+                                    netsnmp_set_request_error(reqinfo, request,
+                                                              ret);
+                                    filterRuleTable_free_undoInfo(ui);
+                                } else if (ui) {
+                        /** remember information for undo purposes later */
+                                    netsnmp_oid_stash_add_data(&undoStorage,
+                                                               suffix,
+                                                               suffix_len,
+                                                               ui);
+                                }
+                                
+                            }
+                            break;
+                          case COLUMN_DESTMACFROMUSERCLASSIDFILTEREXCLUDE:
+                            {
+                                long *retval;
+                                size_t retval_len = 0;
+                                struct undoInfo *ui = NULL;
+                                int ret;
+                                
+                    /** first, get the old value */
+                                retval = get_destMACFromUserClassIDFilterExclude(ci->data_context, &retval_len);
+                                if (retval) {
+                                    ui = SNMP_MALLOC_STRUCT(undoInfo);
+                                    ui->len = retval_len;
+                                    memdup((u_char **) &ui->ptr,
+                                           (u_char *) retval,
+                                           ui->len);
+                                }
+
+                    /** check the new value, possibly against the
+                        older value for a valid state transition */
+                                ret = check_destMACFromUserClassIDFilterExclude(request->requestvb->type,
+                                                   (long *) request->requestvb->val.string,
+                                                   request->requestvb->val_len,
+                                                   retval, retval_len);
+                                if (ret != 0) {
+                                    netsnmp_set_request_error(reqinfo, request,
+                                                              ret);
+                                    filterRuleTable_free_undoInfo(ui);
+                                } else if (ui) {
+                        /** remember information for undo purposes later */
+                                    netsnmp_oid_stash_add_data(&undoStorage,
+                                                               suffix,
+                                                               suffix_len,
+                                                               ui);
+                                }
+                                
+                            }
+                            break;
+                    default:
+                       netsnmp_set_request_error(reqinfo, request,
+                                                 SNMP_ERR_NOTWRITABLE);
+                       break;
+                 }
+                break;
+
+            case MODE_SET_ACTION:
+            /** save a variable copy */
+                switch(table_info->colnum) {
+                         
+                          case COLUMN_FILTERENABLE:
+                            {
+                                int ret;
+                                ret = set_filterEnable(ci->data_context,
+                                             (long *) request->requestvb->val.string,
+                                             request->requestvb->val_len);
+                                if (ret) {
+                                    netsnmp_set_request_error(reqinfo, request,
+                                                              ret);
+                                }
+                            }
+                            break;
+                          case COLUMN_FILTERBRIDGEREFERENCE:
+                            {
+                                int ret;
+                                ret = set_filterBridgeReference(ci->data_context,
+                                             (long *) request->requestvb->val.string,
+                                             request->requestvb->val_len);
+                                if (ret) {
+                                    netsnmp_set_request_error(reqinfo, request,
+                                                              ret);
+                                }
+                            }
+                            break;
+                          case COLUMN_EXCLUSIVITYORDER:
+                            {
+                                int ret;
+                                ret = set_exclusivityOrder(ci->data_context,
+                                             (long *) request->requestvb->val.string,
+                                             request->requestvb->val_len);
+                                if (ret) {
+                                    netsnmp_set_request_error(reqinfo, request,
+                                                              ret);
+                                }
+                            }
+                            break;
+                          case COLUMN_FILTERINTERFACE:
+                            {
+                                int ret;
+                                ret = set_filterInterface(ci->data_context,
+                                             (char *) request->requestvb->val.string,
+                                             request->requestvb->val_len);
+                                if (ret) {
+                                    netsnmp_set_request_error(reqinfo, request,
+                                                              ret);
+                                }
+                            }
+                            break;
+                          case COLUMN_VLANIDFILTER:
+                            {
+                                int ret;
+                                ret = set_vlanIDFilter(ci->data_context,
+                                             (long *) request->requestvb->val.string,
+                                             request->requestvb->val_len);
+                                if (ret) {
+                                    netsnmp_set_request_error(reqinfo, request,
+                                                              ret);
+                                }
+                            }
+                            break;
+                          case COLUMN_ADMITONLYVLANTAGGED:
+                            {
+                                int ret;
+                                ret = set_admitOnlyVLANTagged(ci->data_context,
+                                             (long *) request->requestvb->val.string,
+                                             request->requestvb->val_len);
+                                if (ret) {
+                                    netsnmp_set_request_error(reqinfo, request,
+                                                              ret);
+                                }
+                            }
+                            break;
+                          case COLUMN_ETHERTYPEFILTERLIST:
+                            {
+                                int ret;
+                                ret = set_ethertypeFilterList(ci->data_context,
+                                             (char *) request->requestvb->val.string,
+                                             request->requestvb->val_len);
+                                if (ret) {
+                                    netsnmp_set_request_error(reqinfo, request,
+                                                              ret);
+                                }
+                            }
+                            break;
+                          case COLUMN_ETHERTYPEFILTEREXCLUDE:
+                            {
+                                int ret;
+                                ret = set_ethertypeFilterExclude(ci->data_context,
+                                             (long *) request->requestvb->val.string,
+                                             request->requestvb->val_len);
+                                if (ret) {
+                                    netsnmp_set_request_error(reqinfo, request,
+                                                              ret);
+                                }
+                            }
+                            break;
+                          case COLUMN_SOURCEMACADDRESSFILTERLIST:
+                            {
+                                int ret;
+                                ret = set_sourceMACAddressFilterList(ci->data_context,
+                                             (char *) request->requestvb->val.string,
+                                             request->requestvb->val_len);
+                                if (ret) {
+                                    netsnmp_set_request_error(reqinfo, request,
+                                                              ret);
+                                }
+                            }
+                            break;
+                          case COLUMN_SOURCEMACADDRESSFILTEREXCLUDE:
+                            {
+                                int ret;
+                                ret = set_sourceMACAddressFilterExclude(ci->data_context,
+                                             (long *) request->requestvb->val.string,
+                                             request->requestvb->val_len);
+                                if (ret) {
+                                    netsnmp_set_request_error(reqinfo, request,
+                                                              ret);
+                                }
+                            }
+                            break;
+                          case COLUMN_DESTMACADDRESSFILTERLIST:
+                            {
+                                int ret;
+                                ret = set_destMACAddressFilterList(ci->data_context,
+                                             (char *) request->requestvb->val.string,
+                                             request->requestvb->val_len);
+                                if (ret) {
+                                    netsnmp_set_request_error(reqinfo, request,
+                                                              ret);
+                                }
+                            }
+                            break;
+                          case COLUMN_DESTMACADDRESSFILTEREXCLUDE:
+                            {
+                                int ret;
+                                ret = set_destMACAddressFilterExclude(ci->data_context,
+                                             (long *) request->requestvb->val.string,
+                                             request->requestvb->val_len);
+                                if (ret) {
+                                    netsnmp_set_request_error(reqinfo, request,
+                                                              ret);
+                                }
+                            }
+                            break;
+                          case COLUMN_SRCMACFROMVENDORCLASSIDFILTER:
+                            {
+                                int ret;
+                                ret = set_srcMACFromVendorClassIDFilter(ci->data_context,
+                                             (char *) request->requestvb->val.string,
+                                             request->requestvb->val_len);
+                                if (ret) {
+                                    netsnmp_set_request_error(reqinfo, request,
+                                                              ret);
+                                }
+                            }
+                            break;
+                          case COLUMN_SRCMACFROMVENDORCLASSIDFILTEREXCLUDE:
+                            {
+                                int ret;
+                                ret = set_srcMACFromVendorClassIDFilterExclude(ci->data_context,
+                                             (long *) request->requestvb->val.string,
+                                             request->requestvb->val_len);
+                                if (ret) {
+                                    netsnmp_set_request_error(reqinfo, request,
+                                                              ret);
+                                }
+                            }
+                            break;
+                          case COLUMN_DESTMACFROMVENDORCLASSIDFILTER:
+                            {
+                                int ret;
+                                ret = set_destMACFromVendorClassIDFilter(ci->data_context,
+                                             (char *) request->requestvb->val.string,
+                                             request->requestvb->val_len);
+                                if (ret) {
+                                    netsnmp_set_request_error(reqinfo, request,
+                                                              ret);
+                                }
+                            }
+                            break;
+                          case COLUMN_DESTMACFROMVENDORCLASSIDFILTEREXCLUDE:
+                            {
+                                int ret;
+                                ret = set_destMACFromVendorClassIDFilterExclude(ci->data_context,
+                                             (long *) request->requestvb->val.string,
+                                             request->requestvb->val_len);
+                                if (ret) {
+                                    netsnmp_set_request_error(reqinfo, request,
+                                                              ret);
+                                }
+                            }
+                            break;
+                          case COLUMN_SRCMACFROMCLIENTIDFILTER:
+                            {
+                                int ret;
+                                ret = set_srcMACFromClientIDFilter(ci->data_context,
+                                             (char *) request->requestvb->val.string,
+                                             request->requestvb->val_len);
+                                if (ret) {
+                                    netsnmp_set_request_error(reqinfo, request,
+                                                              ret);
+                                }
+                            }
+                            break;
+                          case COLUMN_SRCMACFROMCLIENTIDFILTEREXCLUDE:
+                            {
+                                int ret;
+                                ret = set_srcMACFromClientIDFilterExclude(ci->data_context,
+                                             (long *) request->requestvb->val.string,
+                                             request->requestvb->val_len);
+                                if (ret) {
+                                    netsnmp_set_request_error(reqinfo, request,
+                                                              ret);
+                                }
+                            }
+                            break;
+                          case COLUMN_DESTMACFROMCLIENTIDFILTER:
+                            {
+                                int ret;
+                                ret = set_destMACFromClientIDFilter(ci->data_context,
+                                             (char *) request->requestvb->val.string,
+                                             request->requestvb->val_len);
+                                if (ret) {
+                                    netsnmp_set_request_error(reqinfo, request,
+                                                              ret);
+                                }
+                            }
+                            break;
+                          case COLUMN_DESTMACFROMCLIENTIDFILTEREXCLUDE:
+                            {
+                                int ret;
+                                ret = set_destMACFromClientIDFilterExclude(ci->data_context,
+                                             (long *) request->requestvb->val.string,
+                                             request->requestvb->val_len);
+                                if (ret) {
+                                    netsnmp_set_request_error(reqinfo, request,
+                                                              ret);
+                                }
+                            }
+                            break;
+                          case COLUMN_SRCMACFROMUSERCLASSIDFILTER:
+                            {
+                                int ret;
+                                ret = set_srcMACFromUserClassIDFilter(ci->data_context,
+                                             (char *) request->requestvb->val.string,
+                                             request->requestvb->val_len);
+                                if (ret) {
+                                    netsnmp_set_request_error(reqinfo, request,
+                                                              ret);
+                                }
+                            }
+                            break;
+                          case COLUMN_SRCMACFROMUSERCLASSIDFILTEREXCLUDE:
+                            {
+                                int ret;
+                                ret = set_srcMACFromUserClassIDFilterExclude(ci->data_context,
+                                             (long *) request->requestvb->val.string,
+                                             request->requestvb->val_len);
+                                if (ret) {
+                                    netsnmp_set_request_error(reqinfo, request,
+                                                              ret);
+                                }
+                            }
+                            break;
+                          case COLUMN_DESTMACFROMUSERCLASSIDFILTER:
+                            {
+                                int ret;
+                                ret = set_destMACFromUserClassIDFilter(ci->data_context,
+                                             (char *) request->requestvb->val.string,
+                                             request->requestvb->val_len);
+                                if (ret) {
+                                    netsnmp_set_request_error(reqinfo, request,
+                                                              ret);
+                                }
+                            }
+                            break;
+                          case COLUMN_DESTMACFROMUSERCLASSIDFILTEREXCLUDE:
+                            {
+                                int ret;
+                                ret = set_destMACFromUserClassIDFilterExclude(ci->data_context,
+                                             (long *) request->requestvb->val.string,
+                                             request->requestvb->val_len);
+                                if (ret) {
+                                    netsnmp_set_request_error(reqinfo, request,
+                                                              ret);
+                                }
+                            }
+                            break;
+                 }
+                break;
+
+            case MODE_SET_COMMIT:
+                if (!ci->have_committed) {
+                    /** do this once per row only */
+                    filterRuleTable_commit_row(&ci->data_context, ci->new_row);
+                    ci->have_committed = 1;
+                }
+                break;
+
+            case MODE_SET_UNDO:
+             /** save a variable copy */
+                switch(table_info->colnum) {
+                          
+                          case COLUMN_FILTERENABLE:
+                            {
+                                int retval;
+                                struct undoInfo *ui;
+                                ui = netsnmp_oid_stash_get_data(undoStorage,
+                                                                suffix,
+                                                                suffix_len);
+                                retval = set_filterEnable(ci->data_context, ui->ptr,
+                                                ui->len);
+                                if (retval) {
+                                    netsnmp_set_request_error(reqinfo, request,
+                                                              SNMP_ERR_UNDOFAILED);
+                                }
+                            }
+                            break;
+                          case COLUMN_FILTERBRIDGEREFERENCE:
+                            {
+                                int retval;
+                                struct undoInfo *ui;
+                                ui = netsnmp_oid_stash_get_data(undoStorage,
+                                                                suffix,
+                                                                suffix_len);
+                                retval = set_filterBridgeReference(ci->data_context, ui->ptr,
+                                                ui->len);
+                                if (retval) {
+                                    netsnmp_set_request_error(reqinfo, request,
+                                                              SNMP_ERR_UNDOFAILED);
+                                }
+                            }
+                            break;
+                          case COLUMN_EXCLUSIVITYORDER:
+                            {
+                                int retval;
+                                struct undoInfo *ui;
+                                ui = netsnmp_oid_stash_get_data(undoStorage,
+                                                                suffix,
+                                                                suffix_len);
+                                retval = set_exclusivityOrder(ci->data_context, ui->ptr,
+                                                ui->len);
+                                if (retval) {
+                                    netsnmp_set_request_error(reqinfo, request,
+                                                              SNMP_ERR_UNDOFAILED);
+                                }
+                            }
+                            break;
+                          case COLUMN_FILTERINTERFACE:
+                            {
+                                int retval;
+                                struct undoInfo *ui;
+                                ui = netsnmp_oid_stash_get_data(undoStorage,
+                                                                suffix,
+                                                                suffix_len);
+                                retval = set_filterInterface(ci->data_context, ui->ptr,
+                                                ui->len);
+                                if (retval) {
+                                    netsnmp_set_request_error(reqinfo, request,
+                                                              SNMP_ERR_UNDOFAILED);
+                                }
+                            }
+                            break;
+                          case COLUMN_VLANIDFILTER:
+                            {
+                                int retval;
+                                struct undoInfo *ui;
+                                ui = netsnmp_oid_stash_get_data(undoStorage,
+                                                                suffix,
+                                                                suffix_len);
+                                retval = set_vlanIDFilter(ci->data_context, ui->ptr,
+                                                ui->len);
+                                if (retval) {
+                                    netsnmp_set_request_error(reqinfo, request,
+                                                              SNMP_ERR_UNDOFAILED);
+                                }
+                            }
+                            break;
+                          case COLUMN_ADMITONLYVLANTAGGED:
+                            {
+                                int retval;
+                                struct undoInfo *ui;
+                                ui = netsnmp_oid_stash_get_data(undoStorage,
+                                                                suffix,
+                                                                suffix_len);
+                                retval = set_admitOnlyVLANTagged(ci->data_context, ui->ptr,
+                                                ui->len);
+                                if (retval) {
+                                    netsnmp_set_request_error(reqinfo, request,
+                                                              SNMP_ERR_UNDOFAILED);
+                                }
+                            }
+                            break;
+                          case COLUMN_ETHERTYPEFILTERLIST:
+                            {
+                                int retval;
+                                struct undoInfo *ui;
+                                ui = netsnmp_oid_stash_get_data(undoStorage,
+                                                                suffix,
+                                                                suffix_len);
+                                retval = set_ethertypeFilterList(ci->data_context, ui->ptr,
+                                                ui->len);
+                                if (retval) {
+                                    netsnmp_set_request_error(reqinfo, request,
+                                                              SNMP_ERR_UNDOFAILED);
+                                }
+                            }
+                            break;
+                          case COLUMN_ETHERTYPEFILTEREXCLUDE:
+                            {
+                                int retval;
+                                struct undoInfo *ui;
+                                ui = netsnmp_oid_stash_get_data(undoStorage,
+                                                                suffix,
+                                                                suffix_len);
+                                retval = set_ethertypeFilterExclude(ci->data_context, ui->ptr,
+                                                ui->len);
+                                if (retval) {
+                                    netsnmp_set_request_error(reqinfo, request,
+                                                              SNMP_ERR_UNDOFAILED);
+                                }
+                            }
+                            break;
+                          case COLUMN_SOURCEMACADDRESSFILTERLIST:
+                            {
+                                int retval;
+                                struct undoInfo *ui;
+                                ui = netsnmp_oid_stash_get_data(undoStorage,
+                                                                suffix,
+                                                                suffix_len);
+                                retval = set_sourceMACAddressFilterList(ci->data_context, ui->ptr,
+                                                ui->len);
+                                if (retval) {
+                                    netsnmp_set_request_error(reqinfo, request,
+                                                              SNMP_ERR_UNDOFAILED);
+                                }
+                            }
+                            break;
+                          case COLUMN_SOURCEMACADDRESSFILTEREXCLUDE:
+                            {
+                                int retval;
+                                struct undoInfo *ui;
+                                ui = netsnmp_oid_stash_get_data(undoStorage,
+                                                                suffix,
+                                                                suffix_len);
+                                retval = set_sourceMACAddressFilterExclude(ci->data_context, ui->ptr,
+                                                ui->len);
+                                if (retval) {
+                                    netsnmp_set_request_error(reqinfo, request,
+                                                              SNMP_ERR_UNDOFAILED);
+                                }
+                            }
+                            break;
+                          case COLUMN_DESTMACADDRESSFILTERLIST:
+                            {
+                                int retval;
+                                struct undoInfo *ui;
+                                ui = netsnmp_oid_stash_get_data(undoStorage,
+                                                                suffix,
+                                                                suffix_len);
+                                retval = set_destMACAddressFilterList(ci->data_context, ui->ptr,
+                                                ui->len);
+                                if (retval) {
+                                    netsnmp_set_request_error(reqinfo, request,
+                                                              SNMP_ERR_UNDOFAILED);
+                                }
+                            }
+                            break;
+                          case COLUMN_DESTMACADDRESSFILTEREXCLUDE:
+                            {
+                                int retval;
+                                struct undoInfo *ui;
+                                ui = netsnmp_oid_stash_get_data(undoStorage,
+                                                                suffix,
+                                                                suffix_len);
+                                retval = set_destMACAddressFilterExclude(ci->data_context, ui->ptr,
+                                                ui->len);
+                                if (retval) {
+                                    netsnmp_set_request_error(reqinfo, request,
+                                                              SNMP_ERR_UNDOFAILED);
+                                }
+                            }
+                            break;
+                          case COLUMN_SRCMACFROMVENDORCLASSIDFILTER:
+                            {
+                                int retval;
+                                struct undoInfo *ui;
+                                ui = netsnmp_oid_stash_get_data(undoStorage,
+                                                                suffix,
+                                                                suffix_len);
+                                retval = set_srcMACFromVendorClassIDFilter(ci->data_context, ui->ptr,
+                                                ui->len);
+                                if (retval) {
+                                    netsnmp_set_request_error(reqinfo, request,
+                                                              SNMP_ERR_UNDOFAILED);
+                                }
+                            }
+                            break;
+                          case COLUMN_SRCMACFROMVENDORCLASSIDFILTEREXCLUDE:
+                            {
+                                int retval;
+                                struct undoInfo *ui;
+                                ui = netsnmp_oid_stash_get_data(undoStorage,
+                                                                suffix,
+                                                                suffix_len);
+                                retval = set_srcMACFromVendorClassIDFilterExclude(ci->data_context, ui->ptr,
+                                                ui->len);
+                                if (retval) {
+                                    netsnmp_set_request_error(reqinfo, request,
+                                                              SNMP_ERR_UNDOFAILED);
+                                }
+                            }
+                            break;
+                          case COLUMN_DESTMACFROMVENDORCLASSIDFILTER:
+                            {
+                                int retval;
+                                struct undoInfo *ui;
+                                ui = netsnmp_oid_stash_get_data(undoStorage,
+                                                                suffix,
+                                                                suffix_len);
+                                retval = set_destMACFromVendorClassIDFilter(ci->data_context, ui->ptr,
+                                                ui->len);
+                                if (retval) {
+                                    netsnmp_set_request_error(reqinfo, request,
+                                                              SNMP_ERR_UNDOFAILED);
+                                }
+                            }
+                            break;
+                          case COLUMN_DESTMACFROMVENDORCLASSIDFILTEREXCLUDE:
+                            {
+                                int retval;
+                                struct undoInfo *ui;
+                                ui = netsnmp_oid_stash_get_data(undoStorage,
+                                                                suffix,
+                                                                suffix_len);
+                                retval = set_destMACFromVendorClassIDFilterExclude(ci->data_context, ui->ptr,
+                                                ui->len);
+                                if (retval) {
+                                    netsnmp_set_request_error(reqinfo, request,
+                                                              SNMP_ERR_UNDOFAILED);
+                                }
+                            }
+                            break;
+                          case COLUMN_SRCMACFROMCLIENTIDFILTER:
+                            {
+                                int retval;
+                                struct undoInfo *ui;
+                                ui = netsnmp_oid_stash_get_data(undoStorage,
+                                                                suffix,
+                                                                suffix_len);
+                                retval = set_srcMACFromClientIDFilter(ci->data_context, ui->ptr,
+                                                ui->len);
+                                if (retval) {
+                                    netsnmp_set_request_error(reqinfo, request,
+                                                              SNMP_ERR_UNDOFAILED);
+                                }
+                            }
+                            break;
+                          case COLUMN_SRCMACFROMCLIENTIDFILTEREXCLUDE:
+                            {
+                                int retval;
+                                struct undoInfo *ui;
+                                ui = netsnmp_oid_stash_get_data(undoStorage,
+                                                                suffix,
+                                                                suffix_len);
+                                retval = set_srcMACFromClientIDFilterExclude(ci->data_context, ui->ptr,
+                                                ui->len);
+                                if (retval) {
+                                    netsnmp_set_request_error(reqinfo, request,
+                                                              SNMP_ERR_UNDOFAILED);
+                                }
+                            }
+                            break;
+                          case COLUMN_DESTMACFROMCLIENTIDFILTER:
+                            {
+                                int retval;
+                                struct undoInfo *ui;
+                                ui = netsnmp_oid_stash_get_data(undoStorage,
+                                                                suffix,
+                                                                suffix_len);
+                                retval = set_destMACFromClientIDFilter(ci->data_context, ui->ptr,
+                                                ui->len);
+                                if (retval) {
+                                    netsnmp_set_request_error(reqinfo, request,
+                                                              SNMP_ERR_UNDOFAILED);
+                                }
+                            }
+                            break;
+                          case COLUMN_DESTMACFROMCLIENTIDFILTEREXCLUDE:
+                            {
+                                int retval;
+                                struct undoInfo *ui;
+                                ui = netsnmp_oid_stash_get_data(undoStorage,
+                                                                suffix,
+                                                                suffix_len);
+                                retval = set_destMACFromClientIDFilterExclude(ci->data_context, ui->ptr,
+                                                ui->len);
+                                if (retval) {
+                                    netsnmp_set_request_error(reqinfo, request,
+                                                              SNMP_ERR_UNDOFAILED);
+                                }
+                            }
+                            break;
+                          case COLUMN_SRCMACFROMUSERCLASSIDFILTER:
+                            {
+                                int retval;
+                                struct undoInfo *ui;
+                                ui = netsnmp_oid_stash_get_data(undoStorage,
+                                                                suffix,
+                                                                suffix_len);
+                                retval = set_srcMACFromUserClassIDFilter(ci->data_context, ui->ptr,
+                                                ui->len);
+                                if (retval) {
+                                    netsnmp_set_request_error(reqinfo, request,
+                                                              SNMP_ERR_UNDOFAILED);
+                                }
+                            }
+                            break;
+                          case COLUMN_SRCMACFROMUSERCLASSIDFILTEREXCLUDE:
+                            {
+                                int retval;
+                                struct undoInfo *ui;
+                                ui = netsnmp_oid_stash_get_data(undoStorage,
+                                                                suffix,
+                                                                suffix_len);
+                                retval = set_srcMACFromUserClassIDFilterExclude(ci->data_context, ui->ptr,
+                                                ui->len);
+                                if (retval) {
+                                    netsnmp_set_request_error(reqinfo, request,
+                                                              SNMP_ERR_UNDOFAILED);
+                                }
+                            }
+                            break;
+                          case COLUMN_DESTMACFROMUSERCLASSIDFILTER:
+                            {
+                                int retval;
+                                struct undoInfo *ui;
+                                ui = netsnmp_oid_stash_get_data(undoStorage,
+                                                                suffix,
+                                                                suffix_len);
+                                retval = set_destMACFromUserClassIDFilter(ci->data_context, ui->ptr,
+                                                ui->len);
+                                if (retval) {
+                                    netsnmp_set_request_error(reqinfo, request,
+                                                              SNMP_ERR_UNDOFAILED);
+                                }
+                            }
+                            break;
+                          case COLUMN_DESTMACFROMUSERCLASSIDFILTEREXCLUDE:
+                            {
+                                int retval;
+                                struct undoInfo *ui;
+                                ui = netsnmp_oid_stash_get_data(undoStorage,
+                                                                suffix,
+                                                                suffix_len);
+                                retval = set_destMACFromUserClassIDFilterExclude(ci->data_context, ui->ptr,
+                                                ui->len);
+                                if (retval) {
+                                    netsnmp_set_request_error(reqinfo, request,
+                                                              SNMP_ERR_UNDOFAILED);
+                                }
+                            }
+                            break;
+                }
+                break;
+                
+            case MODE_SET_FREE:
+                break;
+
+            default:
+                snmp_log(LOG_ERR, "problem encountered in filterRuleTable_handler: unsupported mode\n");
+        }
+    }
+
+    /** clean up after all requset processing has ended */
+    switch(reqinfo->mode) {
+    case MODE_SET_UNDO:
+    case MODE_SET_FREE:
+    case MODE_SET_COMMIT:
+        /** clear out the undo cache */
+        netsnmp_oid_stash_free(&undoStorage, filterRuleTable_free_undoInfo);
+        netsnmp_oid_stash_free(&commitStorage, netsnmp_oid_stash_no_free);
+    }
+
+    return SNMP_ERR_NOERROR;
+}
diff -Naur net-snmp-5.7.2-orig/agent/mibgroup/ZYXEL-PRESTIGE-MIB/filterRuleTable_checkfns.c net-snmp-5.7.2/agent/mibgroup/ZYXEL-PRESTIGE-MIB/filterRuleTable_checkfns.c
--- net-snmp-5.7.2-orig/agent/mibgroup/ZYXEL-PRESTIGE-MIB/filterRuleTable_checkfns.c	1970-01-01 08:00:00.000000000 +0800
+++ net-snmp-5.7.2/agent/mibgroup/ZYXEL-PRESTIGE-MIB/filterRuleTable_checkfns.c	2013-10-08 09:35:17.626117000 +0800
@@ -0,0 +1,694 @@
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *        : mib2c.check_values.conf 9254 2004-01-12 00:43:46Z rstory $
+ */
+
+/********************************************************************
+ *                       NOTE   NOTE   NOTE
+ *   This file is auto-generated and SHOULD NOT BE EDITED by hand.
+ *   Modify the filterRuleTable_checkfns_local.[ch] files insead so that you
+ *   can regenerate this one as mib2c improvements are made.
+ ********************************************************************/
+
+/* standard headers */
+#include <net-snmp/net-snmp-config.h>
+#include <net-snmp/net-snmp-includes.h>
+#include "filterRuleTable_checkfns.h"
+#include "filterRuleTable_checkfns_local.h"
+#include "filterRuleTable_enums.h"
+
+
+/** Decides if an incoming value for the filterEnable mib node is legal.
+ *  @param type    The incoming data type.
+ *  @param val     The value to be checked.
+ *  @param val_len The length of data stored in val (in bytes).
+ *  @return 0 if the incoming value is legal, an SNMP error code otherwise.
+ */
+    int
+    check_filterEnable(int type, long *val, size_t val_len,
+             long *old_val, size_t old_val_len) {
+
+    int ret;
+
+    /** Check to see that we were called legally */
+      if (!val)
+        return SNMP_ERR_GENERR;
+
+    /** Check the incoming type for correctness */
+      if (type != ASN_INTEGER)
+        return SNMP_ERR_WRONGTYPE;
+
+	ret = SNMP_ERR_NOERROR;
+
+
+    /** looks ok, call the local version of the same function. */
+      return check_filterEnable_local(type, val, val_len, old_val, old_val_len);
+    }
+/** Decides if an incoming value for the filterBridgeReference mib node is legal.
+ *  @param type    The incoming data type.
+ *  @param val     The value to be checked.
+ *  @param val_len The length of data stored in val (in bytes).
+ *  @return 0 if the incoming value is legal, an SNMP error code otherwise.
+ */
+    int
+    check_filterBridgeReference(int type, long *val, size_t val_len,
+             long *old_val, size_t old_val_len) {
+
+    int ret;
+
+    /** Check to see that we were called legally */
+      if (!val)
+        return SNMP_ERR_GENERR;
+
+    /** Check the incoming type for correctness */
+      if (type != ASN_INTEGER)
+        return SNMP_ERR_WRONGTYPE;
+
+	ret = SNMP_ERR_NOERROR;
+
+
+    /** looks ok, call the local version of the same function. */
+      return check_filterBridgeReference_local(type, val, val_len, old_val, old_val_len);
+    }
+/** Decides if an incoming value for the exclusivityOrder mib node is legal.
+ *  @param type    The incoming data type.
+ *  @param val     The value to be checked.
+ *  @param val_len The length of data stored in val (in bytes).
+ *  @return 0 if the incoming value is legal, an SNMP error code otherwise.
+ */
+    int
+    check_exclusivityOrder(int type, long *val, size_t val_len,
+             long *old_val, size_t old_val_len) {
+
+    int ret;
+
+    /** Check to see that we were called legally */
+      if (!val)
+        return SNMP_ERR_GENERR;
+
+    /** Check the incoming type for correctness */
+      if (type != ASN_INTEGER)
+        return SNMP_ERR_WRONGTYPE;
+
+	ret = SNMP_ERR_NOERROR;
+
+
+    /** looks ok, call the local version of the same function. */
+      return check_exclusivityOrder_local(type, val, val_len, old_val, old_val_len);
+    }
+/** Decides if an incoming value for the filterInterface mib node is legal.
+ *  @param type    The incoming data type.
+ *  @param val     The value to be checked.
+ *  @param val_len The length of data stored in val (in bytes).
+ *  @return 0 if the incoming value is legal, an SNMP error code otherwise.
+ */
+    int
+    check_filterInterface(int type, char *val, size_t val_len,
+             char *old_val, size_t old_val_len) {
+
+    int ret;
+
+    /** Check to see that we were called legally */
+      if (!val)
+        return SNMP_ERR_GENERR;
+
+    /** Check the incoming type for correctness */
+      if (type != ASN_OCTET_STR)
+        return SNMP_ERR_WRONGTYPE;
+
+    /** Check the ranges of the passed value for legality */
+	    if (
+	       !(val_len >= 0 && val_len <= 17)
+            ) {
+            return SNMP_ERR_WRONGVALUE;
+            }
+
+
+    /** looks ok, call the local version of the same function. */
+      return check_filterInterface_local(type, val, val_len, old_val, old_val_len);
+    }
+/** Decides if an incoming value for the vlanIDFilter mib node is legal.
+ *  @param type    The incoming data type.
+ *  @param val     The value to be checked.
+ *  @param val_len The length of data stored in val (in bytes).
+ *  @return 0 if the incoming value is legal, an SNMP error code otherwise.
+ */
+    int
+    check_vlanIDFilter(int type, long *val, size_t val_len,
+             long *old_val, size_t old_val_len) {
+
+    int ret;
+
+    /** Check to see that we were called legally */
+      if (!val)
+        return SNMP_ERR_GENERR;
+
+    /** Check the incoming type for correctness */
+      if (type != ASN_INTEGER)
+        return SNMP_ERR_WRONGTYPE;
+
+	ret = SNMP_ERR_NOERROR;
+
+
+    /** looks ok, call the local version of the same function. */
+      return check_vlanIDFilter_local(type, val, val_len, old_val, old_val_len);
+    }
+/** Decides if an incoming value for the admitOnlyVLANTagged mib node is legal.
+ *  @param type    The incoming data type.
+ *  @param val     The value to be checked.
+ *  @param val_len The length of data stored in val (in bytes).
+ *  @return 0 if the incoming value is legal, an SNMP error code otherwise.
+ */
+    int
+    check_admitOnlyVLANTagged(int type, long *val, size_t val_len,
+             long *old_val, size_t old_val_len) {
+
+    int ret;
+
+    /** Check to see that we were called legally */
+      if (!val)
+        return SNMP_ERR_GENERR;
+
+    /** Check the incoming type for correctness */
+      if (type != ASN_INTEGER)
+        return SNMP_ERR_WRONGTYPE;
+
+	ret = SNMP_ERR_NOERROR;
+
+
+    /** looks ok, call the local version of the same function. */
+      return check_admitOnlyVLANTagged_local(type, val, val_len, old_val, old_val_len);
+    }
+/** Decides if an incoming value for the ethertypeFilterList mib node is legal.
+ *  @param type    The incoming data type.
+ *  @param val     The value to be checked.
+ *  @param val_len The length of data stored in val (in bytes).
+ *  @return 0 if the incoming value is legal, an SNMP error code otherwise.
+ */
+    int
+    check_ethertypeFilterList(int type, char *val, size_t val_len,
+             char *old_val, size_t old_val_len) {
+
+    int ret;
+
+    /** Check to see that we were called legally */
+      if (!val)
+        return SNMP_ERR_GENERR;
+
+    /** Check the incoming type for correctness */
+      if (type != ASN_OCTET_STR)
+        return SNMP_ERR_WRONGTYPE;
+
+    /** Check the ranges of the passed value for legality */
+	    if (
+	       !(val_len >= 0 && val_len <= 257)
+            ) {
+            return SNMP_ERR_WRONGVALUE;
+            }
+
+
+    /** looks ok, call the local version of the same function. */
+      return check_ethertypeFilterList_local(type, val, val_len, old_val, old_val_len);
+    }
+/** Decides if an incoming value for the ethertypeFilterExclude mib node is legal.
+ *  @param type    The incoming data type.
+ *  @param val     The value to be checked.
+ *  @param val_len The length of data stored in val (in bytes).
+ *  @return 0 if the incoming value is legal, an SNMP error code otherwise.
+ */
+    int
+    check_ethertypeFilterExclude(int type, long *val, size_t val_len,
+             long *old_val, size_t old_val_len) {
+
+    int ret;
+
+    /** Check to see that we were called legally */
+      if (!val)
+        return SNMP_ERR_GENERR;
+
+    /** Check the incoming type for correctness */
+      if (type != ASN_INTEGER)
+        return SNMP_ERR_WRONGTYPE;
+
+	ret = SNMP_ERR_NOERROR;
+
+
+    /** looks ok, call the local version of the same function. */
+      return check_ethertypeFilterExclude_local(type, val, val_len, old_val, old_val_len);
+    }
+/** Decides if an incoming value for the sourceMACAddressFilterList mib node is legal.
+ *  @param type    The incoming data type.
+ *  @param val     The value to be checked.
+ *  @param val_len The length of data stored in val (in bytes).
+ *  @return 0 if the incoming value is legal, an SNMP error code otherwise.
+ */
+    int
+    check_sourceMACAddressFilterList(int type, char *val, size_t val_len,
+             char *old_val, size_t old_val_len) {
+
+    int ret;
+
+    /** Check to see that we were called legally */
+      if (!val)
+        return SNMP_ERR_GENERR;
+
+    /** Check the incoming type for correctness */
+      if (type != ASN_OCTET_STR)
+        return SNMP_ERR_WRONGTYPE;
+
+    /** Check the ranges of the passed value for legality */
+	    if (
+	       !(val_len >= 0 && val_len <= 513)
+            ) {
+            return SNMP_ERR_WRONGVALUE;
+            }
+
+
+    /** looks ok, call the local version of the same function. */
+      return check_sourceMACAddressFilterList_local(type, val, val_len, old_val, old_val_len);
+    }
+/** Decides if an incoming value for the sourceMACAddressFilterExclude mib node is legal.
+ *  @param type    The incoming data type.
+ *  @param val     The value to be checked.
+ *  @param val_len The length of data stored in val (in bytes).
+ *  @return 0 if the incoming value is legal, an SNMP error code otherwise.
+ */
+    int
+    check_sourceMACAddressFilterExclude(int type, long *val, size_t val_len,
+             long *old_val, size_t old_val_len) {
+
+    int ret;
+
+    /** Check to see that we were called legally */
+      if (!val)
+        return SNMP_ERR_GENERR;
+
+    /** Check the incoming type for correctness */
+      if (type != ASN_INTEGER)
+        return SNMP_ERR_WRONGTYPE;
+
+	ret = SNMP_ERR_NOERROR;
+
+
+    /** looks ok, call the local version of the same function. */
+      return check_sourceMACAddressFilterExclude_local(type, val, val_len, old_val, old_val_len);
+    }
+/** Decides if an incoming value for the destMACAddressFilterList mib node is legal.
+ *  @param type    The incoming data type.
+ *  @param val     The value to be checked.
+ *  @param val_len The length of data stored in val (in bytes).
+ *  @return 0 if the incoming value is legal, an SNMP error code otherwise.
+ */
+    int
+    check_destMACAddressFilterList(int type, char *val, size_t val_len,
+             char *old_val, size_t old_val_len) {
+
+    int ret;
+
+    /** Check to see that we were called legally */
+      if (!val)
+        return SNMP_ERR_GENERR;
+
+    /** Check the incoming type for correctness */
+      if (type != ASN_OCTET_STR)
+        return SNMP_ERR_WRONGTYPE;
+
+    /** Check the ranges of the passed value for legality */
+	    if (
+	       !(val_len >= 0 && val_len <= 513)
+            ) {
+            return SNMP_ERR_WRONGVALUE;
+            }
+
+
+    /** looks ok, call the local version of the same function. */
+      return check_destMACAddressFilterList_local(type, val, val_len, old_val, old_val_len);
+    }
+/** Decides if an incoming value for the destMACAddressFilterExclude mib node is legal.
+ *  @param type    The incoming data type.
+ *  @param val     The value to be checked.
+ *  @param val_len The length of data stored in val (in bytes).
+ *  @return 0 if the incoming value is legal, an SNMP error code otherwise.
+ */
+    int
+    check_destMACAddressFilterExclude(int type, long *val, size_t val_len,
+             long *old_val, size_t old_val_len) {
+
+    int ret;
+
+    /** Check to see that we were called legally */
+      if (!val)
+        return SNMP_ERR_GENERR;
+
+    /** Check the incoming type for correctness */
+      if (type != ASN_INTEGER)
+        return SNMP_ERR_WRONGTYPE;
+
+	ret = SNMP_ERR_NOERROR;
+
+
+    /** looks ok, call the local version of the same function. */
+      return check_destMACAddressFilterExclude_local(type, val, val_len, old_val, old_val_len);
+    }
+/** Decides if an incoming value for the srcMACFromVendorClassIDFilter mib node is legal.
+ *  @param type    The incoming data type.
+ *  @param val     The value to be checked.
+ *  @param val_len The length of data stored in val (in bytes).
+ *  @return 0 if the incoming value is legal, an SNMP error code otherwise.
+ */
+    int
+    check_srcMACFromVendorClassIDFilter(int type, char *val, size_t val_len,
+             char *old_val, size_t old_val_len) {
+
+    int ret;
+
+    /** Check to see that we were called legally */
+      if (!val)
+        return SNMP_ERR_GENERR;
+
+    /** Check the incoming type for correctness */
+      if (type != ASN_OCTET_STR)
+        return SNMP_ERR_WRONGTYPE;
+
+    /** Check the ranges of the passed value for legality */
+	    if (
+	       !(val_len >= 0 && val_len <= 257)
+            ) {
+            return SNMP_ERR_WRONGVALUE;
+            }
+
+
+    /** looks ok, call the local version of the same function. */
+      return check_srcMACFromVendorClassIDFilter_local(type, val, val_len, old_val, old_val_len);
+    }
+/** Decides if an incoming value for the srcMACFromVendorClassIDFilterExclude mib node is legal.
+ *  @param type    The incoming data type.
+ *  @param val     The value to be checked.
+ *  @param val_len The length of data stored in val (in bytes).
+ *  @return 0 if the incoming value is legal, an SNMP error code otherwise.
+ */
+    int
+    check_srcMACFromVendorClassIDFilterExclude(int type, long *val, size_t val_len,
+             long *old_val, size_t old_val_len) {
+
+    int ret;
+
+    /** Check to see that we were called legally */
+      if (!val)
+        return SNMP_ERR_GENERR;
+
+    /** Check the incoming type for correctness */
+      if (type != ASN_INTEGER)
+        return SNMP_ERR_WRONGTYPE;
+
+	ret = SNMP_ERR_NOERROR;
+
+
+    /** looks ok, call the local version of the same function. */
+      return check_srcMACFromVendorClassIDFilterExclude_local(type, val, val_len, old_val, old_val_len);
+    }
+/** Decides if an incoming value for the destMACFromVendorClassIDFilter mib node is legal.
+ *  @param type    The incoming data type.
+ *  @param val     The value to be checked.
+ *  @param val_len The length of data stored in val (in bytes).
+ *  @return 0 if the incoming value is legal, an SNMP error code otherwise.
+ */
+    int
+    check_destMACFromVendorClassIDFilter(int type, char *val, size_t val_len,
+             char *old_val, size_t old_val_len) {
+
+    int ret;
+
+    /** Check to see that we were called legally */
+      if (!val)
+        return SNMP_ERR_GENERR;
+
+    /** Check the incoming type for correctness */
+      if (type != ASN_OCTET_STR)
+        return SNMP_ERR_WRONGTYPE;
+
+    /** Check the ranges of the passed value for legality */
+	    if (
+	       !(val_len >= 0 && val_len <= 257)
+            ) {
+            return SNMP_ERR_WRONGVALUE;
+            }
+
+
+    /** looks ok, call the local version of the same function. */
+      return check_destMACFromVendorClassIDFilter_local(type, val, val_len, old_val, old_val_len);
+    }
+/** Decides if an incoming value for the destMACFromVendorClassIDFilterExclude mib node is legal.
+ *  @param type    The incoming data type.
+ *  @param val     The value to be checked.
+ *  @param val_len The length of data stored in val (in bytes).
+ *  @return 0 if the incoming value is legal, an SNMP error code otherwise.
+ */
+    int
+    check_destMACFromVendorClassIDFilterExclude(int type, long *val, size_t val_len,
+             long *old_val, size_t old_val_len) {
+
+    int ret;
+
+    /** Check to see that we were called legally */
+      if (!val)
+        return SNMP_ERR_GENERR;
+
+    /** Check the incoming type for correctness */
+      if (type != ASN_INTEGER)
+        return SNMP_ERR_WRONGTYPE;
+
+	ret = SNMP_ERR_NOERROR;
+
+
+    /** looks ok, call the local version of the same function. */
+      return check_destMACFromVendorClassIDFilterExclude_local(type, val, val_len, old_val, old_val_len);
+    }
+/** Decides if an incoming value for the srcMACFromClientIDFilter mib node is legal.
+ *  @param type    The incoming data type.
+ *  @param val     The value to be checked.
+ *  @param val_len The length of data stored in val (in bytes).
+ *  @return 0 if the incoming value is legal, an SNMP error code otherwise.
+ */
+    int
+    check_srcMACFromClientIDFilter(int type, char *val, size_t val_len,
+             char *old_val, size_t old_val_len) {
+
+    int ret;
+
+    /** Check to see that we were called legally */
+      if (!val)
+        return SNMP_ERR_GENERR;
+
+    /** Check the incoming type for correctness */
+      if (type != ASN_OCTET_STR)
+        return SNMP_ERR_WRONGTYPE;
+
+    /** Check the ranges of the passed value for legality */
+	    if (
+	       !(val_len >= 0 && val_len <= 257)
+            ) {
+            return SNMP_ERR_WRONGVALUE;
+            }
+
+
+    /** looks ok, call the local version of the same function. */
+      return check_srcMACFromClientIDFilter_local(type, val, val_len, old_val, old_val_len);
+    }
+/** Decides if an incoming value for the srcMACFromClientIDFilterExclude mib node is legal.
+ *  @param type    The incoming data type.
+ *  @param val     The value to be checked.
+ *  @param val_len The length of data stored in val (in bytes).
+ *  @return 0 if the incoming value is legal, an SNMP error code otherwise.
+ */
+    int
+    check_srcMACFromClientIDFilterExclude(int type, long *val, size_t val_len,
+             long *old_val, size_t old_val_len) {
+
+    int ret;
+
+    /** Check to see that we were called legally */
+      if (!val)
+        return SNMP_ERR_GENERR;
+
+    /** Check the incoming type for correctness */
+      if (type != ASN_INTEGER)
+        return SNMP_ERR_WRONGTYPE;
+
+	ret = SNMP_ERR_NOERROR;
+
+
+    /** looks ok, call the local version of the same function. */
+      return check_srcMACFromClientIDFilterExclude_local(type, val, val_len, old_val, old_val_len);
+    }
+/** Decides if an incoming value for the destMACFromClientIDFilter mib node is legal.
+ *  @param type    The incoming data type.
+ *  @param val     The value to be checked.
+ *  @param val_len The length of data stored in val (in bytes).
+ *  @return 0 if the incoming value is legal, an SNMP error code otherwise.
+ */
+    int
+    check_destMACFromClientIDFilter(int type, char *val, size_t val_len,
+             char *old_val, size_t old_val_len) {
+
+    int ret;
+
+    /** Check to see that we were called legally */
+      if (!val)
+        return SNMP_ERR_GENERR;
+
+    /** Check the incoming type for correctness */
+      if (type != ASN_OCTET_STR)
+        return SNMP_ERR_WRONGTYPE;
+
+    /** Check the ranges of the passed value for legality */
+	    if (
+	       !(val_len >= 0 && val_len <= 257)
+            ) {
+            return SNMP_ERR_WRONGVALUE;
+            }
+
+
+    /** looks ok, call the local version of the same function. */
+      return check_destMACFromClientIDFilter_local(type, val, val_len, old_val, old_val_len);
+    }
+/** Decides if an incoming value for the destMACFromClientIDFilterExclude mib node is legal.
+ *  @param type    The incoming data type.
+ *  @param val     The value to be checked.
+ *  @param val_len The length of data stored in val (in bytes).
+ *  @return 0 if the incoming value is legal, an SNMP error code otherwise.
+ */
+    int
+    check_destMACFromClientIDFilterExclude(int type, long *val, size_t val_len,
+             long *old_val, size_t old_val_len) {
+
+    int ret;
+
+    /** Check to see that we were called legally */
+      if (!val)
+        return SNMP_ERR_GENERR;
+
+    /** Check the incoming type for correctness */
+      if (type != ASN_INTEGER)
+        return SNMP_ERR_WRONGTYPE;
+
+	ret = SNMP_ERR_NOERROR;
+
+
+    /** looks ok, call the local version of the same function. */
+      return check_destMACFromClientIDFilterExclude_local(type, val, val_len, old_val, old_val_len);
+    }
+/** Decides if an incoming value for the srcMACFromUserClassIDFilter mib node is legal.
+ *  @param type    The incoming data type.
+ *  @param val     The value to be checked.
+ *  @param val_len The length of data stored in val (in bytes).
+ *  @return 0 if the incoming value is legal, an SNMP error code otherwise.
+ */
+    int
+    check_srcMACFromUserClassIDFilter(int type, char *val, size_t val_len,
+             char *old_val, size_t old_val_len) {
+
+    int ret;
+
+    /** Check to see that we were called legally */
+      if (!val)
+        return SNMP_ERR_GENERR;
+
+    /** Check the incoming type for correctness */
+      if (type != ASN_OCTET_STR)
+        return SNMP_ERR_WRONGTYPE;
+
+    /** Check the ranges of the passed value for legality */
+	    if (
+	       !(val_len >= 0 && val_len <= 257)
+            ) {
+            return SNMP_ERR_WRONGVALUE;
+            }
+
+
+    /** looks ok, call the local version of the same function. */
+      return check_srcMACFromUserClassIDFilter_local(type, val, val_len, old_val, old_val_len);
+    }
+/** Decides if an incoming value for the srcMACFromUserClassIDFilterExclude mib node is legal.
+ *  @param type    The incoming data type.
+ *  @param val     The value to be checked.
+ *  @param val_len The length of data stored in val (in bytes).
+ *  @return 0 if the incoming value is legal, an SNMP error code otherwise.
+ */
+    int
+    check_srcMACFromUserClassIDFilterExclude(int type, long *val, size_t val_len,
+             long *old_val, size_t old_val_len) {
+
+    int ret;
+
+    /** Check to see that we were called legally */
+      if (!val)
+        return SNMP_ERR_GENERR;
+
+    /** Check the incoming type for correctness */
+      if (type != ASN_INTEGER)
+        return SNMP_ERR_WRONGTYPE;
+
+	ret = SNMP_ERR_NOERROR;
+
+
+    /** looks ok, call the local version of the same function. */
+      return check_srcMACFromUserClassIDFilterExclude_local(type, val, val_len, old_val, old_val_len);
+    }
+/** Decides if an incoming value for the destMACFromUserClassIDFilter mib node is legal.
+ *  @param type    The incoming data type.
+ *  @param val     The value to be checked.
+ *  @param val_len The length of data stored in val (in bytes).
+ *  @return 0 if the incoming value is legal, an SNMP error code otherwise.
+ */
+    int
+    check_destMACFromUserClassIDFilter(int type, char *val, size_t val_len,
+             char *old_val, size_t old_val_len) {
+
+    int ret;
+
+    /** Check to see that we were called legally */
+      if (!val)
+        return SNMP_ERR_GENERR;
+
+    /** Check the incoming type for correctness */
+      if (type != ASN_OCTET_STR)
+        return SNMP_ERR_WRONGTYPE;
+
+    /** Check the ranges of the passed value for legality */
+	    if (
+	       !(val_len >= 0 && val_len <= 257)
+            ) {
+            return SNMP_ERR_WRONGVALUE;
+            }
+
+
+    /** looks ok, call the local version of the same function. */
+      return check_destMACFromUserClassIDFilter_local(type, val, val_len, old_val, old_val_len);
+    }
+/** Decides if an incoming value for the destMACFromUserClassIDFilterExclude mib node is legal.
+ *  @param type    The incoming data type.
+ *  @param val     The value to be checked.
+ *  @param val_len The length of data stored in val (in bytes).
+ *  @return 0 if the incoming value is legal, an SNMP error code otherwise.
+ */
+    int
+    check_destMACFromUserClassIDFilterExclude(int type, long *val, size_t val_len,
+             long *old_val, size_t old_val_len) {
+
+    int ret;
+
+    /** Check to see that we were called legally */
+      if (!val)
+        return SNMP_ERR_GENERR;
+
+    /** Check the incoming type for correctness */
+      if (type != ASN_INTEGER)
+        return SNMP_ERR_WRONGTYPE;
+
+	ret = SNMP_ERR_NOERROR;
+
+
+    /** looks ok, call the local version of the same function. */
+      return check_destMACFromUserClassIDFilterExclude_local(type, val, val_len, old_val, old_val_len);
+    }
diff -Naur net-snmp-5.7.2-orig/agent/mibgroup/ZYXEL-PRESTIGE-MIB/filterRuleTable_checkfns.h net-snmp-5.7.2/agent/mibgroup/ZYXEL-PRESTIGE-MIB/filterRuleTable_checkfns.h
--- net-snmp-5.7.2-orig/agent/mibgroup/ZYXEL-PRESTIGE-MIB/filterRuleTable_checkfns.h	1970-01-01 08:00:00.000000000 +0800
+++ net-snmp-5.7.2/agent/mibgroup/ZYXEL-PRESTIGE-MIB/filterRuleTable_checkfns.h	2013-10-08 09:35:17.626117000 +0800
@@ -0,0 +1,49 @@
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *        : mib2c.iterate.conf,v 5.6 2003/02/20 00:52:07 hardaker Exp $
+ */
+
+/***********************************************************************
+ *   This file is auto-generated and SHOULD NOT BE EDITED by hand.
+ *   Modify the filterRuleTable_checkfns_local.[ch] files insead.
+ *   (so that you can regenerate this one as mib2c improvements are made)
+ ***********************************************************************/
+#ifndef FILTERRULETABLE_CHECKFNS_H
+#define FILTERRULETABLE_CHECKFNS_H
+
+/** make sure we load the functions that you can modify */
+config_require(ZYXEL-PRESTIGE-MIB/filterRuleTable_checkfns_local)
+
+/* these functions are designed to check incoming values for 
+columns in the filterRuleTable table for legality with respect to 
+datatype and value.
+ */
+
+      int check_filterKey(int type, long *val, size_t val_len, long *old_val, size_t old_val_len);
+      int check_filterEnable(int type, long *val, size_t val_len, long *old_val, size_t old_val_len);
+      int check_filterBridgeReference(int type, long *val, size_t val_len, long *old_val, size_t old_val_len);
+      int check_exclusivityOrder(int type, long *val, size_t val_len, long *old_val, size_t old_val_len);
+      int check_filterInterface(int type, char *val, size_t val_len, char *old_val, size_t old_val_len);
+      int check_vlanIDFilter(int type, long *val, size_t val_len, long *old_val, size_t old_val_len);
+      int check_admitOnlyVLANTagged(int type, long *val, size_t val_len, long *old_val, size_t old_val_len);
+      int check_ethertypeFilterList(int type, char *val, size_t val_len, char *old_val, size_t old_val_len);
+      int check_ethertypeFilterExclude(int type, long *val, size_t val_len, long *old_val, size_t old_val_len);
+      int check_sourceMACAddressFilterList(int type, char *val, size_t val_len, char *old_val, size_t old_val_len);
+      int check_sourceMACAddressFilterExclude(int type, long *val, size_t val_len, long *old_val, size_t old_val_len);
+      int check_destMACAddressFilterList(int type, char *val, size_t val_len, char *old_val, size_t old_val_len);
+      int check_destMACAddressFilterExclude(int type, long *val, size_t val_len, long *old_val, size_t old_val_len);
+      int check_srcMACFromVendorClassIDFilter(int type, char *val, size_t val_len, char *old_val, size_t old_val_len);
+      int check_srcMACFromVendorClassIDFilterExclude(int type, long *val, size_t val_len, long *old_val, size_t old_val_len);
+      int check_destMACFromVendorClassIDFilter(int type, char *val, size_t val_len, char *old_val, size_t old_val_len);
+      int check_destMACFromVendorClassIDFilterExclude(int type, long *val, size_t val_len, long *old_val, size_t old_val_len);
+      int check_srcMACFromClientIDFilter(int type, char *val, size_t val_len, char *old_val, size_t old_val_len);
+      int check_srcMACFromClientIDFilterExclude(int type, long *val, size_t val_len, long *old_val, size_t old_val_len);
+      int check_destMACFromClientIDFilter(int type, char *val, size_t val_len, char *old_val, size_t old_val_len);
+      int check_destMACFromClientIDFilterExclude(int type, long *val, size_t val_len, long *old_val, size_t old_val_len);
+      int check_srcMACFromUserClassIDFilter(int type, char *val, size_t val_len, char *old_val, size_t old_val_len);
+      int check_srcMACFromUserClassIDFilterExclude(int type, long *val, size_t val_len, long *old_val, size_t old_val_len);
+      int check_destMACFromUserClassIDFilter(int type, char *val, size_t val_len, char *old_val, size_t old_val_len);
+      int check_destMACFromUserClassIDFilterExclude(int type, long *val, size_t val_len, long *old_val, size_t old_val_len);
+
+#endif /* FILTERRULETABLE_CHECKFNS_H */
+
diff -Naur net-snmp-5.7.2-orig/agent/mibgroup/ZYXEL-PRESTIGE-MIB/filterRuleTable_checkfns_local.c net-snmp-5.7.2/agent/mibgroup/ZYXEL-PRESTIGE-MIB/filterRuleTable_checkfns_local.c
--- net-snmp-5.7.2-orig/agent/mibgroup/ZYXEL-PRESTIGE-MIB/filterRuleTable_checkfns_local.c	1970-01-01 08:00:00.000000000 +0800
+++ net-snmp-5.7.2/agent/mibgroup/ZYXEL-PRESTIGE-MIB/filterRuleTable_checkfns_local.c	2013-10-08 09:35:17.626117000 +0800
@@ -0,0 +1,486 @@
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *        : mib2c.check_values_local.conf 10232 2004-05-04 23:35:32Z hardaker $
+ */
+
+/* standard headers */
+#include <net-snmp/net-snmp-config.h>
+#include <net-snmp/net-snmp-includes.h>
+#include "filterRuleTable_checkfns.h"
+#include "filterRuleTable_enums.h"
+
+/** Decides if an incoming value for the filterKey mib node is legal, from a local implementation specific viewpoint.
+ *  @param type    The incoming data type.
+ *  @param val     The value to be checked.
+ *  @param val_len The length of data stored in val (in bytes).
+ *  @return 0 if the incoming value is legal, an SNMP error code otherwise.
+ */
+    int
+    check_filterKey_local(int type, long *val, size_t val_len, long *old_val, size_t old_val_len) {
+
+    /** XXX: you may want to check aspects of the new value that
+       were not covered by the automatic checks by the parent function. */
+
+    /** XXX: you make want to check that the requested change from
+        the old value to the new value is legal (ie, the transistion
+        from one value to another is legal */
+      
+    /** if everything looks ok, return SNMP_ERR_NOERROR */
+      return SNMP_ERR_NOERROR;
+    }
+/** Decides if an incoming value for the filterEnable mib node is legal, from a local implementation specific viewpoint.
+ *  @param type    The incoming data type.
+ *  @param val     The value to be checked.
+ *  @param val_len The length of data stored in val (in bytes).
+ *  @return 0 if the incoming value is legal, an SNMP error code otherwise.
+ */
+    int
+    check_filterEnable_local(int type, long *val, size_t val_len, long *old_val, size_t old_val_len) {
+
+    /** XXX: you may want to check aspects of the new value that
+       were not covered by the automatic checks by the parent function. */
+
+    /** XXX: you make want to check that the requested change from
+        the old value to the new value is legal (ie, the transistion
+        from one value to another is legal */
+      
+    /** if everything looks ok, return SNMP_ERR_NOERROR */
+      return SNMP_ERR_NOERROR;
+    }
+/** Decides if an incoming value for the filterBridgeReference mib node is legal, from a local implementation specific viewpoint.
+ *  @param type    The incoming data type.
+ *  @param val     The value to be checked.
+ *  @param val_len The length of data stored in val (in bytes).
+ *  @return 0 if the incoming value is legal, an SNMP error code otherwise.
+ */
+    int
+    check_filterBridgeReference_local(int type, long *val, size_t val_len, long *old_val, size_t old_val_len) {
+
+    /** XXX: you may want to check aspects of the new value that
+       were not covered by the automatic checks by the parent function. */
+
+    /** XXX: you make want to check that the requested change from
+        the old value to the new value is legal (ie, the transistion
+        from one value to another is legal */
+      
+    /** if everything looks ok, return SNMP_ERR_NOERROR */
+      return SNMP_ERR_NOERROR;
+    }
+/** Decides if an incoming value for the exclusivityOrder mib node is legal, from a local implementation specific viewpoint.
+ *  @param type    The incoming data type.
+ *  @param val     The value to be checked.
+ *  @param val_len The length of data stored in val (in bytes).
+ *  @return 0 if the incoming value is legal, an SNMP error code otherwise.
+ */
+    int
+    check_exclusivityOrder_local(int type, long *val, size_t val_len, long *old_val, size_t old_val_len) {
+
+    /** XXX: you may want to check aspects of the new value that
+       were not covered by the automatic checks by the parent function. */
+
+    /** XXX: you make want to check that the requested change from
+        the old value to the new value is legal (ie, the transistion
+        from one value to another is legal */
+      
+    /** if everything looks ok, return SNMP_ERR_NOERROR */
+      return SNMP_ERR_NOERROR;
+    }
+/** Decides if an incoming value for the filterInterface mib node is legal, from a local implementation specific viewpoint.
+ *  @param type    The incoming data type.
+ *  @param val     The value to be checked.
+ *  @param val_len The length of data stored in val (in bytes).
+ *  @return 0 if the incoming value is legal, an SNMP error code otherwise.
+ */
+    int
+    check_filterInterface_local(int type, char *val, size_t val_len, char *old_val, size_t old_val_len) {
+
+    /** XXX: you may want to check aspects of the new value that
+       were not covered by the automatic checks by the parent function. */
+
+    /** XXX: you make want to check that the requested change from
+        the old value to the new value is legal (ie, the transistion
+        from one value to another is legal */
+      
+    /** if everything looks ok, return SNMP_ERR_NOERROR */
+      return SNMP_ERR_NOERROR;
+    }
+/** Decides if an incoming value for the vlanIDFilter mib node is legal, from a local implementation specific viewpoint.
+ *  @param type    The incoming data type.
+ *  @param val     The value to be checked.
+ *  @param val_len The length of data stored in val (in bytes).
+ *  @return 0 if the incoming value is legal, an SNMP error code otherwise.
+ */
+    int
+    check_vlanIDFilter_local(int type, long *val, size_t val_len, long *old_val, size_t old_val_len) {
+
+    /** XXX: you may want to check aspects of the new value that
+       were not covered by the automatic checks by the parent function. */
+
+    /** XXX: you make want to check that the requested change from
+        the old value to the new value is legal (ie, the transistion
+        from one value to another is legal */
+      
+    /** if everything looks ok, return SNMP_ERR_NOERROR */
+      return SNMP_ERR_NOERROR;
+    }
+/** Decides if an incoming value for the admitOnlyVLANTagged mib node is legal, from a local implementation specific viewpoint.
+ *  @param type    The incoming data type.
+ *  @param val     The value to be checked.
+ *  @param val_len The length of data stored in val (in bytes).
+ *  @return 0 if the incoming value is legal, an SNMP error code otherwise.
+ */
+    int
+    check_admitOnlyVLANTagged_local(int type, long *val, size_t val_len, long *old_val, size_t old_val_len) {
+
+    /** XXX: you may want to check aspects of the new value that
+       were not covered by the automatic checks by the parent function. */
+
+    /** XXX: you make want to check that the requested change from
+        the old value to the new value is legal (ie, the transistion
+        from one value to another is legal */
+      
+    /** if everything looks ok, return SNMP_ERR_NOERROR */
+      return SNMP_ERR_NOERROR;
+    }
+/** Decides if an incoming value for the ethertypeFilterList mib node is legal, from a local implementation specific viewpoint.
+ *  @param type    The incoming data type.
+ *  @param val     The value to be checked.
+ *  @param val_len The length of data stored in val (in bytes).
+ *  @return 0 if the incoming value is legal, an SNMP error code otherwise.
+ */
+    int
+    check_ethertypeFilterList_local(int type, char *val, size_t val_len, char *old_val, size_t old_val_len) {
+
+    /** XXX: you may want to check aspects of the new value that
+       were not covered by the automatic checks by the parent function. */
+
+    /** XXX: you make want to check that the requested change from
+        the old value to the new value is legal (ie, the transistion
+        from one value to another is legal */
+      
+    /** if everything looks ok, return SNMP_ERR_NOERROR */
+      return SNMP_ERR_NOERROR;
+    }
+/** Decides if an incoming value for the ethertypeFilterExclude mib node is legal, from a local implementation specific viewpoint.
+ *  @param type    The incoming data type.
+ *  @param val     The value to be checked.
+ *  @param val_len The length of data stored in val (in bytes).
+ *  @return 0 if the incoming value is legal, an SNMP error code otherwise.
+ */
+    int
+    check_ethertypeFilterExclude_local(int type, long *val, size_t val_len, long *old_val, size_t old_val_len) {
+
+    /** XXX: you may want to check aspects of the new value that
+       were not covered by the automatic checks by the parent function. */
+
+    /** XXX: you make want to check that the requested change from
+        the old value to the new value is legal (ie, the transistion
+        from one value to another is legal */
+      
+    /** if everything looks ok, return SNMP_ERR_NOERROR */
+      return SNMP_ERR_NOERROR;
+    }
+/** Decides if an incoming value for the sourceMACAddressFilterList mib node is legal, from a local implementation specific viewpoint.
+ *  @param type    The incoming data type.
+ *  @param val     The value to be checked.
+ *  @param val_len The length of data stored in val (in bytes).
+ *  @return 0 if the incoming value is legal, an SNMP error code otherwise.
+ */
+    int
+    check_sourceMACAddressFilterList_local(int type, char *val, size_t val_len, char *old_val, size_t old_val_len) {
+
+    /** XXX: you may want to check aspects of the new value that
+       were not covered by the automatic checks by the parent function. */
+
+    /** XXX: you make want to check that the requested change from
+        the old value to the new value is legal (ie, the transistion
+        from one value to another is legal */
+      
+    /** if everything looks ok, return SNMP_ERR_NOERROR */
+      return SNMP_ERR_NOERROR;
+    }
+/** Decides if an incoming value for the sourceMACAddressFilterExclude mib node is legal, from a local implementation specific viewpoint.
+ *  @param type    The incoming data type.
+ *  @param val     The value to be checked.
+ *  @param val_len The length of data stored in val (in bytes).
+ *  @return 0 if the incoming value is legal, an SNMP error code otherwise.
+ */
+    int
+    check_sourceMACAddressFilterExclude_local(int type, long *val, size_t val_len, long *old_val, size_t old_val_len) {
+
+    /** XXX: you may want to check aspects of the new value that
+       were not covered by the automatic checks by the parent function. */
+
+    /** XXX: you make want to check that the requested change from
+        the old value to the new value is legal (ie, the transistion
+        from one value to another is legal */
+      
+    /** if everything looks ok, return SNMP_ERR_NOERROR */
+      return SNMP_ERR_NOERROR;
+    }
+/** Decides if an incoming value for the destMACAddressFilterList mib node is legal, from a local implementation specific viewpoint.
+ *  @param type    The incoming data type.
+ *  @param val     The value to be checked.
+ *  @param val_len The length of data stored in val (in bytes).
+ *  @return 0 if the incoming value is legal, an SNMP error code otherwise.
+ */
+    int
+    check_destMACAddressFilterList_local(int type, char *val, size_t val_len, char *old_val, size_t old_val_len) {
+
+    /** XXX: you may want to check aspects of the new value that
+       were not covered by the automatic checks by the parent function. */
+
+    /** XXX: you make want to check that the requested change from
+        the old value to the new value is legal (ie, the transistion
+        from one value to another is legal */
+      
+    /** if everything looks ok, return SNMP_ERR_NOERROR */
+      return SNMP_ERR_NOERROR;
+    }
+/** Decides if an incoming value for the destMACAddressFilterExclude mib node is legal, from a local implementation specific viewpoint.
+ *  @param type    The incoming data type.
+ *  @param val     The value to be checked.
+ *  @param val_len The length of data stored in val (in bytes).
+ *  @return 0 if the incoming value is legal, an SNMP error code otherwise.
+ */
+    int
+    check_destMACAddressFilterExclude_local(int type, long *val, size_t val_len, long *old_val, size_t old_val_len) {
+
+    /** XXX: you may want to check aspects of the new value that
+       were not covered by the automatic checks by the parent function. */
+
+    /** XXX: you make want to check that the requested change from
+        the old value to the new value is legal (ie, the transistion
+        from one value to another is legal */
+      
+    /** if everything looks ok, return SNMP_ERR_NOERROR */
+      return SNMP_ERR_NOERROR;
+    }
+/** Decides if an incoming value for the srcMACFromVendorClassIDFilter mib node is legal, from a local implementation specific viewpoint.
+ *  @param type    The incoming data type.
+ *  @param val     The value to be checked.
+ *  @param val_len The length of data stored in val (in bytes).
+ *  @return 0 if the incoming value is legal, an SNMP error code otherwise.
+ */
+    int
+    check_srcMACFromVendorClassIDFilter_local(int type, char *val, size_t val_len, char *old_val, size_t old_val_len) {
+
+    /** XXX: you may want to check aspects of the new value that
+       were not covered by the automatic checks by the parent function. */
+
+    /** XXX: you make want to check that the requested change from
+        the old value to the new value is legal (ie, the transistion
+        from one value to another is legal */
+      
+    /** if everything looks ok, return SNMP_ERR_NOERROR */
+      return SNMP_ERR_NOERROR;
+    }
+/** Decides if an incoming value for the srcMACFromVendorClassIDFilterExclude mib node is legal, from a local implementation specific viewpoint.
+ *  @param type    The incoming data type.
+ *  @param val     The value to be checked.
+ *  @param val_len The length of data stored in val (in bytes).
+ *  @return 0 if the incoming value is legal, an SNMP error code otherwise.
+ */
+    int
+    check_srcMACFromVendorClassIDFilterExclude_local(int type, long *val, size_t val_len, long *old_val, size_t old_val_len) {
+
+    /** XXX: you may want to check aspects of the new value that
+       were not covered by the automatic checks by the parent function. */
+
+    /** XXX: you make want to check that the requested change from
+        the old value to the new value is legal (ie, the transistion
+        from one value to another is legal */
+      
+    /** if everything looks ok, return SNMP_ERR_NOERROR */
+      return SNMP_ERR_NOERROR;
+    }
+/** Decides if an incoming value for the destMACFromVendorClassIDFilter mib node is legal, from a local implementation specific viewpoint.
+ *  @param type    The incoming data type.
+ *  @param val     The value to be checked.
+ *  @param val_len The length of data stored in val (in bytes).
+ *  @return 0 if the incoming value is legal, an SNMP error code otherwise.
+ */
+    int
+    check_destMACFromVendorClassIDFilter_local(int type, char *val, size_t val_len, char *old_val, size_t old_val_len) {
+
+    /** XXX: you may want to check aspects of the new value that
+       were not covered by the automatic checks by the parent function. */
+
+    /** XXX: you make want to check that the requested change from
+        the old value to the new value is legal (ie, the transistion
+        from one value to another is legal */
+      
+    /** if everything looks ok, return SNMP_ERR_NOERROR */
+      return SNMP_ERR_NOERROR;
+    }
+/** Decides if an incoming value for the destMACFromVendorClassIDFilterExclude mib node is legal, from a local implementation specific viewpoint.
+ *  @param type    The incoming data type.
+ *  @param val     The value to be checked.
+ *  @param val_len The length of data stored in val (in bytes).
+ *  @return 0 if the incoming value is legal, an SNMP error code otherwise.
+ */
+    int
+    check_destMACFromVendorClassIDFilterExclude_local(int type, long *val, size_t val_len, long *old_val, size_t old_val_len) {
+
+    /** XXX: you may want to check aspects of the new value that
+       were not covered by the automatic checks by the parent function. */
+
+    /** XXX: you make want to check that the requested change from
+        the old value to the new value is legal (ie, the transistion
+        from one value to another is legal */
+      
+    /** if everything looks ok, return SNMP_ERR_NOERROR */
+      return SNMP_ERR_NOERROR;
+    }
+/** Decides if an incoming value for the srcMACFromClientIDFilter mib node is legal, from a local implementation specific viewpoint.
+ *  @param type    The incoming data type.
+ *  @param val     The value to be checked.
+ *  @param val_len The length of data stored in val (in bytes).
+ *  @return 0 if the incoming value is legal, an SNMP error code otherwise.
+ */
+    int
+    check_srcMACFromClientIDFilter_local(int type, char *val, size_t val_len, char *old_val, size_t old_val_len) {
+
+    /** XXX: you may want to check aspects of the new value that
+       were not covered by the automatic checks by the parent function. */
+
+    /** XXX: you make want to check that the requested change from
+        the old value to the new value is legal (ie, the transistion
+        from one value to another is legal */
+      
+    /** if everything looks ok, return SNMP_ERR_NOERROR */
+      return SNMP_ERR_NOERROR;
+    }
+/** Decides if an incoming value for the srcMACFromClientIDFilterExclude mib node is legal, from a local implementation specific viewpoint.
+ *  @param type    The incoming data type.
+ *  @param val     The value to be checked.
+ *  @param val_len The length of data stored in val (in bytes).
+ *  @return 0 if the incoming value is legal, an SNMP error code otherwise.
+ */
+    int
+    check_srcMACFromClientIDFilterExclude_local(int type, long *val, size_t val_len, long *old_val, size_t old_val_len) {
+
+    /** XXX: you may want to check aspects of the new value that
+       were not covered by the automatic checks by the parent function. */
+
+    /** XXX: you make want to check that the requested change from
+        the old value to the new value is legal (ie, the transistion
+        from one value to another is legal */
+      
+    /** if everything looks ok, return SNMP_ERR_NOERROR */
+      return SNMP_ERR_NOERROR;
+    }
+/** Decides if an incoming value for the destMACFromClientIDFilter mib node is legal, from a local implementation specific viewpoint.
+ *  @param type    The incoming data type.
+ *  @param val     The value to be checked.
+ *  @param val_len The length of data stored in val (in bytes).
+ *  @return 0 if the incoming value is legal, an SNMP error code otherwise.
+ */
+    int
+    check_destMACFromClientIDFilter_local(int type, char *val, size_t val_len, char *old_val, size_t old_val_len) {
+
+    /** XXX: you may want to check aspects of the new value that
+       were not covered by the automatic checks by the parent function. */
+
+    /** XXX: you make want to check that the requested change from
+        the old value to the new value is legal (ie, the transistion
+        from one value to another is legal */
+      
+    /** if everything looks ok, return SNMP_ERR_NOERROR */
+      return SNMP_ERR_NOERROR;
+    }
+/** Decides if an incoming value for the destMACFromClientIDFilterExclude mib node is legal, from a local implementation specific viewpoint.
+ *  @param type    The incoming data type.
+ *  @param val     The value to be checked.
+ *  @param val_len The length of data stored in val (in bytes).
+ *  @return 0 if the incoming value is legal, an SNMP error code otherwise.
+ */
+    int
+    check_destMACFromClientIDFilterExclude_local(int type, long *val, size_t val_len, long *old_val, size_t old_val_len) {
+
+    /** XXX: you may want to check aspects of the new value that
+       were not covered by the automatic checks by the parent function. */
+
+    /** XXX: you make want to check that the requested change from
+        the old value to the new value is legal (ie, the transistion
+        from one value to another is legal */
+      
+    /** if everything looks ok, return SNMP_ERR_NOERROR */
+      return SNMP_ERR_NOERROR;
+    }
+/** Decides if an incoming value for the srcMACFromUserClassIDFilter mib node is legal, from a local implementation specific viewpoint.
+ *  @param type    The incoming data type.
+ *  @param val     The value to be checked.
+ *  @param val_len The length of data stored in val (in bytes).
+ *  @return 0 if the incoming value is legal, an SNMP error code otherwise.
+ */
+    int
+    check_srcMACFromUserClassIDFilter_local(int type, char *val, size_t val_len, char *old_val, size_t old_val_len) {
+
+    /** XXX: you may want to check aspects of the new value that
+       were not covered by the automatic checks by the parent function. */
+
+    /** XXX: you make want to check that the requested change from
+        the old value to the new value is legal (ie, the transistion
+        from one value to another is legal */
+      
+    /** if everything looks ok, return SNMP_ERR_NOERROR */
+      return SNMP_ERR_NOERROR;
+    }
+/** Decides if an incoming value for the srcMACFromUserClassIDFilterExclude mib node is legal, from a local implementation specific viewpoint.
+ *  @param type    The incoming data type.
+ *  @param val     The value to be checked.
+ *  @param val_len The length of data stored in val (in bytes).
+ *  @return 0 if the incoming value is legal, an SNMP error code otherwise.
+ */
+    int
+    check_srcMACFromUserClassIDFilterExclude_local(int type, long *val, size_t val_len, long *old_val, size_t old_val_len) {
+
+    /** XXX: you may want to check aspects of the new value that
+       were not covered by the automatic checks by the parent function. */
+
+    /** XXX: you make want to check that the requested change from
+        the old value to the new value is legal (ie, the transistion
+        from one value to another is legal */
+      
+    /** if everything looks ok, return SNMP_ERR_NOERROR */
+      return SNMP_ERR_NOERROR;
+    }
+/** Decides if an incoming value for the destMACFromUserClassIDFilter mib node is legal, from a local implementation specific viewpoint.
+ *  @param type    The incoming data type.
+ *  @param val     The value to be checked.
+ *  @param val_len The length of data stored in val (in bytes).
+ *  @return 0 if the incoming value is legal, an SNMP error code otherwise.
+ */
+    int
+    check_destMACFromUserClassIDFilter_local(int type, char *val, size_t val_len, char *old_val, size_t old_val_len) {
+
+    /** XXX: you may want to check aspects of the new value that
+       were not covered by the automatic checks by the parent function. */
+
+    /** XXX: you make want to check that the requested change from
+        the old value to the new value is legal (ie, the transistion
+        from one value to another is legal */
+      
+    /** if everything looks ok, return SNMP_ERR_NOERROR */
+      return SNMP_ERR_NOERROR;
+    }
+/** Decides if an incoming value for the destMACFromUserClassIDFilterExclude mib node is legal, from a local implementation specific viewpoint.
+ *  @param type    The incoming data type.
+ *  @param val     The value to be checked.
+ *  @param val_len The length of data stored in val (in bytes).
+ *  @return 0 if the incoming value is legal, an SNMP error code otherwise.
+ */
+    int
+    check_destMACFromUserClassIDFilterExclude_local(int type, long *val, size_t val_len, long *old_val, size_t old_val_len) {
+
+    /** XXX: you may want to check aspects of the new value that
+       were not covered by the automatic checks by the parent function. */
+
+    /** XXX: you make want to check that the requested change from
+        the old value to the new value is legal (ie, the transistion
+        from one value to another is legal */
+      
+    /** if everything looks ok, return SNMP_ERR_NOERROR */
+      return SNMP_ERR_NOERROR;
+    }
diff -Naur net-snmp-5.7.2-orig/agent/mibgroup/ZYXEL-PRESTIGE-MIB/filterRuleTable_checkfns_local.h net-snmp-5.7.2/agent/mibgroup/ZYXEL-PRESTIGE-MIB/filterRuleTable_checkfns_local.h
--- net-snmp-5.7.2-orig/agent/mibgroup/ZYXEL-PRESTIGE-MIB/filterRuleTable_checkfns_local.h	1970-01-01 08:00:00.000000000 +0800
+++ net-snmp-5.7.2/agent/mibgroup/ZYXEL-PRESTIGE-MIB/filterRuleTable_checkfns_local.h	2013-10-08 09:35:17.626117000 +0800
@@ -0,0 +1,44 @@
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *        : : mib2c.check_values_local.conf 10232 2004-05-04 23:35:32Z hardaker $
+ * 
+ */
+#ifndef FILTERRULETABLE_CHECKFNS_H
+#define FILTERRULETABLE_CHECKFNS_H
+
+/* these functions are designed to check incoming values for 
+columns in the filterRuleTable table for legality with respect to 
+datatype and value according to local conventions.  You should modify
+them as appropriate.  They will be called from parent check_value
+functions that are auto-generated using mib2c and the parent functions
+should NOT be modified.
+ */
+
+    int check_filterKey_local(int type, long *val, size_t val_len, long *old_val, size_t old_val_len);
+    int check_filterEnable_local(int type, long *val, size_t val_len, long *old_val, size_t old_val_len);
+    int check_filterBridgeReference_local(int type, long *val, size_t val_len, long *old_val, size_t old_val_len);
+    int check_exclusivityOrder_local(int type, long *val, size_t val_len, long *old_val, size_t old_val_len);
+    int check_filterInterface_local(int type, char *val, size_t val_len, char *old_val, size_t old_val_len);
+    int check_vlanIDFilter_local(int type, long *val, size_t val_len, long *old_val, size_t old_val_len);
+    int check_admitOnlyVLANTagged_local(int type, long *val, size_t val_len, long *old_val, size_t old_val_len);
+    int check_ethertypeFilterList_local(int type, char *val, size_t val_len, char *old_val, size_t old_val_len);
+    int check_ethertypeFilterExclude_local(int type, long *val, size_t val_len, long *old_val, size_t old_val_len);
+    int check_sourceMACAddressFilterList_local(int type, char *val, size_t val_len, char *old_val, size_t old_val_len);
+    int check_sourceMACAddressFilterExclude_local(int type, long *val, size_t val_len, long *old_val, size_t old_val_len);
+    int check_destMACAddressFilterList_local(int type, char *val, size_t val_len, char *old_val, size_t old_val_len);
+    int check_destMACAddressFilterExclude_local(int type, long *val, size_t val_len, long *old_val, size_t old_val_len);
+    int check_srcMACFromVendorClassIDFilter_local(int type, char *val, size_t val_len, char *old_val, size_t old_val_len);
+    int check_srcMACFromVendorClassIDFilterExclude_local(int type, long *val, size_t val_len, long *old_val, size_t old_val_len);
+    int check_destMACFromVendorClassIDFilter_local(int type, char *val, size_t val_len, char *old_val, size_t old_val_len);
+    int check_destMACFromVendorClassIDFilterExclude_local(int type, long *val, size_t val_len, long *old_val, size_t old_val_len);
+    int check_srcMACFromClientIDFilter_local(int type, char *val, size_t val_len, char *old_val, size_t old_val_len);
+    int check_srcMACFromClientIDFilterExclude_local(int type, long *val, size_t val_len, long *old_val, size_t old_val_len);
+    int check_destMACFromClientIDFilter_local(int type, char *val, size_t val_len, char *old_val, size_t old_val_len);
+    int check_destMACFromClientIDFilterExclude_local(int type, long *val, size_t val_len, long *old_val, size_t old_val_len);
+    int check_srcMACFromUserClassIDFilter_local(int type, char *val, size_t val_len, char *old_val, size_t old_val_len);
+    int check_srcMACFromUserClassIDFilterExclude_local(int type, long *val, size_t val_len, long *old_val, size_t old_val_len);
+    int check_destMACFromUserClassIDFilter_local(int type, char *val, size_t val_len, char *old_val, size_t old_val_len);
+    int check_destMACFromUserClassIDFilterExclude_local(int type, long *val, size_t val_len, long *old_val, size_t old_val_len);
+
+#endif /* FILTERRULETABLE_CHECKFNS_H */
+
diff -Naur net-snmp-5.7.2-orig/agent/mibgroup/ZYXEL-PRESTIGE-MIB/filterRuleTable_columns.h net-snmp-5.7.2/agent/mibgroup/ZYXEL-PRESTIGE-MIB/filterRuleTable_columns.h
--- net-snmp-5.7.2-orig/agent/mibgroup/ZYXEL-PRESTIGE-MIB/filterRuleTable_columns.h	1970-01-01 08:00:00.000000000 +0800
+++ net-snmp-5.7.2/agent/mibgroup/ZYXEL-PRESTIGE-MIB/filterRuleTable_columns.h	2013-10-08 09:35:17.626117000 +0800
@@ -0,0 +1,35 @@
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *  : mib2c.column_defines.conf 7011 2002-05-08 05:42:47Z hardaker $
+ */
+#ifndef FILTERRULETABLE_COLUMNS_H
+#define FILTERRULETABLE_COLUMNS_H
+
+/* column number definitions for table filterRuleTable */
+       #define COLUMN_FILTERRULEINDEX		1
+       #define COLUMN_FILTERKEY		2
+       #define COLUMN_FILTERENABLE		3
+       #define COLUMN_FILTERBRIDGEREFERENCE		4
+       #define COLUMN_EXCLUSIVITYORDER		5
+       #define COLUMN_FILTERINTERFACE		6
+       #define COLUMN_VLANIDFILTER		7
+       #define COLUMN_ADMITONLYVLANTAGGED		8
+       #define COLUMN_ETHERTYPEFILTERLIST		9
+       #define COLUMN_ETHERTYPEFILTEREXCLUDE		10
+       #define COLUMN_SOURCEMACADDRESSFILTERLIST		11
+       #define COLUMN_SOURCEMACADDRESSFILTEREXCLUDE		12
+       #define COLUMN_DESTMACADDRESSFILTERLIST		13
+       #define COLUMN_DESTMACADDRESSFILTEREXCLUDE		14
+       #define COLUMN_SRCMACFROMVENDORCLASSIDFILTER		15
+       #define COLUMN_SRCMACFROMVENDORCLASSIDFILTEREXCLUDE		16
+       #define COLUMN_DESTMACFROMVENDORCLASSIDFILTER		17
+       #define COLUMN_DESTMACFROMVENDORCLASSIDFILTEREXCLUDE		18
+       #define COLUMN_SRCMACFROMCLIENTIDFILTER		19
+       #define COLUMN_SRCMACFROMCLIENTIDFILTEREXCLUDE		20
+       #define COLUMN_DESTMACFROMCLIENTIDFILTER		21
+       #define COLUMN_DESTMACFROMCLIENTIDFILTEREXCLUDE		22
+       #define COLUMN_SRCMACFROMUSERCLASSIDFILTER		23
+       #define COLUMN_SRCMACFROMUSERCLASSIDFILTEREXCLUDE		24
+       #define COLUMN_DESTMACFROMUSERCLASSIDFILTER		25
+       #define COLUMN_DESTMACFROMUSERCLASSIDFILTEREXCLUDE		26
+#endif /* FILTERRULETABLE_COLUMNS_H */
diff -Naur net-snmp-5.7.2-orig/agent/mibgroup/ZYXEL-PRESTIGE-MIB/filterRuleTable_enums.h net-snmp-5.7.2/agent/mibgroup/ZYXEL-PRESTIGE-MIB/filterRuleTable_enums.h
--- net-snmp-5.7.2-orig/agent/mibgroup/ZYXEL-PRESTIGE-MIB/filterRuleTable_enums.h	1970-01-01 08:00:00.000000000 +0800
+++ net-snmp-5.7.2/agent/mibgroup/ZYXEL-PRESTIGE-MIB/filterRuleTable_enums.h	2013-10-08 09:35:17.626117000 +0800
@@ -0,0 +1,9 @@
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *  : mib2c.column_enums.conf 12909 2005-09-29 22:16:22Z hardaker $
+ */
+#ifndef FILTERRULETABLE_ENUMS_H
+#define FILTERRULETABLE_ENUMS_H
+
+
+#endif /* FILTERRULETABLE_ENUMS_H */
diff -Naur net-snmp-5.7.2-orig/agent/mibgroup/ZYXEL-PRESTIGE-MIB/filterRuleTable.h net-snmp-5.7.2/agent/mibgroup/ZYXEL-PRESTIGE-MIB/filterRuleTable.h
--- net-snmp-5.7.2-orig/agent/mibgroup/ZYXEL-PRESTIGE-MIB/filterRuleTable.h	1970-01-01 08:00:00.000000000 +0800
+++ net-snmp-5.7.2/agent/mibgroup/ZYXEL-PRESTIGE-MIB/filterRuleTable.h	2013-10-08 09:35:17.626117000 +0800
@@ -0,0 +1,25 @@
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *        : mib2c.iterate_access.conf 15179 2006-09-08 15:44:37Z dts12 $
+ */
+#ifndef FILTERRULETABLE_H
+#define FILTERRULETABLE_H
+
+/** other required module components */
+config_require(ZYXEL-PRESTIGE-MIB/filterRuleTable_access)
+config_require(ZYXEL-PRESTIGE-MIB/filterRuleTable_checkfns)
+
+/* function declarations */
+void init_filterRuleTable(void);
+void initialize_table_filterRuleTable(void);
+Netsnmp_Node_Handler filterRuleTable_handler;
+
+config_require(ZYXEL-PRESTIGE-MIB/ccclib)
+
+/* column number definitions for table filterRuleTable */
+#include "filterRuleTable_columns.h"
+
+/* enum definions */
+#include "filterRuleTable_enums.h"
+
+#endif /** FILTERRULETABLE_H */
diff -Naur net-snmp-5.7.2-orig/agent/mibgroup/ZYXEL-PRESTIGE-MIB/ipStaticRouteTable_access.c net-snmp-5.7.2/agent/mibgroup/ZYXEL-PRESTIGE-MIB/ipStaticRouteTable_access.c
--- net-snmp-5.7.2-orig/agent/mibgroup/ZYXEL-PRESTIGE-MIB/ipStaticRouteTable_access.c	1970-01-01 08:00:00.000000000 +0800
+++ net-snmp-5.7.2/agent/mibgroup/ZYXEL-PRESTIGE-MIB/ipStaticRouteTable_access.c	2013-10-08 09:35:17.626117000 +0800
@@ -0,0 +1,566 @@
+
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *        : mib2c.access_functions.conf 11358 2004-10-14 12:57:34Z dts12 $
+ */
+
+#include <net-snmp/net-snmp-config.h>
+#include <net-snmp/net-snmp-includes.h>
+#include <net-snmp/agent/net-snmp-agent-includes.h>
+#include "ipStaticRouteTable_access.h"
+#include "ipStaticRouteTable_enums.h"
+#include "ccclib.h"
+
+#include <stdio.h>
+#include <string.h>
+/*the structure of ipStaticRouteTable*/
+typedef struct ipStaticRouteTable_entry{
+long ipStaticRouteIndex;
+    char ipStaticRouteName[33];
+    char ipStaticRouteStatus[9];
+    char ipStaticRouteType[9];
+    char ipStaticRouteDestIpAddr[17];
+    char ipStaticRouteDestSubnetMask[17];
+    char ipStaticRouteSrcIpAddr[17];
+    char ipStaticRouteSrcSubnetMask[17];
+    char ipStaticRouteGatewayIpAddr[17];
+    char ipStaticRouteInterface[257];
+    long ipStaticRouteForwardingPolicy;
+    long ipStaticRouteMTU;
+    long ipStaticRouteMetric;
+    long ipStaticRouteStaticRoute;
+    long ipStaticRouteEnable;
+struct ipStaticRouteTable_entry * next;
+
+}ipStaticRouteTable_entry_t;
+
+struct ipStaticRouteTable_entry  *ipStaticRouteTable_head;
+/* create a new row in the (unsorted) table */
+struct ipStaticRouteTable_entry *
+ipStaticRouteTable_createEntry(
+                 long  ipStaticRouteIndex,
+                 char ipStaticRouteName[33],
+    			char ipStaticRouteStatus[9],
+    char ipStaticRouteType[9],
+    char ipStaticRouteDestIpAddr[17],
+    char ipStaticRouteDestSubnetMask[17],
+    char ipStaticRouteSrcIpAddr[17],
+    char ipStaticRouteSrcSubnetMask[17],
+    char ipStaticRouteGatewayIpAddr[17],
+    char ipStaticRouteInterface[257],
+    long ipStaticRouteForwardingPolicy,
+    long ipStaticRouteMTU,
+    long ipStaticRouteMetric,
+    long ipStaticRouteStaticRoute,
+    long ipStaticRouteEnable
+                ) {
+    struct ipStaticRouteTable_entry *entry;
+
+    entry = SNMP_MALLOC_TYPEDEF(struct ipStaticRouteTable_entry);
+    if (!entry)
+        return NULL;
+
+  entry->ipStaticRouteIndex = ipStaticRouteIndex;
+strcpy(entry->ipStaticRouteName,ipStaticRouteName);
+strcpy(entry->ipStaticRouteStatus,ipStaticRouteStatus);
+strcpy(entry->ipStaticRouteType,ipStaticRouteType);
+strcpy(entry->ipStaticRouteDestIpAddr,ipStaticRouteDestIpAddr);
+strcpy(entry->ipStaticRouteDestSubnetMask,ipStaticRouteDestSubnetMask);
+strcpy(entry->ipStaticRouteSrcIpAddr,ipStaticRouteSrcIpAddr);
+strcpy(entry->ipStaticRouteInterface,ipStaticRouteInterface);
+entry->ipStaticRouteForwardingPolicy=ipStaticRouteForwardingPolicy;
+entry->ipStaticRouteMTU=ipStaticRouteMTU;
+entry->ipStaticRouteMetric=ipStaticRouteMetric;
+entry->ipStaticRouteStaticRoute=ipStaticRouteStaticRoute;
+entry->ipStaticRouteEnable=ipStaticRouteEnable;
+
+
+
+
+
+	
+    entry->next = ipStaticRouteTable_head;
+    ipStaticRouteTable_head = entry;
+    return entry;
+}
+
+
+void
+ipStaticRouteTable_removeEntry( struct ipStaticRouteTable_entry *entry ) {
+    struct ipStaticRouteTable_entry *ptr, *prev;
+
+    if (!entry)
+        return;    /* Nothing to remove */
+
+    for ( ptr  = ipStaticRouteTable_head, prev = NULL;
+          ptr != NULL;
+          prev = ptr, ptr = ptr->next ) {
+        if ( ptr == entry )
+            break;
+    }
+    if ( !ptr )
+        return;    /* Can't find it */
+
+    if ( prev == NULL )
+        ipStaticRouteTable_head = ptr->next;
+    else
+        prev->next = ptr->next;
+
+    SNMP_FREE( entry );   /* XXX - release any other internal resources */
+}
+
+int data_read(void)
+
+{
+int ret=0;
+int staticRouteIndex=0;
+     rdmCB_t *rdmCB=NULL;
+	rdmObj_InternetGatewayDevice_Layer3Forwarding_Forwarding_i_t *entry=NULL;
+int count=0;
+  int i;
+
+  struct  ipStaticRouteTable_entry *temp;
+
+  rdmCB=RDMINIT(RDMNAME);
+	if(rdmCB==NULL){
+		ret=-1;
+		return ret;
+	}
+staticRouteIndex=rdmGetIndexChildCount(rdmCB, InternetGatewayDevice_Layer3Forwarding_Forwarding_i);
+//printf("brian staticRouteIndex %d\n",staticRouteIndex);
+	
+      while (ipStaticRouteTable_head)/*clean link list begin*/
+
+              {
+
+                     temp=ipStaticRouteTable_head->next;
+
+                     ipStaticRouteTable_removeEntry(ipStaticRouteTable_head);
+
+                     ipStaticRouteTable_head=temp;
+
+              }/*clean link list end*/
+
+	for(i=1;i<=staticRouteIndex;i++){
+		if( !rdmGetIndexChildStatus( rdmCB, InternetGatewayDevice_Layer3Forwarding_Forwarding_(i))){
+					continue;
+		}
+		entry=rdmGetObjectByID(rdmCB,InternetGatewayDevice_Layer3Forwarding_Forwarding_(i) );
+		if(entry==NULL){
+			goto fail;
+		}
+		//printf("brian in for loop\n");
+		ipStaticRouteTable_createEntry(i, entry->X_ZyXEL_RouteName, entry->Status, entry->Type, 
+			entry->DestIPAddress, entry->DestSubnetMask,entry->SourceIPAddress,entry->SourceSubnetMask,entry->GatewayIPAddress,entry->Interface,
+			entry->ForwardingPolicy,entry->MTU,entry->ForwardingMetric,entry->StaticRoute,entry->Enable);
+		
+
+	}
+
+
+	   fail:
+		if(rdmCB!=NULL){
+			RDMDEINIT(rdmCB);
+			return ret;
+		}
+
+}
+
+
+
+
+
+
+
+static u_long long_ret;
+
+/** returns the first data point within the ipStaticRouteTable table data.
+
+    Set the my_loop_context variable to the first data point structure
+    of your choice (from which you can find the next one).  This could
+    be anything from the first node in a linked list, to an integer
+    pointer containing the beginning of an array variable.
+
+    Set the my_data_context variable to something to be returned to
+    you later that will provide you with the data to return in a given
+    row.  This could be the same pointer as what my_loop_context is
+    set to, or something different.
+
+    The put_index_data variable contains a list of snmp variable
+    bindings, one for each index in your table.  Set the values of
+    each appropriately according to the data matching the first row
+    and return the put_index_data variable at the end of the function.
+*/
+netsnmp_variable_list *
+ipStaticRouteTable_get_first_data_point(void **my_loop_context, void **my_data_context,
+                          netsnmp_variable_list *put_index_data,
+                          netsnmp_iterator_info *mydata)
+{
+
+    netsnmp_variable_list *vptr;
+data_read();
+    *my_loop_context = ipStaticRouteTable_head/** XXX */;
+    *my_data_context = ipStaticRouteTable_head/** XXX */;
+
+    vptr = put_index_data;
+    
+    //snmp_set_var_value(vptr, (u_char *) /** XXX: ipStaticRouteIndex data */, /** XXX: length of ipStaticRouteIndex data */);
+    //vptr = vptr->next_variable;
+
+    //return put_index_data;
+    return ipStaticRouteTable_get_next_data_point(my_loop_context,my_data_context,put_index_data,mydata);
+}
+
+/** functionally the same as ipStaticRouteTable_get_first_data_point, but
+   my_loop_context has already been set to a previous value and should
+   be updated to the next in the list.  For example, if it was a
+   linked list, you might want to cast it to your local data type and
+   then return my_loop_context->next.  The my_data_context pointer
+   should be set to something you need later and the indexes in
+   put_index_data updated again. */
+netsnmp_variable_list *
+ipStaticRouteTable_get_next_data_point(void **my_loop_context, void **my_data_context,
+                         netsnmp_variable_list *put_index_data,
+                         netsnmp_iterator_info *mydata)
+{
+
+
+
+
+  struct ipStaticRouteTable_entry*entry = (struct ipStaticRouteTable_entry *)*my_loop_context;
+
+    netsnmp_variable_list *idx = put_index_data;
+
+ 
+
+    if ( entry )
+
+           {
+
+        snmp_set_var_value(idx, (u_char *)&entry->ipStaticRouteIndex, sizeof(entry->ipStaticRouteIndex));
+
+        idx = idx->next_variable;
+
+        *my_data_context = (void *)entry;
+
+        *my_loop_context = (struct ipStaticRouteTable_entry *)entry->next;
+
+           }
+
+           else
+
+                  {
+
+        return NULL;
+
+                  }
+
+    return put_index_data;
+
+
+#if 0
+
+    netsnmp_variable_list *vptr;
+
+    *my_loop_context = /** XXX */;
+    *my_data_context = /** XXX */;
+
+    vptr = put_index_data;
+    
+    snmp_set_var_value(vptr, (u_char *) /** XXX: ipStaticRouteIndex data */, /** XXX: length of ipStaticRouteIndex data */);
+    vptr = vptr->next_variable;
+
+    return put_index_data;
+	#endif
+}
+
+/** Create a data_context for non-existent rows that SETs are performed on.
+ *  return a void * pointer which will be passed to subsequent get_XXX
+ *  and set_XXX functions for data retrival and modification during
+ *  this SET request.
+ *
+ *  The indexes are encoded (in order) into the index_data pointer,
+ *  and the column object which triggered the row creation is available
+ *  via the column parameter, if it would be helpful to use that information.
+ */
+void *
+ipStaticRouteTable_create_data_context(netsnmp_variable_list *index_data, int column) {
+    return NULL; /* XXX: you likely want to return a real pointer */
+}
+
+/** If the implemented set_* functions don't operate directly on the
+   real-live data (which is actually recommended), then this function
+   can be used to take a given my_data_context pointer and "commit" it
+   to whereever the modified data needs to be put back to.  For
+   example, if this was a routing table you could publish the modified
+   routes back into the kernel at this point.
+
+   new_or_del will be set to 1 if new, or -1 if it should be deleted
+   or 0 if it is just a modification of an existing row.
+
+   If you free the data yourself, make sure to *my_data_context = NULL */
+int
+ipStaticRouteTable_commit_row(void **my_data_context, int new_or_del)
+{
+    /** Add any necessary commit code here */
+    /*  */
+
+    /* return no errors.  And there shouldn't be any!!!  Ever!!!  You
+    should have checked the values long before this. */
+    return SNMP_ERR_NOERROR;
+}
+
+
+/* User-defined data access functions (per column) for data in table ipStaticRouteTable */
+/*
+ * NOTE:
+ * - these get_ routines MUST return data that will not be freed (ie,
+ *   use static variables or persistent data).  It will be copied, if
+ *   needed, immediately after the get_ routine has been called.
+ * - these SET routines must copy the incoming data and can not take
+ *   ownership of the memory passed in by the val pointer.
+ */
+/** XXX: return a data pointer to the data for the ipStaticRouteIndex column and set
+         ret_len to its proper size in bytes. */
+      long *get_ipStaticRouteIndex(void *data_context, size_t *ret_len) {
+      struct ipStaticRouteTable_entry *entry=(struct ipStaticRouteTable_entry *)data_context;
+	  long_ret=entry->ipStaticRouteIndex;
+	  *ret_len=sizeof(long_ret);
+      return &long_ret; /** XXX: replace this with a pointer to a real value */
+      }
+/** XXX: return a data pointer to the data for the ipStaticRouteName column and set
+         ret_len to its proper size in bytes. */
+      char *get_ipStaticRouteName(void *data_context, size_t *ret_len) {
+      struct ipStaticRouteTable_entry *entry=(struct ipStaticRouteTable_entry *)data_context;
+	  *ret_len=strlen(entry->ipStaticRouteName);
+      return entry->ipStaticRouteName; /** XXX: replace this with a pointer to a real value */
+      }
+/** XXX: Set the value of the ipStaticRouteName column and return
+         SNMP_ERR_NOERROR on success
+         SNMP_ERR_XXX     for SNMP deterministic error codes
+         SNMP_ERR_GENERR  on generic failures (a last result response). */
+      int set_ipStaticRouteName(void *data_context, char *val, size_t val_len) {
+      	 struct ipStaticRouteTable_entry *entry=(struct ipStaticRouteTable_entry *)data_context;
+	char buf[33];
+	memcpy(buf,val,val_len);
+	buf[val_len]='\0';
+	handleOfSetParameterSpecForTable(InternetGatewayDevice_Layer3Forwarding_Forwarding_(entry->ipStaticRouteIndex),
+		"X_ZyXEL_RouteName", buf);
+	//printf("BRIAN set_ipStaticRouteName function\n");
+        return SNMP_ERR_NOERROR;  /** XXX: change if an error occurs */
+      }
+/** XXX: return a data pointer to the data for the ipStaticRouteStatus column and set
+         ret_len to its proper size in bytes. */
+      char *get_ipStaticRouteStatus(void *data_context, size_t *ret_len) {
+      struct ipStaticRouteTable_entry *entry=(struct ipStaticRouteTable_entry *)data_context;
+	  *ret_len=strlen(entry->ipStaticRouteStatus);
+      return entry->ipStaticRouteStatus; /** XXX: replace this with a pointer to a real value */
+      }
+/** XXX: Set the value of the ipStaticRouteStatus column and return
+         SNMP_ERR_NOERROR on success
+         SNMP_ERR_XXX     for SNMP deterministic error codes
+         SNMP_ERR_GENERR  on generic failures (a last result response). */
+      int set_ipStaticRouteStatus(void *data_context, char *val, size_t val_len) {
+       struct ipStaticRouteTable_entry *entry=(struct ipStaticRouteTable_entry *)data_context;
+	   char buf[9];
+	   memcpy(buf,val,val_len);
+	buf[val_len]='\0';
+	handleOfSetParameterSpecForTable(InternetGatewayDevice_Layer3Forwarding_Forwarding_(entry->ipStaticRouteIndex),
+		"Status", buf);
+        return SNMP_ERR_NOERROR;  /** XXX: change if an error occurs */
+      }
+/** XXX: return a data pointer to the data for the ipStaticRouteType column and set
+         ret_len to its proper size in bytes. */
+      char *get_ipStaticRouteType(void *data_context, size_t *ret_len) {
+      struct ipStaticRouteTable_entry *entry=(struct ipStaticRouteTable_entry *)data_context;
+	  *ret_len=strlen(entry->ipStaticRouteType);
+      return entry->ipStaticRouteType; /** XXX: replace this with a pointer to a real value */
+      }
+/** XXX: return a data pointer to the data for the ipStaticRouteDestIpAddr column and set
+         ret_len to its proper size in bytes. */
+      char *get_ipStaticRouteDestIpAddr(void *data_context, size_t *ret_len) {
+    struct ipStaticRouteTable_entry *entry=(struct ipStaticRouteTable_entry *)data_context;
+	  *ret_len=strlen(entry->ipStaticRouteDestIpAddr);
+      return entry->ipStaticRouteDestIpAddr; /** XXX: replace this with a pointer to a real value */
+      }
+/** XXX: Set the value of the ipStaticRouteDestIpAddr column and return
+         SNMP_ERR_NOERROR on success
+         SNMP_ERR_XXX     for SNMP deterministic error codes
+         SNMP_ERR_GENERR  on generic failures (a last result response). */
+      int set_ipStaticRouteDestIpAddr(void *data_context, char *val, size_t val_len) {
+       struct ipStaticRouteTable_entry *entry=(struct ipStaticRouteTable_entry *)data_context;
+	   char buf[17];
+	   memcpy(buf,val,val_len);
+	buf[val_len]='\0';
+	handleOfSetParameterSpecForTable(InternetGatewayDevice_Layer3Forwarding_Forwarding_(entry->ipStaticRouteIndex),
+		"DestIPAddress", buf);
+        return SNMP_ERR_NOERROR;  /** XXX: change if an error occurs */
+      }
+/** XXX: return a data pointer to the data for the ipStaticRouteDestSubnetMask column and set
+         ret_len to its proper size in bytes. */
+      char *get_ipStaticRouteDestSubnetMask(void *data_context, size_t *ret_len) {
+    struct ipStaticRouteTable_entry *entry=(struct ipStaticRouteTable_entry *)data_context;
+	  *ret_len=strlen(entry->ipStaticRouteDestSubnetMask);
+      return entry->ipStaticRouteDestSubnetMask; /** XXX: replace this with a pointer to a real value */
+      }
+/** XXX: Set the value of the ipStaticRouteDestSubnetMask column and return
+         SNMP_ERR_NOERROR on success
+         SNMP_ERR_XXX     for SNMP deterministic error codes
+         SNMP_ERR_GENERR  on generic failures (a last result response). */
+      int set_ipStaticRouteDestSubnetMask(void *data_context, char *val, size_t val_len) {
+       struct ipStaticRouteTable_entry *entry=(struct ipStaticRouteTable_entry *)data_context;
+	   char buf[17];
+	   memcpy(buf,val,val_len);
+	buf[val_len]='\0';
+	handleOfSetParameterSpecForTable(InternetGatewayDevice_Layer3Forwarding_Forwarding_(entry->ipStaticRouteIndex),
+		"DestSubnetMask", buf);
+        return SNMP_ERR_NOERROR;  /** XXX: change if an error occurs */
+      }
+/** XXX: return a data pointer to the data for the ipStaticRouteSrcIpAddr column and set
+         ret_len to its proper size in bytes. */
+      char *get_ipStaticRouteSrcIpAddr(void *data_context, size_t *ret_len) {
+      struct ipStaticRouteTable_entry *entry=(struct ipStaticRouteTable_entry *)data_context;
+	  *ret_len=strlen(entry->ipStaticRouteSrcIpAddr);
+      return entry->ipStaticRouteSrcIpAddr; /** XXX: replace this with a pointer to a real value */
+      }
+/** XXX: Set the value of the ipStaticRouteSrcIpAddr column and return
+         SNMP_ERR_NOERROR on success
+         SNMP_ERR_XXX     for SNMP deterministic error codes
+         SNMP_ERR_GENERR  on generic failures (a last result response). */
+      int set_ipStaticRouteSrcIpAddr(void *data_context, char *val, size_t val_len) {
+       struct ipStaticRouteTable_entry *entry=(struct ipStaticRouteTable_entry *)data_context;
+	   char buf[17];
+	   memcpy(buf,val,val_len);
+	buf[val_len]='\0';
+	handleOfSetParameterSpecForTable(InternetGatewayDevice_Layer3Forwarding_Forwarding_(entry->ipStaticRouteIndex),
+		"SourceIPAddress", buf);
+        return SNMP_ERR_NOERROR;  /** XXX: change if an error occurs */
+      }
+/** XXX: return a data pointer to the data for the ipStaticRouteSrcSubnetMask column and set
+         ret_len to its proper size in bytes. */
+      char *get_ipStaticRouteSrcSubnetMask(void *data_context, size_t *ret_len) {
+     struct ipStaticRouteTable_entry *entry=(struct ipStaticRouteTable_entry *)data_context;
+	  *ret_len=strlen(entry->ipStaticRouteSrcSubnetMask);
+      return entry->ipStaticRouteSrcSubnetMask; /** XXX: replace this with a pointer to a real value */
+      }
+/** XXX: Set the value of the ipStaticRouteSrcSubnetMask column and return
+         SNMP_ERR_NOERROR on success
+         SNMP_ERR_XXX     for SNMP deterministic error codes
+         SNMP_ERR_GENERR  on generic failures (a last result response). */
+      int set_ipStaticRouteSrcSubnetMask(void *data_context, char *val, size_t val_len) {
+       struct ipStaticRouteTable_entry *entry=(struct ipStaticRouteTable_entry *)data_context;
+	   char buf[17];
+	   memcpy(buf,val,val_len);
+	buf[val_len]='\0';
+	handleOfSetParameterSpecForTable(InternetGatewayDevice_Layer3Forwarding_Forwarding_(entry->ipStaticRouteIndex),
+		"SourceSubnetMask", buf);
+        return SNMP_ERR_NOERROR;  /** XXX: change if an error occurs */
+      }
+/** XXX: return a data pointer to the data for the ipStaticRouteGatewayIpAddr column and set
+         ret_len to its proper size in bytes. */
+      char *get_ipStaticRouteGatewayIpAddr(void *data_context, size_t *ret_len) {
+     struct ipStaticRouteTable_entry *entry=(struct ipStaticRouteTable_entry *)data_context;
+	  *ret_len=strlen(entry->ipStaticRouteGatewayIpAddr);
+      return entry->ipStaticRouteGatewayIpAddr; /** XXX: replace this with a pointer to a real value */
+      }
+/** XXX: Set the value of the ipStaticRouteGatewayIpAddr column and return
+         SNMP_ERR_NOERROR on success
+         SNMP_ERR_XXX     for SNMP deterministic error codes
+         SNMP_ERR_GENERR  on generic failures (a last result response). */
+      int set_ipStaticRouteGatewayIpAddr(void *data_context, char *val, size_t val_len) {
+       struct ipStaticRouteTable_entry *entry=(struct ipStaticRouteTable_entry *)data_context;
+	   char buf[17];
+	   memcpy(buf,val,val_len);
+	buf[val_len]='\0';
+	handleOfSetParameterSpecForTable(InternetGatewayDevice_Layer3Forwarding_Forwarding_(entry->ipStaticRouteIndex),
+		"GatewayIPAddress", buf);
+        return SNMP_ERR_NOERROR;  /** XXX: change if an error occurs */
+      }
+/** XXX: return a data pointer to the data for the ipStaticRouteInterface column and set
+         ret_len to its proper size in bytes. */
+      char *get_ipStaticRouteInterface(void *data_context, size_t *ret_len) {
+      struct ipStaticRouteTable_entry *entry=(struct ipStaticRouteTable_entry *)data_context;
+	  *ret_len=strlen(entry->ipStaticRouteInterface);
+      return entry->ipStaticRouteInterface; /** XXX: replace this with a pointer to a real value */
+      }
+/** XXX: return a data pointer to the data for the ipStaticRouteForwardingPolicy column and set
+         ret_len to its proper size in bytes. */
+      long *get_ipStaticRouteForwardingPolicy(void *data_context, size_t *ret_len) {
+      struct ipStaticRouteTable_entry *entry=(struct ipStaticRouteTable_entry *)data_context;
+	  *ret_len=sizeof(long_ret);;
+	  long_ret=entry->ipStaticRouteForwardingPolicy;
+      return &long_ret; /** XXX: replace this with a pointer to a real value */
+      }
+/** XXX: return a data pointer to the data for the ipStaticRouteMTU column and set
+         ret_len to its proper size in bytes. */
+      long *get_ipStaticRouteMTU(void *data_context, size_t *ret_len) {
+      struct ipStaticRouteTable_entry *entry=(struct ipStaticRouteTable_entry *)data_context;
+	  long_ret=entry->ipStaticRouteMTU;
+	  *ret_len=sizeof(long_ret);
+      return &long_ret; /** XXX: replace this with a pointer to a real value */
+      }
+/** XXX: return a data pointer to the data for the ipStaticRouteMetric column and set
+         ret_len to its proper size in bytes. */
+      long *get_ipStaticRouteMetric(void *data_context, size_t *ret_len) {
+     struct ipStaticRouteTable_entry *entry=(struct ipStaticRouteTable_entry *)data_context;
+	 long_ret=entry->ipStaticRouteMetric;
+	  *ret_len=sizeof(long_ret);
+      return &long_ret; /** XXX: replace this with a pointer to a real value */
+      }
+/** XXX: Set the value of the ipStaticRouteMetric column and return
+         SNMP_ERR_NOERROR on success
+         SNMP_ERR_XXX     for SNMP deterministic error codes
+         SNMP_ERR_GENERR  on generic failures (a last result response). */
+      int set_ipStaticRouteMetric(void *data_context, long *val, size_t val_len) {
+       struct ipStaticRouteTable_entry *entry=(struct ipStaticRouteTable_entry *)data_context;
+	   long buf;
+	   memcpy(&buf,val,val_len);
+
+	handleOfSetParameterSpecForTable(InternetGatewayDevice_Layer3Forwarding_Forwarding_(entry->ipStaticRouteIndex),
+		"ForwardingMetric", &buf);
+        return SNMP_ERR_NOERROR;  /** XXX: change if an error occurs */
+      }
+/** XXX: return a data pointer to the data for the ipStaticRouteStaticRoute column and set
+         ret_len to its proper size in bytes. */
+      long *get_ipStaticRouteStaticRoute(void *data_context, size_t *ret_len) {
+      struct ipStaticRouteTable_entry *entry=(struct ipStaticRouteTable_entry *)data_context;
+	  long_ret=entry->ipStaticRouteStaticRoute;
+	  *ret_len=sizeof(long_ret);
+      return &long_ret; /** XXX: replace this with a pointer to a real value */
+      }
+/** XXX: Set the value of the ipStaticRouteStaticRoute column and return
+         SNMP_ERR_NOERROR on success
+         SNMP_ERR_XXX     for SNMP deterministic error codes
+         SNMP_ERR_GENERR  on generic failures (a last result response). */
+      int set_ipStaticRouteStaticRoute(void *data_context, long *val, size_t val_len) {
+       struct ipStaticRouteTable_entry *entry=(struct ipStaticRouteTable_entry *)data_context;
+	   long buf;
+	   memcpy(&buf,val,val_len);
+	
+	handleOfSetParameterSpecForTable(InternetGatewayDevice_Layer3Forwarding_Forwarding_(entry->ipStaticRouteIndex),
+		"StaticRoute", &buf);
+        return SNMP_ERR_NOERROR;  /** XXX: change if an error occurs */
+      }
+/** XXX: return a data pointer to the data for the ipStaticRouteEnable column and set
+         ret_len to its proper size in bytes. */
+      long *get_ipStaticRouteEnable(void *data_context, size_t *ret_len) {
+     struct ipStaticRouteTable_entry *entry=(struct ipStaticRouteTable_entry *)data_context;
+	 long_ret=entry->ipStaticRouteEnable;
+	  *ret_len=sizeof(long_ret);
+      return &long_ret; /** XXX: replace this with a pointer to a real value */
+      }
+/** XXX: Set the value of the ipStaticRouteEnable column and return
+         SNMP_ERR_NOERROR on success
+         SNMP_ERR_XXX     for SNMP deterministic error codes
+         SNMP_ERR_GENERR  on generic failures (a last result response). */
+      int set_ipStaticRouteEnable(void *data_context, long *val, size_t val_len) {
+       struct ipStaticRouteTable_entry *entry=(struct ipStaticRouteTable_entry *)data_context;
+	   long buf;
+	   memcpy(&buf,val,val_len);
+
+	handleOfSetParameterSpecForTable(InternetGatewayDevice_Layer3Forwarding_Forwarding_(entry->ipStaticRouteIndex),
+		"Enable", &buf);
+        return SNMP_ERR_NOERROR;  /** XXX: change if an error occurs */
+      }
+    
+
diff -Naur net-snmp-5.7.2-orig/agent/mibgroup/ZYXEL-PRESTIGE-MIB/ipStaticRouteTable_access.h net-snmp-5.7.2/agent/mibgroup/ZYXEL-PRESTIGE-MIB/ipStaticRouteTable_access.h
--- net-snmp-5.7.2-orig/agent/mibgroup/ZYXEL-PRESTIGE-MIB/ipStaticRouteTable_access.h	1970-01-01 08:00:00.000000000 +0800
+++ net-snmp-5.7.2/agent/mibgroup/ZYXEL-PRESTIGE-MIB/ipStaticRouteTable_access.h	2013-10-08 09:35:17.626117000 +0800
@@ -0,0 +1,42 @@
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *        : mib2c.access_functions.conf 11358 2004-10-14 12:57:34Z dts12 $
+ */
+#ifndef IPSTATICROUTETABLE_ACCESS_H
+#define IPSTATICROUTETABLE_ACCESS_H
+
+/** User-defined data access functions for data in table ipStaticRouteTable */
+/** row level accessors */
+Netsnmp_First_Data_Point  ipStaticRouteTable_get_first_data_point;
+Netsnmp_Next_Data_Point   ipStaticRouteTable_get_next_data_point;
+int ipStaticRouteTable_commit_row(void **my_data_context, int new_or_del);
+void * ipStaticRouteTable_create_data_context(netsnmp_variable_list *index_data, int column);
+
+/** column accessors */
+      long *get_ipStaticRouteIndex(void *data_context, size_t *ret_len);
+      char *get_ipStaticRouteName(void *data_context, size_t *ret_len);
+      int set_ipStaticRouteName(void *data_context, char *val, size_t val_len);
+      char *get_ipStaticRouteStatus(void *data_context, size_t *ret_len);
+      int set_ipStaticRouteStatus(void *data_context, char *val, size_t val_len);
+      char *get_ipStaticRouteType(void *data_context, size_t *ret_len);
+      char *get_ipStaticRouteDestIpAddr(void *data_context, size_t *ret_len);
+      int set_ipStaticRouteDestIpAddr(void *data_context, char *val, size_t val_len);
+      char *get_ipStaticRouteDestSubnetMask(void *data_context, size_t *ret_len);
+      int set_ipStaticRouteDestSubnetMask(void *data_context, char *val, size_t val_len);
+      char *get_ipStaticRouteSrcIpAddr(void *data_context, size_t *ret_len);
+      int set_ipStaticRouteSrcIpAddr(void *data_context, char *val, size_t val_len);
+      char *get_ipStaticRouteSrcSubnetMask(void *data_context, size_t *ret_len);
+      int set_ipStaticRouteSrcSubnetMask(void *data_context, char *val, size_t val_len);
+      char *get_ipStaticRouteGatewayIpAddr(void *data_context, size_t *ret_len);
+      int set_ipStaticRouteGatewayIpAddr(void *data_context, char *val, size_t val_len);
+      char *get_ipStaticRouteInterface(void *data_context, size_t *ret_len);
+      long *get_ipStaticRouteForwardingPolicy(void *data_context, size_t *ret_len);
+      long *get_ipStaticRouteMTU(void *data_context, size_t *ret_len);
+      long *get_ipStaticRouteMetric(void *data_context, size_t *ret_len);
+      int set_ipStaticRouteMetric(void *data_context, long *val, size_t val_len);
+      long *get_ipStaticRouteStaticRoute(void *data_context, size_t *ret_len);
+      int set_ipStaticRouteStaticRoute(void *data_context, long *val, size_t val_len);
+      long *get_ipStaticRouteEnable(void *data_context, size_t *ret_len);
+      int set_ipStaticRouteEnable(void *data_context, long *val, size_t val_len);
+
+#endif /* IPSTATICROUTETABLE_ACCESS_H */
diff -Naur net-snmp-5.7.2-orig/agent/mibgroup/ZYXEL-PRESTIGE-MIB/ipStaticRouteTable.c net-snmp-5.7.2/agent/mibgroup/ZYXEL-PRESTIGE-MIB/ipStaticRouteTable.c
--- net-snmp-5.7.2-orig/agent/mibgroup/ZYXEL-PRESTIGE-MIB/ipStaticRouteTable.c	1970-01-01 08:00:00.000000000 +0800
+++ net-snmp-5.7.2/agent/mibgroup/ZYXEL-PRESTIGE-MIB/ipStaticRouteTable.c	2013-10-08 09:35:17.626117000 +0800
@@ -0,0 +1,1067 @@
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *        : mib2c.iterate_access.conf 15179 2006-09-08 15:44:37Z dts12 $
+ */
+
+#include <net-snmp/net-snmp-config.h>
+#include <net-snmp/net-snmp-includes.h>
+#include <net-snmp/agent/net-snmp-agent-includes.h>
+#include "ipStaticRouteTable.h"
+#include "ipStaticRouteTable_checkfns.h"
+#include "ipStaticRouteTable_access.h"
+
+static netsnmp_oid_stash_node *undoStorage = NULL;
+static netsnmp_oid_stash_node *commitStorage = NULL;
+
+struct undoInfo {
+   void *ptr;
+   size_t len;
+};
+
+struct commitInfo {
+   void *data_context;
+   int have_committed;
+   int new_row;
+};
+
+void
+ipStaticRouteTable_free_undoInfo(void *vptr) {
+    struct undoInfo *ui = vptr;
+    if (!ui)
+        return;
+    SNMP_FREE(ui->ptr);
+    SNMP_FREE(ui);
+}
+
+/** Initialize the ipStaticRouteTable table by defining its contents and how it's structured */
+void
+initialize_table_ipStaticRouteTable(void)
+{
+    static oid ipStaticRouteTable_oid[] = {1,3,6,1,4,1,890,1,2,1,4,1};
+    netsnmp_table_registration_info *table_info;
+    netsnmp_handler_registration *my_handler;
+    netsnmp_iterator_info *iinfo;
+
+    /** create the table registration information structures */
+    table_info = SNMP_MALLOC_TYPEDEF(netsnmp_table_registration_info);
+    iinfo = SNMP_MALLOC_TYPEDEF(netsnmp_iterator_info);
+
+    my_handler = netsnmp_create_handler_registration("ipStaticRouteTable",
+                                             ipStaticRouteTable_handler,
+                                             ipStaticRouteTable_oid,
+                                             OID_LENGTH(ipStaticRouteTable_oid),
+                                             HANDLER_CAN_RWRITE
+                                             );
+            
+    if (!my_handler || !table_info || !iinfo) {
+        snmp_log(LOG_ERR, "malloc failed in initialize_table_ipStaticRouteTable");
+        return; /** Serious error. */
+    }
+
+    /***************************************************
+     * Setting up the table's definition
+     */
+    netsnmp_table_helper_add_indexes(table_info,
+                                  ASN_INTEGER, /** index: ipStaticRouteIndex */
+                             0);
+
+    /** Define the minimum and maximum accessible columns.  This
+        optimizes retrival. */
+    table_info->min_column = 1;
+    table_info->max_column = 15;
+
+    /** iterator access routines */
+    iinfo->get_first_data_point = ipStaticRouteTable_get_first_data_point;
+    iinfo->get_next_data_point = ipStaticRouteTable_get_next_data_point;
+
+    /** you may wish to set these as well */
+#ifdef MAYBE_USE_THESE
+    iinfo->make_data_context = ipStaticRouteTable_context_convert_function;
+    iinfo->free_data_context = ipStaticRouteTable_data_free;
+
+    /** pick *only* one of these if you use them */
+    iinfo->free_loop_context = ipStaticRouteTable_loop_free;
+    iinfo->free_loop_context_at_end = ipStaticRouteTable_loop_free;
+#endif
+
+    /** tie the two structures together */
+    iinfo->table_reginfo = table_info;
+
+    /***************************************************
+     * registering the table with the master agent
+     */
+    DEBUGMSGTL(("initialize_table_ipStaticRouteTable",
+                "Registering table ipStaticRouteTable as a table iterator\n"));		 
+    netsnmp_register_table_iterator(my_handler, iinfo);
+}
+
+/** Initializes the ipStaticRouteTable module */
+void
+init_ipStaticRouteTable(void)
+{
+
+  /** here we initialize all the tables we're planning on supporting */
+    initialize_table_ipStaticRouteTable();
+}
+
+/** handles requests for the ipStaticRouteTable table, if anything else needs to be done */
+int
+ipStaticRouteTable_handler(
+    netsnmp_mib_handler               *handler,
+    netsnmp_handler_registration      *reginfo,
+    netsnmp_agent_request_info        *reqinfo,
+    netsnmp_request_info              *requests) {
+
+    netsnmp_request_info *request;
+    netsnmp_table_request_info *table_info;
+    netsnmp_variable_list *var;
+    struct commitInfo *ci = NULL;
+
+    void *data_context = NULL;
+
+    oid *suffix;
+    size_t suffix_len;
+
+    /** column and row index encoded portion */
+    suffix = requests->requestvb->name + reginfo->rootoid_len + 1;
+    suffix_len = requests->requestvb->name_length -
+        (reginfo->rootoid_len + 1);
+    
+    for(request = requests; request; request = request->next) {
+        var = request->requestvb;
+        if (request->processed != 0)
+            continue;
+
+        switch (reqinfo->mode) {
+        case MODE_GET:
+            data_context =  netsnmp_extract_iterator_context(request);
+            if (data_context == NULL) {
+                netsnmp_set_request_error(reqinfo, request,
+                                          SNMP_NOSUCHINSTANCE);
+                continue;
+            }
+            break;
+
+        case MODE_SET_RESERVE1:
+            data_context =  netsnmp_extract_iterator_context(request);
+            if (data_context == NULL) {
+                netsnmp_set_request_error(reqinfo, request,
+                                          SNMP_ERR_NOCREATION);
+                continue;
+            }
+            break;
+
+        default: /* == the other SET modes */
+            ci = netsnmp_oid_stash_get_data(commitStorage,
+                                            suffix+1, suffix_len-1);
+            break;
+        }
+
+        /** extracts the information about the table from the request */
+        table_info = netsnmp_extract_table_info(request);
+        /** table_info->colnum contains the column number requested */
+        /** table_info->indexes contains a linked list of snmp variable
+           bindings for the indexes of the table.  Values in the list
+           have been set corresponding to the indexes of the
+           request */
+        if (table_info == NULL) {
+            continue;
+        }
+
+        switch(reqinfo->mode) {
+            case MODE_GET:
+                switch(table_info->colnum) {
+                    case COLUMN_IPSTATICROUTEINDEX:
+                            {
+                                long *retval;
+                                size_t retval_len = 0;
+                                retval = get_ipStaticRouteIndex(data_context, &retval_len);
+                                if (retval)
+                                    snmp_set_var_typed_value(var, ASN_INTEGER,
+                                                         (const u_char *) retval,
+                                                         retval_len);
+                            }
+                        break;
+
+                    case COLUMN_IPSTATICROUTENAME:
+                            {
+                                char *retval;
+                                size_t retval_len = 0;
+                                retval = get_ipStaticRouteName(data_context, &retval_len);
+                                if (retval)
+                                    snmp_set_var_typed_value(var, ASN_OCTET_STR,
+                                                         (const u_char *) retval,
+                                                         retval_len);
+                            }
+                        break;
+
+                    case COLUMN_IPSTATICROUTESTATUS:
+                            {
+                                char *retval;
+                                size_t retval_len = 0;
+                                retval = get_ipStaticRouteStatus(data_context, &retval_len);
+                                if (retval)
+                                    snmp_set_var_typed_value(var, ASN_OCTET_STR,
+                                                         (const u_char *) retval,
+                                                         retval_len);
+                            }
+                        break;
+
+                    case COLUMN_IPSTATICROUTETYPE:
+                            {
+                                char *retval;
+                                size_t retval_len = 0;
+                                retval = get_ipStaticRouteType(data_context, &retval_len);
+                                if (retval)
+                                    snmp_set_var_typed_value(var, ASN_OCTET_STR,
+                                                         (const u_char *) retval,
+                                                         retval_len);
+                            }
+                        break;
+
+                    case COLUMN_IPSTATICROUTEDESTIPADDR:
+                            {
+                                char *retval;
+                                size_t retval_len = 0;
+                                retval = get_ipStaticRouteDestIpAddr(data_context, &retval_len);
+                                if (retval)
+                                    snmp_set_var_typed_value(var, ASN_OCTET_STR,
+                                                         (const u_char *) retval,
+                                                         retval_len);
+                            }
+                        break;
+
+                    case COLUMN_IPSTATICROUTEDESTSUBNETMASK:
+                            {
+                                char *retval;
+                                size_t retval_len = 0;
+                                retval = get_ipStaticRouteDestSubnetMask(data_context, &retval_len);
+                                if (retval)
+                                    snmp_set_var_typed_value(var, ASN_OCTET_STR,
+                                                         (const u_char *) retval,
+                                                         retval_len);
+                            }
+                        break;
+
+                    case COLUMN_IPSTATICROUTESRCIPADDR:
+                            {
+                                char *retval;
+                                size_t retval_len = 0;
+                                retval = get_ipStaticRouteSrcIpAddr(data_context, &retval_len);
+                                if (retval)
+                                    snmp_set_var_typed_value(var, ASN_OCTET_STR,
+                                                         (const u_char *) retval,
+                                                         retval_len);
+                            }
+                        break;
+
+                    case COLUMN_IPSTATICROUTESRCSUBNETMASK:
+                            {
+                                char *retval;
+                                size_t retval_len = 0;
+                                retval = get_ipStaticRouteSrcSubnetMask(data_context, &retval_len);
+                                if (retval)
+                                    snmp_set_var_typed_value(var, ASN_OCTET_STR,
+                                                         (const u_char *) retval,
+                                                         retval_len);
+                            }
+                        break;
+
+                    case COLUMN_IPSTATICROUTEGATEWAYIPADDR:
+                            {
+                                char *retval;
+                                size_t retval_len = 0;
+                                retval = get_ipStaticRouteGatewayIpAddr(data_context, &retval_len);
+                                if (retval)
+                                    snmp_set_var_typed_value(var, ASN_OCTET_STR,
+                                                         (const u_char *) retval,
+                                                         retval_len);
+                            }
+                        break;
+
+                    case COLUMN_IPSTATICROUTEINTERFACE:
+                            {
+                                char *retval;
+                                size_t retval_len = 0;
+                                retval = get_ipStaticRouteInterface(data_context, &retval_len);
+                                if (retval)
+                                    snmp_set_var_typed_value(var, ASN_OCTET_STR,
+                                                         (const u_char *) retval,
+                                                         retval_len);
+                            }
+                        break;
+
+                    case COLUMN_IPSTATICROUTEFORWARDINGPOLICY:
+                            {
+                                long *retval;
+                                size_t retval_len = 0;
+                                retval = get_ipStaticRouteForwardingPolicy(data_context, &retval_len);
+                                if (retval)
+                                    snmp_set_var_typed_value(var, ASN_INTEGER,
+                                                         (const u_char *) retval,
+                                                         retval_len);
+                            }
+                        break;
+
+                    case COLUMN_IPSTATICROUTEMTU:
+                            {
+                                long *retval;
+                                size_t retval_len = 0;
+                                retval = get_ipStaticRouteMTU(data_context, &retval_len);
+                                if (retval)
+                                    snmp_set_var_typed_value(var, ASN_INTEGER,
+                                                         (const u_char *) retval,
+                                                         retval_len);
+                            }
+                        break;
+
+                    case COLUMN_IPSTATICROUTEMETRIC:
+                            {
+                                long *retval;
+                                size_t retval_len = 0;
+                                retval = get_ipStaticRouteMetric(data_context, &retval_len);
+                                if (retval)
+                                    snmp_set_var_typed_value(var, ASN_INTEGER,
+                                                         (const u_char *) retval,
+                                                         retval_len);
+                            }
+                        break;
+
+                    case COLUMN_IPSTATICROUTESTATICROUTE:
+                            {
+                                long *retval;
+                                size_t retval_len = 0;
+                                retval = get_ipStaticRouteStaticRoute(data_context, &retval_len);
+                                if (retval)
+                                    snmp_set_var_typed_value(var, ASN_INTEGER,
+                                                         (const u_char *) retval,
+                                                         retval_len);
+                            }
+                        break;
+
+                    case COLUMN_IPSTATICROUTEENABLE:
+                            {
+                                long *retval;
+                                size_t retval_len = 0;
+                                retval = get_ipStaticRouteEnable(data_context, &retval_len);
+                                if (retval)
+                                    snmp_set_var_typed_value(var, ASN_INTEGER,
+                                                         (const u_char *) retval,
+                                                         retval_len);
+                            }
+                        break;
+
+                    default:
+                /** We shouldn't get here */
+                        snmp_log(LOG_ERR, "problem encountered in ipStaticRouteTable_handler: unknown column\n");
+                }
+                break;
+
+            case MODE_SET_RESERVE1:
+                ci = netsnmp_oid_stash_get_data(commitStorage,
+                                                suffix+1, suffix_len-1);
+                
+                if (!ci) {
+                    /** create the commit storage info */
+                    ci = SNMP_MALLOC_STRUCT(commitInfo);
+                    if (!data_context) {
+                        //ci->data_context = ipStaticRouteTable_create_data_context(table_info->indexes, COLUMN_):
+                        ci->new_row = 1;
+			ci->data_context=data_context;
+                    } else {
+                        ci->data_context = data_context;
+                    }
+                    netsnmp_oid_stash_add_data(&commitStorage,
+                                               suffix+1, suffix_len-1, ci);
+                }
+            break;
+                
+            case MODE_SET_RESERVE2:
+                switch(table_info->colnum) {
+                          case COLUMN_IPSTATICROUTENAME:
+                            {
+                                char *retval;
+                                size_t retval_len = 0;
+                                struct undoInfo *ui = NULL;
+                                int ret;
+                                
+                    /** first, get the old value */
+                                retval = get_ipStaticRouteName(ci->data_context, &retval_len);
+                                if (retval) {
+                                    ui = SNMP_MALLOC_STRUCT(undoInfo);
+                                    ui->len = retval_len;
+                                    memdup((u_char **) &ui->ptr,
+                                           (u_char *) retval,
+                                           ui->len);
+                                }
+
+                    /** check the new value, possibly against the
+                        older value for a valid state transition */
+                                ret = check_ipStaticRouteName(request->requestvb->type,
+                                                   (char *) request->requestvb->val.string,
+                                                   request->requestvb->val_len,
+                                                   retval, retval_len);
+                                if (ret != 0) {
+                                    netsnmp_set_request_error(reqinfo, request,
+                                                              ret);
+                                    ipStaticRouteTable_free_undoInfo(ui);
+                                } else if (ui) {
+                        /** remember information for undo purposes later */
+                                    netsnmp_oid_stash_add_data(&undoStorage,
+                                                               suffix,
+                                                               suffix_len,
+                                                               ui);
+                                }
+                                
+                            }
+                            break;
+                          case COLUMN_IPSTATICROUTESTATUS:
+                            {
+                                char *retval;
+                                size_t retval_len = 0;
+                                struct undoInfo *ui = NULL;
+                                int ret;
+                                
+                    /** first, get the old value */
+                                retval = get_ipStaticRouteStatus(ci->data_context, &retval_len);
+                                if (retval) {
+                                    ui = SNMP_MALLOC_STRUCT(undoInfo);
+                                    ui->len = retval_len;
+                                    memdup((u_char **) &ui->ptr,
+                                           (u_char *) retval,
+                                           ui->len);
+                                }
+
+                    /** check the new value, possibly against the
+                        older value for a valid state transition */
+                                ret = check_ipStaticRouteStatus(request->requestvb->type,
+                                                   (char *) request->requestvb->val.string,
+                                                   request->requestvb->val_len,
+                                                   retval, retval_len);
+                                if (ret != 0) {
+                                    netsnmp_set_request_error(reqinfo, request,
+                                                              ret);
+                                    ipStaticRouteTable_free_undoInfo(ui);
+                                } else if (ui) {
+                        /** remember information for undo purposes later */
+                                    netsnmp_oid_stash_add_data(&undoStorage,
+                                                               suffix,
+                                                               suffix_len,
+                                                               ui);
+                                }
+                                
+                            }
+                            break;
+                          case COLUMN_IPSTATICROUTEDESTIPADDR:
+                            {
+                                char *retval;
+                                size_t retval_len = 0;
+                                struct undoInfo *ui = NULL;
+                                int ret;
+                                
+                    /** first, get the old value */
+                                retval = get_ipStaticRouteDestIpAddr(ci->data_context, &retval_len);
+                                if (retval) {
+                                    ui = SNMP_MALLOC_STRUCT(undoInfo);
+                                    ui->len = retval_len;
+                                    memdup((u_char **) &ui->ptr,
+                                           (u_char *) retval,
+                                           ui->len);
+                                }
+
+                    /** check the new value, possibly against the
+                        older value for a valid state transition */
+                                ret = check_ipStaticRouteDestIpAddr(request->requestvb->type,
+                                                   (char *) request->requestvb->val.string,
+                                                   request->requestvb->val_len,
+                                                   retval, retval_len);
+                                if (ret != 0) {
+                                    netsnmp_set_request_error(reqinfo, request,
+                                                              ret);
+                                    ipStaticRouteTable_free_undoInfo(ui);
+                                } else if (ui) {
+                        /** remember information for undo purposes later */
+                                    netsnmp_oid_stash_add_data(&undoStorage,
+                                                               suffix,
+                                                               suffix_len,
+                                                               ui);
+                                }
+                                
+                            }
+                            break;
+                          case COLUMN_IPSTATICROUTEDESTSUBNETMASK:
+                            {
+                                char *retval;
+                                size_t retval_len = 0;
+                                struct undoInfo *ui = NULL;
+                                int ret;
+                                
+                    /** first, get the old value */
+                                retval = get_ipStaticRouteDestSubnetMask(ci->data_context, &retval_len);
+                                if (retval) {
+                                    ui = SNMP_MALLOC_STRUCT(undoInfo);
+                                    ui->len = retval_len;
+                                    memdup((u_char **) &ui->ptr,
+                                           (u_char *) retval,
+                                           ui->len);
+                                }
+
+                    /** check the new value, possibly against the
+                        older value for a valid state transition */
+                                ret = check_ipStaticRouteDestSubnetMask(request->requestvb->type,
+                                                   (char *) request->requestvb->val.string,
+                                                   request->requestvb->val_len,
+                                                   retval, retval_len);
+                                if (ret != 0) {
+                                    netsnmp_set_request_error(reqinfo, request,
+                                                              ret);
+                                    ipStaticRouteTable_free_undoInfo(ui);
+                                } else if (ui) {
+                        /** remember information for undo purposes later */
+                                    netsnmp_oid_stash_add_data(&undoStorage,
+                                                               suffix,
+                                                               suffix_len,
+                                                               ui);
+                                }
+                                
+                            }
+                            break;
+                          case COLUMN_IPSTATICROUTESRCIPADDR:
+                            {
+                                char *retval;
+                                size_t retval_len = 0;
+                                struct undoInfo *ui = NULL;
+                                int ret;
+                                
+                    /** first, get the old value */
+                                retval = get_ipStaticRouteSrcIpAddr(ci->data_context, &retval_len);
+                                if (retval) {
+                                    ui = SNMP_MALLOC_STRUCT(undoInfo);
+                                    ui->len = retval_len;
+                                    memdup((u_char **) &ui->ptr,
+                                           (u_char *) retval,
+                                           ui->len);
+                                }
+
+                    /** check the new value, possibly against the
+                        older value for a valid state transition */
+                                ret = check_ipStaticRouteSrcIpAddr(request->requestvb->type,
+                                                   (char *) request->requestvb->val.string,
+                                                   request->requestvb->val_len,
+                                                   retval, retval_len);
+                                if (ret != 0) {
+                                    netsnmp_set_request_error(reqinfo, request,
+                                                              ret);
+                                    ipStaticRouteTable_free_undoInfo(ui);
+                                } else if (ui) {
+                        /** remember information for undo purposes later */
+                                    netsnmp_oid_stash_add_data(&undoStorage,
+                                                               suffix,
+                                                               suffix_len,
+                                                               ui);
+                                }
+                                
+                            }
+                            break;
+                          case COLUMN_IPSTATICROUTESRCSUBNETMASK:
+                            {
+                                char *retval;
+                                size_t retval_len = 0;
+                                struct undoInfo *ui = NULL;
+                                int ret;
+                                
+                    /** first, get the old value */
+                                retval = get_ipStaticRouteSrcSubnetMask(ci->data_context, &retval_len);
+                                if (retval) {
+                                    ui = SNMP_MALLOC_STRUCT(undoInfo);
+                                    ui->len = retval_len;
+                                    memdup((u_char **) &ui->ptr,
+                                           (u_char *) retval,
+                                           ui->len);
+                                }
+
+                    /** check the new value, possibly against the
+                        older value for a valid state transition */
+                                ret = check_ipStaticRouteSrcSubnetMask(request->requestvb->type,
+                                                   (char *) request->requestvb->val.string,
+                                                   request->requestvb->val_len,
+                                                   retval, retval_len);
+                                if (ret != 0) {
+                                    netsnmp_set_request_error(reqinfo, request,
+                                                              ret);
+                                    ipStaticRouteTable_free_undoInfo(ui);
+                                } else if (ui) {
+                        /** remember information for undo purposes later */
+                                    netsnmp_oid_stash_add_data(&undoStorage,
+                                                               suffix,
+                                                               suffix_len,
+                                                               ui);
+                                }
+                                
+                            }
+                            break;
+                          case COLUMN_IPSTATICROUTEGATEWAYIPADDR:
+                            {
+                                char *retval;
+                                size_t retval_len = 0;
+                                struct undoInfo *ui = NULL;
+                                int ret;
+                                
+                    /** first, get the old value */
+                                retval = get_ipStaticRouteGatewayIpAddr(ci->data_context, &retval_len);
+                                if (retval) {
+                                    ui = SNMP_MALLOC_STRUCT(undoInfo);
+                                    ui->len = retval_len;
+                                    memdup((u_char **) &ui->ptr,
+                                           (u_char *) retval,
+                                           ui->len);
+                                }
+
+                    /** check the new value, possibly against the
+                        older value for a valid state transition */
+                                ret = check_ipStaticRouteGatewayIpAddr(request->requestvb->type,
+                                                   (char *) request->requestvb->val.string,
+                                                   request->requestvb->val_len,
+                                                   retval, retval_len);
+                                if (ret != 0) {
+                                    netsnmp_set_request_error(reqinfo, request,
+                                                              ret);
+                                    ipStaticRouteTable_free_undoInfo(ui);
+                                } else if (ui) {
+                        /** remember information for undo purposes later */
+                                    netsnmp_oid_stash_add_data(&undoStorage,
+                                                               suffix,
+                                                               suffix_len,
+                                                               ui);
+                                }
+                                
+                            }
+                            break;
+                          case COLUMN_IPSTATICROUTEMETRIC:
+                            {
+                                long *retval;
+                                size_t retval_len = 0;
+                                struct undoInfo *ui = NULL;
+                                int ret;
+                                
+                    /** first, get the old value */
+                                retval = get_ipStaticRouteMetric(ci->data_context, &retval_len);
+                                if (retval) {
+                                    ui = SNMP_MALLOC_STRUCT(undoInfo);
+                                    ui->len = retval_len;
+                                    memdup((u_char **) &ui->ptr,
+                                           (u_char *) retval,
+                                           ui->len);
+                                }
+
+                    /** check the new value, possibly against the
+                        older value for a valid state transition */
+                                ret = check_ipStaticRouteMetric(request->requestvb->type,
+                                                   (long *) request->requestvb->val.string,
+                                                   request->requestvb->val_len,
+                                                   retval, retval_len);
+                                if (ret != 0) {
+                                    netsnmp_set_request_error(reqinfo, request,
+                                                              ret);
+                                    ipStaticRouteTable_free_undoInfo(ui);
+                                } else if (ui) {
+                        /** remember information for undo purposes later */
+                                    netsnmp_oid_stash_add_data(&undoStorage,
+                                                               suffix,
+                                                               suffix_len,
+                                                               ui);
+                                }
+                                
+                            }
+                            break;
+                          case COLUMN_IPSTATICROUTESTATICROUTE:
+                            {
+                                long *retval;
+                                size_t retval_len = 0;
+                                struct undoInfo *ui = NULL;
+                                int ret;
+                                
+                    /** first, get the old value */
+                                retval = get_ipStaticRouteStaticRoute(ci->data_context, &retval_len);
+                                if (retval) {
+                                    ui = SNMP_MALLOC_STRUCT(undoInfo);
+                                    ui->len = retval_len;
+                                    memdup((u_char **) &ui->ptr,
+                                           (u_char *) retval,
+                                           ui->len);
+                                }
+
+                    /** check the new value, possibly against the
+                        older value for a valid state transition */
+                                ret = check_ipStaticRouteStaticRoute(request->requestvb->type,
+                                                   (long *) request->requestvb->val.string,
+                                                   request->requestvb->val_len,
+                                                   retval, retval_len);
+                                if (ret != 0) {
+                                    netsnmp_set_request_error(reqinfo, request,
+                                                              ret);
+                                    ipStaticRouteTable_free_undoInfo(ui);
+                                } else if (ui) {
+                        /** remember information for undo purposes later */
+                                    netsnmp_oid_stash_add_data(&undoStorage,
+                                                               suffix,
+                                                               suffix_len,
+                                                               ui);
+                                }
+                                
+                            }
+                            break;
+                          case COLUMN_IPSTATICROUTEENABLE:
+                            {
+                                long *retval;
+                                size_t retval_len = 0;
+                                struct undoInfo *ui = NULL;
+                                int ret;
+                                
+                    /** first, get the old value */
+                                retval = get_ipStaticRouteEnable(ci->data_context, &retval_len);
+                                if (retval) {
+                                    ui = SNMP_MALLOC_STRUCT(undoInfo);
+                                    ui->len = retval_len;
+                                    memdup((u_char **) &ui->ptr,
+                                           (u_char *) retval,
+                                           ui->len);
+                                }
+
+                    /** check the new value, possibly against the
+                        older value for a valid state transition */
+                                ret = check_ipStaticRouteEnable(request->requestvb->type,
+                                                   (long *) request->requestvb->val.string,
+                                                   request->requestvb->val_len,
+                                                   retval, retval_len);
+                                if (ret != 0) {
+                                    netsnmp_set_request_error(reqinfo, request,
+                                                              ret);
+                                    ipStaticRouteTable_free_undoInfo(ui);
+                                } else if (ui) {
+                        /** remember information for undo purposes later */
+                                    netsnmp_oid_stash_add_data(&undoStorage,
+                                                               suffix,
+                                                               suffix_len,
+                                                               ui);
+                                }
+                                
+                            }
+                            break;
+                    default:
+                       netsnmp_set_request_error(reqinfo, request,
+                                                 SNMP_ERR_NOTWRITABLE);
+                       break;
+                 }
+                break;
+
+            case MODE_SET_ACTION:
+            /** save a variable copy */
+                switch(table_info->colnum) {
+                          case COLUMN_IPSTATICROUTENAME:
+                            {
+                                int ret;
+                                ret = set_ipStaticRouteName(ci->data_context,
+                                             (char *) request->requestvb->val.string,
+                                             request->requestvb->val_len);
+                                if (ret) {
+                                    netsnmp_set_request_error(reqinfo, request,
+                                                              ret);
+                                }
+                            }
+                            break;
+                          case COLUMN_IPSTATICROUTESTATUS:
+                            {
+                                int ret;
+                                ret = set_ipStaticRouteStatus(ci->data_context,
+                                             (char *) request->requestvb->val.string,
+                                             request->requestvb->val_len);
+                                if (ret) {
+                                    netsnmp_set_request_error(reqinfo, request,
+                                                              ret);
+                                }
+                            }
+                            break;
+                          case COLUMN_IPSTATICROUTEDESTIPADDR:
+                            {
+                                int ret;
+                                ret = set_ipStaticRouteDestIpAddr(ci->data_context,
+                                             (char *) request->requestvb->val.string,
+                                             request->requestvb->val_len);
+                                if (ret) {
+                                    netsnmp_set_request_error(reqinfo, request,
+                                                              ret);
+                                }
+                            }
+                            break;
+                          case COLUMN_IPSTATICROUTEDESTSUBNETMASK:
+                            {
+                                int ret;
+                                ret = set_ipStaticRouteDestSubnetMask(ci->data_context,
+                                             (char *) request->requestvb->val.string,
+                                             request->requestvb->val_len);
+                                if (ret) {
+                                    netsnmp_set_request_error(reqinfo, request,
+                                                              ret);
+                                }
+                            }
+                            break;
+                          case COLUMN_IPSTATICROUTESRCIPADDR:
+                            {
+                                int ret;
+                                ret = set_ipStaticRouteSrcIpAddr(ci->data_context,
+                                             (char *) request->requestvb->val.string,
+                                             request->requestvb->val_len);
+                                if (ret) {
+                                    netsnmp_set_request_error(reqinfo, request,
+                                                              ret);
+                                }
+                            }
+                            break;
+                          case COLUMN_IPSTATICROUTESRCSUBNETMASK:
+                            {
+                                int ret;
+                                ret = set_ipStaticRouteSrcSubnetMask(ci->data_context,
+                                             (char *) request->requestvb->val.string,
+                                             request->requestvb->val_len);
+                                if (ret) {
+                                    netsnmp_set_request_error(reqinfo, request,
+                                                              ret);
+                                }
+                            }
+                            break;
+                          case COLUMN_IPSTATICROUTEGATEWAYIPADDR:
+                            {
+                                int ret;
+                                ret = set_ipStaticRouteGatewayIpAddr(ci->data_context,
+                                             (char *) request->requestvb->val.string,
+                                             request->requestvb->val_len);
+                                if (ret) {
+                                    netsnmp_set_request_error(reqinfo, request,
+                                                              ret);
+                                }
+                            }
+                            break;
+                          case COLUMN_IPSTATICROUTEMETRIC:
+                            {
+                                int ret;
+                                ret = set_ipStaticRouteMetric(ci->data_context,
+                                             (long *) request->requestvb->val.string,
+                                             request->requestvb->val_len);
+                                if (ret) {
+                                    netsnmp_set_request_error(reqinfo, request,
+                                                              ret);
+                                }
+                            }
+                            break;
+                          case COLUMN_IPSTATICROUTESTATICROUTE:
+                            {
+                                int ret;
+                                ret = set_ipStaticRouteStaticRoute(ci->data_context,
+                                             (long *) request->requestvb->val.string,
+                                             request->requestvb->val_len);
+                                if (ret) {
+                                    netsnmp_set_request_error(reqinfo, request,
+                                                              ret);
+                                }
+                            }
+                            break;
+                          case COLUMN_IPSTATICROUTEENABLE:
+                            {
+                                int ret;
+                                ret = set_ipStaticRouteEnable(ci->data_context,
+                                             (long *) request->requestvb->val.string,
+                                             request->requestvb->val_len);
+                                if (ret) {
+                                    netsnmp_set_request_error(reqinfo, request,
+                                                              ret);
+                                }
+                            }
+                            break;
+                 }
+                break;
+
+            case MODE_SET_COMMIT:
+                if (!ci->have_committed) {
+                    /** do this once per row only */
+                    ipStaticRouteTable_commit_row(&ci->data_context, ci->new_row);
+                    ci->have_committed = 1;
+                }
+                break;
+
+            case MODE_SET_UNDO:
+             /** save a variable copy */
+                switch(table_info->colnum) {
+                          case COLUMN_IPSTATICROUTENAME:
+                            {
+                                int retval;
+                                struct undoInfo *ui;
+                                ui = netsnmp_oid_stash_get_data(undoStorage,
+                                                                suffix,
+                                                                suffix_len);
+                                retval = set_ipStaticRouteName(ci->data_context, ui->ptr,
+                                                ui->len);
+                                if (retval) {
+                                    netsnmp_set_request_error(reqinfo, request,
+                                                              SNMP_ERR_UNDOFAILED);
+                                }
+                            }
+                            break;
+                          case COLUMN_IPSTATICROUTESTATUS:
+                            {
+                                int retval;
+                                struct undoInfo *ui;
+                                ui = netsnmp_oid_stash_get_data(undoStorage,
+                                                                suffix,
+                                                                suffix_len);
+                                retval = set_ipStaticRouteStatus(ci->data_context, ui->ptr,
+                                                ui->len);
+                                if (retval) {
+                                    netsnmp_set_request_error(reqinfo, request,
+                                                              SNMP_ERR_UNDOFAILED);
+                                }
+                            }
+                            break;
+                          case COLUMN_IPSTATICROUTEDESTIPADDR:
+                            {
+                                int retval;
+                                struct undoInfo *ui;
+                                ui = netsnmp_oid_stash_get_data(undoStorage,
+                                                                suffix,
+                                                                suffix_len);
+                                retval = set_ipStaticRouteDestIpAddr(ci->data_context, ui->ptr,
+                                                ui->len);
+                                if (retval) {
+                                    netsnmp_set_request_error(reqinfo, request,
+                                                              SNMP_ERR_UNDOFAILED);
+                                }
+                            }
+                            break;
+                          case COLUMN_IPSTATICROUTEDESTSUBNETMASK:
+                            {
+                                int retval;
+                                struct undoInfo *ui;
+                                ui = netsnmp_oid_stash_get_data(undoStorage,
+                                                                suffix,
+                                                                suffix_len);
+                                retval = set_ipStaticRouteDestSubnetMask(ci->data_context, ui->ptr,
+                                                ui->len);
+                                if (retval) {
+                                    netsnmp_set_request_error(reqinfo, request,
+                                                              SNMP_ERR_UNDOFAILED);
+                                }
+                            }
+                            break;
+                          case COLUMN_IPSTATICROUTESRCIPADDR:
+                            {
+                                int retval;
+                                struct undoInfo *ui;
+                                ui = netsnmp_oid_stash_get_data(undoStorage,
+                                                                suffix,
+                                                                suffix_len);
+                                retval = set_ipStaticRouteSrcIpAddr(ci->data_context, ui->ptr,
+                                                ui->len);
+                                if (retval) {
+                                    netsnmp_set_request_error(reqinfo, request,
+                                                              SNMP_ERR_UNDOFAILED);
+                                }
+                            }
+                            break;
+                          case COLUMN_IPSTATICROUTESRCSUBNETMASK:
+                            {
+                                int retval;
+                                struct undoInfo *ui;
+                                ui = netsnmp_oid_stash_get_data(undoStorage,
+                                                                suffix,
+                                                                suffix_len);
+                                retval = set_ipStaticRouteSrcSubnetMask(ci->data_context, ui->ptr,
+                                                ui->len);
+                                if (retval) {
+                                    netsnmp_set_request_error(reqinfo, request,
+                                                              SNMP_ERR_UNDOFAILED);
+                                }
+                            }
+                            break;
+                          case COLUMN_IPSTATICROUTEGATEWAYIPADDR:
+                            {
+                                int retval;
+                                struct undoInfo *ui;
+                                ui = netsnmp_oid_stash_get_data(undoStorage,
+                                                                suffix,
+                                                                suffix_len);
+                                retval = set_ipStaticRouteGatewayIpAddr(ci->data_context, ui->ptr,
+                                                ui->len);
+                                if (retval) {
+                                    netsnmp_set_request_error(reqinfo, request,
+                                                              SNMP_ERR_UNDOFAILED);
+                                }
+                            }
+                            break;
+                          case COLUMN_IPSTATICROUTEMETRIC:
+                            {
+                                int retval;
+                                struct undoInfo *ui;
+                                ui = netsnmp_oid_stash_get_data(undoStorage,
+                                                                suffix,
+                                                                suffix_len);
+                                retval = set_ipStaticRouteMetric(ci->data_context, ui->ptr,
+                                                ui->len);
+                                if (retval) {
+                                    netsnmp_set_request_error(reqinfo, request,
+                                                              SNMP_ERR_UNDOFAILED);
+                                }
+                            }
+                            break;
+                          case COLUMN_IPSTATICROUTESTATICROUTE:
+                            {
+                                int retval;
+                                struct undoInfo *ui;
+                                ui = netsnmp_oid_stash_get_data(undoStorage,
+                                                                suffix,
+                                                                suffix_len);
+                                retval = set_ipStaticRouteStaticRoute(ci->data_context, ui->ptr,
+                                                ui->len);
+                                if (retval) {
+                                    netsnmp_set_request_error(reqinfo, request,
+                                                              SNMP_ERR_UNDOFAILED);
+                                }
+                            }
+                            break;
+                          case COLUMN_IPSTATICROUTEENABLE:
+                            {
+                                int retval;
+                                struct undoInfo *ui;
+                                ui = netsnmp_oid_stash_get_data(undoStorage,
+                                                                suffix,
+                                                                suffix_len);
+                                retval = set_ipStaticRouteEnable(ci->data_context, ui->ptr,
+                                                ui->len);
+                                if (retval) {
+                                    netsnmp_set_request_error(reqinfo, request,
+                                                              SNMP_ERR_UNDOFAILED);
+                                }
+                            }
+                            break;
+                }
+                break;
+                
+            case MODE_SET_FREE:
+                break;
+
+            default:
+                snmp_log(LOG_ERR, "problem encountered in ipStaticRouteTable_handler: unsupported mode\n");
+        }
+    }
+
+    /** clean up after all requset processing has ended */
+    switch(reqinfo->mode) {
+    case MODE_SET_UNDO:
+    case MODE_SET_FREE:
+    case MODE_SET_COMMIT:
+        /** clear out the undo cache */
+        netsnmp_oid_stash_free(&undoStorage, ipStaticRouteTable_free_undoInfo);
+        netsnmp_oid_stash_free(&commitStorage, netsnmp_oid_stash_no_free);
+    }
+
+    return SNMP_ERR_NOERROR;
+}
diff -Naur net-snmp-5.7.2-orig/agent/mibgroup/ZYXEL-PRESTIGE-MIB/ipStaticRouteTable_checkfns.c net-snmp-5.7.2/agent/mibgroup/ZYXEL-PRESTIGE-MIB/ipStaticRouteTable_checkfns.c
--- net-snmp-5.7.2-orig/agent/mibgroup/ZYXEL-PRESTIGE-MIB/ipStaticRouteTable_checkfns.c	1970-01-01 08:00:00.000000000 +0800
+++ net-snmp-5.7.2/agent/mibgroup/ZYXEL-PRESTIGE-MIB/ipStaticRouteTable_checkfns.c	2013-10-08 09:35:17.626117000 +0800
@@ -0,0 +1,314 @@
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *        : mib2c.check_values.conf 9254 2004-01-12 00:43:46Z rstory $
+ */
+
+/********************************************************************
+ *                       NOTE   NOTE   NOTE
+ *   This file is auto-generated and SHOULD NOT BE EDITED by hand.
+ *   Modify the ipStaticRouteTable_checkfns_local.[ch] files insead so that you
+ *   can regenerate this one as mib2c improvements are made.
+ ********************************************************************/
+
+/* standard headers */
+#include <net-snmp/net-snmp-config.h>
+#include <net-snmp/net-snmp-includes.h>
+#include "ipStaticRouteTable_checkfns.h"
+#include "ipStaticRouteTable_checkfns_local.h"
+#include "ipStaticRouteTable_enums.h"
+
+/** Decides if an incoming value for the ipStaticRouteName mib node is legal.
+ *  @param type    The incoming data type.
+ *  @param val     The value to be checked.
+ *  @param val_len The length of data stored in val (in bytes).
+ *  @return 0 if the incoming value is legal, an SNMP error code otherwise.
+ */
+    int
+    check_ipStaticRouteName(int type, char *val, size_t val_len,
+             char *old_val, size_t old_val_len) {
+
+    int ret;
+
+    /** Check to see that we were called legally */
+      if (!val)
+        return SNMP_ERR_GENERR;
+
+    /** Check the incoming type for correctness */
+      if (type != ASN_OCTET_STR)
+        return SNMP_ERR_WRONGTYPE;
+
+    /** Check the ranges of the passed value for legality */
+	    if (
+	       !(val_len >= 0 && val_len <= 32)
+            ) {
+            return SNMP_ERR_WRONGVALUE;
+            }
+
+
+    /** looks ok, call the local version of the same function. */
+      return check_ipStaticRouteName_local(type, val, val_len, old_val, old_val_len);
+    }
+/** Decides if an incoming value for the ipStaticRouteStatus mib node is legal.
+ *  @param type    The incoming data type.
+ *  @param val     The value to be checked.
+ *  @param val_len The length of data stored in val (in bytes).
+ *  @return 0 if the incoming value is legal, an SNMP error code otherwise.
+ */
+    int
+    check_ipStaticRouteStatus(int type, char *val, size_t val_len,
+             char *old_val, size_t old_val_len) {
+
+    int ret;
+
+    /** Check to see that we were called legally */
+      if (!val)
+        return SNMP_ERR_GENERR;
+
+    /** Check the incoming type for correctness */
+      if (type != ASN_OCTET_STR)
+        return SNMP_ERR_WRONGTYPE;
+
+    /** Check the ranges of the passed value for legality */
+	    if (
+	       !(val_len >= 0 && val_len <= 8)
+            ) {
+            return SNMP_ERR_WRONGVALUE;
+            }
+
+
+    /** looks ok, call the local version of the same function. */
+      return check_ipStaticRouteStatus_local(type, val, val_len, old_val, old_val_len);
+    }
+/** Decides if an incoming value for the ipStaticRouteDestIpAddr mib node is legal.
+ *  @param type    The incoming data type.
+ *  @param val     The value to be checked.
+ *  @param val_len The length of data stored in val (in bytes).
+ *  @return 0 if the incoming value is legal, an SNMP error code otherwise.
+ */
+    int
+    check_ipStaticRouteDestIpAddr(int type, char *val, size_t val_len,
+             char *old_val, size_t old_val_len) {
+
+    int ret;
+
+    /** Check to see that we were called legally */
+      if (!val)
+        return SNMP_ERR_GENERR;
+
+    /** Check the incoming type for correctness */
+      if (type != ASN_OCTET_STR)
+        return SNMP_ERR_WRONGTYPE;
+
+    /** Check the ranges of the passed value for legality */
+	    if (
+	       !(val_len >= 0 && val_len <= 17)
+            ) {
+            return SNMP_ERR_WRONGVALUE;
+            }
+
+
+    /** looks ok, call the local version of the same function. */
+      return check_ipStaticRouteDestIpAddr_local(type, val, val_len, old_val, old_val_len);
+    }
+/** Decides if an incoming value for the ipStaticRouteDestSubnetMask mib node is legal.
+ *  @param type    The incoming data type.
+ *  @param val     The value to be checked.
+ *  @param val_len The length of data stored in val (in bytes).
+ *  @return 0 if the incoming value is legal, an SNMP error code otherwise.
+ */
+    int
+    check_ipStaticRouteDestSubnetMask(int type, char *val, size_t val_len,
+             char *old_val, size_t old_val_len) {
+
+    int ret;
+
+    /** Check to see that we were called legally */
+      if (!val)
+        return SNMP_ERR_GENERR;
+
+    /** Check the incoming type for correctness */
+      if (type != ASN_OCTET_STR)
+        return SNMP_ERR_WRONGTYPE;
+
+    /** Check the ranges of the passed value for legality */
+	    if (
+	       !(val_len >= 0 && val_len <= 17)
+            ) {
+            return SNMP_ERR_WRONGVALUE;
+            }
+
+
+    /** looks ok, call the local version of the same function. */
+      return check_ipStaticRouteDestSubnetMask_local(type, val, val_len, old_val, old_val_len);
+    }
+/** Decides if an incoming value for the ipStaticRouteSrcIpAddr mib node is legal.
+ *  @param type    The incoming data type.
+ *  @param val     The value to be checked.
+ *  @param val_len The length of data stored in val (in bytes).
+ *  @return 0 if the incoming value is legal, an SNMP error code otherwise.
+ */
+    int
+    check_ipStaticRouteSrcIpAddr(int type, char *val, size_t val_len,
+             char *old_val, size_t old_val_len) {
+
+    int ret;
+
+    /** Check to see that we were called legally */
+      if (!val)
+        return SNMP_ERR_GENERR;
+
+    /** Check the incoming type for correctness */
+      if (type != ASN_OCTET_STR)
+        return SNMP_ERR_WRONGTYPE;
+
+    /** Check the ranges of the passed value for legality */
+	    if (
+	       !(val_len >= 0 && val_len <= 17)
+            ) {
+            return SNMP_ERR_WRONGVALUE;
+            }
+
+
+    /** looks ok, call the local version of the same function. */
+      return check_ipStaticRouteSrcIpAddr_local(type, val, val_len, old_val, old_val_len);
+    }
+/** Decides if an incoming value for the ipStaticRouteSrcSubnetMask mib node is legal.
+ *  @param type    The incoming data type.
+ *  @param val     The value to be checked.
+ *  @param val_len The length of data stored in val (in bytes).
+ *  @return 0 if the incoming value is legal, an SNMP error code otherwise.
+ */
+    int
+    check_ipStaticRouteSrcSubnetMask(int type, char *val, size_t val_len,
+             char *old_val, size_t old_val_len) {
+
+    int ret;
+
+    /** Check to see that we were called legally */
+      if (!val)
+        return SNMP_ERR_GENERR;
+
+    /** Check the incoming type for correctness */
+      if (type != ASN_OCTET_STR)
+        return SNMP_ERR_WRONGTYPE;
+
+    /** Check the ranges of the passed value for legality */
+	    if (
+	       !(val_len >= 0 && val_len <= 17)
+            ) {
+            return SNMP_ERR_WRONGVALUE;
+            }
+
+
+    /** looks ok, call the local version of the same function. */
+      return check_ipStaticRouteSrcSubnetMask_local(type, val, val_len, old_val, old_val_len);
+    }
+/** Decides if an incoming value for the ipStaticRouteGatewayIpAddr mib node is legal.
+ *  @param type    The incoming data type.
+ *  @param val     The value to be checked.
+ *  @param val_len The length of data stored in val (in bytes).
+ *  @return 0 if the incoming value is legal, an SNMP error code otherwise.
+ */
+    int
+    check_ipStaticRouteGatewayIpAddr(int type, char *val, size_t val_len,
+             char *old_val, size_t old_val_len) {
+
+    int ret;
+
+    /** Check to see that we were called legally */
+      if (!val)
+        return SNMP_ERR_GENERR;
+
+    /** Check the incoming type for correctness */
+      if (type != ASN_OCTET_STR)
+        return SNMP_ERR_WRONGTYPE;
+
+    /** Check the ranges of the passed value for legality */
+	    if (
+	       !(val_len >= 0 && val_len <= 17)
+            ) {
+            return SNMP_ERR_WRONGVALUE;
+            }
+
+
+    /** looks ok, call the local version of the same function. */
+      return check_ipStaticRouteGatewayIpAddr_local(type, val, val_len, old_val, old_val_len);
+    }
+/** Decides if an incoming value for the ipStaticRouteMetric mib node is legal.
+ *  @param type    The incoming data type.
+ *  @param val     The value to be checked.
+ *  @param val_len The length of data stored in val (in bytes).
+ *  @return 0 if the incoming value is legal, an SNMP error code otherwise.
+ */
+    int
+    check_ipStaticRouteMetric(int type, long *val, size_t val_len,
+             long *old_val, size_t old_val_len) {
+
+    int ret;
+
+    /** Check to see that we were called legally */
+      if (!val)
+        return SNMP_ERR_GENERR;
+
+    /** Check the incoming type for correctness */
+      if (type != ASN_INTEGER)
+        return SNMP_ERR_WRONGTYPE;
+
+	ret = SNMP_ERR_NOERROR;
+
+
+    /** looks ok, call the local version of the same function. */
+      return check_ipStaticRouteMetric_local(type, val, val_len, old_val, old_val_len);
+    }
+/** Decides if an incoming value for the ipStaticRouteStaticRoute mib node is legal.
+ *  @param type    The incoming data type.
+ *  @param val     The value to be checked.
+ *  @param val_len The length of data stored in val (in bytes).
+ *  @return 0 if the incoming value is legal, an SNMP error code otherwise.
+ */
+    int
+    check_ipStaticRouteStaticRoute(int type, long *val, size_t val_len,
+             long *old_val, size_t old_val_len) {
+
+    int ret;
+
+    /** Check to see that we were called legally */
+      if (!val)
+        return SNMP_ERR_GENERR;
+
+    /** Check the incoming type for correctness */
+      if (type != ASN_INTEGER)
+        return SNMP_ERR_WRONGTYPE;
+
+	ret = SNMP_ERR_NOERROR;
+
+
+    /** looks ok, call the local version of the same function. */
+      return check_ipStaticRouteStaticRoute_local(type, val, val_len, old_val, old_val_len);
+    }
+/** Decides if an incoming value for the ipStaticRouteEnable mib node is legal.
+ *  @param type    The incoming data type.
+ *  @param val     The value to be checked.
+ *  @param val_len The length of data stored in val (in bytes).
+ *  @return 0 if the incoming value is legal, an SNMP error code otherwise.
+ */
+    int
+    check_ipStaticRouteEnable(int type, long *val, size_t val_len,
+             long *old_val, size_t old_val_len) {
+
+    int ret;
+
+    /** Check to see that we were called legally */
+      if (!val)
+        return SNMP_ERR_GENERR;
+
+    /** Check the incoming type for correctness */
+      if (type != ASN_INTEGER)
+        return SNMP_ERR_WRONGTYPE;
+
+	ret = SNMP_ERR_NOERROR;
+
+
+    /** looks ok, call the local version of the same function. */
+      return check_ipStaticRouteEnable_local(type, val, val_len, old_val, old_val_len);
+    }
diff -Naur net-snmp-5.7.2-orig/agent/mibgroup/ZYXEL-PRESTIGE-MIB/ipStaticRouteTable_checkfns.h net-snmp-5.7.2/agent/mibgroup/ZYXEL-PRESTIGE-MIB/ipStaticRouteTable_checkfns.h
--- net-snmp-5.7.2-orig/agent/mibgroup/ZYXEL-PRESTIGE-MIB/ipStaticRouteTable_checkfns.h	1970-01-01 08:00:00.000000000 +0800
+++ net-snmp-5.7.2/agent/mibgroup/ZYXEL-PRESTIGE-MIB/ipStaticRouteTable_checkfns.h	2013-10-08 09:35:17.626117000 +0800
@@ -0,0 +1,34 @@
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *        : mib2c.iterate.conf,v 5.6 2003/02/20 00:52:07 hardaker Exp $
+ */
+
+/***********************************************************************
+ *   This file is auto-generated and SHOULD NOT BE EDITED by hand.
+ *   Modify the ipStaticRouteTable_checkfns_local.[ch] files insead.
+ *   (so that you can regenerate this one as mib2c improvements are made)
+ ***********************************************************************/
+#ifndef IPSTATICROUTETABLE_CHECKFNS_H
+#define IPSTATICROUTETABLE_CHECKFNS_H
+
+/** make sure we load the functions that you can modify */
+config_require(ZYXEL-PRESTIGE-MIB/ipStaticRouteTable_checkfns_local)
+
+/* these functions are designed to check incoming values for 
+columns in the ipStaticRouteTable table for legality with respect to 
+datatype and value.
+ */
+
+      int check_ipStaticRouteName(int type, char *val, size_t val_len, char *old_val, size_t old_val_len);
+      int check_ipStaticRouteStatus(int type, char *val, size_t val_len, char *old_val, size_t old_val_len);
+      int check_ipStaticRouteDestIpAddr(int type, char *val, size_t val_len, char *old_val, size_t old_val_len);
+      int check_ipStaticRouteDestSubnetMask(int type, char *val, size_t val_len, char *old_val, size_t old_val_len);
+      int check_ipStaticRouteSrcIpAddr(int type, char *val, size_t val_len, char *old_val, size_t old_val_len);
+      int check_ipStaticRouteSrcSubnetMask(int type, char *val, size_t val_len, char *old_val, size_t old_val_len);
+      int check_ipStaticRouteGatewayIpAddr(int type, char *val, size_t val_len, char *old_val, size_t old_val_len);
+      int check_ipStaticRouteMetric(int type, long *val, size_t val_len, long *old_val, size_t old_val_len);
+      int check_ipStaticRouteStaticRoute(int type, long *val, size_t val_len, long *old_val, size_t old_val_len);
+      int check_ipStaticRouteEnable(int type, long *val, size_t val_len, long *old_val, size_t old_val_len);
+
+#endif /* IPSTATICROUTETABLE_CHECKFNS_H */
+
diff -Naur net-snmp-5.7.2-orig/agent/mibgroup/ZYXEL-PRESTIGE-MIB/ipStaticRouteTable_checkfns_local.c net-snmp-5.7.2/agent/mibgroup/ZYXEL-PRESTIGE-MIB/ipStaticRouteTable_checkfns_local.c
--- net-snmp-5.7.2-orig/agent/mibgroup/ZYXEL-PRESTIGE-MIB/ipStaticRouteTable_checkfns_local.c	1970-01-01 08:00:00.000000000 +0800
+++ net-snmp-5.7.2/agent/mibgroup/ZYXEL-PRESTIGE-MIB/ipStaticRouteTable_checkfns_local.c	2013-10-08 09:35:17.626117000 +0800
@@ -0,0 +1,201 @@
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *        : mib2c.check_values_local.conf 10232 2004-05-04 23:35:32Z hardaker $
+ */
+
+/* standard headers */
+#include <net-snmp/net-snmp-config.h>
+#include <net-snmp/net-snmp-includes.h>
+#include "ipStaticRouteTable_checkfns.h"
+#include "ipStaticRouteTable_enums.h"
+
+/** Decides if an incoming value for the ipStaticRouteName mib node is legal, from a local implementation specific viewpoint.
+ *  @param type    The incoming data type.
+ *  @param val     The value to be checked.
+ *  @param val_len The length of data stored in val (in bytes).
+ *  @return 0 if the incoming value is legal, an SNMP error code otherwise.
+ */
+    int
+    check_ipStaticRouteName_local(int type, char *val, size_t val_len, char *old_val, size_t old_val_len) {
+
+    /** XXX: you may want to check aspects of the new value that
+       were not covered by the automatic checks by the parent function. */
+
+    /** XXX: you make want to check that the requested change from
+        the old value to the new value is legal (ie, the transistion
+        from one value to another is legal */
+      
+    /** if everything looks ok, return SNMP_ERR_NOERROR */
+      return SNMP_ERR_NOERROR;
+    }
+/** Decides if an incoming value for the ipStaticRouteStatus mib node is legal, from a local implementation specific viewpoint.
+ *  @param type    The incoming data type.
+ *  @param val     The value to be checked.
+ *  @param val_len The length of data stored in val (in bytes).
+ *  @return 0 if the incoming value is legal, an SNMP error code otherwise.
+ */
+    int
+    check_ipStaticRouteStatus_local(int type, char *val, size_t val_len, char *old_val, size_t old_val_len) {
+
+    /** XXX: you may want to check aspects of the new value that
+       were not covered by the automatic checks by the parent function. */
+
+    /** XXX: you make want to check that the requested change from
+        the old value to the new value is legal (ie, the transistion
+        from one value to another is legal */
+      
+    /** if everything looks ok, return SNMP_ERR_NOERROR */
+      return SNMP_ERR_NOERROR;
+    }
+/** Decides if an incoming value for the ipStaticRouteDestIpAddr mib node is legal, from a local implementation specific viewpoint.
+ *  @param type    The incoming data type.
+ *  @param val     The value to be checked.
+ *  @param val_len The length of data stored in val (in bytes).
+ *  @return 0 if the incoming value is legal, an SNMP error code otherwise.
+ */
+    int
+    check_ipStaticRouteDestIpAddr_local(int type, char *val, size_t val_len, char *old_val, size_t old_val_len) {
+
+    /** XXX: you may want to check aspects of the new value that
+       were not covered by the automatic checks by the parent function. */
+
+    /** XXX: you make want to check that the requested change from
+        the old value to the new value is legal (ie, the transistion
+        from one value to another is legal */
+      
+    /** if everything looks ok, return SNMP_ERR_NOERROR */
+      return SNMP_ERR_NOERROR;
+    }
+/** Decides if an incoming value for the ipStaticRouteDestSubnetMask mib node is legal, from a local implementation specific viewpoint.
+ *  @param type    The incoming data type.
+ *  @param val     The value to be checked.
+ *  @param val_len The length of data stored in val (in bytes).
+ *  @return 0 if the incoming value is legal, an SNMP error code otherwise.
+ */
+    int
+    check_ipStaticRouteDestSubnetMask_local(int type, char *val, size_t val_len, char *old_val, size_t old_val_len) {
+
+    /** XXX: you may want to check aspects of the new value that
+       were not covered by the automatic checks by the parent function. */
+
+    /** XXX: you make want to check that the requested change from
+        the old value to the new value is legal (ie, the transistion
+        from one value to another is legal */
+      
+    /** if everything looks ok, return SNMP_ERR_NOERROR */
+      return SNMP_ERR_NOERROR;
+    }
+/** Decides if an incoming value for the ipStaticRouteSrcIpAddr mib node is legal, from a local implementation specific viewpoint.
+ *  @param type    The incoming data type.
+ *  @param val     The value to be checked.
+ *  @param val_len The length of data stored in val (in bytes).
+ *  @return 0 if the incoming value is legal, an SNMP error code otherwise.
+ */
+    int
+    check_ipStaticRouteSrcIpAddr_local(int type, char *val, size_t val_len, char *old_val, size_t old_val_len) {
+
+    /** XXX: you may want to check aspects of the new value that
+       were not covered by the automatic checks by the parent function. */
+
+    /** XXX: you make want to check that the requested change from
+        the old value to the new value is legal (ie, the transistion
+        from one value to another is legal */
+      
+    /** if everything looks ok, return SNMP_ERR_NOERROR */
+      return SNMP_ERR_NOERROR;
+    }
+/** Decides if an incoming value for the ipStaticRouteSrcSubnetMask mib node is legal, from a local implementation specific viewpoint.
+ *  @param type    The incoming data type.
+ *  @param val     The value to be checked.
+ *  @param val_len The length of data stored in val (in bytes).
+ *  @return 0 if the incoming value is legal, an SNMP error code otherwise.
+ */
+    int
+    check_ipStaticRouteSrcSubnetMask_local(int type, char *val, size_t val_len, char *old_val, size_t old_val_len) {
+
+    /** XXX: you may want to check aspects of the new value that
+       were not covered by the automatic checks by the parent function. */
+
+    /** XXX: you make want to check that the requested change from
+        the old value to the new value is legal (ie, the transistion
+        from one value to another is legal */
+      
+    /** if everything looks ok, return SNMP_ERR_NOERROR */
+      return SNMP_ERR_NOERROR;
+    }
+/** Decides if an incoming value for the ipStaticRouteGatewayIpAddr mib node is legal, from a local implementation specific viewpoint.
+ *  @param type    The incoming data type.
+ *  @param val     The value to be checked.
+ *  @param val_len The length of data stored in val (in bytes).
+ *  @return 0 if the incoming value is legal, an SNMP error code otherwise.
+ */
+    int
+    check_ipStaticRouteGatewayIpAddr_local(int type, char *val, size_t val_len, char *old_val, size_t old_val_len) {
+
+    /** XXX: you may want to check aspects of the new value that
+       were not covered by the automatic checks by the parent function. */
+
+    /** XXX: you make want to check that the requested change from
+        the old value to the new value is legal (ie, the transistion
+        from one value to another is legal */
+      
+    /** if everything looks ok, return SNMP_ERR_NOERROR */
+      return SNMP_ERR_NOERROR;
+    }
+/** Decides if an incoming value for the ipStaticRouteMetric mib node is legal, from a local implementation specific viewpoint.
+ *  @param type    The incoming data type.
+ *  @param val     The value to be checked.
+ *  @param val_len The length of data stored in val (in bytes).
+ *  @return 0 if the incoming value is legal, an SNMP error code otherwise.
+ */
+    int
+    check_ipStaticRouteMetric_local(int type, long *val, size_t val_len, long *old_val, size_t old_val_len) {
+
+    /** XXX: you may want to check aspects of the new value that
+       were not covered by the automatic checks by the parent function. */
+
+    /** XXX: you make want to check that the requested change from
+        the old value to the new value is legal (ie, the transistion
+        from one value to another is legal */
+      
+    /** if everything looks ok, return SNMP_ERR_NOERROR */
+      return SNMP_ERR_NOERROR;
+    }
+/** Decides if an incoming value for the ipStaticRouteStaticRoute mib node is legal, from a local implementation specific viewpoint.
+ *  @param type    The incoming data type.
+ *  @param val     The value to be checked.
+ *  @param val_len The length of data stored in val (in bytes).
+ *  @return 0 if the incoming value is legal, an SNMP error code otherwise.
+ */
+    int
+    check_ipStaticRouteStaticRoute_local(int type, long *val, size_t val_len, long *old_val, size_t old_val_len) {
+
+    /** XXX: you may want to check aspects of the new value that
+       were not covered by the automatic checks by the parent function. */
+
+    /** XXX: you make want to check that the requested change from
+        the old value to the new value is legal (ie, the transistion
+        from one value to another is legal */
+      
+    /** if everything looks ok, return SNMP_ERR_NOERROR */
+      return SNMP_ERR_NOERROR;
+    }
+/** Decides if an incoming value for the ipStaticRouteEnable mib node is legal, from a local implementation specific viewpoint.
+ *  @param type    The incoming data type.
+ *  @param val     The value to be checked.
+ *  @param val_len The length of data stored in val (in bytes).
+ *  @return 0 if the incoming value is legal, an SNMP error code otherwise.
+ */
+    int
+    check_ipStaticRouteEnable_local(int type, long *val, size_t val_len, long *old_val, size_t old_val_len) {
+
+    /** XXX: you may want to check aspects of the new value that
+       were not covered by the automatic checks by the parent function. */
+
+    /** XXX: you make want to check that the requested change from
+        the old value to the new value is legal (ie, the transistion
+        from one value to another is legal */
+      
+    /** if everything looks ok, return SNMP_ERR_NOERROR */
+      return SNMP_ERR_NOERROR;
+    }
diff -Naur net-snmp-5.7.2-orig/agent/mibgroup/ZYXEL-PRESTIGE-MIB/ipStaticRouteTable_checkfns_local.h net-snmp-5.7.2/agent/mibgroup/ZYXEL-PRESTIGE-MIB/ipStaticRouteTable_checkfns_local.h
--- net-snmp-5.7.2-orig/agent/mibgroup/ZYXEL-PRESTIGE-MIB/ipStaticRouteTable_checkfns_local.h	1970-01-01 08:00:00.000000000 +0800
+++ net-snmp-5.7.2/agent/mibgroup/ZYXEL-PRESTIGE-MIB/ipStaticRouteTable_checkfns_local.h	2013-10-08 09:35:17.626117000 +0800
@@ -0,0 +1,29 @@
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *        : : mib2c.check_values_local.conf 10232 2004-05-04 23:35:32Z hardaker $
+ * 
+ */
+#ifndef IPSTATICROUTETABLE_CHECKFNS_H
+#define IPSTATICROUTETABLE_CHECKFNS_H
+
+/* these functions are designed to check incoming values for 
+columns in the ipStaticRouteTable table for legality with respect to 
+datatype and value according to local conventions.  You should modify
+them as appropriate.  They will be called from parent check_value
+functions that are auto-generated using mib2c and the parent functions
+should NOT be modified.
+ */
+
+    int check_ipStaticRouteName_local(int type, char *val, size_t val_len, char *old_val, size_t old_val_len);
+    int check_ipStaticRouteStatus_local(int type, char *val, size_t val_len, char *old_val, size_t old_val_len);
+    int check_ipStaticRouteDestIpAddr_local(int type, char *val, size_t val_len, char *old_val, size_t old_val_len);
+    int check_ipStaticRouteDestSubnetMask_local(int type, char *val, size_t val_len, char *old_val, size_t old_val_len);
+    int check_ipStaticRouteSrcIpAddr_local(int type, char *val, size_t val_len, char *old_val, size_t old_val_len);
+    int check_ipStaticRouteSrcSubnetMask_local(int type, char *val, size_t val_len, char *old_val, size_t old_val_len);
+    int check_ipStaticRouteGatewayIpAddr_local(int type, char *val, size_t val_len, char *old_val, size_t old_val_len);
+    int check_ipStaticRouteMetric_local(int type, long *val, size_t val_len, long *old_val, size_t old_val_len);
+    int check_ipStaticRouteStaticRoute_local(int type, long *val, size_t val_len, long *old_val, size_t old_val_len);
+    int check_ipStaticRouteEnable_local(int type, long *val, size_t val_len, long *old_val, size_t old_val_len);
+
+#endif /* IPSTATICROUTETABLE_CHECKFNS_H */
+
diff -Naur net-snmp-5.7.2-orig/agent/mibgroup/ZYXEL-PRESTIGE-MIB/ipStaticRouteTable_columns.h net-snmp-5.7.2/agent/mibgroup/ZYXEL-PRESTIGE-MIB/ipStaticRouteTable_columns.h
--- net-snmp-5.7.2-orig/agent/mibgroup/ZYXEL-PRESTIGE-MIB/ipStaticRouteTable_columns.h	1970-01-01 08:00:00.000000000 +0800
+++ net-snmp-5.7.2/agent/mibgroup/ZYXEL-PRESTIGE-MIB/ipStaticRouteTable_columns.h	2013-10-08 09:35:17.626117000 +0800
@@ -0,0 +1,24 @@
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *  : mib2c.column_defines.conf 7011 2002-05-08 05:42:47Z hardaker $
+ */
+#ifndef IPSTATICROUTETABLE_COLUMNS_H
+#define IPSTATICROUTETABLE_COLUMNS_H
+
+/* column number definitions for table ipStaticRouteTable */
+       #define COLUMN_IPSTATICROUTEINDEX		1
+       #define COLUMN_IPSTATICROUTENAME		2
+       #define COLUMN_IPSTATICROUTESTATUS		3
+       #define COLUMN_IPSTATICROUTETYPE		4
+       #define COLUMN_IPSTATICROUTEDESTIPADDR		5
+       #define COLUMN_IPSTATICROUTEDESTSUBNETMASK		6
+       #define COLUMN_IPSTATICROUTESRCIPADDR		7
+       #define COLUMN_IPSTATICROUTESRCSUBNETMASK		8
+       #define COLUMN_IPSTATICROUTEGATEWAYIPADDR		9
+       #define COLUMN_IPSTATICROUTEINTERFACE		10
+       #define COLUMN_IPSTATICROUTEFORWARDINGPOLICY		11
+       #define COLUMN_IPSTATICROUTEMTU		12
+       #define COLUMN_IPSTATICROUTEMETRIC		13
+       #define COLUMN_IPSTATICROUTESTATICROUTE		14
+       #define COLUMN_IPSTATICROUTEENABLE		15
+#endif /* IPSTATICROUTETABLE_COLUMNS_H */
diff -Naur net-snmp-5.7.2-orig/agent/mibgroup/ZYXEL-PRESTIGE-MIB/ipStaticRouteTable_enums.h net-snmp-5.7.2/agent/mibgroup/ZYXEL-PRESTIGE-MIB/ipStaticRouteTable_enums.h
--- net-snmp-5.7.2-orig/agent/mibgroup/ZYXEL-PRESTIGE-MIB/ipStaticRouteTable_enums.h	1970-01-01 08:00:00.000000000 +0800
+++ net-snmp-5.7.2/agent/mibgroup/ZYXEL-PRESTIGE-MIB/ipStaticRouteTable_enums.h	2013-10-08 09:35:17.626117000 +0800
@@ -0,0 +1,9 @@
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *  : mib2c.column_enums.conf 12909 2005-09-29 22:16:22Z hardaker $
+ */
+#ifndef IPSTATICROUTETABLE_ENUMS_H
+#define IPSTATICROUTETABLE_ENUMS_H
+
+
+#endif /* IPSTATICROUTETABLE_ENUMS_H */
diff -Naur net-snmp-5.7.2-orig/agent/mibgroup/ZYXEL-PRESTIGE-MIB/ipStaticRouteTable.h net-snmp-5.7.2/agent/mibgroup/ZYXEL-PRESTIGE-MIB/ipStaticRouteTable.h
--- net-snmp-5.7.2-orig/agent/mibgroup/ZYXEL-PRESTIGE-MIB/ipStaticRouteTable.h	1970-01-01 08:00:00.000000000 +0800
+++ net-snmp-5.7.2/agent/mibgroup/ZYXEL-PRESTIGE-MIB/ipStaticRouteTable.h	2013-10-08 09:35:17.626117000 +0800
@@ -0,0 +1,26 @@
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *        : mib2c.iterate_access.conf 15179 2006-09-08 15:44:37Z dts12 $
+ */
+#ifndef IPSTATICROUTETABLE_H
+#define IPSTATICROUTETABLE_H
+
+/** other required module components */
+config_require(ZYXEL-PRESTIGE-MIB/ipStaticRouteTable_access)
+config_require(ZYXEL-PRESTIGE-MIB/ipStaticRouteTable_checkfns)
+
+/* function declarations */
+void init_ipStaticRouteTable(void);
+void initialize_table_ipStaticRouteTable(void);
+Netsnmp_Node_Handler ipStaticRouteTable_handler;
+
+
+/* column number definitions for table ipStaticRouteTable */
+#include "ipStaticRouteTable_columns.h"
+
+/* enum definions */
+#include "ipStaticRouteTable_enums.h"
+
+config_require(ZYXEL-PRESTIGE-MIB/ccclib)
+
+#endif /** IPSTATICROUTETABLE_H */
diff -Naur net-snmp-5.7.2-orig/agent/mibgroup/ZYXEL-PRESTIGE-MIB/lanDeviceNumberOfEntry.c net-snmp-5.7.2/agent/mibgroup/ZYXEL-PRESTIGE-MIB/lanDeviceNumberOfEntry.c
--- net-snmp-5.7.2-orig/agent/mibgroup/ZYXEL-PRESTIGE-MIB/lanDeviceNumberOfEntry.c	1970-01-01 08:00:00.000000000 +0800
+++ net-snmp-5.7.2/agent/mibgroup/ZYXEL-PRESTIGE-MIB/lanDeviceNumberOfEntry.c	2013-10-08 09:35:17.626117000 +0800
@@ -0,0 +1,46 @@
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *        : mib2c.scalar.conf 11805 2005-01-07 09:37:18Z dts12 $
+ */
+
+#include <net-snmp/net-snmp-config.h>
+#include <net-snmp/net-snmp-includes.h>
+#include <net-snmp/agent/net-snmp-agent-includes.h>
+#include "lanDeviceNumberOfEntry.h"
+
+/** Initializes the lanDeviceNumberOfEntry module */
+void
+init_lanDeviceNumberOfEntry(void)
+{
+    static oid lanDeviceNumberOfEntry_oid[] = { PRESTIGE_LANDEVSUM_OID };
+
+	DEBUGMSGTL(("lanDeviceNumberOfEntry", "Initializing\n"));
+
+    netsnmp_register_scalar(
+        netsnmp_create_handler_registration("lanDeviceNumberOfEntry", handle_lanDeviceNumberOfEntry,
+                               lanDeviceNumberOfEntry_oid, OID_LENGTH(lanDeviceNumberOfEntry_oid),
+                               HANDLER_CAN_RONLY
+        ));
+}
+
+int
+handle_lanDeviceNumberOfEntry(netsnmp_mib_handler *handler,
+                          netsnmp_handler_registration *reginfo,
+                          netsnmp_agent_request_info   *reqinfo,
+                          netsnmp_request_info         *requests)
+{
+    
+    int ret=SNMP_ERR_NOERROR;
+	switch(reqinfo->mode) {
+		case MODE_GET:
+		case MODE_GETBULK:
+			ret=handleOfGetIntfDevNum( requests, ASN_INTEGER, 0);
+			break;
+		default:
+		/* we should never get here, so this is a really bad error */
+			snmp_log(LOG_ERR, "unknown mode (%d) in %s\n", reqinfo->mode,__FUNCTION__ );
+			return SNMP_ERR_GENERR;
+    }
+
+	return ret;
+}
diff -Naur net-snmp-5.7.2-orig/agent/mibgroup/ZYXEL-PRESTIGE-MIB/lanDeviceNumberOfEntry.h net-snmp-5.7.2/agent/mibgroup/ZYXEL-PRESTIGE-MIB/lanDeviceNumberOfEntry.h
--- net-snmp-5.7.2-orig/agent/mibgroup/ZYXEL-PRESTIGE-MIB/lanDeviceNumberOfEntry.h	1970-01-01 08:00:00.000000000 +0800
+++ net-snmp-5.7.2/agent/mibgroup/ZYXEL-PRESTIGE-MIB/lanDeviceNumberOfEntry.h	2013-10-08 09:35:17.626117000 +0800
@@ -0,0 +1,16 @@
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *        : mib2c.scalar.conf 11805 2005-01-07 09:37:18Z dts12 $
+ */
+#ifndef LANDEVICENUMBEROFENTRY_H
+#define LANDEVICENUMBEROFENTRY_H
+#include "zylib.h"
+
+/* function declarations */
+void init_lanDeviceNumberOfEntry(void);
+Netsnmp_Node_Handler handle_lanDeviceNumberOfEntry;
+config_require(ZYXEL-PRESTIGE-MIB/zylib);
+
+#define PRESTIGE_LANDEVSUM_OID PRESTIGE_COMM_OID, 10
+
+#endif /* LANDEVICENUMBEROFENTRY_H */
diff -Naur net-snmp-5.7.2-orig/agent/mibgroup/ZYXEL-PRESTIGE-MIB/prestigeDynDns.c net-snmp-5.7.2/agent/mibgroup/ZYXEL-PRESTIGE-MIB/prestigeDynDns.c
--- net-snmp-5.7.2-orig/agent/mibgroup/ZYXEL-PRESTIGE-MIB/prestigeDynDns.c	1970-01-01 08:00:00.000000000 +0800
+++ net-snmp-5.7.2/agent/mibgroup/ZYXEL-PRESTIGE-MIB/prestigeDynDns.c	2013-10-10 22:21:38.857352000 +0800
@@ -0,0 +1,558 @@
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *        : mib2c.scalar.conf 11805 2005-01-07 09:37:18Z dts12 $
+ */
+
+#include <net-snmp/net-snmp-config.h>
+#include <net-snmp/net-snmp-includes.h>
+#include <net-snmp/agent/net-snmp-agent-includes.h>
+#include "prestigeDynDns.h"
+
+#define OTHER 1
+#define YES 2
+#define NO 3
+
+/** Initializes the prestigeDynDns module */
+void
+init_prestigeDynDns(void)
+{
+    static oid ddnsActiveStatus_oid[] = { PRESTIGE_DDNS_OID, 1 };
+    static oid ddnsServiceProvider_oid[] = { PRESTIGE_DDNS_OID,2 };
+    static oid ddnsHost_oid[] = { PRESTIGE_DDNS_OID, 3 };
+    static oid ddnsType_oid[] = { PRESTIGE_DDNS_OID, 4 };
+    static oid ddnsUser_oid[] = { PRESTIGE_DDNS_OID, 5 };
+    static oid ddnsPassword_oid[] = { PRESTIGE_DDNS_OID, 6 };
+    static oid ddnsEnableWildcard_oid[] = { PRESTIGE_DDNS_OID, 7 };
+    static oid ddnsIpAddrPolicy_oid[] = { PRESTIGE_DDNS_OID, 8 };
+
+	DEBUGMSGTL(("prestigeDynDns", "Initializing\n"));
+
+    netsnmp_register_scalar(
+        netsnmp_create_handler_registration("ddnsActiveStatus", handle_ddnsActiveStatus,
+                               ddnsActiveStatus_oid, OID_LENGTH(ddnsActiveStatus_oid),
+                               HANDLER_CAN_RWRITE
+        ));
+    netsnmp_register_scalar(
+        netsnmp_create_handler_registration("ddnsServiceProvider", handle_ddnsServiceProvider,
+                               ddnsServiceProvider_oid, OID_LENGTH(ddnsServiceProvider_oid),
+                               HANDLER_CAN_RWRITE
+        ));
+    netsnmp_register_scalar(
+        netsnmp_create_handler_registration("ddnsHost", handle_ddnsHost,
+                               ddnsHost_oid, OID_LENGTH(ddnsHost_oid),
+                               HANDLER_CAN_RWRITE
+        ));
+    netsnmp_register_scalar(
+        netsnmp_create_handler_registration("ddnsType", handle_ddnsType,
+                               ddnsType_oid, OID_LENGTH(ddnsType_oid),
+                               HANDLER_CAN_RWRITE
+        ));
+    netsnmp_register_scalar(
+        netsnmp_create_handler_registration("ddnsUser", handle_ddnsUser,
+                               ddnsUser_oid, OID_LENGTH(ddnsUser_oid),
+                               HANDLER_CAN_RWRITE
+        ));
+    netsnmp_register_scalar(
+        netsnmp_create_handler_registration("ddnsPassword", handle_ddnsPassword,
+                               ddnsPassword_oid, OID_LENGTH(ddnsPassword_oid),
+                               HANDLER_CAN_RWRITE
+        ));
+    netsnmp_register_scalar(
+        netsnmp_create_handler_registration("ddnsEnableWildcard", handle_ddnsEnableWildcard,
+                               ddnsEnableWildcard_oid, OID_LENGTH(ddnsEnableWildcard_oid),
+                               HANDLER_CAN_RWRITE
+        ));
+    netsnmp_register_scalar(
+        netsnmp_create_handler_registration("ddnsIpAddrPolicy", handle_ddnsIpAddrPolicy,
+                               ddnsIpAddrPolicy_oid, OID_LENGTH(ddnsIpAddrPolicy_oid),
+                               HANDLER_CAN_RWRITE
+        ));
+}
+
+int handle_ddnsActiveStatus(netsnmp_mib_handler *handler,
+                          netsnmp_handler_registration *reginfo,
+                          netsnmp_agent_request_info   *reqinfo,
+                          netsnmp_request_info         *requests)
+{
+    int ret = SNMP_ERR_NOERROR;
+    int enbl, size;
+	char *tmp;
+	//void *buf = NULL;
+	
+    switch(reqinfo->mode) {
+
+		case MODE_GET:
+		case MODE_GETBULK:
+			ret=handleOfGetParameter(IGD_DDNS, "Enable",requests, ASN_INTEGER);
+			if(ret == SNMP_ERR_NOERROR){
+				if(*requests->requestvb->val.integer == 0) *requests->requestvb->val.integer = NO;
+				else *requests->requestvb->val.integer = YES;
+			}
+			break;
+
+        case MODE_SET_RESERVE1:
+                /* or you could use netsnmp_check_vb_type_and_size instead */
+            ret = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
+            if ( ret != SNMP_ERR_NOERROR ) {
+                netsnmp_set_request_error(reqinfo, requests, ret );
+            }
+            break;
+
+        case MODE_SET_RESERVE2:
+			enbl = *requests->requestvb->val.integer;
+			if(!(enbl == YES || enbl == NO || enbl == OTHER)){
+				ret = SNMP_ERR_GENERR;
+				netsnmp_set_request_error(reqinfo, requests, ret );
+			}
+			break;
+
+        case MODE_SET_FREE:
+            break;
+
+        case MODE_SET_ACTION:
+            /* XXX: perform the value change here */
+			enbl = *requests->requestvb->val.integer;
+			if(enbl == YES || enbl == NO ){
+				if(enbl == YES) *requests->requestvb->val.integer = 1;
+				else *requests->requestvb->val.integer = 0;
+				ret = handleOfSetParameter(IGD_DDNS, "Enable", requests);
+			}
+
+            break;
+
+        case MODE_SET_COMMIT:
+            /* XXX: delete temporary storage */
+            break;
+
+        case MODE_SET_UNDO:
+            /* XXX: UNDO and return to previous value for the object */ 
+            break;
+
+        default:
+            /* we should never get here, so this is a really bad error */
+            snmp_log(LOG_ERR, "unknown mode (%d) in %s\n", reqinfo->mode,__FUNCTION__);
+            return SNMP_ERR_GENERR;
+    }
+	
+	//if(buf) free(buf);
+    return ret;
+}
+
+int handle_ddnsServiceProvider(netsnmp_mib_handler *handler,
+                          netsnmp_handler_registration *reginfo,
+                          netsnmp_agent_request_info   *reqinfo,
+                          netsnmp_request_info         *requests)
+{
+    int ret = SNMP_ERR_NOERROR;
+    char *tmp;
+	
+    switch(reqinfo->mode) {
+
+        case MODE_GET:
+		case MODE_GETBULK:
+            ret=handleOfGetParameter(IGD_DDNS, "ServiceProvider",requests, ASN_OCTET_STR);
+            break;
+
+        case MODE_SET_RESERVE1:
+                /* or you could use netsnmp_check_vb_type_and_size instead */
+            ret = netsnmp_check_vb_type(requests->requestvb, ASN_OCTET_STR);
+            if ( ret != SNMP_ERR_NOERROR ) {
+                netsnmp_set_request_error(reqinfo, requests, ret );
+            }
+            break;
+
+        case MODE_SET_RESERVE2:
+			tmp = requests->requestvb->val.string;
+			if(!strcmp("dyndns", tmp)){
+				ret = SNMP_ERR_NOERROR;
+			} else if(!strcmp("freedns", tmp)){
+				ret = SNMP_ERR_NOERROR;
+			} else if(!strcmp("zoneedit", tmp)){
+				ret = SNMP_ERR_NOERROR;
+			} else if(!strcmp("noip", tmp)){
+				ret = SNMP_ERR_NOERROR;
+			} else if(!strcmp("gnudip", tmp)){
+				ret = SNMP_ERR_NOERROR;
+			} else {
+				ret = SNMP_ERR_GENERR;
+			}
+			
+			if ( ret != SNMP_ERR_NOERROR ) {
+                netsnmp_set_request_error(reqinfo, requests, ret );
+            }
+			break;
+			
+        case MODE_SET_FREE:
+            break;
+
+        case MODE_SET_ACTION:
+            /* XXX: perform the value change here */
+			ret=handleOfSetParameter(IGD_DDNS, "ServiceProvider", requests);
+            if (ret) {
+                netsnmp_set_request_error(reqinfo, requests, ret );
+            }
+            break;
+
+        case MODE_SET_COMMIT:
+            /* XXX: delete temporary storage */
+            break;
+
+        case MODE_SET_UNDO:
+            /* XXX: UNDO and return to previous value for the object */
+            break;
+
+        default:
+            /* we should never get here, so this is a really bad error */
+            snmp_log(LOG_ERR, "unknown mode (%d) in %s\n", reqinfo->mode,__FUNCTION__);
+            return SNMP_ERR_GENERR;
+    }
+
+    return ret;
+}
+
+int handle_ddnsHost(netsnmp_mib_handler *handler,
+                          netsnmp_handler_registration *reginfo,
+                          netsnmp_agent_request_info   *reqinfo,
+                          netsnmp_request_info         *requests)
+{
+    int ret = SNMP_ERR_NOERROR;
+	char *tmp;
+    
+    switch(reqinfo->mode) {
+
+        case MODE_GET:
+			case MODE_GETBULK:
+            ret=handleOfGetParameter(IGD_DDNS, "HostName",requests, ASN_OCTET_STR);
+            break;
+
+        case MODE_SET_RESERVE1:
+                /* or you could use netsnmp_check_vb_type_and_size instead */
+            ret = netsnmp_check_vb_type(requests->requestvb, ASN_IPADDRESS);
+            if ( ret != SNMP_ERR_NOERROR ) {
+                netsnmp_set_request_error(reqinfo, requests, ret );
+            }
+            break;
+
+        case MODE_SET_RESERVE2:
+            /* XXX malloc "undo" storage buffer */
+        case MODE_SET_FREE:
+
+            break;
+
+        case MODE_SET_ACTION:
+			ret=handleOfSetParameter(IGD_DDNS, "HostName", requests);
+            if (ret) {
+                netsnmp_set_request_error(reqinfo, requests,ret /* some error */);
+            }
+            break;
+
+        case MODE_SET_COMMIT:
+            /* XXX: delete temporary storage */
+            
+            break;
+
+        case MODE_SET_UNDO:
+            /* XXX: UNDO and return to previous value for the object */
+           
+            break;
+
+        default:
+            /* we should never get here, so this is a really bad error */
+            snmp_log(LOG_ERR, "unknown mode (%d) in %s\n", reqinfo->mode,__FUNCTION__);
+            return SNMP_ERR_GENERR;
+    }
+
+    return ret;
+}
+
+int handle_ddnsType(netsnmp_mib_handler *handler,
+                          netsnmp_handler_registration *reginfo,
+                          netsnmp_agent_request_info   *reqinfo,
+                          netsnmp_request_info         *requests)
+{
+	int ret = SNMP_ERR_NOERROR;
+    char *tmp;
+	
+    switch(reqinfo->mode) {
+        case MODE_GET:
+		case MODE_GETBULK:
+            ret=handleOfGetParameter(IGD_DDNS, "DDNSType",requests, ASN_OCTET_STR);
+            break;
+
+        case MODE_SET_RESERVE1:
+                /* or you could use netsnmp_check_vb_type_and_size instead */
+            ret = netsnmp_check_vb_type(requests->requestvb, ASN_OCTET_STR);
+            if ( ret != SNMP_ERR_NOERROR ) {
+                netsnmp_set_request_error(reqinfo, requests, ret );
+            }
+            break;
+
+        case MODE_SET_RESERVE2:
+            tmp = requests->requestvb->val.string;
+			snmp_log(LOG_ERR, "%s: %s\n", __FUNCTION__, tmp);
+			if(!strcmp("dynamic", tmp)){
+				ret = SNMP_ERR_NOERROR;
+			} else if(!strcmp("static", tmp)){
+				ret = SNMP_ERR_NOERROR;
+			} else if(!strcmp("custom", tmp)){
+				ret = SNMP_ERR_NOERROR;
+			} else {
+				ret = SNMP_ERR_GENERR;
+			}
+			
+			if ( ret != SNMP_ERR_NOERROR ) {
+                netsnmp_set_request_error(reqinfo, requests, ret );
+            }
+			break;      
+
+        case MODE_SET_FREE:
+            break;
+
+        case MODE_SET_ACTION:
+			ret=handleOfSetParameter(IGD_DDNS, "DDNSType", requests);
+            if (ret) {
+                netsnmp_set_request_error(reqinfo, requests,ret );
+            }
+            break;
+
+        case MODE_SET_COMMIT:
+            /* XXX: delete temporary storage */
+            break;
+
+        case MODE_SET_UNDO:
+            /* XXX: UNDO and return to previous value for the object */
+            break;
+
+        default:
+            /* we should never get here, so this is a really bad error */
+            snmp_log(LOG_ERR, "unknown mode (%d) in %s\n", reqinfo->mode,__FUNCTION__);
+            return SNMP_ERR_GENERR;
+    }
+
+    return ret;
+}
+
+int handle_ddnsUser(netsnmp_mib_handler *handler,
+                          netsnmp_handler_registration *reginfo,
+                          netsnmp_agent_request_info   *reqinfo,
+                          netsnmp_request_info         *requests)
+{
+    int ret = SNMP_ERR_NOERROR;
+    
+    switch(reqinfo->mode) {
+
+        case MODE_GET:
+		case MODE_GETBULK:
+            ret=handleOfGetParameter(IGD_DDNS, "UserName",requests, ASN_OCTET_STR);
+            break;
+
+        case MODE_SET_RESERVE1:
+                /* or you could use netsnmp_check_vb_type_and_size instead */
+            ret = netsnmp_check_vb_type(requests->requestvb, ASN_OCTET_STR);
+            if ( ret != SNMP_ERR_NOERROR ) {
+                netsnmp_set_request_error(reqinfo, requests, ret );
+            }
+            break;
+
+        case MODE_SET_RESERVE2:
+            /* XXX malloc "undo" storage buffer */
+			
+        case MODE_SET_FREE:
+
+            break;
+
+        case MODE_SET_ACTION:
+			ret=handleOfSetParameter(IGD_DDNS, "UserName", requests);
+            if (ret) {
+                netsnmp_set_request_error(reqinfo, requests,ret );
+            }
+            break;
+
+        case MODE_SET_COMMIT:
+            /* XXX: delete temporary storage */
+            break;
+
+        case MODE_SET_UNDO:
+            /* XXX: UNDO and return to previous value for the object */
+            break;
+
+        default:
+            /* we should never get here, so this is a really bad error */
+            snmp_log(LOG_ERR, "unknown mode (%d) in %s\n", reqinfo->mode,__FUNCTION__);
+            return SNMP_ERR_GENERR;
+    }
+
+    return ret;
+}
+
+int handle_ddnsPassword(netsnmp_mib_handler *handler,
+                          netsnmp_handler_registration *reginfo,
+                          netsnmp_agent_request_info   *reqinfo,
+                          netsnmp_request_info         *requests)
+{
+    int ret = SNMP_ERR_NOERROR;
+    
+    switch(reqinfo->mode) {
+        case MODE_GET:
+		case MODE_GETBULK:
+            ret=handleOfGetParameter(IGD_DDNS, "Password",requests, ASN_OCTET_STR);
+            break;
+
+        case MODE_SET_RESERVE1:
+            ret = netsnmp_check_vb_type(requests->requestvb, ASN_OCTET_STR);
+            if ( ret != SNMP_ERR_NOERROR ) {
+                netsnmp_set_request_error(reqinfo, requests, ret );
+            }
+            break;
+
+        case MODE_SET_RESERVE2:
+            /* XXX malloc "undo" storage buffer */
+
+        case MODE_SET_FREE:
+
+            break;
+
+        case MODE_SET_ACTION:
+			ret=handleOfSetParameter(IGD_DDNS, "Password", requests);
+            if (ret) {
+                netsnmp_set_request_error(reqinfo, requests,ret );
+            }
+            break;
+
+        case MODE_SET_COMMIT:
+            /* XXX: delete temporary storage */
+            break;
+
+        case MODE_SET_UNDO:
+            /* XXX: UNDO and return to previous value for the object */
+            break;
+
+        default:
+            /* we should never get here, so this is a really bad error */
+            snmp_log(LOG_ERR, "unknown mode (%d) in %s\n", reqinfo->mode,__FUNCTION__);
+            return SNMP_ERR_GENERR;
+    }
+
+    return ret;
+}
+
+int handle_ddnsEnableWildcard(netsnmp_mib_handler *handler,
+                          netsnmp_handler_registration *reginfo,
+                          netsnmp_agent_request_info   *reqinfo,
+                          netsnmp_request_info         *requests)
+{
+    int ret = SNMP_ERR_NOERROR;
+	int enbl, size;
+	//void *buf = NULL;
+	
+	snmp_log(LOG_ERR,"%s, enter\n", __func__);
+    switch(reqinfo->mode) {
+        case MODE_GET:
+		case MODE_GETBULK:
+			ret=handleOfGetParameter(IGD_DDNS, "Wildcard",requests, ASN_INTEGER);
+			if(ret == SNMP_ERR_NOERROR){
+				if(*requests->requestvb->val.integer == 0) *requests->requestvb->val.integer = NO;
+				else *requests->requestvb->val.integer = YES;
+			}
+
+            break;
+			
+        case MODE_SET_RESERVE1:
+            ret = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
+            if ( ret != SNMP_ERR_NOERROR ) {
+                netsnmp_set_request_error(reqinfo, requests, ret );
+            }
+            break;
+
+        case MODE_SET_RESERVE2:
+			enbl = *requests->requestvb->val.integer;
+
+			if(!(enbl == YES || enbl == NO || enbl == OTHER)){
+				ret = SNMP_ERR_GENERR;
+				netsnmp_set_request_error(reqinfo, requests, ret );
+			}
+            break;
+			
+        case MODE_SET_FREE:
+            break;
+
+        case MODE_SET_ACTION:
+			enbl = *requests->requestvb->val.integer;
+			if(enbl == YES || enbl == NO ){
+				if(enbl == YES) *requests->requestvb->val.integer = 1;
+				else *requests->requestvb->val.integer = 0;
+				ret = handleOfSetParameter(IGD_DDNS, "Wildcard", requests);
+			}
+
+            break;
+
+        case MODE_SET_COMMIT:
+            /* XXX: delete temporary storage */
+            
+            break;
+
+        case MODE_SET_UNDO:
+            /* XXX: UNDO and return to previous value for the object */
+           
+            break;
+
+        default:
+            /* we should never get here, so this is a really bad error */
+            snmp_log(LOG_ERR, "unknown mode (%d) in %s\n", reqinfo->mode,__FUNCTION__);
+            return SNMP_ERR_GENERR;
+    }
+
+	//if(buf) free(buf);
+    return ret;
+}
+
+int handle_ddnsIpAddrPolicy(netsnmp_mib_handler *handler,
+                          netsnmp_handler_registration *reginfo,
+                          netsnmp_agent_request_info   *reqinfo,
+                          netsnmp_request_info         *requests)
+{
+	int ret = SNMP_ERR_NOERROR;
+    int enbl; 
+	
+    switch(reqinfo->mode) {
+        case MODE_GET:
+		case MODE_GETBULK:
+            ret=handleOfGetParameter(IGD_DDNS, "IPAddressPolicy",requests, ASN_INTEGER);
+            break;
+
+        case MODE_SET_RESERVE1:
+                /* or you could use netsnmp_check_vb_type_and_size instead */
+            ret = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
+            if ( ret != SNMP_ERR_NOERROR ) {
+                netsnmp_set_request_error(reqinfo, requests, ret );
+            }
+            break;
+
+        case MODE_SET_RESERVE2:
+            /* XXX malloc "undo" storage buffer */ 
+        case MODE_SET_FREE:
+            break;
+
+        case MODE_SET_ACTION:
+			ret=handleOfSetParameter(IGD_DDNS, "IPAddressPolicy", requests);
+            if (ret) {
+                netsnmp_set_request_error(reqinfo, requests,ret );
+            }
+            break;
+
+        case MODE_SET_COMMIT:
+            /* XXX: delete temporary storage */
+            break;
+
+        case MODE_SET_UNDO:
+            /* XXX: UNDO and return to previous value for the object */
+            break;
+
+        default:
+            /* we should never get here, so this is a really bad error */
+            snmp_log(LOG_ERR, "unknown mode (%d) in %s\n", reqinfo->mode,__FUNCTION__);
+            return SNMP_ERR_GENERR;
+    }
+
+    return ret;
+}
diff -Naur net-snmp-5.7.2-orig/agent/mibgroup/ZYXEL-PRESTIGE-MIB/prestigeDynDns.h net-snmp-5.7.2/agent/mibgroup/ZYXEL-PRESTIGE-MIB/prestigeDynDns.h
--- net-snmp-5.7.2-orig/agent/mibgroup/ZYXEL-PRESTIGE-MIB/prestigeDynDns.h	1970-01-01 08:00:00.000000000 +0800
+++ net-snmp-5.7.2/agent/mibgroup/ZYXEL-PRESTIGE-MIB/prestigeDynDns.h	2013-10-10 22:21:38.857352000 +0800
@@ -0,0 +1,23 @@
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *        : mib2c.scalar.conf 11805 2005-01-07 09:37:18Z dts12 $
+ */
+#ifndef PRESTIGEDYNDNS_H
+#define PRESTIGEDYNDNS_H
+#include "zylib.h"
+
+/* function declarations */
+void init_prestigeDynDns(void);
+Netsnmp_Node_Handler handle_ddnsActiveStatus;
+Netsnmp_Node_Handler handle_ddnsServiceProvider;
+Netsnmp_Node_Handler handle_ddnsHost;
+Netsnmp_Node_Handler handle_ddnsType;
+Netsnmp_Node_Handler handle_ddnsUser;
+Netsnmp_Node_Handler handle_ddnsPassword;
+Netsnmp_Node_Handler handle_ddnsEnableWildcard;
+Netsnmp_Node_Handler handle_ddnsIpAddrPolicy;
+config_require(ZYXEL-PRESTIGE-MIB/zylib)
+
+#define PRESTIGE_DDNS_OID PRESTIGE_COMM_OID, 2
+
+#endif /* PRESTIGEDYNDNS_H */
diff -Naur net-snmp-5.7.2-orig/agent/mibgroup/ZYXEL-PRESTIGE-MIB/prestigeLAN.c net-snmp-5.7.2/agent/mibgroup/ZYXEL-PRESTIGE-MIB/prestigeLAN.c
--- net-snmp-5.7.2-orig/agent/mibgroup/ZYXEL-PRESTIGE-MIB/prestigeLAN.c	1970-01-01 08:00:00.000000000 +0800
+++ net-snmp-5.7.2/agent/mibgroup/ZYXEL-PRESTIGE-MIB/prestigeLAN.c	2013-10-10 22:21:38.857352000 +0800
@@ -0,0 +1,1187 @@
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *        : mib2c.scalar.conf 11805 2005-01-07 09:37:18Z dts12 $
+ */
+
+#include <net-snmp/net-snmp-config.h>
+#include <net-snmp/net-snmp-includes.h>
+#include <net-snmp/agent/net-snmp-agent-includes.h>
+#include "prestigeLAN.h"
+
+#define PRESTIGE_LAN_FILTER_OID PRESTIGE_LAN_OID, 1
+#define PRESTIGE_LAN_DHCP_OID PRESTIGE_LAN_OID, 2
+#define PRESTIGE_LAN_TCPIP_OID PRESTIGE_LAN_OID, 3
+
+/** Initializes the prestigeLAN module */
+void
+init_prestigeLAN(void)
+{
+// LAN FILTER
+    static oid inProtocolFilterSet_oid[] = { PRESTIGE_LAN_FILTER_OID, 1 };
+    static oid inDeviceFilterSet_oid[] = { PRESTIGE_LAN_FILTER_OID, 2 };
+    static oid outProtocolFilterSet_oid[] = { PRESTIGE_LAN_FILTER_OID, 3 };
+    static oid outDeviceFilterSet_oid[] = { PRESTIGE_LAN_FILTER_OID, 4 };
+// LAN DHCP
+    static oid dhcpStatus_oid[] = { PRESTIGE_LAN_DHCP_OID, 1 };
+    static oid dhcpStartIpAddr_oid[] = { PRESTIGE_LAN_DHCP_OID, 2 };
+    static oid dhcpEndIpAddr_oid[] = { PRESTIGE_LAN_DHCP_OID, 3 };
+    static oid dhcpPrimaryDnsServer_oid[] = { PRESTIGE_LAN_DHCP_OID, 4 };
+    static oid dhcpSecondaryDnsServer_oid[] = { PRESTIGE_LAN_DHCP_OID, 5 };
+    static oid dhcpRemoteDhcpServer_oid[] = { PRESTIGE_LAN_DHCP_OID, 6 };
+// LAN TCPIP
+    static oid lanIpAddress_oid[] = { PRESTIGE_LAN_TCPIP_OID, 1 };
+    static oid lanIpSubnetMask_oid[] = { PRESTIGE_LAN_TCPIP_OID, 2 };
+//    static oid lanIpRipDirection_oid[] = { PRESTIGE_LAN_TCPIP_OID, 3 };
+//    static oid lanIpRipVersion_oid[] = { PRESTIGE_LAN_TCPIP_OID, 4 };
+    static oid lanIpMulticast_oid[] = { PRESTIGE_LAN_TCPIP_OID, 5 };
+
+	DEBUGMSGTL(("prestigeLAN", "Initializing\n"));
+#if 0
+    netsnmp_register_scalar(
+        netsnmp_create_handler_registration("inProtocolFilterSet", handle_inProtocolFilterSet,
+                               inProtocolFilterSet_oid, OID_LENGTH(inProtocolFilterSet_oid),
+                               HANDLER_CAN_RWRITE
+        ));
+    netsnmp_register_scalar(
+        netsnmp_create_handler_registration("inDeviceFilterSet", handle_inDeviceFilterSet,
+                               inDeviceFilterSet_oid, OID_LENGTH(inDeviceFilterSet_oid),
+                               HANDLER_CAN_RWRITE
+        ));
+    netsnmp_register_scalar(
+        netsnmp_create_handler_registration("outProtocolFilterSet", handle_outProtocolFilterSet,
+                               outProtocolFilterSet_oid, OID_LENGTH(outProtocolFilterSet_oid),
+                               HANDLER_CAN_RWRITE
+        ));
+    netsnmp_register_scalar(
+        netsnmp_create_handler_registration("outDeviceFilterSet", handle_outDeviceFilterSet,
+                               outDeviceFilterSet_oid, OID_LENGTH(outDeviceFilterSet_oid),
+                               HANDLER_CAN_RWRITE
+        ));
+#endif
+
+// LAN DHCP handle function register
+    netsnmp_register_scalar(
+        netsnmp_create_handler_registration("dhcpStatus", handle_dhcpStatus,
+                               dhcpStatus_oid, OID_LENGTH(dhcpStatus_oid),
+                               HANDLER_CAN_RWRITE
+        ));
+
+    netsnmp_register_scalar(
+        netsnmp_create_handler_registration("dhcpStartIpAddr", handle_dhcpStartIpAddr,
+                               dhcpStartIpAddr_oid, OID_LENGTH(dhcpStartIpAddr_oid),
+                               HANDLER_CAN_RWRITE
+        ));
+
+    netsnmp_register_scalar(
+        netsnmp_create_handler_registration("dhcpEndIpAddr", handle_dhcpEndIpAddr,
+                               dhcpEndIpAddr_oid, OID_LENGTH(dhcpEndIpAddr_oid),
+                               HANDLER_CAN_RWRITE
+        ));
+    netsnmp_register_scalar(
+        netsnmp_create_handler_registration("dhcpPrimaryDnsServer", handle_dhcpPrimaryDnsServer,
+                               dhcpPrimaryDnsServer_oid, OID_LENGTH(dhcpPrimaryDnsServer_oid),
+                               HANDLER_CAN_RWRITE
+        ));
+	netsnmp_register_scalar(
+        netsnmp_create_handler_registration("dhcpSecondaryDnsServer", handle_dhcpSecondaryDnsServer,
+                               dhcpSecondaryDnsServer_oid, OID_LENGTH(dhcpSecondaryDnsServer_oid),
+                               HANDLER_CAN_RWRITE
+        ));
+   
+    netsnmp_register_scalar(
+        netsnmp_create_handler_registration("dhcpRemoteDhcpServer", handle_dhcpRemoteDhcpServer,
+                               dhcpRemoteDhcpServer_oid, OID_LENGTH(dhcpRemoteDhcpServer_oid),
+                               HANDLER_CAN_RWRITE
+        ));
+		
+// LAN TCPIP handle function register
+    netsnmp_register_scalar(
+        netsnmp_create_handler_registration("lanIpAddress", handle_lanIpAddress,
+                               lanIpAddress_oid, OID_LENGTH(lanIpAddress_oid),
+                               HANDLER_CAN_RWRITE
+        ));
+    netsnmp_register_scalar(
+        netsnmp_create_handler_registration("lanIpSubnetMask", handle_lanIpSubnetMask,
+                               lanIpSubnetMask_oid, OID_LENGTH(lanIpSubnetMask_oid),
+                               HANDLER_CAN_RWRITE
+        ));
+#if 0
+    netsnmp_register_scalar(
+        netsnmp_create_handler_registration("lanIpRipDirection", handle_lanIpRipDirection,
+                               lanIpRipDirection_oid, OID_LENGTH(lanIpRipDirection_oid),
+                               HANDLER_CAN_RWRITE
+        ));
+    netsnmp_register_scalar(
+        netsnmp_create_handler_registration("lanIpRipVersion", handle_lanIpRipVersion,
+                               lanIpRipVersion_oid, OID_LENGTH(lanIpRipVersion_oid),
+                               HANDLER_CAN_RWRITE
+        ));
+#endif
+    netsnmp_register_scalar(
+        netsnmp_create_handler_registration("lanIpMulticast", handle_lanIpMulticast,
+                               lanIpMulticast_oid, OID_LENGTH(lanIpMulticast_oid),
+                               HANDLER_CAN_RWRITE
+        ));
+
+}
+
+#if 0
+int
+handle_inProtocolFilterSet(netsnmp_mib_handler *handler,
+                          netsnmp_handler_registration *reginfo,
+                          netsnmp_agent_request_info   *reqinfo,
+                          netsnmp_request_info         *requests)
+{
+    int ret;
+    /* We are never called for a GETNEXT if it's registered as a
+       "instance", as it's "magically" handled for us.  */
+
+    /* a instance handler also only hands us one request at a time, so
+       we don't need to loop over a list of requests; we'll only get one. */
+    
+    switch(reqinfo->mode) {
+
+        case MODE_GET:
+            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
+                                     (u_char *) /* XXX: a pointer to the scalar's data */,
+                                     /* XXX: the length of the data in bytes */);
+            break;
+
+        /*
+         * SET REQUEST
+         *
+         * multiple states in the transaction.  See:
+         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
+         */
+        case MODE_SET_RESERVE1:
+                /* or you could use netsnmp_check_vb_type_and_size instead */
+            ret = netsnmp_check_vb_type(requests->requestvb, ASN_OCTET_STR);
+            if ( ret != SNMP_ERR_NOERROR ) {
+                netsnmp_set_request_error(reqinfo, requests, ret );
+            }
+            break;
+
+        case MODE_SET_RESERVE2:
+            /* XXX malloc "undo" storage buffer */
+            if (/* XXX if malloc, or whatever, failed: */) {
+                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_RESOURCEUNAVAILABLE);
+            }
+            break;
+
+        case MODE_SET_FREE:
+            /* XXX: free resources allocated in RESERVE1 and/or
+               RESERVE2.  Something failed somewhere, and the states
+               below won't be called. */
+            break;
+
+        case MODE_SET_ACTION:
+            /* XXX: perform the value change here */
+            if (/* XXX: error? */) {
+                netsnmp_set_request_error(reqinfo, requests, /* some error */);
+            }
+            break;
+
+        case MODE_SET_COMMIT:
+            /* XXX: delete temporary storage */
+            if (/* XXX: error? */) {
+                /* try _really_really_ hard to never get to this point */
+                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
+            }
+            break;
+
+        case MODE_SET_UNDO:
+            /* XXX: UNDO and return to previous value for the object */
+            if (/* XXX: error? */) {
+                /* try _really_really_ hard to never get to this point */
+                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_UNDOFAILED);
+            }
+            break;
+
+        default:
+            /* we should never get here, so this is a really bad error */
+            ZYSNMP_ERR( "unknown mode (%d) in handle_inProtocolFilterSet\n", reqinfo->mode );
+            return SNMP_ERR_GENERR;
+    }
+
+    return SNMP_ERR_NOERROR;
+}
+int
+handle_inDeviceFilterSet(netsnmp_mib_handler *handler,
+                          netsnmp_handler_registration *reginfo,
+                          netsnmp_agent_request_info   *reqinfo,
+                          netsnmp_request_info         *requests)
+{
+    int ret;
+    /* We are never called for a GETNEXT if it's registered as a
+       "instance", as it's "magically" handled for us.  */
+
+    /* a instance handler also only hands us one request at a time, so
+       we don't need to loop over a list of requests; we'll only get one. */
+    
+    switch(reqinfo->mode) {
+
+        case MODE_GET:
+            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
+                                     (u_char *) /* XXX: a pointer to the scalar's data */,
+                                     /* XXX: the length of the data in bytes */);
+            break;
+
+        /*
+         * SET REQUEST
+         *
+         * multiple states in the transaction.  See:
+         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
+         */
+        case MODE_SET_RESERVE1:
+                /* or you could use netsnmp_check_vb_type_and_size instead */
+            ret = netsnmp_check_vb_type(requests->requestvb, ASN_OCTET_STR);
+            if ( ret != SNMP_ERR_NOERROR ) {
+                netsnmp_set_request_error(reqinfo, requests, ret );
+            }
+            break;
+
+        case MODE_SET_RESERVE2:
+            /* XXX malloc "undo" storage buffer */
+            if (/* XXX if malloc, or whatever, failed: */) {
+                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_RESOURCEUNAVAILABLE);
+            }
+            break;
+
+        case MODE_SET_FREE:
+            /* XXX: free resources allocated in RESERVE1 and/or
+               RESERVE2.  Something failed somewhere, and the states
+               below won't be called. */
+            break;
+
+        case MODE_SET_ACTION:
+            /* XXX: perform the value change here */
+            if (/* XXX: error? */) {
+                netsnmp_set_request_error(reqinfo, requests, /* some error */);
+            }
+            break;
+
+        case MODE_SET_COMMIT:
+            /* XXX: delete temporary storage */
+            if (/* XXX: error? */) {
+                /* try _really_really_ hard to never get to this point */
+                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
+            }
+            break;
+
+        case MODE_SET_UNDO:
+            /* XXX: UNDO and return to previous value for the object */
+            if (/* XXX: error? */) {
+                /* try _really_really_ hard to never get to this point */
+                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_UNDOFAILED);
+            }
+            break;
+
+        default:
+            /* we should never get here, so this is a really bad error */
+            ZYSNMP_ERR( "unknown mode (%d)\n", reqinfo->mode );
+            return SNMP_ERR_GENERR;
+    }
+
+    return SNMP_ERR_NOERROR;
+}
+int
+handle_outProtocolFilterSet(netsnmp_mib_handler *handler,
+                          netsnmp_handler_registration *reginfo,
+                          netsnmp_agent_request_info   *reqinfo,
+                          netsnmp_request_info         *requests)
+{
+    int ret;
+    /* We are never called for a GETNEXT if it's registered as a
+       "instance", as it's "magically" handled for us.  */
+
+    /* a instance handler also only hands us one request at a time, so
+       we don't need to loop over a list of requests; we'll only get one. */
+    
+    switch(reqinfo->mode) {
+
+        case MODE_GET:
+            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
+                                     (u_char *) /* XXX: a pointer to the scalar's data */,
+                                     /* XXX: the length of the data in bytes */);
+            break;
+
+        /*
+         * SET REQUEST
+         *
+         * multiple states in the transaction.  See:
+         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
+         */
+        case MODE_SET_RESERVE1:
+                /* or you could use netsnmp_check_vb_type_and_size instead */
+            ret = netsnmp_check_vb_type(requests->requestvb, ASN_OCTET_STR);
+            if ( ret != SNMP_ERR_NOERROR ) {
+                netsnmp_set_request_error(reqinfo, requests, ret );
+            }
+            break;
+
+        case MODE_SET_RESERVE2:
+            /* XXX malloc "undo" storage buffer */
+            if (/* XXX if malloc, or whatever, failed: */) {
+                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_RESOURCEUNAVAILABLE);
+            }
+            break;
+
+        case MODE_SET_FREE:
+            /* XXX: free resources allocated in RESERVE1 and/or
+               RESERVE2.  Something failed somewhere, and the states
+               below won't be called. */
+            break;
+
+        case MODE_SET_ACTION:
+            /* XXX: perform the value change here */
+            if (/* XXX: error? */) {
+                netsnmp_set_request_error(reqinfo, requests, /* some error */);
+            }
+            break;
+
+        case MODE_SET_COMMIT:
+            /* XXX: delete temporary storage */
+            if (/* XXX: error? */) {
+                /* try _really_really_ hard to never get to this point */
+                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
+            }
+            break;
+
+        case MODE_SET_UNDO:
+            /* XXX: UNDO and return to previous value for the object */
+            if (/* XXX: error? */) {
+                /* try _really_really_ hard to never get to this point */
+                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_UNDOFAILED);
+            }
+            break;
+
+        default:
+            /* we should never get here, so this is a really bad error */
+            ZYSNMP_ERR( "unknown mode (%d)\n", reqinfo->mode );
+            return SNMP_ERR_GENERR;
+    }
+
+    return SNMP_ERR_NOERROR;
+}
+int
+handle_outDeviceFilterSet(netsnmp_mib_handler *handler,
+                          netsnmp_handler_registration *reginfo,
+                          netsnmp_agent_request_info   *reqinfo,
+                          netsnmp_request_info         *requests)
+{
+    int ret;
+    /* We are never called for a GETNEXT if it's registered as a
+       "instance", as it's "magically" handled for us.  */
+
+    /* a instance handler also only hands us one request at a time, so
+       we don't need to loop over a list of requests; we'll only get one. */
+    
+    switch(reqinfo->mode) {
+
+        case MODE_GET:
+            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
+                                     (u_char *) /* XXX: a pointer to the scalar's data */,
+                                     /* XXX: the length of the data in bytes */);
+            break;
+
+        /*
+         * SET REQUEST
+         *
+         * multiple states in the transaction.  See:
+         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
+         */
+        case MODE_SET_RESERVE1:
+                /* or you could use netsnmp_check_vb_type_and_size instead */
+            ret = netsnmp_check_vb_type(requests->requestvb, ASN_OCTET_STR);
+            if ( ret != SNMP_ERR_NOERROR ) {
+                netsnmp_set_request_error(reqinfo, requests, ret );
+            }
+            break;
+
+        case MODE_SET_RESERVE2:
+            /* XXX malloc "undo" storage buffer */
+            if (/* XXX if malloc, or whatever, failed: */) {
+                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_RESOURCEUNAVAILABLE);
+            }
+            break;
+
+        case MODE_SET_FREE:
+            /* XXX: free resources allocated in RESERVE1 and/or
+               RESERVE2.  Something failed somewhere, and the states
+               below won't be called. */
+            break;
+
+        case MODE_SET_ACTION:
+            /* XXX: perform the value change here */
+            if (/* XXX: error? */) {
+                netsnmp_set_request_error(reqinfo, requests, /* some error */);
+            }
+            break;
+
+        case MODE_SET_COMMIT:
+            /* XXX: delete temporary storage */
+            if (/* XXX: error? */) {
+                /* try _really_really_ hard to never get to this point */
+                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
+            }
+            break;
+
+        case MODE_SET_UNDO:
+            /* XXX: UNDO and return to previous value for the object */
+            if (/* XXX: error? */) {
+                /* try _really_really_ hard to never get to this point */
+                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_UNDOFAILED);
+            }
+            break;
+
+        default:
+            /* we should never get here, so this is a really bad error */
+            ZYSNMP_ERR( "unknown mode (%d)\n", reqinfo->mode );
+            return SNMP_ERR_GENERR;
+    }
+
+    return SNMP_ERR_NOERROR;
+}
+#endif
+
+
+int handle_dhcpStatus(netsnmp_mib_handler *handler,
+                          netsnmp_handler_registration *reginfo,
+                          netsnmp_agent_request_info   *reqinfo,
+                          netsnmp_request_info         *requests)
+{
+	int ret = SNMP_ERR_NOERROR, enbl;
+	char ifname[10];
+	
+	ZYSNMP_DEBUG("enter\n");
+	
+    switch(reqinfo->mode) {
+        case MODE_GET:
+		case MODE_GETBULK:
+			sprintf(ifname,"br%d", 0);
+			ret = handleOfLanDhcpRelayParam(ifname, "Enable", requests, ASN_INTEGER , HANDLE_GET);
+			if(ret == SNMP_ERR_NOERROR && *requests->requestvb->val.integer == 1){
+				*requests->requestvb->val.integer = DHCP_RELAY;
+			}
+			else{
+				ret = handleOfLanDhcpParam(ifname, "Enable", requests, ASN_INTEGER , HANDLE_GET);
+				if(ret == SNMP_ERR_NOERROR && *requests->requestvb->val.integer == 1){
+					*requests->requestvb->val.integer = DHCP_SERVER;
+				}
+				else{
+					ret = SNMP_ERR_NOERROR;
+					enbl = DHCP_DISABLE;
+					snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *)&enbl, sizeof(enbl));
+				}
+			}
+            break;
+
+        case MODE_SET_RESERVE1:
+                /* or you could use netsnmp_check_vb_type_and_size instead */
+            ret = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
+            if ( ret != SNMP_ERR_NOERROR ) {
+                netsnmp_set_request_error(reqinfo, requests, ret );
+            }
+            break;
+
+        case MODE_SET_RESERVE2:
+			enbl = *requests->requestvb->val.integer;
+			if(!(enbl == DHCP_DISABLE || enbl == DHCP_SERVER || enbl == DHCP_RELAY )){
+				ret = SNMP_ERR_GENERR;
+				netsnmp_set_request_error(reqinfo, requests, ret );
+			}
+            break;
+
+        case MODE_SET_FREE:
+            break;
+
+        case MODE_SET_ACTION:
+			sprintf(ifname,"br%d", 0);
+			enbl = *requests->requestvb->val.integer;
+			ret = handleOfChangeDhcpMode(ifname, enbl);
+            if (ret) {
+                netsnmp_set_request_error(reqinfo, requests,ret /* some error */);
+            }
+            break;
+
+        case MODE_SET_COMMIT:
+
+            break;
+
+        case MODE_SET_UNDO:
+
+            break;
+
+        default:
+            ZYSNMP_ERR( "unknown mode (%d)\n", reqinfo->mode );
+            return SNMP_ERR_GENERR;
+    }
+
+    return ret;
+}
+
+int handle_dhcpStartIpAddr(netsnmp_mib_handler *handler,
+                          netsnmp_handler_registration *reginfo,
+                          netsnmp_agent_request_info   *reqinfo,
+                          netsnmp_request_info         *requests)
+{
+    int ret = SNMP_ERR_NOERROR;
+	char ifname[10];
+	
+	ZYSNMP_DEBUG("enter\n");
+	
+	switch(reqinfo->mode) {
+        case MODE_GET:
+		case MODE_GETBULK:
+			sprintf(ifname,"br%d", 0);
+			ret = handleOfLanDhcpParam(ifname, "MinAddress", requests, ASN_OCTET_STR ,HANDLE_GET);
+			if(ret != SNMP_ERR_NOERROR) netsnmp_set_request_error(reqinfo, requests, ret );
+            break;
+
+        case MODE_SET_RESERVE1:
+            ret = netsnmp_check_vb_type(requests->requestvb, ASN_OCTET_STR);
+            if ( ret != SNMP_ERR_NOERROR ) {
+                netsnmp_set_request_error(reqinfo, requests, ret );
+            }
+            break;
+
+        case MODE_SET_RESERVE2:
+			if(checkIpAddress(requests->requestvb->val.string) != 1){
+				ret = SNMP_ERR_GENERR;
+				netsnmp_set_request_error(reqinfo, requests, ret );
+			}
+            break;
+
+        case MODE_SET_FREE:
+
+            break;
+
+        case MODE_SET_ACTION:
+			sprintf(ifname,"br%d", 0);
+			ret = handleOfLanDhcpPoolAddr(ifname, requests->requestvb->val.string, NULL, strlen(requests->requestvb->val.string), HANDLE_SET);
+            if (ret) {
+                netsnmp_set_request_error(reqinfo, requests,ret /* some error */);
+            }
+            break;
+
+        case MODE_SET_COMMIT:
+
+            break;
+
+        case MODE_SET_UNDO:
+
+            break;
+
+        default:
+            /* we should never get here, so this is a really bad error */
+            ZYSNMP_ERR( "unknown mode (%d)\n", reqinfo->mode);
+            return SNMP_ERR_GENERR;
+    }
+
+    return ret;
+}
+
+int handle_dhcpEndIpAddr(netsnmp_mib_handler *handler,
+                          netsnmp_handler_registration *reginfo,
+                          netsnmp_agent_request_info   *reqinfo,
+                          netsnmp_request_info         *requests)
+{
+    int ret = SNMP_ERR_NOERROR;
+	char ifname[10];
+	
+	ZYSNMP_DEBUG("enter\n");
+	
+	switch(reqinfo->mode) {
+        case MODE_GET:
+		case MODE_GETBULK:
+			sprintf(ifname,"br%d", 0);
+			ret = handleOfLanDhcpParam(ifname, "MaxAddress", requests, ASN_OCTET_STR , HANDLE_GET);
+			if(ret != SNMP_ERR_NOERROR) netsnmp_set_request_error(reqinfo, requests, ret );
+            break;
+
+        case MODE_SET_RESERVE1:
+            ret = netsnmp_check_vb_type(requests->requestvb, ASN_OCTET_STR);
+            if ( ret != SNMP_ERR_NOERROR ) {
+                netsnmp_set_request_error(reqinfo, requests, ret );
+            }
+            break;
+
+        case MODE_SET_RESERVE2:
+
+            break;
+
+        case MODE_SET_FREE:
+
+            break;
+
+        case MODE_SET_ACTION:
+			sprintf(ifname,"br%d", 0);
+			ret = handleOfLanDhcpPoolAddr(ifname, NULL, requests->requestvb->val.string, strlen(requests->requestvb->val.string), HANDLE_SET);
+            if (ret) {
+                netsnmp_set_request_error(reqinfo, requests,ret /* some error */);
+            }
+            break;
+
+        case MODE_SET_COMMIT:
+
+            break;
+
+        case MODE_SET_UNDO:
+
+            break;
+
+        default:
+            /* we should never get here, so this is a really bad error */
+            ZYSNMP_ERR( "unknown mode (%d)\n", reqinfo->mode);
+            return SNMP_ERR_GENERR;
+    }
+
+    return ret;
+}
+
+#define DNSADDRLEN 20
+int handle_dhcpPrimaryDnsServer(netsnmp_mib_handler *handler,
+                          netsnmp_handler_registration *reginfo,
+                          netsnmp_agent_request_info   *reqinfo,
+                          netsnmp_request_info         *requests)
+{
+    int ret = SNMP_ERR_NOERROR;
+	char ifname[10], *dns1;
+	
+	ZYSNMP_DEBUG("enter\n");
+	
+	switch(reqinfo->mode) {
+        case MODE_GET:
+		case MODE_GETBULK:
+			sprintf(ifname,"br%d", 0);
+			dns1 = malloc(DNSADDRLEN);
+			dns1[0] = '\0';
+			ret = handleOfLanDhcpDns(ifname, dns1, NULL, DNSADDRLEN, HANDLE_GET);
+			if(ret == SNMP_ERR_NOERROR){
+				ZYSNMP_DEBUG("DNS primary address: %s\n", dns1);
+				snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR, (u_char *)dns1, strlen(dns1));
+			}
+			else netsnmp_set_request_error(reqinfo, requests, ret );
+			free(dns1);
+            break;
+
+        case MODE_SET_RESERVE1:
+            ret = netsnmp_check_vb_type(requests->requestvb, ASN_OCTET_STR);
+            if ( ret != SNMP_ERR_NOERROR ) {
+                netsnmp_set_request_error(reqinfo, requests, ret );
+            }
+            break;
+
+        case MODE_SET_RESERVE2:
+			if(strcmp(requests->requestvb->val.string, "")){
+				if(checkIpAddress(requests->requestvb->val.string) != 1){
+					ret = SNMP_ERR_GENERR;
+					netsnmp_set_request_error(reqinfo, requests, ret );
+				}
+			}
+            break;
+
+        case MODE_SET_FREE:
+
+            break;
+
+        case MODE_SET_ACTION:
+			sprintf(ifname,"br%d", 0);
+			dns1 = requests->requestvb->val.string;
+			ret = handleOfLanDhcpDns(ifname, dns1, NULL, strlen(dns1), HANDLE_SET);
+			
+			if(ret != SNMP_ERR_NOERROR){
+				netsnmp_set_request_error(reqinfo, requests, ret );
+			}
+            break;
+
+        case MODE_SET_COMMIT:
+
+            break;
+
+        case MODE_SET_UNDO:
+
+            break;
+
+        default:
+            /* we should never get here, so this is a really bad error */
+            ZYSNMP_ERR( "unknown mode (%d)\n", reqinfo->mode);
+            return SNMP_ERR_GENERR;
+    }
+
+    return ret;
+}
+
+int handle_dhcpSecondaryDnsServer(netsnmp_mib_handler *handler,
+                          netsnmp_handler_registration *reginfo,
+                          netsnmp_agent_request_info   *reqinfo,
+                          netsnmp_request_info         *requests)
+{
+    int ret = SNMP_ERR_NOERROR;
+	char ifname[10], *dns2;
+	
+	ZYSNMP_DEBUG("enter\n");
+	
+	switch(reqinfo->mode) {
+        case MODE_GET:
+		case MODE_GETBULK:
+			sprintf(ifname,"br%d", 0);
+			dns2 = malloc(DNSADDRLEN);
+			dns2[0] = '\0';
+			ret = handleOfLanDhcpDns(ifname, NULL, dns2, DNSADDRLEN, HANDLE_GET);
+			if(ret == SNMP_ERR_NOERROR){
+				ZYSNMP_DEBUG("DNS secondary address: %s\n", dns2);
+				snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR, (u_char *)dns2, strlen(dns2));
+			}
+			else netsnmp_set_request_error(reqinfo, requests, ret );
+			free(dns2);
+            break;
+
+        case MODE_SET_RESERVE1:
+            ret = netsnmp_check_vb_type(requests->requestvb, ASN_OCTET_STR);
+            if ( ret != SNMP_ERR_NOERROR ) {
+                netsnmp_set_request_error(reqinfo, requests, ret );
+            }
+            break;
+
+        case MODE_SET_RESERVE2:
+			if(strcmp(requests->requestvb->val.string, "")){
+				if(checkIpAddress(requests->requestvb->val.string) != 1){
+					ret = SNMP_ERR_GENERR;
+					netsnmp_set_request_error(reqinfo, requests, ret );
+				}
+			}
+            break;
+
+        case MODE_SET_FREE:
+
+            break;
+
+        case MODE_SET_ACTION:
+			sprintf(ifname,"br%d", 0);
+			dns2 = requests->requestvb->val.string;
+			ret = handleOfLanDhcpDns(ifname, NULL, dns2, strlen(dns2), HANDLE_SET);
+			
+			if(ret != SNMP_ERR_NOERROR){
+				netsnmp_set_request_error(reqinfo, requests, ret );
+			}
+            break;
+
+        case MODE_SET_COMMIT:
+
+            break;
+
+        case MODE_SET_UNDO:
+
+            break;
+
+        default:
+            /* we should never get here, so this is a really bad error */
+            ZYSNMP_ERR( "unknown mode (%d)\n", reqinfo->mode);
+            return SNMP_ERR_GENERR;
+    }
+
+    return ret;
+}
+
+int handle_dhcpRemoteDhcpServer(netsnmp_mib_handler *handler,
+                          netsnmp_handler_registration *reginfo,
+                          netsnmp_agent_request_info   *reqinfo,
+                          netsnmp_request_info         *requests)
+{
+	 int ret = SNMP_ERR_NOERROR;
+    char ifname[10];
+	
+	ZYSNMP_DEBUG("enter\n");
+	
+	switch(reqinfo->mode) {
+        case MODE_GET:
+		case MODE_GETBULK:
+			sprintf(ifname,"br%d", 0);
+			ret = handleOfLanDhcpRelayParam(ifname, "DHCPServerIPAddress", requests, ASN_OCTET_STR , HANDLE_GET);	
+			if(ret != SNMP_ERR_NOERROR){
+				 netsnmp_set_request_error(reqinfo, requests, ret );
+			}
+            break;
+
+        case MODE_SET_RESERVE1:
+            ret = netsnmp_check_vb_type(requests->requestvb, ASN_OCTET_STR);
+            if ( ret != SNMP_ERR_NOERROR ) {
+                netsnmp_set_request_error(reqinfo, requests, ret );
+            }
+            break;
+
+        case MODE_SET_RESERVE2:
+			if(checkIpAddress(requests->requestvb->val.string) != 1){
+				ret = SNMP_ERR_GENERR;
+				netsnmp_set_request_error(reqinfo, requests, ret );
+			}
+            break;
+
+        case MODE_SET_FREE:
+
+            break;
+
+        case MODE_SET_ACTION:
+			sprintf(ifname,"br%d", 0);
+			ret = handleOfLanDhcpRelayParam(ifname, "DHCPServerIPAddress", requests, ASN_OCTET_STR , HANDLE_SET);	
+			if(ret != SNMP_ERR_NOERROR){
+				 netsnmp_set_request_error(reqinfo, requests, ret );
+			}
+            break;
+
+        case MODE_SET_COMMIT:
+            break;
+
+        case MODE_SET_UNDO:
+            break;
+
+        default:
+            /* we should never get here, so this is a really bad error */
+            ZYSNMP_ERR("unknown mode (%d) in %s\n", reqinfo->mode);
+			return SNMP_ERR_GENERR;
+   	}
+	return ret;
+}
+
+int handle_lanIpAddress(netsnmp_mib_handler *handler,
+                          netsnmp_handler_registration *reginfo,
+                          netsnmp_agent_request_info   *reqinfo,
+                          netsnmp_request_info         *requests)
+{
+    int ret = SNMP_ERR_NOERROR;
+	char ifname[10];
+	
+	ZYSNMP_DEBUG("enter\n");
+	
+    switch(reqinfo->mode) {
+
+        case MODE_GET:
+		case MODE_GETBULK:
+			sprintf(ifname,"br%d", 0);
+			ret = handleOfLanAddrParam(ifname, "IPAddress", requests, ASN_OCTET_STR , HANDLE_GET);
+            break;
+
+        case MODE_SET_RESERVE1:
+                /* or you could use netsnmp_check_vb_type_and_size instead */
+			ret = netsnmp_check_vb_type(requests->requestvb, ASN_OCTET_STR);		
+            if ( ret != SNMP_ERR_NOERROR ) {
+                netsnmp_set_request_error(reqinfo, requests, ret );
+            }
+            break;
+
+        case MODE_SET_RESERVE2:
+            if(checkIpAddress(requests->requestvb->val.string) != 1){
+				ret = SNMP_ERR_GENERR;
+				netsnmp_set_request_error(reqinfo, requests, ret );
+			}
+			break;
+
+        case MODE_SET_FREE:
+
+            break;
+			
+        case MODE_SET_ACTION:
+			sprintf(ifname,"br%d", 0);
+			ret = handleOfLanAddrParam(ifname, "IPAddress", requests, ASN_OCTET_STR , HANDLE_SET);
+			if (ret  != SNMP_ERR_NOERROR) {
+                netsnmp_set_request_error(reqinfo, requests, ret/* some error */);
+            }
+            break;
+
+        case MODE_SET_COMMIT:
+            /* XXX: delete temporary storage */
+            
+            break;
+
+        case MODE_SET_UNDO:
+            /* XXX: UNDO and return to previous value for the object */
+           
+            break;
+
+        default:
+            /* we should never get here, so this is a really bad error */
+            ZYSNMP_ERR( "unknown mode (%d)\n", reqinfo->mode);
+            return SNMP_ERR_GENERR;
+    }
+
+    return ret;
+}
+
+int handle_lanIpSubnetMask(netsnmp_mib_handler *handler,
+                          netsnmp_handler_registration *reginfo,
+                          netsnmp_agent_request_info   *reqinfo,
+                          netsnmp_request_info         *requests)
+{
+    int ret = SNMP_ERR_NOERROR;
+	char ifname[10];
+	
+	ZYSNMP_DEBUG("enter\n");
+	
+    switch(reqinfo->mode) {
+        case MODE_GET:
+		case MODE_GETBULK:
+			sprintf(ifname,"br%d", 0);
+			ret = handleOfLanAddrParam(ifname, "SubnetMask", requests, ASN_OCTET_STR , HANDLE_GET);
+            break;
+
+        case MODE_SET_RESERVE1:
+                /* or you could use netsnmp_check_vb_type_and_size instead */
+            ret = netsnmp_check_vb_type(requests->requestvb, ASN_OCTET_STR);
+            if ( ret != SNMP_ERR_NOERROR ) {
+                netsnmp_set_request_error(reqinfo, requests, ret );
+            }
+            break;
+
+        case MODE_SET_RESERVE2:
+            if(checkSubnetMask(requests->requestvb->val.string) != 1){
+				ret = SNMP_ERR_GENERR;
+				netsnmp_set_request_error(reqinfo, requests, ret );
+			}
+			break;
+
+        case MODE_SET_FREE:
+
+            break;
+			
+        case MODE_SET_ACTION:
+			sprintf(ifname,"br%d", 0);
+			ret = handleOfLanAddrParam(ifname, "SubnetMask", requests, ASN_OCTET_STR , HANDLE_SET);
+			if (ret  != SNMP_ERR_NOERROR) {
+                netsnmp_set_request_error(reqinfo, requests, ret/* some error */);
+            }
+            break;
+			
+        case MODE_SET_COMMIT:
+            
+            break;
+
+        case MODE_SET_UNDO:
+           
+            break;
+
+        default:
+            /* we should never get here, so this is a really bad error */
+            ZYSNMP_ERR( "unknown mode (%d) in %s\n", reqinfo->mode,__FUNCTION__);
+            return SNMP_ERR_GENERR;
+    }
+
+    return ret;
+}
+
+#if 0
+int
+handle_lanIpRipDirection(netsnmp_mib_handler *handler,
+                          netsnmp_handler_registration *reginfo,
+                          netsnmp_agent_request_info   *reqinfo,
+                          netsnmp_request_info         *requests)
+{
+#if 0
+    int ret;
+    /* We are never called for a GETNEXT if it's registered as a
+       "instance", as it's "magically" handled for us.  */
+
+    /* a instance handler also only hands us one request at a time, so
+       we don't need to loop over a list of requests; we'll only get one. */
+    
+    switch(reqinfo->mode) {
+
+        case MODE_GET:
+            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
+                                     (u_char *) /* XXX: a pointer to the scalar's data */,
+                                     /* XXX: the length of the data in bytes */);
+            break;
+
+        /*
+         * SET REQUEST
+         *
+         * multiple states in the transaction.  See:
+         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
+         */
+        case MODE_SET_RESERVE1:
+                /* or you could use netsnmp_check_vb_type_and_size instead */
+            ret = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
+            if ( ret != SNMP_ERR_NOERROR ) {
+                netsnmp_set_request_error(reqinfo, requests, ret );
+            }
+            break;
+
+        case MODE_SET_RESERVE2:
+            /* XXX malloc "undo" storage buffer */
+            if (/* XXX if malloc, or whatever, failed: */) {
+                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_RESOURCEUNAVAILABLE);
+            }
+            break;
+
+        case MODE_SET_FREE:
+            /* XXX: free resources allocated in RESERVE1 and/or
+               RESERVE2.  Something failed somewhere, and the states
+               below won't be called. */
+            break;
+
+        case MODE_SET_ACTION:
+            /* XXX: perform the value change here */
+            if (/* XXX: error? */) {
+                netsnmp_set_request_error(reqinfo, requests, /* some error */);
+            }
+            break;
+
+        case MODE_SET_COMMIT:
+            /* XXX: delete temporary storage */
+            if (/* XXX: error? */) {
+                /* try _really_really_ hard to never get to this point */
+                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
+            }
+            break;
+
+        case MODE_SET_UNDO:
+            /* XXX: UNDO and return to previous value for the object */
+            if (/* XXX: error? */) {
+                /* try _really_really_ hard to never get to this point */
+                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_UNDOFAILED);
+            }
+            break;
+
+        default:
+            /* we should never get here, so this is a really bad error */
+            ZYSNMP_ERR( "unknown mode (%d) in handle_lanIpRipDirection\n", reqinfo->mode );
+            return SNMP_ERR_GENERR;
+    }
+#endif
+    return SNMP_ERR_NOERROR;
+}
+
+int handle_lanIpRipVersion(netsnmp_mib_handler *handler,
+                          netsnmp_handler_registration *reginfo,
+                          netsnmp_agent_request_info   *reqinfo,
+                          netsnmp_request_info         *requests)
+{
+    int ret;
+
+    switch(reqinfo->mode) {
+        case MODE_GET:
+		case MODE_GETBULK:
+            ret=handleOfGetParameter(InternetGatewayDevice_LANDevice_1_LANEthernetInterfaceConfig_1, "X_ZyXEL_RIP_Version",requests, ASN_OCTET_STR);
+            break;
+			
+        case MODE_SET_RESERVE1:
+            ret = netsnmp_check_vb_type(requests->requestvb, ASN_OCTET_STR);
+            if ( ret != SNMP_ERR_NOERROR ) {
+                netsnmp_set_request_error(reqinfo, requests, ret );
+            }
+            break;
+
+        case MODE_SET_RESERVE2:
+            /* XXX malloc "undo" storage buffer */
+           
+
+        case MODE_SET_FREE:
+            /* XXX: free resources allocated in RESERVE1 and/or
+               RESERVE2.  Something failed somewhere, and the states
+               below won't be called. */
+            break;
+
+        case MODE_SET_ACTION:
+            /* XXX: perform the value change here */
+			ret=handleOfSetParameter(InternetGatewayDevice_LANDevice_1_LANEthernetInterfaceConfig_1, "X_ZyXEL_RIP_Version", requests);
+            if (/* XXX: error? */ret) {
+                netsnmp_set_request_error(reqinfo, requests,ret /* some error */);
+            }
+            break;
+
+        case MODE_SET_COMMIT:
+            /* XXX: delete temporary storage */
+            
+            break;
+
+        case MODE_SET_UNDO:
+            /* XXX: UNDO and return to previous value for the object */
+           
+            break;
+
+        default:
+            /* we should never get here, so this is a really bad error */
+            ZYSNMP_ERR( "unknown mode (%d) in %s\n", reqinfo->mode,__FUNCTION__);
+            return SNMP_ERR_GENERR;
+    }
+
+    return ret;
+}
+#endif
+
+#define IGMP_V1 2
+#define IGMP_V2 3
+#define IGMP_V3 4
+int handle_lanIpMulticast(netsnmp_mib_handler *handler,
+                          netsnmp_handler_registration *reginfo,
+                          netsnmp_agent_request_info   *reqinfo,
+                          netsnmp_request_info         *requests)
+{
+	int ver, size;
+    int ret = SNMP_ERR_NOERROR;
+	char *tmp;
+	void *buf = NULL;
+
+    switch(reqinfo->mode) {
+        case MODE_GET:
+		case MODE_GETBULK:
+            ret=handleOfGetParameter(IGD_LAN_IGMP, "IgmpVersion",requests, ASN_INTEGER);
+			if(ret == SNMP_ERR_NOERROR){
+				if(*requests->requestvb->val.integer == 1) *requests->requestvb->val.integer = IGMP_V1;
+				else if (*requests->requestvb->val.integer == 2) *requests->requestvb->val.integer = IGMP_V2;
+				else if (*requests->requestvb->val.integer == 3) *requests->requestvb->val.integer = IGMP_V3;
+			}
+
+            break;
+
+        case MODE_SET_RESERVE1:
+            ret = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
+            if ( ret != SNMP_ERR_NOERROR ) {
+                netsnmp_set_request_error(reqinfo, requests, ret );
+            }
+            break;
+
+        case MODE_SET_RESERVE2:
+            ver = *requests->requestvb->val.integer;
+			if(!(ver == IGMP_V1 || ver == IGMP_V2 || ver == IGMP_V3)){
+				ret = SNMP_ERR_GENERR;
+				netsnmp_set_request_error(reqinfo, requests, ret );
+			}
+			break;
+
+        case MODE_SET_FREE:
+            break;
+
+        case MODE_SET_ACTION:
+			ver = *requests->requestvb->val.integer;
+			if(ver == IGMP_V1)requests->requestvb->val.integer = 1;
+			else if(ver == IGMP_V2)requests->requestvb->val.integer = 2;
+			else if(ver == IGMP_V3)requests->requestvb->val.integer = 3;
+			else break;
+			
+			ret=handleOfSetParameter(IGD_LAN_IGMP, "IgmpVersion", requests);
+            if (ret) {
+                netsnmp_set_request_error(reqinfo, requests,ret );
+            }
+            break;
+
+        case MODE_SET_COMMIT:
+            /* XXX: delete temporary storage */
+            
+            break;
+
+        case MODE_SET_UNDO:
+            /* XXX: UNDO and return to previous value for the object */
+           
+            break;
+
+        default:
+            /* we should never get here, so this is a really bad error */
+            ZYSNMP_ERR( "unknown mode (%d)\n", reqinfo->mode);
+            return SNMP_ERR_GENERR;
+    }
+
+
+    return ret;
+}
+
diff -Naur net-snmp-5.7.2-orig/agent/mibgroup/ZYXEL-PRESTIGE-MIB/prestigeLAN.h net-snmp-5.7.2/agent/mibgroup/ZYXEL-PRESTIGE-MIB/prestigeLAN.h
--- net-snmp-5.7.2-orig/agent/mibgroup/ZYXEL-PRESTIGE-MIB/prestigeLAN.h	1970-01-01 08:00:00.000000000 +0800
+++ net-snmp-5.7.2/agent/mibgroup/ZYXEL-PRESTIGE-MIB/prestigeLAN.h	2013-10-10 22:21:38.857352000 +0800
@@ -0,0 +1,30 @@
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *        : mib2c.scalar.conf 11805 2005-01-07 09:37:18Z dts12 $
+ */
+#ifndef PRESTIGELAN_H
+#define PRESTIGELAN_H
+#include "zylib.h"
+
+/* function declarations */
+void init_prestigeLAN(void);
+Netsnmp_Node_Handler handle_inProtocolFilterSet;
+Netsnmp_Node_Handler handle_inDeviceFilterSet;
+Netsnmp_Node_Handler handle_outProtocolFilterSet;
+Netsnmp_Node_Handler handle_outDeviceFilterSet;
+Netsnmp_Node_Handler handle_dhcpStatus;
+Netsnmp_Node_Handler handle_dhcpStartIpAddr;
+Netsnmp_Node_Handler handle_dhcpEndIpAddr;
+Netsnmp_Node_Handler handle_dhcpPrimaryDnsServer;
+Netsnmp_Node_Handler handle_dhcpSecondaryDnsServer;
+Netsnmp_Node_Handler handle_dhcpRemoteDhcpServer;
+Netsnmp_Node_Handler handle_lanIpAddress;
+Netsnmp_Node_Handler handle_lanIpSubnetMask;
+Netsnmp_Node_Handler handle_lanIpRipDirection;
+Netsnmp_Node_Handler handle_lanIpRipVersion;
+Netsnmp_Node_Handler handle_lanIpMulticast;
+config_require(ZYXEL-PRESTIGE-MIB/zylib);
+
+#define PRESTIGE_LAN_OID PRESTIGE_COMM_OID, 3
+
+#endif /* PRESTIGELAN_H */
diff -Naur net-snmp-5.7.2-orig/agent/mibgroup/ZYXEL-PRESTIGE-MIB/prestigeSystem.c net-snmp-5.7.2/agent/mibgroup/ZYXEL-PRESTIGE-MIB/prestigeSystem.c
--- net-snmp-5.7.2-orig/agent/mibgroup/ZYXEL-PRESTIGE-MIB/prestigeSystem.c	1970-01-01 08:00:00.000000000 +0800
+++ net-snmp-5.7.2/agent/mibgroup/ZYXEL-PRESTIGE-MIB/prestigeSystem.c	2013-10-08 09:35:17.626117000 +0800
@@ -0,0 +1,1028 @@
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *        : mib2c.scalar.conf 11805 2005-01-07 09:37:18Z dts12 $
+ */
+#include <net-snmp/net-snmp-config.h>
+#include <net-snmp/net-snmp-includes.h>
+#include <net-snmp/agent/net-snmp-agent-includes.h>
+#include <sys/sysinfo.h>
+
+#define SYS_CPU_INFO_FILE "/proc/stat"
+#define SYS_MEM_INFO_FILE "/proc/meminfo"
+#include "prestigeSystem.h"
+
+#define SYS_STRING_LEN 256
+
+extern int gdasmid;
+
+/*static int sysLocationSet=0;
+static char sysLocation[SYS_STRING_LEN] = NETSNMP_SYS_LOC;*/
+
+/*extern int handleOfGetParameter(cccoffset_t id,const char *parameter,netsnmp_request_info  *requests,u_char type);
+
+extern int handleOfSetParameter(cccoffset_t id,char *parameter,netsnmp_request_info *requests);*/
+	
+
+
+/** Initializes the prestigeSystem module */
+void
+init_prestigeSystem(void)
+{
+    static oid sysRasFWVersion_oid[] 		= { PRESTIGE_SYS_OID, 1 };
+    static oid sysHWVersion_oid[]			= { PRESTIGE_SYS_OID, 2 };
+    static oid manufacturer_oid[] 			= { PRESTIGE_SYS_OID, 3 };
+    static oid modelName_oid[] 				= { PRESTIGE_SYS_OID, 4 };
+    static oid sysLocation_oid[] 			= { PRESTIGE_SYS_OID, 5 };
+    static oid sysConatctPersion_oid[] 		= { PRESTIGE_SYS_OID, 6 };
+    static oid manufacturerOUI_oid[] 		= { PRESTIGE_SYS_OID, 7 };
+    static oid description_oid[] 			= { PRESTIGE_SYS_OID, 8 };
+    static oid productClass_oid[] 			= { PRESTIGE_SYS_OID, 9 };
+    static oid serialNumber_oid[] 			= { PRESTIGE_SYS_OID, 10 };
+    static oid specVersion_oid[] 			= { PRESTIGE_SYS_OID, 11 };
+    static oid upTime_oid[] 				= { PRESTIGE_SYS_OID, 12 };
+    static oid provisioningCode_oid[] 		= { PRESTIGE_SYS_OID, 13 };
+    static oid deviceLog_oid[] 				= { PRESTIGE_SYS_OID, 14 };
+#if 0
+    static oid sysModemVersion_oid[] 		= { PRESTIGE_SYS_OID, 15 };
+    static oid sysProtocolRouteIp_oid[] 	= { PRESTIGE_SYS_OID, 16 };
+    static oid sysProtocolBridge_oid[] 		= { PRESTIGE_SYS_OID, 17 };
+#endif
+    static oid sysDomainName_oid[] 			= { PRESTIGE_SYS_OID, 18 };
+    static oid sysReset_oid[] 				= { PRESTIGE_SYS_OID, 19 };
+    static oid sysCpuUtilization_oid[] 		= { PRESTIGE_SYS_OID, 20 };
+    static oid sysMemoryUtilization_oid[] 	= { PRESTIGE_SYS_OID, 21 };
+	
+	/** .1.3.6.1.2.1.1 system mib **/
+	static oid sysDescr_oid[]				= { 1, 3, 6, 1, 2, 1, 1, 1 };
+	static oid sysObjID_oid[]				= { 1, 3, 6, 1, 2, 1, 1, 2 };
+	static oid sysUpTime_oid[]				= { 1, 3, 6, 1, 2, 1, 1, 3 };
+	static oid sysContact_oid[]				= { 1, 3, 6, 1, 2, 1, 1, 4 };
+	static oid sysName_oid[]				= { 1, 3, 6, 1, 2, 1, 1, 5 };
+	static oid sysLoc_oid[]					= { 1, 3, 6, 1, 2, 1, 1, 6 };
+	
+	DEBUGMSGTL(("prestigeSystem", "Initializing\n"));
+
+	netsnmp_register_scalar(
+        netsnmp_create_handler_registration("sysRasFWVersion", handle_sysRasFWVersion,
+                               sysRasFWVersion_oid, OID_LENGTH(sysRasFWVersion_oid),
+                               HANDLER_CAN_RONLY
+
+        ));
+
+    netsnmp_register_scalar(
+        netsnmp_create_handler_registration("sysHWVersion", handle_sysHWVersion,
+                               sysHWVersion_oid, OID_LENGTH(sysHWVersion_oid),
+                               HANDLER_CAN_RONLY
+
+        ));
+
+    netsnmp_register_scalar(
+        netsnmp_create_handler_registration("Manufacturer", handle_manufacturer,
+                               manufacturer_oid, OID_LENGTH(manufacturer_oid),
+                               HANDLER_CAN_RONLY
+
+        ));
+		
+    netsnmp_register_scalar(
+        netsnmp_create_handler_registration("ModelName", handle_modelName,
+                               modelName_oid, OID_LENGTH(modelName_oid),
+                               HANDLER_CAN_RONLY
+
+        ));
+		
+	netsnmp_register_scalar(
+        netsnmp_create_handler_registration("Location", handle_sysLocation,
+                               sysLocation_oid, OID_LENGTH(sysLocation_oid),
+                               HANDLER_CAN_RWRITE
+
+        ));
+		
+	netsnmp_register_scalar(
+        netsnmp_create_handler_registration("Connatctperson", handle_sysConatctPersion,
+                               sysConatctPersion_oid, OID_LENGTH(sysConatctPersion_oid),
+                               HANDLER_CAN_RWRITE
+
+        ));
+
+    netsnmp_register_scalar(
+        netsnmp_create_handler_registration("ManufacturerOUI", handle_manufacturerOUI,
+                               manufacturerOUI_oid, OID_LENGTH(manufacturerOUI_oid),
+                               HANDLER_CAN_RONLY
+
+        ));
+
+    netsnmp_register_scalar(
+        netsnmp_create_handler_registration("Description", handle_description,
+                               description_oid, OID_LENGTH(description_oid),
+                               HANDLER_CAN_RONLY
+
+        ));
+
+    netsnmp_register_scalar(
+        netsnmp_create_handler_registration("ProductClass", handle_productClass,
+                               productClass_oid, OID_LENGTH(productClass_oid),
+                               HANDLER_CAN_RONLY
+
+        ));
+
+    netsnmp_register_scalar(
+        netsnmp_create_handler_registration("serialNumber", handle_serialNumber,
+                               serialNumber_oid, OID_LENGTH(serialNumber_oid),
+                               HANDLER_CAN_RONLY
+
+        ));
+
+    netsnmp_register_scalar(
+        netsnmp_create_handler_registration("specVersion", handle_specVersion,
+                               specVersion_oid, OID_LENGTH(specVersion_oid),
+                               HANDLER_CAN_RONLY
+
+        ));
+	
+	netsnmp_register_scalar(
+        netsnmp_create_handler_registration("UpTime", handle_upTime,
+                               upTime_oid, OID_LENGTH(upTime_oid),
+                               HANDLER_CAN_RONLY
+
+        ));
+
+    netsnmp_register_scalar(
+        netsnmp_create_handler_registration("ProvisioningCode", handle_provisioningCode,
+                               provisioningCode_oid, OID_LENGTH(provisioningCode_oid),
+                               HANDLER_CAN_RWRITE
+
+        ));
+
+    netsnmp_register_scalar(
+        netsnmp_create_handler_registration("DeviceLog", handle_deviceLog,
+                               deviceLog_oid, OID_LENGTH(deviceLog_oid),
+                               HANDLER_CAN_RONLY
+
+        ));
+
+#if 0
+	netsnmp_register_scalar(
+        netsnmp_create_handler_registration("sysModemVersion", handle_sysModemVersion,
+                               sysModemVersion_oid, OID_LENGTH(sysModemVersion_oid),
+                               HANDLER_CAN_RONLY
+        ));	
+		
+    netsnmp_register_scalar(
+        netsnmp_create_handler_registration("sysProtocolRouteIp", handle_sysProtocolRouteIp,
+                               sysProtocolRouteIp_oid, OID_LENGTH(sysProtocolRouteIp_oid),
+                               HANDLER_CAN_RWRITE
+        ));
+
+    netsnmp_register_scalar(
+        netsnmp_create_handler_registration("sysProtocolBridge", handle_sysProtocolBridge,
+                               sysProtocolBridge_oid, OID_LENGTH(sysProtocolBridge_oid),
+                               HANDLER_CAN_RWRITE
+        ));
+#endif		
+    netsnmp_register_scalar(
+        netsnmp_create_handler_registration("sysDomainName", handle_sysDomainName,
+                               sysDomainName_oid, OID_LENGTH(sysDomainName_oid),
+                               HANDLER_CAN_RWRITE
+        ));
+
+    netsnmp_register_scalar(
+        netsnmp_create_handler_registration("sysReset", handle_sysReset,
+                               sysReset_oid, OID_LENGTH(sysReset_oid),
+                               HANDLER_CAN_RWRITE
+        ));
+
+    netsnmp_register_scalar(
+        netsnmp_create_handler_registration("sysCpuUtilization", handle_sysCpuUtilization,
+                               sysCpuUtilization_oid, OID_LENGTH(sysCpuUtilization_oid),
+                               HANDLER_CAN_RONLY
+        ));
+
+    netsnmp_register_scalar(
+        netsnmp_create_handler_registration("sysMemoryUtilization", handle_sysMemoryUtilization,
+                               sysMemoryUtilization_oid, OID_LENGTH(sysMemoryUtilization_oid),
+                               HANDLER_CAN_RONLY
+        ));
+		
+		
+	/*** System mib ***/
+	
+	netsnmp_register_scalar(
+        netsnmp_create_handler_registration("sysDescr", handle_description,
+                               sysDescr_oid, OID_LENGTH(sysDescr_oid),
+                               HANDLER_CAN_RONLY
+
+        ));
+	
+	netsnmp_register_scalar(
+        netsnmp_create_handler_registration("sysObjectId", handle_sysObjectId,
+                               sysObjID_oid, OID_LENGTH(sysObjID_oid),
+                               HANDLER_CAN_RONLY
+
+        ));
+	
+	netsnmp_register_scalar(
+        netsnmp_create_handler_registration("sysUpTime", handle_upTime,
+                               sysUpTime_oid, OID_LENGTH(sysUpTime_oid),
+                               HANDLER_CAN_RONLY
+
+        ));
+	
+	netsnmp_register_scalar(
+        netsnmp_create_handler_registration("sysContact", handle_sysConatctPersion,
+                               sysContact_oid, OID_LENGTH(sysContact_oid),
+                               HANDLER_CAN_RWRITE
+
+        ));
+		
+	netsnmp_register_scalar(
+        netsnmp_create_handler_registration("sysName", handle_sysName,
+                               sysName_oid, OID_LENGTH(sysName_oid),
+                               HANDLER_CAN_RWRITE
+
+        ));
+		
+	netsnmp_register_scalar(
+        netsnmp_create_handler_registration("sysLocation", handle_sysLocation,
+                               sysLoc_oid, OID_LENGTH(sysLoc_oid),
+                               HANDLER_CAN_RWRITE
+
+        ));
+}
+
+int handle_sysName(netsnmp_mib_handler *handler,
+                          netsnmp_handler_registration *reginfo,
+                          netsnmp_agent_request_info   *reqinfo,
+                          netsnmp_request_info         *requests)
+{
+	int ret=SNMP_ERR_NOERROR;
+   	switch(reqinfo->mode) {
+        case MODE_GET:
+		case MODE_GETBULK:
+            ret=handleOfGetParameter(IGD_ZYXEL_SYS_INFO, "HostName", requests,ASN_OCTET_STR);
+			break;
+			
+		case MODE_SET_RESERVE1:
+                /* or you could use netsnmp_check_vb_type_and_size instead */
+            ret = netsnmp_check_vb_type(requests->requestvb, ASN_OCTET_STR);
+            if ( ret != SNMP_ERR_NOERROR ) {
+                netsnmp_set_request_error(reqinfo, requests, ret );
+            }
+            break;
+			
+        case MODE_SET_RESERVE2:
+			break;
+
+        case MODE_SET_FREE:
+            break;
+
+        case MODE_SET_ACTION:
+			ret=handleOfSetParameter(IGD_ZYXEL_SYS_INFO, "HostName", requests);
+            break;
+
+        case MODE_SET_COMMIT:
+            break;
+			
+		case MODE_SET_UNDO:
+            break;
+			
+        default:
+            // we should never get here, so this is a really bad error 
+            snmp_log(LOG_ERR, "unknown mode (%d) in handle_sysSysName\n", reqinfo->mode );
+            return SNMP_ERR_GENERR;
+    }
+
+	return ret;
+}
+
+int handle_sysObjectId(netsnmp_mib_handler *handler,
+                          netsnmp_handler_registration *reginfo,
+                          netsnmp_agent_request_info   *reqinfo,
+                          netsnmp_request_info         *requests)
+{
+    int ret=SNMP_ERR_NOERROR;
+	static oid zyxel_mid[] = {ZYXEL_MIB_OID};
+	int i, len;
+	
+    switch(reqinfo->mode) {
+        case MODE_GET:
+		case MODE_GETBULK:
+			snmp_set_var_typed_value(requests->requestvb, ASN_OBJECT_ID,
+					(u_char *)zyxel_mid, sizeof(zyxel_mid));
+			break;
+        default:
+            /* we should never get here, so this is a really bad error */
+            snmp_log(LOG_ERR, "unknown mode (%d) in %s\n", reqinfo->mode,__FUNCTION__ );
+            return SNMP_ERR_GENERR;
+    }
+	
+	return ret;
+}
+
+int handle_sysRasFWVersion(netsnmp_mib_handler *handler,
+                          netsnmp_handler_registration *reginfo,
+                          netsnmp_agent_request_info   *reqinfo,
+                          netsnmp_request_info         *requests)
+{
+    int ret=SNMP_ERR_NOERROR;
+    switch(reqinfo->mode) {
+        case MODE_GET:
+		case MODE_GETBULK:
+            ret=handleOfGetParameter(IGD_DeviceInfo, "SoftwareVersion", requests,ASN_OCTET_STR);
+			break;
+        default:
+            /* we should never get here, so this is a really bad error */
+            snmp_log(LOG_ERR, "unknown mode (%d) in %s\n", reqinfo->mode,__FUNCTION__ );
+            return SNMP_ERR_GENERR;
+    }
+	
+	return ret;
+}
+
+int handle_sysHWVersion(netsnmp_mib_handler *handler,
+                          netsnmp_handler_registration *reginfo,
+                          netsnmp_agent_request_info   *reqinfo,
+                          netsnmp_request_info         *requests)
+{
+	int ret=SNMP_ERR_NOERROR;
+	switch(reqinfo->mode) {
+		case MODE_GET:
+	 	case MODE_GETBULK:
+			ret=handleOfGetParameter(IGD_DeviceInfo, "HardwareVersion", requests,ASN_OCTET_STR);
+           	break;
+		default:
+            /* we should never get here, so this is a really bad error */
+			snmp_log(LOG_ERR, "unknown mode (%d) in %s\n", reqinfo->mode,__FUNCTION__ );
+			return SNMP_ERR_GENERR;
+	}
+	return ret;
+}
+
+int handle_manufacturer(netsnmp_mib_handler *handler,
+                          netsnmp_handler_registration *reginfo,
+                          netsnmp_agent_request_info   *reqinfo,
+                          netsnmp_request_info         *requests)
+{
+	int ret=SNMP_ERR_NOERROR;
+	switch(reqinfo->mode) {
+        case MODE_GET:
+		case MODE_GETBULK:
+			ret=handleOfGetParameter(IGD_DeviceInfo, "Manufacturer", requests,ASN_OCTET_STR);
+			break;
+        default:
+            /* we should never get here, so this is a really bad error */
+            snmp_log(LOG_ERR, "unknown mode (%d) in %s\n", reqinfo->mode,__FUNCTION__ );
+            return SNMP_ERR_GENERR;
+    }
+	
+	return ret;
+}
+
+int handle_modelName(netsnmp_mib_handler *handler,
+                          netsnmp_handler_registration *reginfo,
+                          netsnmp_agent_request_info   *reqinfo,
+                          netsnmp_request_info         *requests)
+{
+	int ret=SNMP_ERR_NOERROR;
+   	switch(reqinfo->mode) {
+        case MODE_GET:
+		case MODE_GETBULK:
+            ret=handleOfGetParameter(IGD_DeviceInfo, "ModelName", requests,ASN_OCTET_STR);
+			break;
+        default:
+            // we should never get here, so this is a really bad error 
+            snmp_log(LOG_ERR, "unknown mode (%d) in handle_sysSysName\n", reqinfo->mode );
+            return SNMP_ERR_GENERR;
+    }
+
+		return ret;
+}
+
+int handle_manufacturerOUI(netsnmp_mib_handler *handler,
+                          netsnmp_handler_registration *reginfo,
+                          netsnmp_agent_request_info   *reqinfo,
+                          netsnmp_request_info         *requests)
+{
+    int ret=SNMP_ERR_NOERROR;
+	switch(reqinfo->mode) {
+		case MODE_GET:
+	 	case MODE_GETBULK:
+			ret=handleOfGetParameter(IGD_DeviceInfo, "ManufacturerOUI", requests,ASN_OCTET_STR);
+           	break;
+		default:
+            /* we should never get here, so this is a really bad error */
+			snmp_log(LOG_ERR, "unknown mode (%d) in %s\n", reqinfo->mode,__FUNCTION__ );
+			return SNMP_ERR_GENERR;
+	}
+	return ret;
+}
+
+int handle_description(netsnmp_mib_handler *handler,
+                          netsnmp_handler_registration *reginfo,
+                          netsnmp_agent_request_info   *reqinfo,
+                          netsnmp_request_info         *requests)
+{
+   int ret=SNMP_ERR_NOERROR;
+	switch(reqinfo->mode) {
+		case MODE_GET:
+	 	case MODE_GETBULK:
+			ret=handleOfGetParameter(IGD_DeviceInfo, "Description", requests,ASN_OCTET_STR);
+           	break;
+		default:
+            /* we should never get here, so this is a really bad error */
+			snmp_log(LOG_ERR, "unknown mode (%d) in %s\n", reqinfo->mode,__FUNCTION__ );
+			return SNMP_ERR_GENERR;
+	}
+	return ret;
+}
+
+int handle_productClass(netsnmp_mib_handler *handler,
+                          netsnmp_handler_registration *reginfo,
+                          netsnmp_agent_request_info   *reqinfo,
+                          netsnmp_request_info         *requests)
+{
+   int ret=SNMP_ERR_NOERROR;
+	switch(reqinfo->mode) {
+		case MODE_GET:
+	 	case MODE_GETBULK:
+			ret=handleOfGetParameter(IGD_DeviceInfo, "ProductClass", requests,ASN_OCTET_STR);
+           	break;
+		default:
+            /* we should never get here, so this is a really bad error */
+			snmp_log(LOG_ERR, "unknown mode (%d) in %s\n", reqinfo->mode,__FUNCTION__ );
+			return SNMP_ERR_GENERR;
+	}
+	return ret;
+}
+
+int handle_serialNumber(netsnmp_mib_handler *handler,
+                          netsnmp_handler_registration *reginfo,
+                          netsnmp_agent_request_info   *reqinfo,
+                          netsnmp_request_info         *requests)
+{
+    int ret=SNMP_ERR_NOERROR;
+	switch(reqinfo->mode) {
+		case MODE_GET:
+	 	case MODE_GETBULK:
+			ret=handleOfGetParameter(IGD_DeviceInfo, "SerialNumber", requests,ASN_OCTET_STR);
+           	break;
+		default:
+            /* we should never get here, so this is a really bad error */
+			snmp_log(LOG_ERR, "unknown mode (%d) in %s\n", reqinfo->mode,__FUNCTION__ );
+			return SNMP_ERR_GENERR;
+	}
+	return ret;
+}
+/***TR 181 not support***/
+int handle_specVersion(netsnmp_mib_handler *handler,
+                          netsnmp_handler_registration *reginfo,
+                          netsnmp_agent_request_info   *reqinfo,
+                          netsnmp_request_info         *requests)
+{
+    int ret=SNMP_ERR_NOERROR;
+	switch(reqinfo->mode) {
+		case MODE_GET:
+	 	case MODE_GETBULK:
+			ret=handleOfGetParameter(IGD_DeviceInfo, "SpecVersion", requests,ASN_OCTET_STR);
+           	break;
+		default:
+			snmp_log(LOG_ERR, "unknown mode (%d) in %s\n", reqinfo->mode,__FUNCTION__ );
+			return SNMP_ERR_GENERR;
+	}
+	return ret;
+}
+
+int handle_upTime(netsnmp_mib_handler *handler,
+                          netsnmp_handler_registration *reginfo,
+                          netsnmp_agent_request_info   *reqinfo,
+                          netsnmp_request_info         *requests)
+{
+	struct sysinfo info;
+	u_long timepass;
+	sysinfo(&info);
+	timepass=info.uptime*100;
+		
+		
+	int ret=SNMP_ERR_NOERROR;
+	switch(reqinfo->mode) {
+		case MODE_GET:
+	 	case MODE_GETBULK:
+			ret=handleOfGetParameter(IGD_DeviceInfo, "UpTime", requests,ASN_INTEGER);
+           	break;
+		default:
+            /* we should never get here, so this is a really bad error */
+			snmp_log(LOG_ERR, "unknown mode (%d) in %s\n", reqinfo->mode,__FUNCTION__ );
+			return SNMP_ERR_GENERR;
+	}
+	return ret;
+}
+
+int handle_provisioningCode(netsnmp_mib_handler *handler,
+                          netsnmp_handler_registration *reginfo,
+                          netsnmp_agent_request_info   *reqinfo,
+                          netsnmp_request_info         *requests)
+{
+   	int ret=SNMP_ERR_NOERROR;
+    switch(reqinfo->mode) {
+        case MODE_GET:
+		case MODE_GETBULK:
+            ret=handleOfGetParameter(IGD_DeviceInfo, "ProvisioningCode", requests,ASN_OCTET_STR);
+			break;
+        case MODE_SET_RESERVE1:
+#if 0
+                /* or you could use netsnmp_check_vb_type_and_size instead */
+            ret = netsnmp_check_vb_type(requests->requestvb, ASN_OCTET_STR);
+            if ( ret != SNMP_ERR_NOERROR ) {
+                netsnmp_set_request_error(reqinfo, requests, ret );
+            }
+#endif
+            break;
+
+        default:
+            /* we should never get here, so this is a really bad error */
+            snmp_log(LOG_ERR, "unknown mode (%d) in %s\n", reqinfo->mode,__FUNCTION__ );
+            return SNMP_ERR_GENERR;
+    }
+
+    return ret;
+}
+/****In our data-modal not support***/
+int handle_deviceLog(netsnmp_mib_handler *handler,
+                          netsnmp_handler_registration *reginfo,
+                          netsnmp_agent_request_info   *reqinfo,
+                          netsnmp_request_info         *requests)
+{
+    int ret=SNMP_ERR_NOERROR;
+	switch(reqinfo->mode) {
+		case MODE_GET:
+	 	case MODE_GETBULK:
+			ret=handleOfGetParameter(IGD_DeviceInfo, "DeviceLog", requests,ASN_OCTET_STR);
+           	break;
+		default:
+			snmp_log(LOG_ERR, "unknown mode (%d) in %s\n", reqinfo->mode,__FUNCTION__ );
+			return SNMP_ERR_GENERR;
+	}
+	return ret;
+}
+
+int handle_sysLocation(netsnmp_mib_handler *handler,
+                          netsnmp_handler_registration *reginfo,
+                          netsnmp_agent_request_info   *reqinfo,
+                          netsnmp_request_info         *requests)
+{
+    int ret;
+    switch(reqinfo->mode) {
+        case MODE_GET:
+			case MODE_GETBULK:
+				ret=handleOfGetParameter(IGD_ZYXEL_SYS_INFO, "Location", requests,ASN_OCTET_STR);
+            break;
+			
+        case MODE_SET_RESERVE1:
+                /* or you could use netsnmp_check_vb_type_and_size instead */
+            ret = netsnmp_check_vb_type(requests->requestvb, ASN_OCTET_STR);
+            if ( ret != SNMP_ERR_NOERROR ) {
+                netsnmp_set_request_error(reqinfo, requests, ret );
+				snmp_log(LOG_ERR, "%s: ERROR MODE_SET_RESERVE1\n", __FUNCTION__ );
+            }
+            break;
+			
+        case MODE_SET_RESERVE2:
+            break;
+			
+        case MODE_SET_FREE:
+            break;
+			
+        case MODE_SET_ACTION:
+			ret=handleOfSetParameter(IGD_ZYXEL_SYS_INFO, "Location", requests);
+            break;
+			
+		case MODE_SET_COMMIT:
+            break;
+			
+		case MODE_SET_UNDO:
+            break;	
+			
+        default:
+            /* we should never get here, so this is a really bad error */
+            snmp_log(LOG_ERR, "unknown mode (%d) in handle_sysLocation\n", reqinfo->mode );
+            return SNMP_ERR_GENERR;
+    }
+
+    return ret;
+}
+
+int handle_sysConatctPersion(netsnmp_mib_handler *handler,
+                          netsnmp_handler_registration *reginfo,
+                          netsnmp_agent_request_info   *reqinfo,
+                          netsnmp_request_info         *requests)
+{
+    int ret;
+    switch(reqinfo->mode) {
+
+        case MODE_GET:
+			case MODE_GETBULK:
+				ret=handleOfGetParameter(IGD_ZYXEL_SYS_INFO, "Contact", requests,ASN_OCTET_STR);
+            break;
+
+        case MODE_SET_RESERVE1:
+                /* or you could use netsnmp_check_vb_type_and_size instead */
+            ret = netsnmp_check_vb_type(requests->requestvb, ASN_OCTET_STR);
+            if ( ret != SNMP_ERR_NOERROR ) {
+                netsnmp_set_request_error(reqinfo, requests, ret );
+            }
+            break;
+			
+        case MODE_SET_RESERVE2:
+            break;
+			
+        case MODE_SET_FREE:
+            break;
+			
+        case MODE_SET_ACTION:
+            /* XXX: perform the value change here */
+			ret=handleOfSetParameter(IGD_ZYXEL_SYS_INFO, "Contact", requests);
+            break;
+			
+		case MODE_SET_COMMIT:
+            break;
+			
+        case MODE_SET_UNDO:    
+            break;	
+			
+        default:
+            /* we should never get here, so this is a really bad error */
+            snmp_log(LOG_ERR, "unknown mode (%d) in handle_sysConatctPersion\n", reqinfo->mode );
+            return SNMP_ERR_GENERR;
+    }
+
+    return ret;
+}
+
+#if 0
+int handle_sysModemVersion(netsnmp_mib_handler *handler,
+                          netsnmp_handler_registration *reginfo,
+                          netsnmp_agent_request_info   *reqinfo,
+                          netsnmp_request_info         *requests)
+{
+    /* We are never called for a GETNEXT if it's registered as a
+       "instance", as it's "magically" handled for us.  */
+
+    /* a instance handler also only hands us one request at a time, so
+       we don't need to loop over a list of requests; we'll only get one. */
+    
+    switch(reqinfo->mode) {
+
+        case MODE_GET:
+            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
+                                     (u_char *) /* XXX: a pointer to the scalar's data */,
+                                     /* XXX: the length of the data in bytes */);
+            break;
+
+
+        default:
+            /* we should never get here, so this is a really bad error */
+            snmp_log(LOG_ERR, "unknown mode (%d) in handle_sysModemVersion\n", reqinfo->mode );
+            return SNMP_ERR_GENERR;
+    }
+
+    return SNMP_ERR_NOERROR;
+}
+int
+handle_sysProtocolRouteIp(netsnmp_mib_handler *handler,
+                          netsnmp_handler_registration *reginfo,
+                          netsnmp_agent_request_info   *reqinfo,
+                          netsnmp_request_info         *requests)
+{
+    int ret;
+    /* We are never called for a GETNEXT if it's registered as a
+       "instance", as it's "magically" handled for us.  */
+
+    /* a instance handler also only hands us one request at a time, so
+       we don't need to loop over a list of requests; we'll only get one. */
+    
+    switch(reqinfo->mode) {
+
+        case MODE_GET:
+            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
+                                     (u_char *) /* XXX: a pointer to the scalar's data */,
+                                     /* XXX: the length of the data in bytes */);
+            break;
+
+        /*
+         * SET REQUEST
+         *
+         * multiple states in the transaction.  See:
+         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
+         */
+        case MODE_SET_RESERVE1:
+                /* or you could use netsnmp_check_vb_type_and_size instead */
+            ret = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
+            if ( ret != SNMP_ERR_NOERROR ) {
+                netsnmp_set_request_error(reqinfo, requests, ret );
+            }
+            break;
+
+        case MODE_SET_RESERVE2:
+            /* XXX malloc "undo" storage buffer */
+            if (/* XXX if malloc, or whatever, failed: */) {
+                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_RESOURCEUNAVAILABLE);
+            }
+            break;
+
+        case MODE_SET_FREE:
+            /* XXX: free resources allocated in RESERVE1 and/or
+               RESERVE2.  Something failed somewhere, and the states
+               below won't be called. */
+            break;
+
+        case MODE_SET_ACTION:
+            /* XXX: perform the value change here */
+            if (/* XXX: error? */) {
+                netsnmp_set_request_error(reqinfo, requests, /* some error */);
+            }
+            break;
+
+        case MODE_SET_COMMIT:
+            /* XXX: delete temporary storage */
+            if (/* XXX: error? */) {
+                /* try _really_really_ hard to never get to this point */
+                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
+            }
+            break;
+
+        case MODE_SET_UNDO:
+            /* XXX: UNDO and return to previous value for the object */
+            if (/* XXX: error? */) {
+                /* try _really_really_ hard to never get to this point */
+                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_UNDOFAILED);
+            }
+            break;
+
+        default:
+            /* we should never get here, so this is a really bad error */
+            snmp_log(LOG_ERR, "unknown mode (%d) in handle_sysProtocolRouteIp\n", reqinfo->mode );
+            return SNMP_ERR_GENERR;
+    }
+
+    return SNMP_ERR_NOERROR;
+}
+int
+handle_sysProtocolBridge(netsnmp_mib_handler *handler,
+                          netsnmp_handler_registration *reginfo,
+                          netsnmp_agent_request_info   *reqinfo,
+                          netsnmp_request_info         *requests)
+{
+    int ret;
+    /* We are never called for a GETNEXT if it's registered as a
+       "instance", as it's "magically" handled for us.  */
+
+    /* a instance handler also only hands us one request at a time, so
+       we don't need to loop over a list of requests; we'll only get one. */
+    
+    switch(reqinfo->mode) {
+
+        case MODE_GET:
+            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
+                                     (u_char *) /* XXX: a pointer to the scalar's data */,
+                                     /* XXX: the length of the data in bytes */);
+            break;
+
+        /*
+         * SET REQUEST
+         *
+         * multiple states in the transaction.  See:
+         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
+         */
+        case MODE_SET_RESERVE1:
+                /* or you could use netsnmp_check_vb_type_and_size instead */
+            ret = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
+            if ( ret != SNMP_ERR_NOERROR ) {
+                netsnmp_set_request_error(reqinfo, requests, ret );
+            }
+            break;
+
+        case MODE_SET_RESERVE2:
+            /* XXX malloc "undo" storage buffer */
+            if (/* XXX if malloc, or whatever, failed: */) {
+                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_RESOURCEUNAVAILABLE);
+            }
+            break;
+
+        case MODE_SET_FREE:
+            /* XXX: free resources allocated in RESERVE1 and/or
+               RESERVE2.  Something failed somewhere, and the states
+               below won't be called. */
+            break;
+
+        case MODE_SET_ACTION:
+            /* XXX: perform the value change here */
+            if (/* XXX: error? */) {
+                netsnmp_set_request_error(reqinfo, requests, /* some error */);
+            }
+            break;
+
+        case MODE_SET_COMMIT:
+            /* XXX: delete temporary storage */
+            if (/* XXX: error? */) {
+                /* try _really_really_ hard to never get to this point */
+                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
+            }
+            break;
+
+        case MODE_SET_UNDO:
+            /* XXX: UNDO and return to previous value for the object */
+            if (/* XXX: error? */) {
+                /* try _really_really_ hard to never get to this point */
+                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_UNDOFAILED);
+            }
+            break;
+
+        default:
+            /* we should never get here, so this is a really bad error */
+            snmp_log(LOG_ERR, "unknown mode (%d) in handle_sysProtocolBridge\n", reqinfo->mode );
+            return SNMP_ERR_GENERR;
+    }
+
+    return SNMP_ERR_NOERROR;
+}
+#endif
+
+int handle_sysDomainName(netsnmp_mib_handler *handler,
+                          netsnmp_handler_registration *reginfo,
+                          netsnmp_agent_request_info   *reqinfo,
+                          netsnmp_request_info         *requests)
+{
+	int ret;
+
+    switch(reqinfo->mode) {
+
+        case MODE_GET:
+		case MODE_GETBULK:
+            ret=handleOfGetParameter(IGD_ZYXEL_SYS_INFO, "DomainName",requests, ASN_OCTET_STR);
+            break;
+
+        case MODE_SET_RESERVE1:
+                /* or you could use netsnmp_check_vb_type_and_size instead */
+            ret = netsnmp_check_vb_type(requests->requestvb, ASN_IPADDRESS);
+            if ( ret != SNMP_ERR_NOERROR ) {
+                netsnmp_set_request_error(reqinfo, requests, ret );
+            }
+            break;
+			
+        case MODE_SET_RESERVE2:
+			break;
+			
+        case MODE_SET_FREE:
+            break;
+
+        case MODE_SET_ACTION:
+			ret=handleOfSetParameter(IGD_ZYXEL_SYS_INFO, "DomainName", requests);
+            break;
+			
+		case MODE_SET_COMMIT:
+            break;
+			
+		case MODE_SET_UNDO:
+            break;	
+			
+        default:
+            /* we should never get here, so this is a really bad error */
+            snmp_log(LOG_ERR, "unknown mode (%d) in %s\n", reqinfo->mode,__FUNCTION__);
+            return SNMP_ERR_GENERR;
+    }
+
+    return ret;
+}
+
+int handle_sysReset(netsnmp_mib_handler *handler,
+                          netsnmp_handler_registration *reginfo,
+                          netsnmp_agent_request_info   *reqinfo,
+                          netsnmp_request_info         *requests)
+{
+    int ret;
+	
+#define OTHER 1
+#define YES 2
+#define NO 3
+	//#define ROMREST "sys romreset 1"
+    int reset=3;
+	
+    switch(reqinfo->mode) {
+
+        case MODE_GET:
+            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
+                                     (u_char *)&reset /* XXX: a pointer to the scalar's data */,
+                                     sizeof(reset)/* XXX: the length of the data in bytes */);
+            break;
+
+        case MODE_SET_RESERVE1:
+                /* or you could use netsnmp_check_vb_type_and_size instead */
+            break;
+
+        case MODE_SET_RESERVE2:
+            /* XXX malloc "undo" storage buffer */
+            break;
+
+        case MODE_SET_FREE:
+            /* XXX: free resources allocated in RESERVE1 and/or
+               RESERVE2.  Something failed somewhere, and the states
+               below won't be called. */
+            break;
+
+        case MODE_SET_ACTION:
+            /* XXX: perform the value change here */
+            if(*(requests->requestvb->val.integer) == YES){
+				if(zcfgFeRestoreDefault(NULL) != ZCFG_SUCCESS)
+					ret = SNMP_ERR_GENERR;
+			}
+            break;
+
+        case MODE_SET_COMMIT:
+            /* XXX: delete temporary storage */
+            
+            break;
+
+        case MODE_SET_UNDO:
+            /* XXX: UNDO and return to previous value for the object */
+            
+            break;
+
+        default:
+            /* we should never get here, so this is a really bad error */
+            snmp_log(LOG_ERR, "unknown mode (%d) in handle_sysReset\n", reqinfo->mode );
+            return SNMP_ERR_GENERR;
+    }
+
+    return SNMP_ERR_NOERROR;
+}
+
+int handle_sysCpuUtilization(netsnmp_mib_handler *handler,
+                          netsnmp_handler_registration *reginfo,
+                          netsnmp_agent_request_info   *reqinfo,
+                          netsnmp_request_info         *requests)
+{
+    float cpuValue;
+	char tempBuffer[256]="";
+	unsigned long cpu1[8],cpu2[8];
+	char cpuUsage[8];
+	FILE *fp;
+	if ((fp = fopen(SYS_CPU_INFO_FILE, "r")) != NULL) {
+		if (fgets(tempBuffer, sizeof(tempBuffer), fp) != NULL)
+			sscanf(tempBuffer, "%*s %lu %lu %lu %lu %lu %lu %lu %lu", &cpu1[0], &cpu1[1], &cpu1[2], &cpu1[3], &cpu1[4], &cpu1[5], &cpu1[6], &cpu1[7]);
+		fclose(fp);
+		sleep(1);
+		if ((fp = fopen(SYS_CPU_INFO_FILE, "r")) != NULL) {
+			if (fgets(tempBuffer, sizeof(tempBuffer), fp) != NULL)
+				sscanf(tempBuffer, "%*s %lu %lu %lu %lu %lu %lu %lu %lu", &cpu2[0], &cpu2[1], &cpu2[2], &cpu2[3], &cpu2[4], &cpu2[5], &cpu2[6], &cpu2[7]);
+			fclose(fp);
+			cpuValue = 100 - ((cpu2[3] - cpu1[3]) / (float)(cpu2[0] - cpu1[0] + cpu2[1] - cpu1[1] + cpu2[2] - cpu1[2] + cpu2[3] - cpu1[3] + cpu2[4] - cpu1[4] + cpu2[5] - cpu1[5] + cpu2[6] - cpu1[6] + cpu2[7] - cpu1[7]) * 100);
+			sprintf(cpuUsage, "%3.1f%%", cpuValue);
+		}
+	}
+
+    switch(reqinfo->mode) {
+
+        case MODE_GET:
+			case MODE_GETBULK:
+            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
+                                     (u_char *)cpuUsage/* XXX: a pointer to the scalar's data */,
+                                    strlen(cpuUsage)/* XXX: the length of the data in bytes */);
+            break;
+
+
+        default:
+            /* we should never get here, so this is a really bad error */
+            snmp_log(LOG_ERR, "unknown mode (%d) in handle_sysCpuUtilization\n", reqinfo->mode );
+            return SNMP_ERR_GENERR;
+    }
+
+    return SNMP_ERR_NOERROR;
+}
+
+int handle_sysMemoryUtilization(netsnmp_mib_handler *handler,
+                          netsnmp_handler_registration *reginfo,
+                          netsnmp_agent_request_info   *reqinfo,
+                          netsnmp_request_info         *requests)
+{
+    struct sysinfo info;
+	char memusage[8];
+	sysinfo(&info);
+	sprintf(memusage,"%3.1f%%",(info.totalram - info.freeram) / (float)info.totalram * 100);
+    switch(reqinfo->mode) {
+
+        case MODE_GET:
+			case MODE_GETBULK:
+            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
+                                     (u_char *)memusage /* XXX: a pointer to the scalar's data */,
+                                    strlen(memusage) /* XXX: the length of the data in bytes */);
+            break;
+
+
+        default:
+            /* we should never get here, so this is a really bad error */
+            snmp_log(LOG_ERR, "unknown mode (%d) in handle_sysMemoryUtilization\n", reqinfo->mode );
+            return SNMP_ERR_GENERR;
+    }
+
+    return SNMP_ERR_NOERROR;
+}
+
diff -Naur net-snmp-5.7.2-orig/agent/mibgroup/ZYXEL-PRESTIGE-MIB/prestigeSystem.h net-snmp-5.7.2/agent/mibgroup/ZYXEL-PRESTIGE-MIB/prestigeSystem.h
--- net-snmp-5.7.2-orig/agent/mibgroup/ZYXEL-PRESTIGE-MIB/prestigeSystem.h	1970-01-01 08:00:00.000000000 +0800
+++ net-snmp-5.7.2/agent/mibgroup/ZYXEL-PRESTIGE-MIB/prestigeSystem.h	2013-10-10 22:21:38.857352000 +0800
@@ -0,0 +1,39 @@
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *        : mib2c.scalar.conf 11805 2005-01-07 09:37:18Z dts12 $
+ */
+#ifndef PRESTIGESYSTEM_H
+#define PRESTIGESYSTEM_H
+
+#include "zylib.h"
+/* function declarations */
+void init_prestigeSystem(void);
+Netsnmp_Node_Handler handle_sysRasFWVersion;
+Netsnmp_Node_Handler handle_sysHWVersion;
+Netsnmp_Node_Handler handle_manufacturer;
+Netsnmp_Node_Handler handle_modelName;
+Netsnmp_Node_Handler handle_sysLocation;
+Netsnmp_Node_Handler handle_sysConatctPersion;
+Netsnmp_Node_Handler handle_manufacturerOUI;
+Netsnmp_Node_Handler handle_description;
+Netsnmp_Node_Handler handle_productClass;
+Netsnmp_Node_Handler handle_serialNumber;
+Netsnmp_Node_Handler handle_specVersion;
+Netsnmp_Node_Handler handle_upTime;
+Netsnmp_Node_Handler handle_provisioningCode;
+Netsnmp_Node_Handler handle_deviceLog;
+Netsnmp_Node_Handler handle_sysModemVersion;
+Netsnmp_Node_Handler handle_sysProtocolRouteIp;
+Netsnmp_Node_Handler handle_sysProtocolBridge;
+Netsnmp_Node_Handler handle_sysDomainName;
+Netsnmp_Node_Handler handle_sysReset;
+Netsnmp_Node_Handler handle_sysCpuUtilization;
+Netsnmp_Node_Handler handle_sysMemoryUtilization;
+Netsnmp_Node_Handler handle_sysObjectId;
+Netsnmp_Node_Handler handle_sysName;
+
+config_require(ZYXEL-PRESTIGE-MIB/zylib);
+
+#define PRESTIGE_SYS_OID PRESTIGE_COMM_OID, 1
+
+#endif /* PRESTIGESYSTEM_H */
diff -Naur net-snmp-5.7.2-orig/agent/mibgroup/ZYXEL-PRESTIGE-MIB/prestigeTraps.c net-snmp-5.7.2/agent/mibgroup/ZYXEL-PRESTIGE-MIB/prestigeTraps.c
--- net-snmp-5.7.2-orig/agent/mibgroup/ZYXEL-PRESTIGE-MIB/prestigeTraps.c	1970-01-01 08:00:00.000000000 +0800
+++ net-snmp-5.7.2/agent/mibgroup/ZYXEL-PRESTIGE-MIB/prestigeTraps.c	2013-10-08 09:35:17.626117000 +0800
@@ -0,0 +1,714 @@
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *        : mib2c.notify.conf 10110 2004-04-15 12:29:19Z dts12 $
+ */
+
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *        : mib2c.notify.conf 10110 2004-04-15 12:29:19Z dts12 $
+ */
+
+#include <net-snmp/net-snmp-config.h>
+#include <net-snmp/net-snmp-includes.h>
+#include <net-snmp/agent/net-snmp-agent-includes.h>
+#include "prestigeTraps.h"
+
+//static oid snmptrap_oid[] = {1, 3, 6, 4,,1,890,1,2,1,99,1};
+//static const oid snmptrap_oid[] = {1, 3, 6, 1, 6, 3, 1, 1, 4, 1, 0};
+/** @example notification.c
+ *  This example shows how to send a notification from inside the
+ *  agent.  In this case we do something really boring to decide
+ *  whether to send a notification or not: we simply sleep for 30
+ *  seconds and send it, then we sleep for 30 more and send it again.
+ *  We do this through the snmp_alarm mechanisms (which are safe to
+ *  use within the agent.  Don't use the system alarm() call, it won't
+ *  work properly).  Normally, you would probably want to do something
+ *  to test whether or not to send an alarm, based on the type of mib
+ *  module you were creating.
+ *
+ *  When this module is compiled into the agent (run configure with
+ *  --with-mib-modules="examples/notification") then it should send
+ *  out traps, which when received by the snmptrapd demon will look
+ *  roughly like:
+ *
+ *  2002-05-08 08:57:05 localhost.localdomain [udp:127.0.0.1:32865]:
+ *      sysUpTimeInstance = Timeticks: (3803) 0:00:38.03        snmpTrapOID.0 = OID: netSnmpExampleNotification
+ *
+ */
+
+/*
+ * start be including the appropriate header files 
+ */
+#include <net-snmp/net-snmp-config.h>
+#include <net-snmp/net-snmp-includes.h>
+#include <net-snmp/agent/net-snmp-agent-includes.h>
+
+/*
+ * contains prototypes 
+ */
+#include "notification.h"
+#include "prestigeTraps.h"
+#include <stdio.h>
+
+/*
+ * our initialization routine
+ * (to get called, the function name must match init_FILENAME() 
+ */
+void
+init_prestigeTraps(void)
+{
+	
+	
+    DEBUGMSGTL(("example_notification",
+                "initializing (setting callback alarm)\n"));
+
+    snmp_alarm_register(35,     /* seconds */
+                        0,      /* repeat (every 30 seconds). */
+                        send_example_notification,      /* our callback */
+                        NULL    /* no callback data needed */
+        );
+	
+}
+
+/** here we send a SNMP v2 trap (which can be sent through snmpv3 and
+ *  snmpv1 as well) and send it out.
+ *
+ *     The various "send_trap()" calls allow you to specify traps in different
+ *  formats.  And the various "trapsink" directives allow you to specify
+ *  destinations to receive different formats.
+ *  But *all* traps are sent to *all* destinations, regardless of how they
+ *  were specified.
+ *  
+ *  
+ *  I.e. it's
+ * @verbatim
+ *                                           ___  trapsink
+ *                                          /
+ *      send_easy_trap \___  [  Trap      ] ____  trap2sink
+ *                      ___  [ Generator  ]
+ *      send_v2trap    /     [            ] ----- informsink
+ *                                          \____
+ *                                                trapsess
+ *  
+ *  *Not*
+ *       send_easy_trap  ------------------->  trapsink
+ *       send_v2trap     ------------------->  trap2sink
+ *       ????            ------------------->  informsink
+ *       ????            ------------------->  trapsess
+ * @endverbatim
+ */
+void
+send_example_notification(unsigned int clientreg, void *clientarg)
+{
+    /*
+     * define the OID for the notification we're going to send
+     * NET-SNMP-EXAMPLES-MIB::netSnmpExampleHeartbeatNotification 
+     */
+     #if 0
+    oid             notification_oid[] =
+        { 1,3,6,1,4,1,890,1,2,1,99,1 };
+    size_t          notification_oid_len = OID_LENGTH(notification_oid);
+    static u_long count = 0;
+
+    /*
+     * In the notification, we have to assign our notification OID to
+     * the snmpTrapOID.0 object. Here is it's definition. 
+     */
+    oid             objid_snmptrap[] = { 1, 3, 6, 1, 6, 3, 1, 1, 4, 1, 0 };
+    size_t          objid_snmptrap_len = OID_LENGTH(objid_snmptrap);
+
+    /*
+     * define the OIDs for the varbinds we're going to include
+     *  with the notification -
+     * NET-SNMP-EXAMPLES-MIB::netSnmpExampleHeartbeatRate  and
+     * NET-SNMP-EXAMPLES-MIB::netSnmpExampleHeartbeatName 
+     */
+    oid      hbeat_rate_oid[]   = { 1, 3, 6, 1, 4, 1, 8072, 2, 3, 2, 1, 0 };
+    size_t   hbeat_rate_oid_len = OID_LENGTH(hbeat_rate_oid);
+    oid      hbeat_name_oid[]   = { 1, 3, 6, 1, 4, 1, 8072, 2, 3, 2, 2, 0 };
+    size_t   hbeat_name_oid_len = OID_LENGTH(hbeat_name_oid);
+
+    /*
+     * here is where we store the variables to be sent in the trap 
+     */
+    netsnmp_variable_list *notification_vars = NULL;
+    const char *heartbeat_name = "A girl named Maria";
+const *rebootreson="sys reboot by user";
+#ifdef  RANDOM_HEARTBEAT
+    int  heartbeat_rate = rand() % 60;
+#else
+    int  heartbeat_rate = 30;
+#endif
+
+    DEBUGMSGTL(("example_notification", "defining the trap\n"));
+
+    /*
+     * add in the trap definition object 
+     */
+    snmp_varlist_add_variable(&notification_vars,
+                              /*
+                               * the snmpTrapOID.0 variable 
+                               */
+                              objid_snmptrap, objid_snmptrap_len,
+                              /*
+                               * value type is an OID 
+                               */
+                              ASN_OBJECT_ID,
+                              /*
+                               * value contents is our notification OID 
+                               */
+                              (u_char *) rebootreson,
+                              /*
+                               * size in bytes = oid length * sizeof(oid) 
+                               */
+                              //notification_oid_len * sizeof(oid)
+                              strlen(rebootreson));
+
+    /*
+     * add in the additional objects defined as part of the trap
+     */
+
+    snmp_varlist_add_variable(&notification_vars,
+                               hbeat_rate_oid, hbeat_rate_oid_len,
+                               ASN_INTEGER,
+                              (u_char *)&heartbeat_rate,
+                                  sizeof(heartbeat_rate));
+	
+
+    /*
+     * if we want to insert additional objects, we do it here 
+     */
+    if (heartbeat_rate < 30 ) {
+        snmp_varlist_add_variable(&notification_vars,
+                               hbeat_name_oid, hbeat_name_oid_len,
+                               ASN_OCTET_STR,
+                               heartbeat_name, strlen(heartbeat_name));
+    }
+
+    /*
+     * send the trap out.  This will send it to all registered
+     * receivers (see the "SETTING UP TRAP AND/OR INFORM DESTINATIONS"
+     * section of the snmpd.conf manual page. 
+     */
+    ++count;
+    DEBUGMSGTL(("example_notification", "sending trap %ld\n",count));
+    send_v2trap(notification_vars);
+
+    /*
+     * free the created notification variable list 
+     */
+    DEBUGMSGTL(("example_notification", "cleaning up\n"));
+    snmp_free_varbind(notification_vars);
+	#endif
+	FILE *fp=NULL;
+	int flag=1;
+	//fp=fopen("/tmp/tmp.snmp","r");
+	
+	if(access("/tmp/tmp.snmp", F_OK)){//first time start
+		fp=fopen("/tmp/tmp.snmp.start","r");
+		if(fp!=NULL){
+			fscanf(fp,"%d",&flag);
+			fclose(fp);
+			if(flag!=0){
+	 			send_easy_trap(0, 0);
+				fp=fopen("/tmp/tmp.snmp.start","w");
+				fprintf(fp,"%d",0);
+				fclose(fp);
+				fp=fopen("/tmp/tmp.snmp","w");
+				fprintf(fp,"%d",1);
+				fclose(fp);
+			}
+			
+			
+		}
+		
+	}
+	else{
+		//fclose(fp);
+	}
+}
+
+
+
+#if 0
+
+/*
+ *  Template MIB group implementation - example.c
+ *
+ */
+
+/*
+ * include important headers 
+ */
+#include <net-snmp/net-snmp-config.h>
+#if HAVE_STDLIB_H
+#include <stdlib.h>
+#endif
+#if HAVE_STRING_H
+#include <string.h>
+#else
+#include <strings.h>
+#endif
+
+#include <net-snmp/net-snmp-includes.h>
+#include <net-snmp/agent/net-snmp-agent-includes.h>
+
+/*
+ * header_generic() comes from here 
+ */
+#include "util_funcs/header_generic.h"
+
+/*
+ * include our .h file 
+ */
+
+   /*
+    *  Certain objects can be set via configuration file directives.
+    *  These variables hold the values for such objects, as they need to
+    *   be accessible to both the config handlers, and the callback routine.
+    */
+#define EXAMPLE_STR_LEN	300
+#define EXAMPLE_STR_DEFAULT	"life the universe and everything"
+int             example_int = 42;
+char            example_str[EXAMPLE_STR_LEN];
+
+        /*
+         * Forward declarations for the config handlers 
+         */
+void            example_parse_config_exampleint(const char *token,
+                                                char *cptr);
+void            example_parse_config_examplestr(const char *token,
+                                                char *cptr);
+void            example_free_config_exampleint(void);
+void            example_free_config_examplestr(void);
+
+
+        /*********************
+	 *
+	 *  Initialisation & common implementation functions
+	 *
+	 *********************/
+
+    /*
+     * This array structure defines a representation of the
+     *  MIB being implemented.
+     *
+     * The type of the array is 'struct variableN', where N is
+     *  large enough to contain the longest OID sub-component
+     *  being loaded.  This will normally be the maximum value
+     *  of the fifth field in each line.  In this case, the second
+     *  and third entries are both of size 2, so we're using
+     *  'struct variable2'
+     *
+     * The supported values for N are listed in <agent/var_struct.h>
+     *  If the value you need is not listed there, simply use the
+     *  next largest that is.
+     *
+     * The format of each line is as follows
+     *  (using the first entry as an example):
+     *      1: EXAMPLESTRING:
+     *          The magic number defined in the example header file.
+     *          This is passed to the callback routine and is used
+     *            to determine which object is being queried.
+     *      2: ASN_OCTET_STR:
+     *          The type of the object.
+     *          Valid types are listed in <snmp_impl.h>
+     *      3: NETSNMP_OLDAPI_RONLY (or NETSNMP_OLDAPI_RWRITE):
+     *          Whether this object can be SET or not.
+     *      4: var_example:
+     *          The callback routine, used when the object is queried.
+     *          This will usually be the same for all objects in a module
+     *            and is typically defined later in this file.
+     *      5: 1:
+     *          The length of the OID sub-component (the next field)
+     *      6: {1}:
+     *          The OID sub-components of this entry.
+     *          In other words, the bits of the full OID that differ
+     *            between the various entries of this array.
+     *          This value is appended to the common prefix (defined later)
+     *            to obtain the full OID of each entry.
+     */
+struct variable2 example_variables[] = {
+    
+    {EXAMPLETRIGGERTRAP2, ASN_OCTET_STR, NETSNMP_OLDAPI_RWRITE,
+     var_example, 99, {1}}
+};
+
+    /*
+     * This array defines the OID of the top of the mib tree that we're
+     *  registering underneath.
+     * Note that this needs to be the correct size for the OID being 
+     *  registered, so that the length of the OID can be calculated.
+     *  The format given here is the simplest way to achieve this.
+     */
+oid             example_variables_oid[] = {1,3,6,1,4,1,890,1,2,1 };
+
+
+
+    /*
+     * This function is called at the time the agent starts up
+     *  to do any initializations that might be required.
+     *
+     * In theory it is optional and can be omitted if no
+     *  initialization is needed.  In practise, every module
+     *  will need to register itself (or the objects being
+     *  implemented will not appear in the MIB tree), and this
+     *  registration is typically done here.
+     *
+     * If this function is added or removed, you must re-run
+     *  the configure script, to detect this change.
+     */
+void
+init_prestigeTraps(void)
+{
+    /*
+     * Register ourselves with the agent to handle our mib tree.
+     * The arguments are:
+     *    descr:   A short description of the mib group being loaded.
+     *    var:     The variable structure to load.
+     *                  (the name of the variable structure defined above)
+     *    vartype: The type of this variable structure
+     *    theoid:  The OID pointer this MIB is being registered underneath.
+     */
+    REGISTER_MIB("example", example_variables, variable2,
+                 example_variables_oid);
+
+
+    /*
+     *  Register config handlers for the two objects that can be set
+     *   via configuration file directive.
+     *  Also set a default value for the string object.  Note that the
+     *   example integer variable was initialised above.
+     */
+    strncpy(example_str, EXAMPLE_STR_DEFAULT, EXAMPLE_STR_LEN);
+
+    snmpd_register_config_handler("exampleint",
+                                  example_parse_config_exampleint,
+                                  example_free_config_exampleint,
+                                  "exampleint value");
+    snmpd_register_config_handler("examplestr",
+                                  example_parse_config_examplestr,
+                                  example_free_config_examplestr,
+                                  "examplestr value");
+    snmpd_register_config_handler("examplestring",
+                                  example_parse_config_examplestr,
+                                  example_free_config_examplestr,
+                                  "examplestring value");
+
+    /*
+     * One common requirement is to read values from the kernel.
+     * This is usually initialised here, to speed up access when the
+     *  information is read in, as a response to an incoming request.
+     *
+     * This module doesn't actually use this mechanism,
+     * so this call is commented out here.
+     */
+    /*
+     * auto_nlist( "example_symbol", 0, 0 ); 
+     */
+}
+
+        /*********************
+	 *
+	 *  Configuration file handling functions
+	 *
+	 *********************/
+
+void
+example_parse_config_exampleint(const char *token, char *cptr)
+{
+    example_int = atoi(cptr);
+}
+
+void
+example_parse_config_examplestr(const char *token, char *cptr)
+{
+    /*
+     * Make sure the string fits in the space allocated for it.
+     */
+    if (strlen(cptr) < EXAMPLE_STR_LEN)
+        strcpy(example_str, cptr);
+    else {
+        /*
+         * Truncate the string if necessary.
+         * An alternative approach would be to log an error,
+         *  and discard this value altogether.
+         */
+        strncpy(example_str, cptr, EXAMPLE_STR_LEN - 4);
+        example_str[EXAMPLE_STR_LEN - 4] = 0;
+        strcat(example_str, "...");
+        example_str[EXAMPLE_STR_LEN - 1] = 0;
+    }
+}
+
+        /*
+         * We don't need to do anything special when closing down 
+         */
+void
+example_free_config_exampleint(void)
+{
+}
+
+void
+example_free_config_examplestr(void)
+{
+}
+
+        /*********************
+	 *
+	 *  System specific implementation functions
+	 *
+	 *********************/
+
+    /*
+     * Define the callback function used in the example_variables structure.
+     * This is called whenever an incoming request refers to an object
+     *  within this sub-tree.
+     *
+     * Four of the parameters are used to pass information in.
+     * These are:
+     *    vp      The entry from the 'example_variables' array for the
+     *             object being queried.
+     *    name    The OID from the request.
+     *    length  The length of this OID.
+     *    exact   A flag to indicate whether this is an 'exact' request
+     *             (GET/SET) or an 'inexact' one (GETNEXT/GETBULK).
+     *
+     * Four of the parameters are used to pass information back out.
+     * These are:
+     *    name     The OID being returned.
+     *    length   The length of this OID.
+     *    var_len  The length of the answer being returned.
+     *    write_method   A pointer to the SET function for this object.
+     *
+     * Note that name & length serve a dual purpose in both roles.
+     */
+
+u_char         *
+var_example(struct variable *vp,
+            oid * name,
+            size_t * length,
+            int exact, size_t * var_len, WriteMethod ** write_method)
+{
+    /*
+     *  The result returned from this function needs to be a pointer to
+     *    static data (so that it can be accessed from outside).
+     *  Define suitable variables for any type of data we may return.
+     */
+    static char     string[EXAMPLE_STR_LEN];    /* for EXAMPLESTRING   */
+    static oid      oid_ret[12]; /* for EXAMPLEOBJECTID */
+    static long     long_ret;   /* for everything else */
+
+    /*
+     * Before returning an answer, we need to check that the request
+     *  refers to a valid instance of this object.  The utility routine
+     *  'header_generic' can be used to do this for scalar objects.
+     *
+     * This routine 'header_simple_table' does the same thing for "simple"
+     *  tables. (See the AGENT.txt file for the definition of a simple table).
+     *
+     * Both these utility routines also set up default values for the
+     *  return arguments (assuming the check succeeded).
+     * The name and length are set suitably for the current object,
+     *  var_len assumes that the result is an integer of some form,
+     *  and write_method assumes that the object cannot be set.
+     *
+     * If these assumptions are correct, this callback routine simply
+     * needs to return a pointer to the appropriate value (using 'long_ret').
+     * Otherwise, 'var_len' and/or 'write_method' should be set suitably.
+     */
+    DEBUGMSGTL(("example", "var_example entered\n"));
+    if (header_generic(vp, name, length, exact, var_len, write_method) ==
+        MATCH_FAILED)
+        return NULL;
+
+
+    /*
+     * Many object will need to obtain data from the operating system in
+     *  order to return the appropriate value.  Typically, this is done
+     *  here - immediately following the 'header' call, and before the
+     *  switch statement. This is particularly appropriate if a single 
+     *  interface call can return data for all the objects supported.
+     *
+     * This example module does not rely on external data, so no such
+     *  calls are needed in this case.  
+     */
+
+    /*
+     * Now use the magic number from the variable pointer 'vp' to
+     *  select the particular object being queried.
+     * In each case, one of the static objects is set up with the
+     *  appropriate information, and returned mapped to a 'u_char *'
+     */
+    switch (vp->magic) {
+    case EXAMPLETRIGGERTRAP2:
+        /*
+         * This object is essentially "write-only".
+         * It only exists to trigger the sending of a v2 trap.
+         * Reading it will always return 0.
+         */
+        long_ret = 0;
+        *write_method = write_exampletrap2;
+        return (u_char *) & long_ret;
+
+    default:
+        /*
+         *  This will only be triggered if there's a problem with
+         *   the coding of the module.  SNMP requests that reference
+         *   a non-existant OID will be directed elsewhere.
+         *  If this branch is reached, log an error, so that
+         *   the problem can be investigated.
+         */
+        DEBUGMSGTL(("snmpd", "unknown sub-id %d in examples/var_example\n",
+                    vp->magic));
+    }
+    /*
+     * If we fall through to here, fail by returning NULL.
+     * This is essentially a continuation of the 'default' case above.
+     */
+    return NULL;
+}
+
+        /*********************
+	 *
+	 *  Writeable object SET handling routines
+	 *
+	 *********************/
+
+
+/*
+ * this documents how to send a SNMPv2 (and higher) trap via the
+ * send_v2trap() API.
+ * 
+ * Coding SNMP-v2 Trap:
+ * 
+ * The SNMPv2-Trap PDU contains at least a pair of object names and
+ * values: - sysUpTime.0 whose value is the time in hundredths of a
+ * second since the netwok management portion of system was last
+ * reinitialized.  - snmpTrapOID.0 which is part of the trap group SNMPv2
+ * MIB whose value is the object-id of the specific trap you have defined
+ * in your own MIB.  Other variables can be added to caracterize the
+ * trap.
+ * 
+ * The function send_v2trap adds automaticallys the two objects but the
+ * value of snmpTrapOID.0 is 0.0 by default. If you want to add your trap
+ * name, you have to reconstruct this object and to add your own
+ * variable.
+ * 
+ */
+
+
+
+int
+write_exampletrap2(int action,
+                   u_char * var_val,
+                   u_char var_val_type,
+                   size_t var_val_len,
+                   u_char * statP, oid * name, size_t name_len)
+{
+    long            intval;
+
+    /*
+     * these variales will be used when we send the trap 
+     */
+    oid             objid_snmptrap[] = { 1, 3, 6, 1, 6, 3, 1, 1, 4, 1, 0 };     /* snmpTrapOID.0 */
+    oid             demo_trap[] = { 1,3,6,1,4,1,890,1,2,1,99,1 };  /*demo-trap */
+    oid             example_string_oid[] =
+        { 1,3,6,1,4,1,890,1,2,1,99,1.0};
+    static netsnmp_variable_list var_trap;
+    static netsnmp_variable_list var_obj;
+
+    DEBUGMSGTL(("example", "write_exampletrap2 entered: action=%d\n",
+                action));
+    switch (action) {
+    case RESERVE1:
+        /*
+         *  The only acceptable value is the integer 1
+         */
+        if (var_val_type != ASN_INTEGER) {
+            DEBUGMSGTL(("example", "%x not integer type", var_val_type));
+            return SNMP_ERR_WRONGTYPE;
+        }
+        if (var_val_len > sizeof(long)) {
+            DEBUGMSGTL(("example", "wrong length %x", var_val_len));
+            return SNMP_ERR_WRONGLENGTH;
+        }
+
+        intval = *((long *) var_val);
+        if (intval != 1) {
+            DEBUGMSGTL(("example", "wrong value %x", intval));
+            return SNMP_ERR_WRONGVALUE;
+        }
+        break;
+
+    case RESERVE2:
+        /*
+         * No resources are required.... 
+         */
+        break;
+
+    case FREE:
+        /*
+         * ... so no resources need be freed 
+         */
+        break;
+
+    case ACTION:
+        /*
+         *  Having triggered the sending of a trap,
+         *   it would be impossible to revoke this,
+         *   so we can't actually invoke the action here.
+         */
+        break;
+
+    case UNDO:
+        /*
+         * We haven't done anything yet,
+         * so there's nothing to undo 
+         */
+        break;
+
+    case COMMIT:
+        /*
+         *  Everything else worked, so it's now safe
+         *   to trigger the trap.
+         *  Note that this is *only* acceptable since
+         *   the trap sending routines are "failsafe".
+         *  (In fact, they can fail, but they return no
+         *   indication of this, which is the next best thing!)
+         */
+
+        /*
+         * trap definition objects 
+         */
+
+        var_trap.next_variable = &var_obj;      /* next variable */
+        var_trap.name = objid_snmptrap; /* snmpTrapOID.0 */
+        var_trap.name_length = sizeof(objid_snmptrap) / sizeof(oid);    /* number of sub-ids */
+        var_trap.type = ASN_OBJECT_ID;
+        var_trap.val.objid = demo_trap; /* demo-trap objid */
+        var_trap.val_len = sizeof(demo_trap);   /* length in bytes (not number of subids!) */
+
+
+        /*
+         * additional objects 
+         */
+
+
+        var_obj.next_variable = NULL;   /* No more variables after this one */
+        var_obj.name = example_string_oid;
+        var_obj.name_length = sizeof(example_string_oid) / sizeof(oid); /* number of sub-ids */
+        var_obj.type = ASN_OCTET_STR;   /* type of variable */
+        var_obj.val.string = example_str;       /* value */
+        var_obj.val_len = strlen(example_str);
+        DEBUGMSGTL(("example", "write_exampletrap2 sending the v2 trap\n"));
+        send_v2trap(&var_trap);
+        DEBUGMSGTL(("example", "write_exampletrap2 v2 trap sent\n"));
+
+        break;
+
+    }
+    return SNMP_ERR_NOERROR;
+}
+#endif
+
diff -Naur net-snmp-5.7.2-orig/agent/mibgroup/ZYXEL-PRESTIGE-MIB/prestigeTraps.h net-snmp-5.7.2/agent/mibgroup/ZYXEL-PRESTIGE-MIB/prestigeTraps.h
--- net-snmp-5.7.2-orig/agent/mibgroup/ZYXEL-PRESTIGE-MIB/prestigeTraps.h	1970-01-01 08:00:00.000000000 +0800
+++ net-snmp-5.7.2/agent/mibgroup/ZYXEL-PRESTIGE-MIB/prestigeTraps.h	2013-10-08 09:35:17.626117000 +0800
@@ -0,0 +1,18 @@
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *        : mib2c.notify.conf 10110 2004-04-15 12:29:19Z dts12 $
+ */
+#ifndef PRESTIGETRAPS_H
+#define PRESTIGETRAPS_H
+#if 0
+#define	EXAMPLETRIGGERTRAP2     8
+config_require(util_funcs/header_generic)
+FindVarMethod var_example;   
+WriteMethod write_exampletrap2;
+#endif
+int sent_trap();
+void
+send_example_notification(unsigned int clientreg, void *clientarg);
+/* function declarations */
+
+#endif /* PRESTIGETRAPS_H */
diff -Naur net-snmp-5.7.2-orig/agent/mibgroup/ZYXEL-PRESTIGE-MIB/prestigeXDSL.c net-snmp-5.7.2/agent/mibgroup/ZYXEL-PRESTIGE-MIB/prestigeXDSL.c
--- net-snmp-5.7.2-orig/agent/mibgroup/ZYXEL-PRESTIGE-MIB/prestigeXDSL.c	1970-01-01 08:00:00.000000000 +0800
+++ net-snmp-5.7.2/agent/mibgroup/ZYXEL-PRESTIGE-MIB/prestigeXDSL.c	2013-10-08 09:35:17.626117000 +0800
@@ -0,0 +1,157 @@
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *        : mib2c.scalar.conf 11805 2005-01-07 09:37:18Z dts12 $
+ */
+
+#include <net-snmp/net-snmp-config.h>
+#include <net-snmp/net-snmp-includes.h>
+#include <net-snmp/agent/net-snmp-agent-includes.h>
+#include "prestigeXDSL.h"
+#include "ccclib.h"
+
+/** Initializes the prestigeXDSL module */
+void
+init_prestigeXDSL(void)
+{
+    static oid FarEndCRCError_oid[] = { 1,3,6,1,4,1,890,1,2,1,6,1 };
+    static oid NearEndCRCError_oid[] = { 1,3,6,1,4,1,890,1,2,1,6,2 };
+    static oid DSLModemUptime_oid[] = { 1,3,6,1,4,1,890,1,2,1,6,3 };
+    static oid DSLModemDowntime_oid[] = { 1,3,6,1,4,1,890,1,2,1,6,4 };
+
+  DEBUGMSGTL(("prestigeXDSL", "Initializing\n"));
+
+    netsnmp_register_scalar(
+        netsnmp_create_handler_registration("FarEndCRCError", handle_FarEndCRCError,
+                               FarEndCRCError_oid, OID_LENGTH(FarEndCRCError_oid),
+                               HANDLER_CAN_RONLY
+        ));
+    netsnmp_register_scalar(
+        netsnmp_create_handler_registration("NearEndCRCError", handle_NearEndCRCError,
+                               NearEndCRCError_oid, OID_LENGTH(NearEndCRCError_oid),
+                               HANDLER_CAN_RONLY
+        ));
+    netsnmp_register_scalar(
+        netsnmp_create_handler_registration("DSLModemUptime", handle_DSLModemUptime,
+                               DSLModemUptime_oid, OID_LENGTH(DSLModemUptime_oid),
+                               HANDLER_CAN_RONLY
+        ));
+    netsnmp_register_scalar(
+        netsnmp_create_handler_registration("DSLModemDowntime", handle_DSLModemDowntime,
+                               DSLModemDowntime_oid, OID_LENGTH(DSLModemDowntime_oid),
+                               HANDLER_CAN_RONLY
+        ));
+}
+
+int
+handle_FarEndCRCError(netsnmp_mib_handler *handler,
+                          netsnmp_handler_registration *reginfo,
+                          netsnmp_agent_request_info   *reqinfo,
+                          netsnmp_request_info         *requests)
+{
+    /* We are never called for a GETNEXT if it's registered as a
+       "instance", as it's "magically" handled for us.  */
+
+    /* a instance handler also only hands us one request at a time, so
+       we don't need to loop over a list of requests; we'll only get one. */
+    
+    int ret=SNMP_ERR_NOERROR;
+    	switch(reqinfo->mode) {
+        case MODE_GET:
+			case MODE_GETBULK:
+            			ret=handleOfGetParameter(InternetGatewayDevice_WANDevice_1_WANDSLInterfaceConfig_Stats_Showtime, "ATUCCRCErrors", requests,ASN_INTEGER);
+           break;
+        default:
+            /* we should never get here, so this is a really bad error */
+            snmp_log(LOG_ERR, "unknown mode (%d) in %s\n", reqinfo->mode,__FUNCTION__ );
+            return SNMP_ERR_GENERR;
+    }
+
+   // return SNMP_ERR_NOERROR;
+	
+	return ret;
+}
+int
+handle_NearEndCRCError(netsnmp_mib_handler *handler,
+                          netsnmp_handler_registration *reginfo,
+                          netsnmp_agent_request_info   *reqinfo,
+                          netsnmp_request_info         *requests)
+{
+    /* We are never called for a GETNEXT if it's registered as a
+       "instance", as it's "magically" handled for us.  */
+
+    /* a instance handler also only hands us one request at a time, so
+       we don't need to loop over a list of requests; we'll only get one. */
+    
+     int ret=SNMP_ERR_NOERROR;
+    	switch(reqinfo->mode) {
+        case MODE_GET:
+			case MODE_GETBULK:
+            			ret=handleOfGetParameter(InternetGatewayDevice_WANDevice_1_WANDSLInterfaceConfig_Stats_Showtime, "CRCErrors", requests,ASN_INTEGER);
+           break;
+        default:
+            /* we should never get here, so this is a really bad error */
+            snmp_log(LOG_ERR, "unknown mode (%d) in %s\n", reqinfo->mode,__FUNCTION__ );
+            return SNMP_ERR_GENERR;
+    }
+
+   // return SNMP_ERR_NOERROR;
+	
+	return ret;
+}
+int
+handle_DSLModemUptime(netsnmp_mib_handler *handler,
+                          netsnmp_handler_registration *reginfo,
+                          netsnmp_agent_request_info   *reqinfo,
+                          netsnmp_request_info         *requests)
+{
+    /* We are never called for a GETNEXT if it's registered as a
+       "instance", as it's "magically" handled for us.  */
+
+    /* a instance handler also only hands us one request at a time, so
+       we don't need to loop over a list of requests; we'll only get one. */
+    
+    int ret=SNMP_ERR_NOERROR;
+    	switch(reqinfo->mode) {
+        case MODE_GET:
+			case MODE_GETBULK:
+            			ret=handleOfGetParameter(InternetGatewayDevice_WANDevice_1_WANDSLInterfaceConfig, "ShowtimeStart", requests,ASN_INTEGER);
+           break;
+        default:
+            /* we should never get here, so this is a really bad error */
+            snmp_log(LOG_ERR, "unknown mode (%d) in %s\n", reqinfo->mode,__FUNCTION__ );
+            return SNMP_ERR_GENERR;
+    }
+
+   // return SNMP_ERR_NOERROR;
+	
+	return ret;
+}
+int
+handle_DSLModemDowntime(netsnmp_mib_handler *handler,
+                          netsnmp_handler_registration *reginfo,
+                          netsnmp_agent_request_info   *reqinfo,
+                          netsnmp_request_info         *requests)
+{
+    /* We are never called for a GETNEXT if it's registered as a
+       "instance", as it's "magically" handled for us.  */
+
+    /* a instance handler also only hands us one request at a time, so
+       we don't need to loop over a list of requests; we'll only get one. */
+    
+   	int ret=SNMP_ERR_NOERROR;
+    	switch(reqinfo->mode) {
+        case MODE_GET:
+			case MODE_GETBULK:
+            			ret=handleOfGetParameter(InternetGatewayDevice_WANDevice_1_WANDSLInterfaceConfig_Stats_Showtime, "ErroredSecs", requests,ASN_INTEGER);
+           break;
+        default:
+            /* we should never get here, so this is a really bad error */
+            snmp_log(LOG_ERR, "unknown mode (%d) in %s\n", reqinfo->mode,__FUNCTION__ );
+            return SNMP_ERR_GENERR;
+    }
+
+   // return SNMP_ERR_NOERROR;
+	
+	return ret;
+
+}
diff -Naur net-snmp-5.7.2-orig/agent/mibgroup/ZYXEL-PRESTIGE-MIB/prestigeXDSL.h net-snmp-5.7.2/agent/mibgroup/ZYXEL-PRESTIGE-MIB/prestigeXDSL.h
--- net-snmp-5.7.2-orig/agent/mibgroup/ZYXEL-PRESTIGE-MIB/prestigeXDSL.h	1970-01-01 08:00:00.000000000 +0800
+++ net-snmp-5.7.2/agent/mibgroup/ZYXEL-PRESTIGE-MIB/prestigeXDSL.h	2013-10-08 09:35:17.626117000 +0800
@@ -0,0 +1,15 @@
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *        : mib2c.scalar.conf 11805 2005-01-07 09:37:18Z dts12 $
+ */
+#ifndef PRESTIGEXDSL_H
+#define PRESTIGEXDSL_H
+
+/* function declarations */
+void init_prestigeXDSL(void);
+Netsnmp_Node_Handler handle_FarEndCRCError;
+Netsnmp_Node_Handler handle_NearEndCRCError;
+Netsnmp_Node_Handler handle_DSLModemUptime;
+Netsnmp_Node_Handler handle_DSLModemDowntime;
+
+#endif /* PRESTIGEXDSL_H */
diff -Naur net-snmp-5.7.2-orig/agent/mibgroup/ZYXEL-PRESTIGE-MIB/time.c net-snmp-5.7.2/agent/mibgroup/ZYXEL-PRESTIGE-MIB/time.c
--- net-snmp-5.7.2-orig/agent/mibgroup/ZYXEL-PRESTIGE-MIB/time.c	1970-01-01 08:00:00.000000000 +0800
+++ net-snmp-5.7.2/agent/mibgroup/ZYXEL-PRESTIGE-MIB/time.c	2013-10-10 22:21:38.857352000 +0800
@@ -0,0 +1,334 @@
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *        : mib2c.scalar.conf 11805 2005-01-07 09:37:18Z dts12 $
+ */
+
+#include <net-snmp/net-snmp-config.h>
+#include <net-snmp/net-snmp-includes.h>
+#include <net-snmp/agent/net-snmp-agent-includes.h>
+#include "time.h"
+
+#define OTHER 1
+#define YES 2
+#define NO 3
+
+/** Initializes the time module */
+void
+init_time(void)
+{
+    static oid enable_oid[] = {PRESTIGE_TIME_OID, 1 };
+    static oid status_oid[] = { PRESTIGE_TIME_OID, 2 };
+    static oid currentLocaltime_oid[] = { PRESTIGE_TIME_OID, 3 };
+    static oid localTimeZoneName_oid[] = { PRESTIGE_TIME_OID, 4 };
+    //static oid xZyXELDefaultRouteProfileName_oid[] = { PRESTIGE_TIME_OID, 5 };
+
+	DEBUGMSGTL(("time", "Initializing\n"));
+
+    netsnmp_register_scalar(
+        netsnmp_create_handler_registration("enable", handle_enable,
+                               enable_oid, OID_LENGTH(enable_oid),
+                               HANDLER_CAN_RWRITE
+        ));
+    netsnmp_register_scalar(
+        netsnmp_create_handler_registration("status", handle_status,
+                               status_oid, OID_LENGTH(status_oid),
+                               HANDLER_CAN_RONLY
+        ));
+    netsnmp_register_scalar(
+        netsnmp_create_handler_registration("currentLocaltime", handle_currentLocaltime,
+                               currentLocaltime_oid, OID_LENGTH(currentLocaltime_oid),
+                               HANDLER_CAN_RONLY
+        ));
+    netsnmp_register_scalar(
+        netsnmp_create_handler_registration("localTimeZoneName", handle_localTimeZoneName,
+                               localTimeZoneName_oid, OID_LENGTH(localTimeZoneName_oid),
+                               HANDLER_CAN_RWRITE
+        ));
+#if 0
+    netsnmp_register_scalar(
+        netsnmp_create_handler_registration("xZyXELDefaultRouteProfileName", handle_xZyXELDefaultRouteProfileName,
+                               xZyXELDefaultRouteProfileName_oid, OID_LENGTH(xZyXELDefaultRouteProfileName_oid),
+                               HANDLER_CAN_RWRITE
+        ));
+#endif
+}
+
+int handle_enable(netsnmp_mib_handler *handler,
+                          netsnmp_handler_registration *reginfo,
+                          netsnmp_agent_request_info   *reqinfo,
+                          netsnmp_request_info         *requests)
+{
+    int ret=SNMP_ERR_NOERROR;
+	int enbl, size;
+	//void *buf = NULL;
+	
+    switch(reqinfo->mode) {
+        case MODE_GET:
+		case MODE_GETBULK:
+			ret=handleOfGetParameter(IGD_Time, "Enable", requests, ASN_INTEGER);
+			if(ret == SNMP_ERR_NOERROR){
+				if(*requests->requestvb->val.integer == 0) *requests->requestvb->val.integer = NO;
+				else *requests->requestvb->val.integer = YES;
+			}
+/*
+			if(handleOfGetParameterToBuf(IGD_Time, "Enable", &buf, &size) != -1){
+				enbl = *((unsigned char *)buf);
+				size = sizeof(int);
+				if(enbl == 1) enbl = YES;
+				else enbl = NO;
+				snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
+					(u_char *)&enbl, size);
+			}
+			else ret = SNMP_ERR_GENERR;
+*/			
+			break;
+			
+        case MODE_SET_RESERVE1:
+                /* or you could use netsnmp_check_vb_type_and_size instead */
+            ret = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
+            if ( ret != SNMP_ERR_NOERROR ) {
+                netsnmp_set_request_error(reqinfo, requests, ret );
+            }
+            break;
+
+        case MODE_SET_RESERVE2:
+            enbl = *requests->requestvb->val.integer;
+			if(!(enbl == YES || enbl == NO || enbl == OTHER)){
+				ret = SNMP_ERR_GENERR;
+				netsnmp_set_request_error(reqinfo, requests, ret );
+			}
+            break;
+
+        case MODE_SET_FREE:
+            /* XXX: free resources allocated in RESERVE1 and/or
+               RESERVE2.  Something failed somewhere, and the states
+               below won't be called. */
+            break;
+
+        case MODE_SET_ACTION:
+			enbl = *requests->requestvb->val.integer;
+			if(enbl == YES || enbl == NO ){
+				if(enbl == YES) *requests->requestvb->val.integer = 1;
+				else *requests->requestvb->val.integer = 0;
+				ret = handleOfSetParameter(IGD_Time, "Enable", requests);
+			}
+/*			
+			enbl = *requests->requestvb->val.integer;
+
+			if(enbl == YES || enbl == NO ){
+				buf = malloc(5);
+				if(enbl == YES){
+					sprintf(buf, "1");
+				}
+				else if(enbl == NO){
+					sprintf(buf, "0");
+				}
+				
+				ret=handleOfSetParameterFromBuf(IGD_Time, "Enable", buf);
+				if (ret) {
+					netsnmp_set_request_error(reqinfo, requests,ret );
+				}
+			}
+*/
+            break;
+
+        case MODE_SET_COMMIT:
+            /* XXX: delete temporary storage */
+            break;
+
+        case MODE_SET_UNDO:
+            /* XXX: UNDO and return to previous value for the object */
+            break;
+			
+        default:
+            /* we should never get here, so this is a really bad error */
+            snmp_log(LOG_ERR, "unknown mode (%d) in handle_enable\n", reqinfo->mode );
+            return SNMP_ERR_GENERR;
+    }
+
+	//if(buf) free(buf);
+    return ret;
+}
+
+int handle_status(netsnmp_mib_handler *handler,
+                          netsnmp_handler_registration *reginfo,
+                          netsnmp_agent_request_info   *reqinfo,
+                          netsnmp_request_info         *requests)
+{ 
+	int ret=SNMP_ERR_NOERROR;
+	switch(reqinfo->mode) {
+		case MODE_GET:
+		case MODE_GETBULK:
+			ret=handleOfGetParameter(IGD_Time, "Status", requests, ASN_OCTET_STR);
+			break;
+			
+        default:
+            /* we should never get here, so this is a really bad error */
+            snmp_log(LOG_ERR, "unknown mode (%d) in handle_status\n", reqinfo->mode );
+            return SNMP_ERR_GENERR;
+    }
+
+    return ret;
+}
+int
+handle_currentLocaltime(netsnmp_mib_handler *handler,
+                          netsnmp_handler_registration *reginfo,
+                          netsnmp_agent_request_info   *reqinfo,
+                          netsnmp_request_info         *requests)
+{
+    int ret=SNMP_ERR_NOERROR;
+	switch(reqinfo->mode) {
+		case MODE_GET:
+		case MODE_GETBULK:
+			ret=handleOfGetParameter(IGD_Time, "CurrentLocalTime", requests, ASN_TIMETICKS);
+			break;
+	   
+		default:
+			/* we should never get here, so this is a really bad error */
+			snmp_log(LOG_ERR, "unknown mode (%d) in %s\n", reqinfo->mode,__FUNCTION__ );
+			return SNMP_ERR_GENERR;
+    }
+
+    return ret;
+}
+int
+handle_localTimeZoneName(netsnmp_mib_handler *handler,
+                          netsnmp_handler_registration *reginfo,
+                          netsnmp_agent_request_info   *reqinfo,
+                          netsnmp_request_info         *requests)
+{
+    int hour, min;
+	char sign;
+    int ret=SNMP_ERR_NOERROR;
+	
+	switch(reqinfo->mode) {
+        case MODE_GET:
+		case MODE_GETBULK:
+			ret=handleOfGetParameter(IGD_Time, "X_ZYXEL_TimeZone", requests,ASN_OCTET_STR);
+			break;
+			
+        case MODE_SET_RESERVE1:
+                /* or you could use netsnmp_check_vb_type_and_size instead */
+            ret = netsnmp_check_vb_type(requests->requestvb, ASN_OCTET_STR);
+            if ( ret != SNMP_ERR_NOERROR ) {
+                netsnmp_set_request_error(reqinfo, requests, ret );
+				if(sscanf(requests->requestvb->val.string, "%c%d:%d", &sign, &hour, &min) == 3){
+					if(sign == '+' || sign == '-'){
+						if(!(hour >= 0 && hour <= 12 && min == 0))
+							ret = SNMP_ERR_GENERR;
+					}
+					else ret = SNMP_ERR_GENERR;
+				}
+				else ret = SNMP_ERR_GENERR;
+				
+				if ( ret != SNMP_ERR_NOERROR ) {
+					netsnmp_set_request_error(reqinfo, requests, ret );
+				}
+            }
+            break;
+
+        case MODE_SET_RESERVE2:
+
+            break;
+
+        case MODE_SET_FREE:
+            /* XXX: free resources allocated in RESERVE1 and/or
+               RESERVE2.  Something failed somewhere, and the states
+               below won't be called. */
+            break;
+
+        case MODE_SET_ACTION:
+            /* XXX: perform the value change here */
+			ret=handleOfSetParameter(IGD_Time, "X_ZYXEL_TimeZone", requests);
+            if (ret/* XXX: error? */) {
+                netsnmp_set_request_error(reqinfo, requests, ret/* some error */);
+            }
+            break;
+
+        case MODE_SET_COMMIT:
+            /* XXX: delete temporary storage */           
+            break;
+
+        case MODE_SET_UNDO:
+            /* XXX: UNDO and return to previous value for the object */
+            break;
+			
+        default:
+            /* we should never get here, so this is a really bad error */
+            snmp_log(LOG_ERR, "unknown mode (%d) in handle_localTimeZoneName\n", reqinfo->mode );
+            return SNMP_ERR_GENERR;
+    }
+
+    return ret;
+}
+#if 0 
+int handle_xZyXELDefaultRouteProfileName(netsnmp_mib_handler *handler,
+                          netsnmp_handler_registration *reginfo,
+                          netsnmp_agent_request_info   *reqinfo,
+                          netsnmp_request_info         *requests)
+{
+    /* We are never called for a GETNEXT if it's registered as a
+       "instance", as it's "magically" handled for us.  */
+
+    /* a instance handler also only hands us one request at a time, so
+       we don't need to loop over a list of requests; we'll only get one. */
+    
+    int ret=SNMP_ERR_NOERROR;
+    	switch(reqinfo->mode) {
+        case MODE_GET:
+			case MODE_GETBULK:
+            			ret=handleOfGetParameter(InternetGatewayDevice_Time, "X_ZyXEL_DefaultRouteProfileName", requests,ASN_OCTET_STR);
+           break;
+#if 1
+        /*
+         * SET REQUEST
+         *
+         * multiple states in the transaction.  See:
+         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
+         */
+        case MODE_SET_RESERVE1:
+                /* or you could use netsnmp_check_vb_type_and_size instead */
+            ret = netsnmp_check_vb_type(requests->requestvb, ASN_OCTET_STR);
+            if ( ret != SNMP_ERR_NOERROR ) {
+                netsnmp_set_request_error(reqinfo, requests, ret );
+            }
+            break;
+
+        case MODE_SET_RESERVE2:
+            /* XXX malloc "undo" storage buffer */
+            
+            break;
+
+        case MODE_SET_FREE:
+            /* XXX: free resources allocated in RESERVE1 and/or
+               RESERVE2.  Something failed somewhere, and the states
+               below won't be called. */
+            break;
+
+        case MODE_SET_ACTION:
+            /* XXX: perform the value change here */
+			ret=handleOfSetParameter(InternetGatewayDevice_Time, "X_ZyXEL_DefaultRouteProfileName", requests);
+            if (ret/* XXX: error? */) {
+                netsnmp_set_request_error(reqinfo, requests, ret/* some error */);
+            }
+            break;
+
+        case MODE_SET_COMMIT:
+            /* XXX: delete temporary storage */
+            
+            break;
+
+        case MODE_SET_UNDO:
+            /* XXX: UNDO and return to previous value for the object */
+           
+            break;
+#endif
+        default:
+            /* we should never get here, so this is a really bad error */
+            snmp_log(LOG_ERR, "unknown mode (%d) in handle_xZyXELDefaultRouteProfileName\n", reqinfo->mode );
+            return SNMP_ERR_GENERR;
+    }
+
+    return ret;
+}
+#endif
\ No newline at end of file
diff -Naur net-snmp-5.7.2-orig/agent/mibgroup/ZYXEL-PRESTIGE-MIB/time.h net-snmp-5.7.2/agent/mibgroup/ZYXEL-PRESTIGE-MIB/time.h
--- net-snmp-5.7.2-orig/agent/mibgroup/ZYXEL-PRESTIGE-MIB/time.h	1970-01-01 08:00:00.000000000 +0800
+++ net-snmp-5.7.2/agent/mibgroup/ZYXEL-PRESTIGE-MIB/time.h	2013-10-10 22:21:38.857352000 +0800
@@ -0,0 +1,20 @@
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *        : mib2c.scalar.conf 11805 2005-01-07 09:37:18Z dts12 $
+ */
+#ifndef TIME_H
+#define TIME_H
+
+#include "zylib.h"
+/* function declarations */
+void init_time(void);
+Netsnmp_Node_Handler handle_enable;
+Netsnmp_Node_Handler handle_status;
+Netsnmp_Node_Handler handle_currentLocaltime;
+Netsnmp_Node_Handler handle_localTimeZoneName;
+//Netsnmp_Node_Handler handle_xZyXELDefaultRouteProfileName;
+config_require(ZYXEL-PRESTIGE-MIB/zylib);
+
+#define PRESTIGE_TIME_OID PRESTIGE_COMM_OID, 8
+
+#endif /* TIME_H */
diff -Naur net-snmp-5.7.2-orig/agent/mibgroup/ZYXEL-PRESTIGE-MIB/wanDeviceNumberOfEntry.c net-snmp-5.7.2/agent/mibgroup/ZYXEL-PRESTIGE-MIB/wanDeviceNumberOfEntry.c
--- net-snmp-5.7.2-orig/agent/mibgroup/ZYXEL-PRESTIGE-MIB/wanDeviceNumberOfEntry.c	1970-01-01 08:00:00.000000000 +0800
+++ net-snmp-5.7.2/agent/mibgroup/ZYXEL-PRESTIGE-MIB/wanDeviceNumberOfEntry.c	2013-10-08 09:35:17.626117000 +0800
@@ -0,0 +1,45 @@
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *        : mib2c.scalar.conf 11805 2005-01-07 09:37:18Z dts12 $
+ */
+
+#include <net-snmp/net-snmp-config.h>
+#include <net-snmp/net-snmp-includes.h>
+#include <net-snmp/agent/net-snmp-agent-includes.h>
+#include "wanDeviceNumberOfEntry.h"
+
+/** Initializes the wanDeviceNumberOfEntry module */
+void
+init_wanDeviceNumberOfEntry(void)
+{
+    static oid wanDeviceNumberOfEntry_oid[] = { PRESTIGE_WANDEVSUM_OID };
+
+	DEBUGMSGTL(("wanDeviceNumberOfEntry", "Initializing\n"));
+
+    netsnmp_register_scalar(
+        netsnmp_create_handler_registration("wanDeviceNumberOfEntry", handle_wanDeviceNumberOfEntry,
+                               wanDeviceNumberOfEntry_oid, OID_LENGTH(wanDeviceNumberOfEntry_oid),
+                               HANDLER_CAN_RONLY
+        ));
+}
+
+int
+handle_wanDeviceNumberOfEntry(netsnmp_mib_handler *handler,
+                          netsnmp_handler_registration *reginfo,
+                          netsnmp_agent_request_info   *reqinfo,
+                          netsnmp_request_info         *requests)
+{
+    int ret=SNMP_ERR_NOERROR;
+	switch(reqinfo->mode) {
+        case MODE_GET:
+		case MODE_GETBULK:
+			ret=handleOfGetIntfDevNum( requests, ASN_INTEGER, 1);
+			break;
+        default:
+            /* we should never get here, so this is a really bad error */
+            snmp_log(LOG_ERR, "unknown mode (%d) in %s\n", reqinfo->mode,__FUNCTION__ );
+            return SNMP_ERR_GENERR;
+    }
+
+	return ret;
+}
diff -Naur net-snmp-5.7.2-orig/agent/mibgroup/ZYXEL-PRESTIGE-MIB/wanDeviceNumberOfEntry.h net-snmp-5.7.2/agent/mibgroup/ZYXEL-PRESTIGE-MIB/wanDeviceNumberOfEntry.h
--- net-snmp-5.7.2-orig/agent/mibgroup/ZYXEL-PRESTIGE-MIB/wanDeviceNumberOfEntry.h	1970-01-01 08:00:00.000000000 +0800
+++ net-snmp-5.7.2/agent/mibgroup/ZYXEL-PRESTIGE-MIB/wanDeviceNumberOfEntry.h	2013-10-08 09:35:17.626117000 +0800
@@ -0,0 +1,16 @@
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *        : mib2c.scalar.conf 11805 2005-01-07 09:37:18Z dts12 $
+ */
+#ifndef WANDEVICENUMBEROFENTRY_H
+#define WANDEVICENUMBEROFENTRY_H
+#include "zylib.h"
+
+/* function declarations */
+void init_wanDeviceNumberOfEntry(void);
+Netsnmp_Node_Handler handle_wanDeviceNumberOfEntry;
+config_require(ZYXEL-PRESTIGE-MIB/zylib);
+
+#define PRESTIGE_WANDEVSUM_OID PRESTIGE_COMM_OID, 11
+
+#endif /* WANDEVICENUMBEROFENTRY_H */
diff -Naur net-snmp-5.7.2-orig/agent/mibgroup/ZYXEL-PRESTIGE-MIB/zylib.c net-snmp-5.7.2/agent/mibgroup/ZYXEL-PRESTIGE-MIB/zylib.c
--- net-snmp-5.7.2-orig/agent/mibgroup/ZYXEL-PRESTIGE-MIB/zylib.c	1970-01-01 08:00:00.000000000 +0800
+++ net-snmp-5.7.2/agent/mibgroup/ZYXEL-PRESTIGE-MIB/zylib.c	2013-10-10 22:21:38.857352000 +0800
@@ -0,0 +1,1355 @@
+#include <net-snmp/net-snmp-config.h>
+#include <net-snmp/net-snmp-includes.h>
+#include <net-snmp/agent/net-snmp-agent-includes.h>
+//#include <string.h>
+#include <stdlib.h>
+#include <syslog.h>
+#include <time.h>
+#include <sys/socket.h>
+#include <netinet/in.h>
+#include <arpa/inet.h>
+#include "zylib.h"
+
+#define u_int8 unsigned char
+#define u_int16 unsigned short
+#define u_int32 unsigned int
+
+int createDhcpPoolAddr(const char *ipAddr, const char *netmask, char *minAddr, char *maxAddr){
+	int mask, first, last, ip, subnet, change=0;
+	struct in_addr addr;
+	char *str;
+	if(ipAddr == NULL || netmask == NULL || minAddr == NULL || maxAddr == NULL) return -1;
+	
+	if (!inet_aton(ipAddr, &addr)) return -1;
+	ip = ntohl(addr.s_addr);
+	if (!inet_aton(netmask, &addr)) return -1;	
+	mask = ntohl(addr.s_addr);
+	
+	if (inet_aton(minAddr, &addr))
+		first= ntohl(addr.s_addr);
+	else first = 0;
+	
+	if (inet_aton(maxAddr, &addr))
+		last= ntohl(addr.s_addr);
+	else last = 0;
+	
+	subnet = ip & mask;
+	
+	if(first == 0 || last == 0){
+		first = subnet + 1;
+		last = subnet + ~mask - 1;
+	}
+	else if(subnet != (first & mask) || subnet != (last & mask)){
+		first = subnet + 1;
+		last = subnet + ~mask - 1;
+	}
+	
+	if(ip == last) last = ip - 1;
+	else if(ip == first) first = ip + 1;
+	else if(first < ip && ip < last){
+		if((ip - first) < (last - ip)) first = ip + 1;
+		else last = ip - 1;
+	}
+	
+	addr.s_addr = htonl(first);
+	str = inet_ntoa(addr);
+	if(strcmp(str, minAddr)){
+		strcpy(minAddr, str);
+		change = 1;
+	}
+	
+	addr.s_addr = htonl(last);
+	str = inet_ntoa(addr);
+	if(strcmp(str, maxAddr)){
+		strcpy(maxAddr, str);
+		change = 1;
+	}
+	ZYSNMP_ERR("DHCP Pool: %s to %s\n", minAddr, maxAddr);
+	return change;
+}
+
+int compareIpAddress(const char *ip, const char *ip2){
+	struct in_addr addr, addr2, mask;
+
+	if(ip == NULL || ip2 == NULL) return -1;
+	if ( ! inet_aton(ip, &addr) ) {
+		return -1;
+	}
+	if ( ! inet_aton(ip2, &addr2) ) {
+		return -1;
+	}
+
+	return ( (addr.s_addr) < (addr2.s_addr) );
+}
+
+int checkValidIpAddress(const char *ip,const char *subnet){
+	struct in_addr addr, mask;
+	int network, first, last, ipaddr;
+	if(ip == NULL && subnet == NULL) return -1;
+	if ( ! inet_aton(ip, &addr) ) {
+		return -1;
+	}
+	if ( ! inet_aton(subnet, &mask) ) {
+		return -1;
+	}
+
+	network = ntohl(addr.s_addr & mask.s_addr);
+	first = network + 1;
+	last = network + ~ntohl(mask.s_addr) - 1;
+	ipaddr = ntohl(addr.s_addr);
+	
+	return (first <=ipaddr && ipaddr <=last);
+}
+
+int checkIpNetwork(const char *ip, const char *ip2, const char *subnet){
+	struct in_addr addr, addr2, mask;
+
+	if(ip == NULL || ip2 == NULL || subnet == NULL) return -1;
+	if ( ! inet_aton(ip, &addr) ) {
+		return -1;
+	}
+	if ( ! inet_aton(ip2, &addr2) ) {
+		return -1;
+	}	
+	if ( ! inet_aton(subnet, &mask) ) {
+		return -1;
+	}
+
+	return ( (addr.s_addr & mask.s_addr) == (addr2.s_addr & mask.s_addr) );
+}
+
+int checkIpAddress(const char *ip){
+	struct in_addr addr;
+	
+	if(ip == NULL) return -1;
+	if ( ! inet_aton(ip, &addr) ) {
+		return 0;
+	}
+	return 1;
+}
+
+int checkSubnetMask(const char *mask){
+	struct in_addr addr;
+	int mbits, mk, i;
+	
+	if(mask == NULL) return -1;
+	if ( ! inet_aton(mask, &addr) ) {
+		return 0;
+	}
+	mk = ntohl(addr.s_addr);
+	for(mbits=32;(mk & (1L<<(32-mbits))) == 0;mbits-- ) 
+		;
+	mk = 0;
+	for(i=0;i<mbits;i++)
+		mk |= 1<<(31-i);
+	if(mk != ntohl(addr.s_addr)){
+		return 0;
+	}
+	return 1;
+}
+
+int parseVal2Str (char *buf, size_t buf_len, netsnmp_variable_list *var){
+	int len = 0, i;
+	char *tmp;
+	u_char* ip;
+	struct enum_list *ep;
+
+	if(buf == NULL || var == NULL) return -1;
+	memset(buf, 0, buf_len);
+	
+	switch (var->type) {
+		case ASN_INTEGER:
+			snprintf(buf, buf_len, "%ld", *var->val.integer);
+			len = strlen(buf);
+			break;
+
+		case ASN_GAUGE:
+		case ASN_COUNTER:
+		case ASN_TIMETICKS:
+		case ASN_UINTEGER:
+			snprintf(buf, buf_len, "%lu", (unsigned long) *var->val.integer);
+			len = strlen(buf);
+			break;
+
+		case ASN_OCTET_STR:
+		case ASN_OPAQUE:
+			//ZYSNMP_ERR("%d, %s\n",var->val_len, var->val.string);   
+			len = var->val_len;
+			if (len > buf_len)
+				len = buf_len;
+			memcpy(buf, (char*)var->val.string, len);
+			//ZYSNMP_ERR("%d, %s\n",strlen(buf),buf); 
+			break;
+
+		case ASN_IPADDRESS:
+			ip = (u_char*)var->val.string;
+			snprintf(buf, buf_len, "%d.%d.%d.%d", ip[0], ip[1], ip[2], ip[3]);
+			len = strlen(buf);
+			break;
+
+		case ASN_NULL:
+			break;
+
+		case ASN_OBJECT_ID:
+			tmp = buf;
+			len = var->val_len/sizeof(oid);
+			for (i=0; i < len; i++) {
+				tmp += sprintf(tmp,".%lu",var->val.objid[i]);
+			}
+			len = strlen(buf);
+			break;
+
+
+		case ASN_COUNTER64:
+		case ASN_OPAQUE_COUNTER64:
+		case ASN_OPAQUE_U64:
+			printU64(buf,(struct counter64 *)var->val.counter64);
+			len = strlen(buf);
+			break;
+
+		case ASN_OPAQUE_I64:
+			printI64(buf,(struct counter64 *)var->val.counter64);
+			len = strlen(buf);
+			break;
+
+		case ASN_BIT_STR:
+			snprint_bitstring(buf, buf_len, var, NULL, NULL, NULL);
+			len = strlen(buf);
+			break;
+
+		case ASN_OPAQUE_FLOAT:
+			if (var->val.floatVal)
+				snprintf(buf, buf_len, "%f", *var->val.floatVal);
+			len = strlen(buf);
+			break;
+
+		case ASN_OPAQUE_DOUBLE:
+			if (var->val.doubleVal)
+				snprintf(buf, buf_len, "%f", *var->val.doubleVal);
+			len = strlen(buf);
+			break;
+
+		case ASN_NSAP:
+		default:
+			len = -1;
+			fprintf(stderr,"snprint_value: asn type not handled %d\n",var->type);
+	}
+	return(len);
+}
+
+int parseStr2Val(const char *buf, const int type, const int varType, netsnmp_variable_list *var){
+	int len = 0, size, i;
+	u_char *val = NULL, *tmp = NULL;
+	char *patch;
+	
+	if(buf == NULL || var == NULL) return -1;
+	
+	switch (varType) {
+		case ASN_BOOLEAN:
+			size = sizeof(u_int8); 
+			val = (u_char *) malloc(size);
+			
+			if(type == json_type_int || type == json_type_uint8 || type == json_type_ulong
+					|| type == json_type_uint16 || type == json_type_uint32 || type == json_type_boolean){
+				i = atoi(buf);
+				if(i == 1 || i ==0)
+					*((u_int8*)val) = i;
+				else{ size = -1; break;}
+			}
+			else if(type == json_type_string){
+				if(strcasecmp(buf, "true")){
+					*((u_int8*)val) = 1;
+				}
+				else if(strcasecmp(buf, "false")){
+					*((u_int8*)val) = 0;
+				}
+				else{ size = -1; break;}
+			}
+			else{ size = -1; break;}
+			
+			snmp_set_var_typed_value(var, varType, (u_char *)val, size);
+			break;
+		case ASN_INTEGER:
+		case ASN_UINTEGER:
+		case ASN_COUNTER:
+		case ASN_GAUGE:
+			if(type == json_type_int){ size = 4; val = (u_char *) malloc(size); *((u_int16*)val) = atoi(buf);}
+			else if(type == json_type_uint8 || type == json_type_boolean){ size = 1; val = (u_char *) malloc(size); *((u_int8*)val) = atoi(buf);}
+			else if(type == json_type_uint16){ size = 2; val = (u_char *) malloc(size); *((u_int16*)val) = atoi(buf);}
+			else if(type == json_type_uint32 || type == json_type_ulong){ size = 4; val = (u_char *) malloc(size); *((u_int32*)val) = atoi(buf);}
+			else {size = -1; break;}
+
+			snmp_set_var_typed_value(var, varType, (u_char *)val, size);
+			break;
+
+		case ASN_TIMETICKS:
+			if(type == json_type_string || type == json_type_time){
+				tmp = (u_char*)malloc(sizeof(struct tm));
+				if(strptime(buf, "%Y-%m-%dT%H:%M:%S", (struct tm *) tmp)==0){
+					free(tmp);
+					size = -1; 
+					break;
+				}
+				size = sizeof(time_t);
+				val = (u_char*) malloc(size);
+				*((time_t*)val) = timegm((struct tm*)tmp) * 1000;
+				free(tmp);
+				snmp_set_var_typed_value(var, varType, (u_char *)val, size);
+				
+				ZYSNMP_DEBUG("%s, TimeTicks: %d, size: %d\n", buf, *((time_t*)val), size);
+				break;
+			}
+			else if(type == json_type_int || type == json_type_uint8 || type == json_type_ulong
+					|| type == json_type_uint16 || type == json_type_uint32){
+				size = sizeof(time_t);
+				val = (u_char*) malloc(size);
+				*((time_t*)val) = atoi(buf);
+				snmp_set_var_typed_value(var, varType, (u_char *)val, size);
+				break;
+			}
+			else size = -1;
+			
+			break;
+		
+		case ASN_BIT_STR:
+		case ASN_OCTET_STR:
+		case ASN_OPAQUE:
+			size = strlen(buf);
+			snmp_set_var_typed_value(var, varType, (u_char *)buf, size);
+			break;
+
+		case ASN_IPADDRESS:
+			if(type == json_type_string){
+				size = sizeof(u_char)*4;
+				val = (u_char*) malloc(size);
+				sscanf(buf, "%d.%d.%d.%d", val[0], val[1], val[2], val[3]);
+				snmp_set_var_typed_value(var, varType, (u_char *)val, size);
+			}
+			else size = -1;
+			
+			break;
+
+		case ASN_NULL:
+			break;
+
+		case ASN_OBJECT_ID:
+			if(type == json_type_string){
+				if(buf[0] == '.'){
+					size = sizeof(oid) * MAX_OID_LEN;
+					val = (u_char*)malloc(size);
+					tmp = (u_char*)malloc(strlen(buf));
+					strcpy(tmp, buf+1);
+					
+					i = 0;
+					patch = strtok (tmp , ".");
+					while (patch != NULL){
+						*(((oid*)val)+i) = atoi(patch);
+						patch = strtok (NULL, ".");
+						i++;
+					}
+					free(tmp); tmp = NULL;
+					
+					snmp_set_var_typed_value(var, varType, (u_char *)val, i*sizeof(oid));
+				}
+				else size = -1;
+			}
+			else size = -1;
+			break;
+			
+		case ASN_OPAQUE_FLOAT:
+			if(json_type_double){
+				size = sizeof(float);
+				val = (u_char*)malloc(size);
+				*((float*)val) = atof(buf);
+				snmp_set_var_typed_value(var, varType, (u_char *)val, size);
+			}
+			else size = -1;
+			break;
+
+		case ASN_OPAQUE_DOUBLE:
+			if(json_type_double){
+				size = sizeof(double);
+				val = (u_char*)malloc(size);
+				*((float*)val) = atof(buf);
+				snmp_set_var_typed_value(var, varType, (u_char *)val, size);
+			}
+			else size = -1;
+			break;
+		
+		case ASN_NSAP:
+		default:
+			size = -1;
+	}
+	
+	if(val != NULL) free(val);
+	if(size == -1) ZYSNMP_ERR("Cannot parse string(%s) to asn type(%d)\n", buf, varType);
+	return size;
+}
+
+int findObjByParameterValue(uint32_t oid, const char *paramName, const char *paramVal ,objIndex_t *ObjIid, struct json_object **obj){
+	int found;
+	zcfgRet_t ret;
+	struct json_object *tmpObj = NULL;
+	char *paramStrVal;
+
+	printf("%s, enter\n", __func__);
+	if(paramName == NULL || paramVal == NULL || ObjIid == NULL) return 0;
+
+	if(zcfgFeParamTypeGetByName(oid, paramName) == ZCFG_NO_SUCH_PARAMETER) return 0;
+
+	IID_INIT(*ObjIid);
+	found = 0;
+
+	while((ret = zcfgFeObjJsonGetNext(oid, ObjIid, &tmpObj)) == ZCFG_SUCCESS) {
+		paramStrVal = zcfgFeParamValGet(tmpObj, paramName);
+		if(paramStrVal != NULL){
+			if(!strcmp(paramStrVal, paramVal)){
+				found = 1;
+				*obj = tmpObj;
+				break;
+			}
+		}
+		/*Free the json object*/
+		zcfgFeJsonObjFree(tmpObj);
+		tmpObj = NULL;
+	}
+
+	if(found) return 1;
+	else return 0;
+}
+
+int findObjByIid(uint32_t oid, objIndex_t *ObjIid, struct json_object **obj){
+	int found = 0;
+	zcfgRet_t ret;
+	struct json_object *tmpObj = NULL;
+	uint32_t ipv4Oid = 0;
+
+	printf("%s, enter1111\n", __func__);
+	if(ObjIid == NULL) return 0;
+
+	ret = zcfgFeObjJsonGet(oid, ObjIid, &tmpObj);
+	if (ret == ZCFG_SUCCESS) {
+		printf("%s\n", json_object_to_json_string(tmpObj));
+		found = 1;
+		*obj = tmpObj;
+	}
+
+	if(found) return 1;
+	else return 0;
+}
+
+int IsWanInterfaceObject(char *objPath){
+	zcfgRet_t ret;
+	uint32_t oid = 0;
+	objIndex_t objIid;
+	char *paramStrVal;
+	char parameterName[64];
+	char *objPathTmp[1024], *objPathPtr;
+	char *DeviceName = "Device.";
+	char *lowLayerPath;
+	int paramType = 0;
+	struct json_object *obj = NULL;
+	int isWan = 0;
+
+	if(objPath == NULL) return -1;
+
+	if(strncmp(objPath, DeviceName, strlen(DeviceName))){
+		sprintf(objPathTmp, "%s%s", DeviceName, objPath);
+		objPathPtr = objPathTmp;
+	}
+	else objPathPtr = objPath;
+
+	oid = zcfgFeObjNameToObjId(objPathPtr, &objIid);
+	if(oid != ZCFG_NO_SUCH_OBJECT) {
+		if( oid != RDM_OID_BRIDGING_BR_PORT){
+			ret = zcfgFeObjJsonGet(oid, &objIid, &obj);
+			if (ret == ZCFG_SUCCESS) {
+				sprintf(parameterName, "LowerLayers");
+				paramStrVal = zcfgFeParamValGet(obj, parameterName);
+				if(paramStrVal != NULL && strlen(paramStrVal) !=0 ){
+					lowLayerPath = paramStrVal;
+					isWan = IsWanInterfaceObject(lowLayerPath);
+				}
+				else{
+					sprintf(parameterName, "Upstream");
+					paramStrVal = zcfgFeParamValGet(obj, parameterName);
+					printf("Upstream: %s\n", paramStrVal);
+					if(paramStrVal != NULL){
+						isWan = atoi(paramStrVal);
+					}
+					else{
+						isWan = -1;
+					}
+				}
+			}
+			else return -1;
+		}
+		else isWan = 0;
+	}
+	else return -1;
+
+	if(obj) zcfgFeJsonObjFree(obj);
+	return isWan;
+}
+
+int handleOfGetNumberOfIntf(int *wanSum, int *lanSum){
+	int i, ret, totalIpNum, isWan;
+	zcfgRet_t zRet;
+	objIndex_t IpObjIid;
+	struct json_object *IpObj = NULL;
+	char *IpObjName = "Device.IP";
+	uint32_t IpOid = 0;
+	char *paramStrVal;
+	char parameterName[64] = "";
+	char IpIntfPath[1024] = "";
+	int paramType = 0;
+
+	printf("%s, enter\n", __func__);
+	if(wanSum == NULL || lanSum == NULL) return -1;
+
+	IpOid = RDM_OID_IP;
+
+	IID_INIT(IpObjIid);
+	ret = zcfgFeObjJsonGet(IpOid, &IpObjIid, &IpObj);
+
+	if (ret == ZCFG_SUCCESS) {
+		strcpy(parameterName, "InterfaceNumberOfEntries");
+
+		paramStrVal = zcfgFeParamValGet(IpObj, parameterName);
+		if(paramStrVal == NULL){
+			ZYSNMP_ERR("Cannot get parameter (%s.%s)\n", IpObjName, parameterName);
+			ret = -1;
+			goto fail;
+		}
+		
+		totalIpNum = atoi(paramStrVal);
+
+		*wanSum = *lanSum = 0; 
+		for(i=1;i<=totalIpNum;i++){
+			sprintf(IpIntfPath, "%s.Interface.%d", IpObjName, i);
+			isWan = IsWanInterfaceObject(IpIntfPath);
+			if(isWan == 0){
+				(*lanSum)++;
+			}
+			else if(isWan == 1){
+				(*wanSum)++;
+			}
+			else {
+				;/*fo nothing*/
+			}
+		}
+		ret = 0;
+	}
+	else{
+		snmp_log(LOG_ERR,"Cannot get Object (%s)\n", IpObjName);
+		ret = -1;
+		goto fail;
+	}
+
+fail:
+	if(IpObj) zcfgFeJsonObjFree(IpObj);
+	return ret;
+}
+/*____________________________________________________________
+get a interface summary from rdm and send to the request management
+parameters:
+	rerquests: the request infomation agent have received, when we send the response,we need this
+	type: which type of your parameter is. the management will receive same type
+	ifType: which type of interface type, LAN=0, WAN=1
+return:
+	0:success
+	-1: something is error
+_______________________________________________*/
+int handleOfGetIntfDevNum(netsnmp_request_info  *requests, u_char type, u_char ifType){
+	int ret=SNMP_ERR_NOERROR;
+	int wanSum =0, lanSum =0, size, tmpSum;
+	char tmp[20];
+	void *val;
+	if(handleOfGetNumberOfIntf(&wanSum, &lanSum) != -1){
+		if(ifType) tmpSum = wanSum; //WAN
+		else tmpSum = lanSum; //LAN
+		
+		if(type == ASN_INTEGER){
+			size = sizeof(int);
+			val = (void *)&tmpSum;
+		}
+		else{
+			sprintf(tmp, "%d", tmpSum);
+			size = strlen(tmp);
+			val = (void *)tmp;
+		}
+		snmp_set_var_typed_value(requests->requestvb, type,
+					(u_char *)val, size);
+	}
+	else ret = SNMP_ERR_GENERR;
+	
+	return ret;
+}
+
+/*____________________________________________________________
+get a parameter from rdm and send to the request management
+parameters:
+	id: the Object ID you want to get
+	parameter: which parameter you want to get under this ojbect
+	rerquests: the request infomation agent have received, when we send the response,we need this
+	type: which type of your parameter is. the management will receive same type
+return:
+	0:success
+	-1: something is error
+_______________________________________________*/
+
+int handleOfGetParameter(zcfg_offset_t rid,const char *parameter,netsnmp_request_info  *requests, u_char type){
+	int ret=SNMP_ERR_NOERROR;
+	int size;
+	void *tmp = NULL, *val;
+	zcfgRet_t zRet;
+	objIndex_t objIid;
+	struct json_object *jobj = NULL;
+	void *paramStrVal;
+	int paramType = 0;
+	
+	IID_INIT(objIid);
+	zRet = zcfgFeObjJsonGet(rid, &objIid, &jobj);
+	if (zRet == ZCFG_SUCCESS) {
+		paramType = zcfgFeParamTypeGetByName(rid, parameter);
+
+		if(paramType == ZCFG_NO_SUCH_PARAMETER){
+			ret = SNMP_ERR_GENERR;
+			goto fail;
+		}
+		paramStrVal = zcfgFeParamValGet(jobj, parameter);
+		
+		if(paramStrVal != NULL){
+			ZYSNMP_DEBUG("Parameter Name %s value %s type %d\n", parameter, paramStrVal, paramType);
+			if(parseStr2Val(paramStrVal, paramType, type, requests->requestvb) == -1){
+				ZYSNMP_ERR("Cannot set value to snmp variable\n");
+				ret = SNMP_ERR_GENERR;
+				goto fail;
+			}
+		}
+		else{
+			ret = SNMP_ERR_GENERR;
+			ZYSNMP_ERR("Cannot get Parameter(%s)\n", parameter);
+			goto fail;
+		}
+	}
+	else{
+		ret = SNMP_ERR_NOACCESS;
+		ZYSNMP_ERR("Cannot get Parameter(%s)\n", parameter);
+		goto fail;
+	}
+fail:
+	if(jobj) zcfgFeJsonObjFree(jobj);
+	if(tmp) free(tmp);
+	return ret;
+}
+
+#define STR_BUF_LEN 1024
+/*___________________________________________________
+Set a parameter value to rdm, when we call set request ,this function will be called.
+function paramters:
+	id: the object id want to set
+	parameter: which parameter you want to set under this Object id
+	requests: snmp received request infomation, in this function we only used to get the value of the set-request give us
+return:
+	0: success
+	-1: something is error
+_________________________________________________________*/
+int handleOfSetParameter(zcfg_offset_t rid, const char *parameter,netsnmp_request_info *requests){
+	int ret=SNMP_ERR_NOERROR;
+	zcfgRet_t zRet;
+	int size;
+	objIndex_t objIid;
+	struct json_object *jobj = NULL;
+	void *paramStrVal;
+	int paramType = 0;
+	char val[STR_BUF_LEN];
+
+	ZYSNMP_DEBUG("enter\n");
+	
+	if(parseVal2Str(val, STR_BUF_LEN, requests->requestvb) <= 0){
+		ZYSNMP_ERR("Error to parse variable to string\n");
+		ret = SNMP_ERR_GENERR;
+		goto fail;
+	}
+	
+	IID_INIT(objIid);
+	zRet = zcfgFeObjJsonGet(rid, &objIid, &jobj);
+	if (zRet == ZCFG_SUCCESS || zRet == ZCFG_EMPTY_OBJECT) {
+		paramType = zcfgFeParamTypeGetByName(rid, parameter);
+
+		if(paramType == ZCFG_NO_SUCH_PARAMETER){
+			ZYSNMP_ERR("Error to get object\n");
+			ret = SNMP_ERR_GENERR;
+			goto fail;
+		}
+
+		if(val != NULL){
+			//ZYSNMP_ERR("Set %s = %s\n", parameter, requests->requestvb->val.string);
+			if((zRet = zcfgFeJsonObjParamSet(rid, parameter, paramType, jobj, val)) == ZCFG_SUCCESS){
+				zRet = zcfgFeObjJsonSet(rid, &objIid, jobj, NULL);
+			}
+			if(zRet != ZCFG_SUCCESS){
+				ZYSNMP_ERR("Error to set obj parameter(%s)\n", parameter);
+				ret = SNMP_ERR_GENERR;
+				goto fail;
+			}
+		}
+		else{
+			ret = SNMP_ERR_GENERR;
+			ZYSNMP_ERR( "Error input argument\n");
+			goto fail;
+		}
+	}
+	else{
+		ret = SNMP_ERR_NOACCESS;
+		ZYSNMP_ERR( "Cannot get Parameter(%s)\n", parameter);
+		goto fail;
+	}
+fail:
+	if(jobj) zcfgFeJsonObjFree(jobj);
+	return ret;
+}
+
+int handleOfLanAddrParam(const char *ifname, const char *parameter, netsnmp_request_info  *requests, u_char type, enum HANDLE_MODE mode){
+	int ret=SNMP_ERR_NOERROR;
+	zcfgRet_t zRet;
+	struct json_object *intfObj = NULL, *ipv4Obj = NULL;
+	objIndex_t intfIid, ipv4Iid;
+	int paramType;
+	char *paramStrVal;
+	char *tmpbuf = NULL;
+	char *ip = NULL, *mask = NULL;
+	
+	ZYSNMP_DEBUG("enter\n");
+	if(ifname == NULL || parameter == NULL) 
+		return SNMP_ERR_GENERR;
+	if((paramType = zcfgFeParamTypeGetByName(RDM_OID_IP_IFACE_V4_ADDR, parameter)) == ZCFG_NO_SUCH_PARAMETER) 
+		return SNMP_ERR_GENERR;
+
+	if(findObjByParameterValue(RDM_OID_IP_IFACE, "X_ZYXEL_IfName", ifname, &intfIid, &intfObj)){
+		IID_INIT(ipv4Iid);
+		ipv4Iid.level = 2;
+		ipv4Iid.idx[0] = intfIid.idx[0];
+		ipv4Iid.idx[1] = 1;
+		if(findObjByIid(RDM_OID_IP_IFACE_V4_ADDR, &ipv4Iid, &ipv4Obj)){
+			if(mode == HANDLE_GET){
+				paramStrVal = zcfgFeParamValGet(ipv4Obj, parameter);
+				if(paramStrVal != NULL){
+					if(parseStr2Val(paramStrVal, paramType, type, requests->requestvb) == -1){
+						ZYSNMP_ERR("Error to parse string to variable\n");
+						ret = SNMP_ERR_GENERR;
+						goto fail;
+					}
+				}
+				else{
+					ZYSNMP_ERR("Error to get parameter(%s) value\n", parameter);
+					ret = SNMP_ERR_GENERR;
+					goto fail;
+				}
+			}
+			else if(mode == HANDLE_SET){
+				tmpbuf = malloc(STR_BUF_LEN);
+				if(tmpbuf){
+					if(parseVal2Str(tmpbuf, STR_BUF_LEN, requests->requestvb) <= 0){
+						ZYSNMP_ERR("Error to parse variable to string\n");
+						ret = SNMP_ERR_GENERR;
+						goto fail;
+					}
+					ZYSNMP_ERR("parameter(%s) , len: %d , value: %s\n", parameter, strlen(tmpbuf), tmpbuf);
+					if(!strcmp(parameter, "SubnetMask") || !strcmp(parameter, "IPAddress")){
+						if(!strcmp(parameter, "IPAddress")){
+							mask = zcfgFeParamValGet(ipv4Obj, "SubnetMask");
+							ip = tmpbuf;
+						} else{
+							ip = zcfgFeParamValGet(ipv4Obj, "IPAddress");
+							mask = tmpbuf;
+						}
+						if( !checkValidIpAddress(ip, mask)){
+							ZYSNMP_ERR("Invalid IP address or Subet mask\n");
+							ret = SNMP_ERR_GENERR;
+							goto fail;
+						}
+					}
+					
+					if((zRet = zcfgFeJsonObjParamSet(RDM_OID_IP_IFACE_V4_ADDR, parameter, paramType, ipv4Obj, tmpbuf)) == ZCFG_SUCCESS){
+						zRet = zcfgFeObjJsonSet(RDM_OID_IP_IFACE_V4_ADDR, &ipv4Iid, ipv4Obj, NULL);
+					}
+					if(zRet != ZCFG_SUCCESS){
+						ZYSNMP_ERR("Error to set obj parameter(%s) , len: %d , value: %s\n", parameter, strlen(tmpbuf), tmpbuf);
+						ret = SNMP_ERR_GENERR;
+						goto fail;
+					}
+					else if(ip != NULL && mask != NULL){
+						char minAddr[20], maxAddr[20];
+						memset(minAddr, 0, 20);
+						memset(maxAddr, 0, 20);
+						if(handleOfLanDhcpPoolAddr(ifname, minAddr, maxAddr, 20, HANDLE_GET) == SNMP_ERR_NOERROR){
+							if(createDhcpPoolAddr(ip, mask, minAddr, maxAddr)){
+								if(handleOfLanDhcpPoolAddr(ifname, minAddr, maxAddr, 20, HANDLE_SET) != SNMP_ERR_NOERROR)
+									ZYSNMP_ERR("Error to change DHCP Pool range (%s, %s)\n",minAddr, maxAddr);
+							}
+						}
+					}
+				}
+				else{
+					ZYSNMP_ERR("Cannot allocate memory(%d)\n", STR_BUF_LEN);
+					ret = SNMP_ERR_GENERR; goto fail;
+				}
+			}
+			else{
+				ZYSNMP_ERR("Not support mode(%d)\n", mode);
+				ret = SNMP_ERR_GENERR; goto fail;
+			}
+		}else { ZYSNMP_ERR("Error to get obj (%s)\n", "RDM_OID_IP_IFACE_V4_ADDR");  ret = SNMP_ERR_GENERR; goto fail; }
+	}
+	else {ZYSNMP_ERR("Error to get obj (%s)\n", "RDM_OID_IP_IFACE");  ret = SNMP_ERR_GENERR; goto fail; }
+	
+fail:
+	if(intfObj) zcfgFeJsonObjFree(intfObj);
+	if(ipv4Obj) zcfgFeJsonObjFree(ipv4Obj);
+	if(tmpbuf) free(tmpbuf);
+	return ret;
+}
+
+int handleOfLanDhcpParam(const char *ifname, const char *parameter, netsnmp_request_info  *requests, u_char type, enum HANDLE_MODE mode){
+	int ret=SNMP_ERR_NOERROR;
+	zcfgRet_t zRet;
+	struct json_object *intfObj = NULL, *dhcpObj = NULL;
+	objIndex_t intfIid, dhcpIid;
+	int paramType;
+	char path[256];
+	char *paramStrVal;
+	char *tmpbuf = NULL;
+	
+	if(ifname == NULL || parameter == NULL) 
+		return SNMP_ERR_GENERR;
+	if((paramType = zcfgFeParamTypeGetByName(RDM_OID_DHCPV4_SRV_POOL, parameter)) == ZCFG_NO_SUCH_PARAMETER) 
+		return SNMP_ERR_GENERR;
+
+	if(findObjByParameterValue(RDM_OID_IP_IFACE, "X_ZYXEL_IfName", ifname, &intfIid, &intfObj)){
+		sprintf(path, "IP.Interface.%d", intfIid.idx[0]);
+		if(findObjByParameterValue(RDM_OID_DHCPV4_SRV_POOL, "Interface", path, &dhcpIid, &dhcpObj)){
+			if(mode == HANDLE_GET){
+				paramStrVal = zcfgFeParamValGet(dhcpObj, parameter);
+				if(paramStrVal != NULL){
+					if(parseStr2Val(paramStrVal, paramType, type, requests->requestvb) == -1){
+						ZYSNMP_ERR("Error to parse string to variable\n");
+						ret = SNMP_ERR_GENERR;
+						goto fail;
+					}
+				}
+				else{
+					ZYSNMP_ERR("Error to get parameter(%s) value\n", parameter);
+					ret = SNMP_ERR_GENERR;
+					goto fail;
+				}
+			}
+			else if(mode == HANDLE_SET){
+				tmpbuf = malloc(STR_BUF_LEN);
+				if(tmpbuf){
+					if(parseVal2Str(tmpbuf, STR_BUF_LEN, requests->requestvb) <= 0){
+						ZYSNMP_ERR("Error to parse variable to string\n");
+						ret = SNMP_ERR_GENERR;
+						goto fail;
+					}
+					if((zRet = zcfgFeJsonObjParamSet(RDM_OID_DHCPV4_SRV_POOL, parameter, paramType, dhcpObj, tmpbuf)) == ZCFG_SUCCESS){
+						zRet = zcfgFeObjJsonSet(RDM_OID_DHCPV4_SRV_POOL, &dhcpIid, dhcpObj, NULL);
+					}
+					if(zRet != ZCFG_SUCCESS){
+						ZYSNMP_ERR("Error to set obj parameter(%s)\n", parameter);
+						ret = SNMP_ERR_GENERR;
+						goto fail;
+					}
+				}
+				else{
+					ZYSNMP_ERR("Cannot allocate memory(%d)\n", STR_BUF_LEN);
+					ret = SNMP_ERR_GENERR; goto fail;
+				}
+			}
+			else{
+				ZYSNMP_ERR("Not support mode(%d)\n", mode);
+				ret = SNMP_ERR_GENERR; goto fail;
+			}
+		}
+		else{ ret = SNMP_ERR_GENERR; goto fail; }
+	}
+	else { ret = SNMP_ERR_GENERR; goto fail; }
+	
+fail:
+	if(intfObj) zcfgFeJsonObjFree(intfObj);
+	if(dhcpObj) zcfgFeJsonObjFree(dhcpObj);
+	if(tmpbuf) free(tmpbuf);
+	return ret;
+}
+
+int handleOfLanDhcpRelayParam(const char *ifname, const char *parameter, netsnmp_request_info  *requests, u_char type, enum HANDLE_MODE mode){
+	int ret=SNMP_ERR_NOERROR;
+	zcfgRet_t zRet;
+	struct json_object *intfObj = NULL, *relayObj = NULL;
+	objIndex_t intfIid, relayIid;
+	int paramType;
+	char path[256];
+	char *paramStrVal;
+	char *tmpbuf = NULL;
+	
+	if(ifname == NULL || parameter == NULL) 
+		return SNMP_ERR_GENERR;
+	if((paramType = zcfgFeParamTypeGetByName(RDM_OID_DHCPV4_RELAY_FWD, parameter)) == ZCFG_NO_SUCH_PARAMETER) 
+		return SNMP_ERR_GENERR;
+
+	if(findObjByParameterValue(RDM_OID_IP_IFACE, "X_ZYXEL_IfName", ifname, &intfIid, &intfObj)){
+		sprintf(path, "IP.Interface.%d", intfIid.idx[0]);
+		if(findObjByParameterValue(RDM_OID_DHCPV4_RELAY_FWD, "Interface", path, &relayIid, &relayObj)){
+			if(mode == HANDLE_GET){
+				paramStrVal = zcfgFeParamValGet(relayObj, parameter);
+				if(paramStrVal != NULL){
+					if(parseStr2Val(paramStrVal, paramType, type, requests->requestvb) == -1){
+						ZYSNMP_ERR("Error to parse string to variable\n");
+						ret = SNMP_ERR_GENERR;
+						goto fail;
+					}
+				}
+				else{
+					ZYSNMP_ERR("Error to get parameter(%s) value\n", parameter);
+					ret = SNMP_ERR_GENERR;
+					goto fail;
+				}
+			}
+			else if(mode == HANDLE_SET){
+				tmpbuf = malloc(STR_BUF_LEN);
+				if(tmpbuf){
+					if(parseVal2Str(tmpbuf, STR_BUF_LEN, requests->requestvb) <= 0){
+						ZYSNMP_ERR("Error to parse variable to string\n");
+						ret = SNMP_ERR_GENERR;
+						goto fail;
+					}
+					if((zRet = zcfgFeJsonObjParamSet(RDM_OID_DHCPV4_RELAY_FWD, parameter, paramType, relayObj, tmpbuf)) == ZCFG_SUCCESS){
+						zRet = zcfgFeObjJsonSet(RDM_OID_DHCPV4_RELAY_FWD, &relayIid, relayObj, NULL);
+					}
+					if(zRet != ZCFG_SUCCESS){
+						ZYSNMP_ERR("Error to set obj parameter(%s)\n", parameter);
+						ret = SNMP_ERR_GENERR;
+						goto fail;
+					}
+				}
+				else{
+					ZYSNMP_ERR("Cannot allocate memory(%d)\n", STR_BUF_LEN);
+					ret = SNMP_ERR_GENERR; goto fail;
+				}
+			}
+			else{
+				ZYSNMP_ERR("Not support mode(%d)\n", mode);
+				ret = SNMP_ERR_GENERR; goto fail;
+			}
+		}
+		else{ ret = SNMP_ERR_GENERR; goto fail; }
+	}
+	else { ret = SNMP_ERR_GENERR; goto fail; }
+	
+fail:
+	if(intfObj) zcfgFeJsonObjFree(intfObj);
+	if(relayObj) zcfgFeJsonObjFree(relayObj);
+	if(tmpbuf) free(tmpbuf);
+	return ret;
+}
+
+int handleOfLanDhcpDns(const char *ifname, char *dns1, char *dns2, int size, enum HANDLE_MODE mode){
+	int ret=SNMP_ERR_NOERROR;
+	zcfgRet_t zRet;
+	struct json_object *intfObj = NULL, *dhcpObj = NULL;
+	objIndex_t intfIid, dhcpIid;
+	char path[256];
+	char *DNSServer, *DNSType, *tmp, *tmpDns1 = NULL, *tmpDns2 = NULL;
+	
+	if(ifname == NULL || (dns1 == NULL && dns2 == NULL)) 
+		return SNMP_ERR_GENERR;
+		
+	if(findObjByParameterValue(RDM_OID_IP_IFACE, "X_ZYXEL_IfName", ifname, &intfIid, &intfObj)){
+		sprintf(path, "IP.Interface.%d", intfIid.idx[0]);
+		if(findObjByParameterValue(RDM_OID_DHCPV4_SRV_POOL, "Interface", path, &dhcpIid, &dhcpObj)){
+			DNSType = zcfgFeParamValGet(dhcpObj, "X_ZYXEL_DNS_Type");
+			
+			if(DNSType != NULL){
+				if(!strcmp(DNSType, "Static")){
+					DNSServer = zcfgFeParamValGet(dhcpObj, "DNSServers");
+					if(DNSServer != NULL){
+						tmp = strchr(DNSServer, ',');
+						if(tmp != NULL){
+							*tmp = '\0';
+							tmpDns2 = tmp+1;
+						}
+						tmpDns1 = DNSServer;
+						
+						if(mode == HANDLE_GET){
+							if(dns1 != NULL && tmpDns1 != NULL) strncpy(dns1, tmpDns1, size);
+							if(dns2 != NULL && tmpDns2 != NULL) strncpy(dns2, tmpDns2, size);
+						}
+						else if(mode == HANDLE_SET){
+							if(dns1 != NULL ) tmpDns1 = dns1;
+							if(dns2 != NULL ) tmpDns2 = dns2;
+							sprintf( path, "%s%s%s", 
+									(tmpDns1==NULL) ? "" : tmpDns1, 
+									(tmpDns2==NULL) ? "" : ",",
+									(tmpDns2==NULL) ? "" : tmpDns2
+								);
+							
+							if((zRet = zcfgFeJsonObjParamSet(RDM_OID_DHCPV4_SRV_POOL, "DNSServers", json_type_string, dhcpObj, path)) == ZCFG_SUCCESS){
+								zRet = zcfgFeObjJsonSet(RDM_OID_DHCPV4_SRV_POOL, &dhcpIid, dhcpObj, NULL);
+							}
+							if(zRet != ZCFG_SUCCESS){
+								ZYSNMP_ERR("Error to set obj parameter(%s). value: %s\n", "DNSServers", path);
+								ret = SNMP_ERR_GENERR;
+								goto fail;
+							}
+						}
+						else{ ZYSNMP_ERR("Not support mode(%d)\n", mode); ret = SNMP_ERR_GENERR; goto fail;}
+					}
+					else{ ret = SNMP_ERR_GENERR; goto fail;}
+				}
+			}
+		} else{ ret = SNMP_ERR_GENERR; goto fail;}
+	}
+	else{ ret = SNMP_ERR_GENERR; goto fail;}
+	
+fail:
+	if(intfObj) zcfgFeJsonObjFree(intfObj);
+	if(dhcpObj) zcfgFeJsonObjFree(dhcpObj);
+	return ret;
+}
+
+int handleOfLanDhcpPoolAddr(const char *ifname, char *startAddr, char *endAddr, int size, enum HANDLE_MODE mode){
+	int ret=SNMP_ERR_NOERROR;
+	zcfgRet_t zRet;
+	struct json_object *intfObj = NULL, *dhcpObj = NULL, *ipv4Obj = NULL;
+	objIndex_t intfIid, dhcpIid, ipv4Iid;
+	char path[256];
+	char *minAddr, *maxAddr, *subnet, *ipAddr;
+	
+	ZYSNMP_DEBUG("enter\n");
+	if(ifname == NULL || (startAddr == NULL && endAddr == NULL)) return SNMP_ERR_GENERR;
+	
+	if(findObjByParameterValue(RDM_OID_IP_IFACE, "X_ZYXEL_IfName", ifname, &intfIid, &intfObj)){
+
+		sprintf(path, "IP.Interface.%d", intfIid.idx[0]);
+		if(findObjByParameterValue(RDM_OID_DHCPV4_SRV_POOL, "Interface", path, &dhcpIid, &dhcpObj)){
+			minAddr = zcfgFeParamValGet(dhcpObj, "MinAddress");
+			maxAddr = zcfgFeParamValGet(dhcpObj, "MaxAddress");
+			if(mode == HANDLE_GET){
+				if(startAddr != NULL && minAddr != NULL)
+					strncpy(startAddr, minAddr, size);
+				if(endAddr != NULL && maxAddr != NULL)
+					strncpy(endAddr, maxAddr, size);
+			}
+			else if(mode == HANDLE_SET){
+				
+				IID_INIT(ipv4Iid);
+				ipv4Iid.level = 2;
+				ipv4Iid.idx[0] = intfIid.idx[0];
+				ipv4Iid.idx[1] = 1;
+				if(findObjByIid(RDM_OID_IP_IFACE_V4_ADDR, &ipv4Iid, &ipv4Obj) != 1){
+					ZYSNMP_ERR("Cannot get object(%s)\n", "RDM_OID_IP_IFACE_V4_ADDR");
+					ret = SNMP_ERR_GENERR;
+					goto fail;
+				}
+				subnet = zcfgFeParamValGet(ipv4Obj, "SubnetMask");
+				ipAddr = zcfgFeParamValGet(ipv4Obj, "IPAddress");
+				
+				if(subnet == NULL || ipAddr == NULL){
+					ZYSNMP_ERR("Cannot get SubnetMask and IPAddress\n", "RDM_OID_IP_IFACE_V4_ADDR");
+					ret = SNMP_ERR_GENERR;
+					goto fail;
+				}
+				
+				if(startAddr != NULL) minAddr = startAddr;
+				else if(endAddr != NULL) maxAddr = endAddr;
+				else{ minAddr = startAddr; maxAddr = endAddr;}
+				
+				if(checkIpNetwork(minAddr, ipAddr, subnet) != 1 || 
+					checkIpNetwork(maxAddr, ipAddr, subnet) != 1)
+				{
+					ZYSNMP_ERR("The dhcp pool address range(%s : %s) is not in LAN ip address(%s, %s) network\n", minAddr, maxAddr, ipAddr, subnet);
+					ret = SNMP_ERR_GENERR;
+					goto fail;
+				}
+				
+				if(!compareIpAddress(minAddr, maxAddr)){
+					ZYSNMP_ERR("The invalid dhcp pool address range(%s : %s)\n", minAddr, maxAddr);
+					ret = SNMP_ERR_GENERR;
+					goto fail;
+				}
+				
+				if((zRet = zcfgFeJsonObjParamSet(RDM_OID_DHCPV4_SRV_POOL, "MinAddress", json_type_string, dhcpObj, minAddr)) == ZCFG_SUCCESS
+					&& (zRet = zcfgFeJsonObjParamSet(RDM_OID_DHCPV4_SRV_POOL, "MaxAddress", json_type_string, dhcpObj, maxAddr)) == ZCFG_SUCCESS)
+				{
+					zRet = zcfgFeObjJsonSet(RDM_OID_DHCPV4_SRV_POOL, &dhcpIid, dhcpObj, NULL);
+				}
+				if(zRet != ZCFG_SUCCESS){
+					ZYSNMP_ERR("Error to set obj parameter(%s). value: %s\n", "DNSServers", path);
+					ret = SNMP_ERR_GENERR;
+					goto fail;
+				}
+			}
+			else{ ZYSNMP_ERR("Not support mode(%d)\n", mode); ret = SNMP_ERR_GENERR; goto fail;}
+		}
+		else { ZYSNMP_ERR("Cannot get object(%s)\n", "RDM_OID_DHCPV4_SRV_POOL"); ret = SNMP_ERR_GENERR; goto fail; }
+	}
+	else { ZYSNMP_ERR("Cannot get object(%s)\n", "RDM_OID_IP_IFACE"); ret = SNMP_ERR_GENERR; goto fail; }
+	
+fail:
+	if(intfObj) zcfgFeJsonObjFree(intfObj);
+	if(dhcpObj) zcfgFeJsonObjFree(dhcpObj);
+	if(ipv4Obj) zcfgFeJsonObjFree(ipv4Obj);
+	
+	return ret;
+}
+#if 0
+int handleOfChangeDhcpPool(const char *ifname, char *ipAddr, char *netmask){
+	int ret=SNMP_ERR_NOERROR;
+	zcfgRet_t zRet;
+	struct json_object *intfObj = NULL, *dhcpObj = NULL;
+	objIndex_t intfIid, dhcpIid;
+	char path[256];
+	char *minAddr, *maxAddr;
+	
+	if(ifname == NULL || ipAddr == NULL || netmask == NULL) return SNMP_ERR_GENERR;
+	
+	if(findObjByParameterValue(RDM_OID_IP_IFACE, "X_ZYXEL_IfName", ifname, &intfIid, &intfObj)){
+		sprintf(path, "IP.Interface.%d", intfIid.idx[0]);
+		if(findObjByParameterValue(RDM_OID_DHCPV4_SRV_POOL, "Interface", path, &dhcpIid, &dhcpObj)){
+			minAddr = zcfgFeParamValGet(dhcpObj, "MinAddress");
+			maxAddr = zcfgFeParamValGet(dhcpObj, "MaxAddress");
+			if(minAddr != NULL && maxAddr != NULL){
+				int mask, first, last, ip, subnet, change=0;
+				struct in_addr addr;
+				char *str;
+				
+				inet_aton(ipAddr, &addr);
+				ip = ntohl(addr.s_addr);
+				inet_aton(netmask, &addr);
+				mask = ntohl(addr.s_addr);
+				inet_aton(minAddr, &addr);
+				first= ntohl(addr.s_addr);
+				inet_aton(maxAddr, &addr);
+				last = ntohl(addr.s_addr);			
+				subnet = ip & mask;
+
+				if(subnet != (first & mask) || subnet != (last & mask)){ 
+					first = subnet + 1;
+					last = subnet + ~mask - 1;
+				}
+				
+				if(ip == last) last = ip - 1;
+				else if(ip == first) first = ip + 1;
+				else if(first < ip && ip < last){
+					if((ip - first) < (last - ip)) first = ip + 1;
+					else last = ip - 1;
+				}
+
+				addr.s_addr = htonl(first);
+				str = inet_ntoa(addr);
+				if(strcmp(str, minAddr)){
+					minAddr = malloc(strlen(str));
+					strcpy(minAddr, str);
+					change = 1;
+					zRet = zcfgFeJsonObjParamSet(RDM_OID_DHCPV4_SRV_POOL, "MinAddress", json_type_string, dhcpObj, minAddr);
+					free(minAddr);
+				}
+				
+				if(zRet == ZCFG_SUCCESS){
+					addr.s_addr = htonl(last);
+					str = inet_ntoa(addr);
+					if(strcmp(str, maxAddr)){
+						maxAddr = malloc(strlen(str));
+						strcpy(maxAddr, str);
+						change = 1;
+						zRet = zcfgFeJsonObjParamSet(RDM_OID_DHCPV4_SRV_POOL, "MaxAddress", json_type_string, dhcpObj, maxAddr);
+						free(maxAddr);
+					}
+				}
+				
+				if(change == 1 && zRet == ZCFG_SUCCESS){
+					zRet = zcfgFeObjJsonSet(RDM_OID_DHCPV4_SRV_POOL, &dhcpIid, dhcpObj, NULL);
+				}
+				
+				if(change == 1 && zRet != ZCFG_SUCCESS){
+					ZYSNMP_ERR("Error to change DHCP pool size.\n");
+					ret = SNMP_ERR_GENERR;
+					goto fail;
+				}
+			}
+		}
+		else { ZYSNMP_ERR("Cannot get object(%s)\n", "RDM_OID_DHCPV4_SRV_POOL"); ret = SNMP_ERR_GENERR; goto fail; }
+	}
+	else { ZYSNMP_ERR("Cannot get object(%s)\n", "RDM_OID_IP_IFACE"); ret = SNMP_ERR_GENERR; goto fail; }
+	
+fail:
+	if(intfObj) zcfgFeJsonObjFree(intfObj);
+	if(dhcpObj) zcfgFeJsonObjFree(dhcpObj);
+	
+	return ret;
+}
+
+int SetWANIntfNATMode(int enbl){
+	zcfgRet_t ret;
+	struct json_object *natIntfObj;
+	objIndex_t natIntfIid;
+	char *paramStrVal, tmpStr[10];
+	int e;
+	while((ret = zcfgFeObjJsonGetNext(RDM_OID_NAT_INTF_SETTING, &natIntfIid, &natIntfObj)) == ZCFG_SUCCESS) {
+		paramStrVal = zcfgFeParamValGet(natIntfObj, "Enable");
+		if(paramStrVal != NULL){
+			e = atoi(paramStrVal);
+			if(e != enbl){
+				sprintf(tmpStr, "%d", enbl);
+				if((ret = zcfgFeJsonObjParamSet(RDM_OID_NAT_INTF_SETTING, "Enable", json_type_boolean, natIntfObj, tmpStr)) == ZCFG_SUCCESS
+				{
+					ret = zcfgFeObjJsonSet(RDM_OID_NAT_INTF_SETTING, &natIntfIid, natIntfObj, NULL);
+				}
+			}
+		}
+		zcfgFeJsonObjFree(natIntfObj);
+		natIntfObj = NULL;
+	}
+	return ZCFG_SUCCESS
+}
+#endif
+
+int handleOfChangeDhcpMode(const char *ifname, enum DHCP_MODE mode){
+	int ret=SNMP_ERR_NOERROR, oid;
+	zcfgRet_t zRet;
+	struct json_object *intfObj = NULL, *dhcpObj = NULL, *relayObj = NULL, *ipv4Obj = NULL;
+	objIndex_t intfIid, dhcpIid, relayIid, ipv4Iid;
+	char tmp[256];
+	enum DHCP_MODE cur_mode;
+	
+	if(ifname == NULL || mode >= DHCP_NONE) return SNMP_ERR_GENERR;
+	
+	if(findObjByParameterValue(RDM_OID_IP_IFACE, "X_ZYXEL_IfName", ifname, &intfIid, &intfObj)){
+		sprintf(tmp, "IP.Interface.%d", intfIid.idx[0]);
+		if(findObjByParameterValue(RDM_OID_DHCPV4_SRV_POOL, "Interface", tmp, &dhcpIid, &dhcpObj)){
+			cur_mode = DHCP_SERVER;
+		}
+		else if(findObjByParameterValue(RDM_OID_DHCPV4_RELAY_FWD, "Interface", tmp, &relayIid, &relayObj)){
+			cur_mode = DHCP_RELAY;
+		}
+		else cur_mode = DHCP_DISABLE;
+		
+		if(mode != cur_mode){
+			if(mode == DHCP_DISABLE){
+				if(cur_mode == DHCP_SERVER){
+					zRet = zcfgFeObjJsonDel(RDM_OID_DHCPV4_SRV_POOL, &dhcpIid, NULL);
+					if(zRet != ZCFG_SUCCESS){
+						ZYSNMP_ERR("Cannot delete object(%s), ret=%d\n", "RDM_OID_DHCPV4_SRV_POOL", zRet); ret = SNMP_ERR_GENERR; goto fail;
+					}
+				}
+				else if(cur_mode == DHCP_RELAY){
+					zRet = zcfgFeObjJsonDel(RDM_OID_DHCPV4_RELAY_FWD, &relayIid, NULL);
+					if(zRet != ZCFG_SUCCESS){
+						ZYSNMP_ERR("Cannot delete object(%s), ret=%d\n", "RDM_OID_DHCPV4_RELAY_FWD", zRet); ret = SNMP_ERR_GENERR; goto fail;
+					}
+				}
+			}
+			else if(mode == DHCP_SERVER){
+				char *ip, *mask, minAddr[20], maxAddr[20];
+				IID_INIT(ipv4Iid);
+				ipv4Iid.level = 2;
+				ipv4Iid.idx[0] = intfIid.idx[0];
+				ipv4Iid.idx[1] = 1;
+				if(findObjByIid(RDM_OID_IP_IFACE_V4_ADDR, &ipv4Iid, &ipv4Obj)){
+					mask = zcfgFeParamValGet(ipv4Obj, "SubnetMask");
+					ip = zcfgFeParamValGet(ipv4Obj, "IPAddress");
+					memset(minAddr, 0, 20);
+					memset(maxAddr, 0, 20);
+					createDhcpPoolAddr(ip, mask, minAddr, maxAddr);
+				}
+				else{
+					ZYSNMP_ERR("Cannot get object(%s)\n", "RDM_OID_IP_IFACE_V4_ADDR"); ret = SNMP_ERR_GENERR; goto fail;
+				}
+				
+				if(cur_mode == DHCP_RELAY){
+					zRet = zcfgFeObjJsonDel(RDM_OID_DHCPV4_RELAY_FWD, &relayIid, NULL);
+					if(zRet != ZCFG_SUCCESS){
+						ZYSNMP_ERR("Cannot delete object(%s) , ret=%d\n", "RDM_OID_DHCPV4_RELAY_FWD", zRet); ret = SNMP_ERR_GENERR; goto fail;
+					}
+				}
+				IID_INIT(dhcpIid);
+				oid = RDM_OID_DHCPV4_SRV_POOL;
+				if((zRet = zcfgFeObjJsonAdd(oid, &dhcpIid, NULL)) == ZCFG_SUCCESS){
+					if(zRet = zcfgFeObjJsonGet(oid, &dhcpIid, &dhcpObj) == ZCFG_SUCCESS){
+						sprintf(tmp,"true");
+						zcfgFeJsonObjParamSet(oid, "Enable", json_type_boolean, dhcpObj, tmp);
+						sprintf(tmp, "IP.Interface.%d", intfIid.idx[0]);
+						zcfgFeJsonObjParamSet(oid, "Interface", json_type_string, dhcpObj, tmp);
+						sprintf(tmp, "DNS Proxy");
+						zcfgFeJsonObjParamSet(oid, "X_ZYXEL_DNS_Type", json_type_string, dhcpObj, tmp);
+						
+						memset(minAddr, 0, 20);
+						memset(maxAddr, 0, 20);
+						if(createDhcpPoolAddr(ip, mask, minAddr, maxAddr)!= -1){
+							zcfgFeJsonObjParamSet(oid, "MinAddress", json_type_string, dhcpObj, minAddr);
+							zcfgFeJsonObjParamSet(oid, "MaxAddress", json_type_string, dhcpObj, maxAddr);
+						}
+						
+						zRet = zcfgFeObjJsonSet(oid, &dhcpIid, dhcpObj, NULL);
+						if(zRet != ZCFG_SUCCESS){
+							ZYSNMP_ERR("Error to set obj(%s)\n", "RDM_OID_DHCPV4_SRV_POOL");
+							ret = SNMP_ERR_GENERR;
+							goto fail;
+						}
+					}
+				}
+				else{
+					ZYSNMP_ERR("Error to add obj(%s) , ret=%d\n", "RDM_OID_DHCPV4_SRV_POOL", zRet);
+					ret = SNMP_ERR_GENERR;
+					goto fail;
+				}
+			}
+			else if(mode == DHCP_RELAY){
+				if(cur_mode == DHCP_SERVER){
+					zRet = zcfgFeObjJsonDel(RDM_OID_DHCPV4_SRV_POOL, &dhcpIid, NULL);
+					if(zRet != ZCFG_SUCCESS){
+						ZYSNMP_ERR("Cannot delete object(%s)\n", "RDM_OID_DHCPV4_SRV_POOL"); ret = SNMP_ERR_GENERR; goto fail;
+					}
+				}
+				IID_INIT(relayIid);
+				oid = RDM_OID_DHCPV4_RELAY_FWD;
+				if((zRet = zcfgFeObjJsonAdd(oid, &relayIid, NULL)) == ZCFG_SUCCESS){
+					if(zRet = zcfgFeObjJsonGet(oid, &relayIid, &relayObj) == ZCFG_SUCCESS){
+						sprintf(tmp,"true");
+						zcfgFeJsonObjParamSet(oid, "Enable", json_type_boolean, relayObj, tmp);
+						sprintf(tmp, "IP.Interface.%d", intfIid.idx[0]);
+						zcfgFeJsonObjParamSet(oid, "Interface", json_type_string, relayObj, tmp);
+						sprintf(tmp, "0.0.0.0");
+						zcfgFeJsonObjParamSet(oid, "DHCPServerIPAddress", json_type_string, relayObj, tmp);
+						
+						
+						zRet = zcfgFeObjJsonSet(oid, &relayIid, relayObj, NULL);
+						if(zRet != ZCFG_SUCCESS){
+							ZYSNMP_ERR("Error to set obj(%s)\n", "RDM_OID_DHCPV4_RELAY_FWD");
+							ret = SNMP_ERR_GENERR;
+							goto fail;
+						}
+					}
+				}
+				else{
+					ZYSNMP_ERR("Error to add obj(%s) , ret=%d\n", "RDM_OID_DHCPV4_RELAY_FWD", zRet);
+					ret = SNMP_ERR_GENERR;
+					goto fail;
+				}
+			}
+			else{
+				ZYSNMP_ERR("Not support DHCP mode(%d)\n", mode);
+				ret = SNMP_ERR_GENERR;
+				goto fail;
+			}
+		}
+	}
+	else { ZYSNMP_ERR("Cannot get object(%s)\n", "RDM_OID_IP_IFACE"); ret = SNMP_ERR_GENERR; goto fail; }
+	
+fail:
+	if(intfObj) zcfgFeJsonObjFree(intfObj);
+	if(dhcpObj) zcfgFeJsonObjFree(dhcpObj);
+	if(relayObj) zcfgFeJsonObjFree(relayObj);
+	return ret;
+}
\ No newline at end of file
diff -Naur net-snmp-5.7.2-orig/agent/mibgroup/ZYXEL-PRESTIGE-MIB/zylib.h net-snmp-5.7.2/agent/mibgroup/ZYXEL-PRESTIGE-MIB/zylib.h
--- net-snmp-5.7.2-orig/agent/mibgroup/ZYXEL-PRESTIGE-MIB/zylib.h	1970-01-01 08:00:00.000000000 +0800
+++ net-snmp-5.7.2/agent/mibgroup/ZYXEL-PRESTIGE-MIB/zylib.h	2014-01-20 10:59:01.055293456 +0800
@@ -0,0 +1,60 @@
+#ifndef CCCLIB_HBRIAN
+#define CCCLIB_HBRIAN
+
+#include "json/json_object.h"
+#include "zcfg_common.h"
+#include "zcfg_rdm_oid.h"
+#include "zcfg_rdm_obj.h"
+#include "zcfg_fe_rdm_string.h"
+#include "zcfg_fe_rdm_access.h"
+/*
+#include <net-snmp/net-snmp-config.h>
+#include <net-snmp/net-snmp-includes.h>
+#include <net-snmp/agent/net-snmp-agent-includes.h>
+*/
+enum HANDLE_MODE{
+	HANDLE_GET,
+	HANDLE_SET,
+	HANDLE_NONE
+};
+
+enum DHCP_MODE{
+	DHCP_DISABLE = 1,
+	DHCP_SERVER = 2,
+	DHCP_RELAY =3,
+	DHCP_NONE
+};
+
+#define ZYSNMP_ERR(F, argv...) snmp_log(LOG_ERR,"%s:" F, __FUNCTION__, ##argv);
+#define ZYSNMP_DEBUG(F, argv...) snmp_log(LOG_DEBUG,"%s:" F, __FUNCTION__, ##argv);
+#define ZYSNMP_NOTICE(F, argv...) snmp_log(LOG_NOTICE,"%s:" F, __FUNCTION__, ##argv);
+#define ZYSNMP_WARN(F, argv...) snmp_log(LOG_WARNING,"%s:" F, __FUNCTION__, ##argv);
+
+int compareIpAddress(const char *ip, const char *ip2);
+int checkIpDomain(const char *ip, const char *ip2, const char *mask);
+int checkValidIpAddress(const char *ip,const char *subnet);
+int checkIpAddress(const char *ip);
+int checkSubnetMask(const char *mask);
+
+int handleOfGetIntfDevNum(netsnmp_request_info  *requests, u_char type, u_char ifType);
+int handleOfGetParameter(zcfg_offset_t rid,const char *parameter,netsnmp_request_info  *requests, u_char type);
+int handleOfSetParameter(zcfg_offset_t rid, const char *parameter,netsnmp_request_info *requests);
+int handleOfLanAddrParam(const char *ifname, const char *parameter, netsnmp_request_info  *requests, u_char type, enum HANDLE_MODE mode);
+int handleOfLanDhcpParam(const char *ifname, const char *parameter, netsnmp_request_info  *requests, u_char type, enum HANDLE_MODE mode);
+int handleOfLanDhcpRelayParam(const char *ifname, const char *parameter, netsnmp_request_info  *requests, u_char type, enum HANDLE_MODE mode);
+int handleOfLanDhcpDns(const char *ifname, char *dns1, char *dns2, int size, enum HANDLE_MODE mode);
+int handleOfLanDhcpPoolAddr(const char *ifname, char *startAddr, char *endAddr, int size, enum HANDLE_MODE mode);
+//int handleOfChangeDhcpPool(const char *ifname, char *ipAddr, char *netmask);
+int handleOfChangeDhcpMode(const char *ifname, enum DHCP_MODE mode);
+
+#define ZYXEL_MIB_OID 1, 3, 6, 1, 4, 1, 890
+#define PRESTIGE_OID ZYXEL_MIB_OID, 1, 2
+#define PRESTIGE_COMM_OID PRESTIGE_OID, 1
+
+#define IGD_Device RDM_OID_DEVICE
+#define IGD_DeviceInfo RDM_OID_DEV_INFO
+#define IGD_ZYXEL_SYS_INFO RDM_OID_SYSTEM_INFO
+#define IGD_Time RDM_OID_TIME
+#define IGD_DDNS RDM_OID_D_DNS
+#define IGD_LAN_IGMP RDM_OID_ZY_IGMP
+#endif
diff -Naur net-snmp-5.7.2-orig/agent/mibgroup/ZYXEL-PRESTIGE-MIB.h net-snmp-5.7.2/agent/mibgroup/ZYXEL-PRESTIGE-MIB.h
--- net-snmp-5.7.2-orig/agent/mibgroup/ZYXEL-PRESTIGE-MIB.h	1970-01-01 08:00:00.000000000 +0800
+++ net-snmp-5.7.2/agent/mibgroup/ZYXEL-PRESTIGE-MIB.h	2013-11-26 14:01:45.122817000 +0800
@@ -0,0 +1,19 @@
+/*
+ * module to include the modules
+ */
+config_require(ZYXEL-PRESTIGE-MIB/prestigeSystem);
+config_require(ZYXEL-PRESTIGE-MIB/deviceConfig);
+config_require(ZYXEL-PRESTIGE-MIB/deviceSummary);
+config_require(ZYXEL-PRESTIGE-MIB/wanDeviceNumberOfEntry);
+config_require(ZYXEL-PRESTIGE-MIB/lanDeviceNumberOfEntry);
+config_require(ZYXEL-PRESTIGE-MIB/time);
+config_require(ZYXEL-PRESTIGE-MIB/prestigeLAN);
+//config_require(ZYXEL-PRESTIGE-MIB/ipStaticRouteTable);
+//config_require(ZYXEL-PRESTIGE-MIB/filterRuleTable);
+config_require(ZYXEL-PRESTIGE-MIB/prestigeDynDns);
+//config_require(ZYXEL-PRESTIGE-MIB/prestigeXDSL);
+//config_require(ZYXEL-PRESTIGE-MIB/prestigeTraps);
+
+config_exclude(mibII/system_mib)
+
+config_add_mib(ZYXEL-PRESTIGE_MIB);
\ No newline at end of file
diff -Naur net-snmp-5.7.2-orig/agent/snmpd.c net-snmp-5.7.2/agent/snmpd.c
--- net-snmp-5.7.2-orig/agent/snmpd.c	2012-10-10 06:28:58.000000000 +0800
+++ net-snmp-5.7.2/agent/snmpd.c	2013-10-08 09:35:17.626117000 +0800
@@ -152,6 +152,11 @@
 #include <net-snmp/agent/table.h>
 #include <net-snmp/agent/table_iterator.h>
 
+#if 1 //__ZYXEL__, include zcfg header
+#include "zcfg_msg.h"
+#include "zcfg_eid.h"
+#endif
+
 /*
  * Include winservice.h to support Windows Service
  */
@@ -940,6 +945,9 @@
     /*
      * start library 
      */
+#if 1 //__ZYXEL__, initial zcfg	 
+	zcfgEidInit(ZCFG_EID_SNMPD, "snmpd");
+#endif
     init_snmp(app_name);
 
     if ((ret = init_master_agent()) != 0) {
diff -Naur net-snmp-5.7.2-orig/apps/Makefile.in net-snmp-5.7.2/apps/Makefile.in
--- net-snmp-5.7.2-orig/apps/Makefile.in	2012-10-10 06:28:58.000000000 +0800
+++ net-snmp-5.7.2/apps/Makefile.in	2014-01-20 14:57:57.847237366 +0800
@@ -205,7 +205,7 @@
 
 libnetsnmptrapd.$(LIB_EXTENSION)$(LIB_VERSION): $(LLIBTRAPD_OBJS)
 	$(LIB_LD_CMD) $@ ${LLIBTRAPD_OBJS} $(MIBLIB) $(USELIBS) $(PERLLDOPTS_FOR_LIBS) $(LIB_LD_LIBS)
-	$(RANLIB) $@
+#	$(RANLIB) $@
 
 snmpinforminstall:
 	rm -f $(INSTALL_PREFIX)$(bindir)/snmpinform$(EXEEXT)
diff -Naur net-snmp-5.7.2-orig/Makefile.rules net-snmp-5.7.2/Makefile.rules
--- net-snmp-5.7.2-orig/Makefile.rules	2012-10-10 06:28:58.000000000 +0800
+++ net-snmp-5.7.2/Makefile.rules	2014-01-20 15:27:06.071228561 +0800
@@ -84,12 +84,17 @@
 
 # installlibs handles local, ucd and subdir libs. need to do subdir libs
 # before bins, sinze those libs may be needed for successful linking
-install: installlocalheaders @installucdheaders@ \
-         installlibs \
+# install: installlocalheaders @installucdheaders@ \
+#         installlibs \
+#         installlocalbin      installlocalsbin   \
+#         installsubdirs      $(OTHERINSTALL)
+install: installlibs \
          installlocalbin      installlocalsbin   \
          installsubdirs      $(OTHERINSTALL)
 
-uninstall: uninstalllibs uninstallbin uninstallsbin uninstallheaders \
+# uninstall: uninstalllibs uninstallbin uninstallsbin uninstallheaders \
+#           uninstallsubdirs $(OTHERUNINSTALL)
+uninstall: uninstalllibs uninstallbin uninstallsbin \
            uninstallsubdirs $(OTHERUNINSTALL)
 
 installprogs: installbin installsbin
@@ -237,7 +242,6 @@
 		$(INSTALL) $(INSTALLLIBS) $(INSTALL_PREFIX)$(libdir) ; \
 		for i in $$it ; do \
 			echo "installing $$i in $(INSTALL_PREFIX)$(libdir)"; \
-			$(RANLIB) $(INSTALL_PREFIX)$(libdir)/$$i ; \
 		done ; \
 		$(LIB_LDCONFIG_CMD) ; \
 	fi
@@ -249,7 +253,6 @@
 		$(INSTALL) $(INSTALLPOSTLIBS) $(INSTALL_PREFIX)$(libdir) ; \
 		for i in $$it ; do \
 			echo "installing $$i in $(INSTALL_PREFIX)$(libdir)"; \
-			$(RANLIB) $(INSTALL_PREFIX)$(libdir)/$$i ; \
 		done ; \
 		$(LIB_LDCONFIG_CMD) ; \
 	fi
@@ -261,7 +264,6 @@
 		$(INSTALL) $(INSTALLUCDLIBS) $(INSTALL_PREFIX)$(libdir) ; \
 		for i in $$it ; do \
 			echo "installing $$i in $(INSTALL_PREFIX)$(libdir)"; \
-			$(RANLIB) $(INSTALL_PREFIX)$(libdir)/$$i ; \
 		done ; \
 		$(LIB_LDCONFIG_CMD) ; \
 	fi
@@ -278,7 +280,7 @@
 		done \
 	fi
 
-uninstalllibs:
+uninstalllibs: uninstallpostlibs
 	@if test "$(INSTALLLIBS)" != ""; then \
 		it="$(INSTALLLIBS)" ; \
 		for i in $$it ; do   \
@@ -287,6 +289,14 @@
 		done \
 	fi
 
+uninstallpostlibs: 
+	@if test "$(INSTALLPOSTLIBS)" != ""; then \
+		it="$(INSTALLPOSTLIBS)" ; \
+		for i in $$it ; do   \
+			$(UNINSTALL) $(INSTALL_PREFIX)$(libdir)/$$i ; \
+			echo "removing $$i from $(INSTALL_PREFIX)$(libdir)"; \
+		done \
+	fi
 #
 # normal bin binaries
 #
@@ -389,11 +399,15 @@
 			fi  \
 		done \
 	fi
-
+	
+rmMakefile:
+	rm Makefile
+	
 #
 # cleaning targets
 #
-clean: cleansubdirs $(OTHERCLEANTODOS)
+### clean: cleansubdirs $(OTHERCLEANTODOS)
+clean: cleansubdirs $(OTHERCLEANTODOS) uninstall
 	$(LIBTOOLCLEAN) ${OBJS} ${LOBJS}  ${FTOBJS} core $(STANDARDCLEANTARGETS) $(OTHERCLEANTARGETS)
 
 cleansubdirs:
diff -Naur net-snmp-5.7.2-orig/snmpd.conf.tmp net-snmp-5.7.2/snmpd.conf.tmp
--- net-snmp-5.7.2-orig/snmpd.conf.tmp	1970-01-01 08:00:00.000000000 +0800
+++ net-snmp-5.7.2/snmpd.conf.tmp	2013-11-26 14:01:45.122817000 +0800
@@ -0,0 +1,38 @@
+agentaddress udp:%PORT%
+
+# sysServices 72
+# sysObjectID .1.3.6.1.4.1.890
+# sysName %SYSNAME%
+# sysContact %SYSCONT%
+# sysLocation %SYSLOC%
+# sysDescr %SYSDESC%
+
+rocommunity %ROCOUM%
+rwcommunity %RWCOUM%
+trapcommunity %TRAPCOUM%
+
+com2sec RoUser default %ROCOUM%
+com2sec RwUser default %RWCOUM%
+com2sec TrapUser default %TRAPCOUM%
+group RoUserGroup v1 RoUser
+group RoUserGroup v2c RoUser
+group RwUserGroup v1 RwUser
+group RwUserGroup v2c RwUser
+group TrapUserGroup v1 TrapUser
+group TrapUserGroup v2c TrapUser
+access RoUserGroup "" any noauth exact all none none
+access RwUserGroup "" any noauth exact all all none
+access TrapUserGroup "" any noauth exact all none all
+
+rouser admin
+#agentSecName admin
+iquerySecName admin
+
+#defaultMonitors yes
+#linkUpDownNotifications yes
+
+notificationEvent linkUpTrap .1.3.6.1.6.3.1.1.5.4 .1.3.6.1.2.1.2.2.1.1 .1.3.6.1.2.1.2.2.1.2 .1.3.6.1.2.1.2.2.1.7 .1.3.6.1.2.1.2.2.1.8
+notificationEvent linkDownTrap .1.3.6.1.6.3.1.1.5.3 .1.3.6.1.2.1.2.2.1.1 .1.3.6.1.2.1.2.2.1.2 .1.3.6.1.2.1.2.2.1.7 .1.3.6.1.2.1.2.2.1.8
+monitor  -r 30 -e linkUpTrap   "Interface linkUp"   .1.3.6.1.2.1.2.2.1.8 != 2
+monitor  -r 30 -e linkDownTrap "Interface linkDown" .1.3.6.1.2.1.2.2.1.8 == 2
+
diff -Naur net-snmp-5.7.2-orig/snmplib/Makefile.in net-snmp-5.7.2/snmplib/Makefile.in
--- net-snmp-5.7.2-orig/snmplib/Makefile.in	2012-10-10 06:28:58.000000000 +0800
+++ net-snmp-5.7.2/snmplib/Makefile.in	2014-01-20 14:44:51.427241409 +0800
@@ -231,11 +231,11 @@
 # how to build the libraries.
 libnetsnmp.$(LIB_EXTENSION)$(LIB_VERSION):    $(TOBJS)
 	$(LIB_LD_CMD) $@ $(TOBJS) @LD_NO_UNDEFINED@ $(LDFLAGS) @LNETSNMPLIBS@
-	$(RANLIB) $@
+#	$(RANLIB) $@
 
 libsnmp.$(LIB_EXTENSION)$(LIB_VERSION):    $(TOBJS)
 	$(LIB_LD_CMD) $@ $(TOBJS) @LD_NO_UNDEFINED@ $(LDFLAGS) @LNETSNMPLIBS@
-	$(RANLIB) $@
+#	$(RANLIB) $@
 
 #
 # internal test objects
