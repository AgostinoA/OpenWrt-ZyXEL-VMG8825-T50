Index: linux-3.18.21/include/linux/mm.h
===================================================================
--- linux-3.18.21.orig/include/linux/mm.h	2015-09-01 06:19:23.000000000 +0800
+++ linux-3.18.21/include/linux/mm.h	2018-05-29 11:39:13.184067341 +0800
@@ -2029,6 +2029,10 @@
 #define FOLL_MIGRATION	0x400	/* wait for page to replace migration entry */
 #define FOLL_TRIED	0x800	/* a retry, previous pass started an IO */
 
+#if 1 // CVE-2016-5195 dirty COW
+#define FOLL_COW	0x4000	/* internal GUP flag */
+#endif
+
 typedef int (*pte_fn_t)(pte_t *pte, pgtable_t token, unsigned long addr,
 			void *data);
 extern int apply_to_page_range(struct mm_struct *mm, unsigned long address,
Index: linux-3.18.21/mm/gup.c
===================================================================
--- linux-3.18.21.orig/mm/gup.c	2015-09-01 06:19:23.000000000 +0800
+++ linux-3.18.21/mm/gup.c	2018-05-29 11:38:53.029133939 +0800
@@ -32,6 +32,18 @@
 	return NULL;
 }
 
+#if 1 // CVE-2016-5195 Dirty COW
+/*
+ * FOLL_FORCE can write to even unwritable pte's, but only
+ * after we've gone through a COW cycle and they are dirty.
+ */
+static inline bool can_follow_write_pte(pte_t pte, unsigned int flags)
+{
+	return pte_write(pte) ||
+		((flags & FOLL_FORCE) && (flags & FOLL_COW) && pte_dirty(pte));
+}
+#endif
+
 static struct page *follow_page_pte(struct vm_area_struct *vma,
 		unsigned long address, pmd_t *pmd, unsigned int flags)
 {
@@ -66,7 +78,11 @@
 	}
 	if ((flags & FOLL_NUMA) && pte_numa(pte))
 		goto no_page;
+	#if 1 // CVE-2016-5195 Dirty COW
+	if ((flags & FOLL_WRITE) && !can_follow_write_pte(pte, flags)) {
+	#else
 	if ((flags & FOLL_WRITE) && !pte_write(pte)) {
+	#endif
 		pte_unmap_unlock(ptep, ptl);
 		return NULL;
 	}
@@ -315,7 +331,11 @@
 	 * reCOWed by userspace write).
 	 */
 	if ((ret & VM_FAULT_WRITE) && !(vma->vm_flags & VM_WRITE))
+		#if 1 // CVE-2016-5195 Dirty COW
+		*flags |= FOLL_COW;
+		#else
 		*flags &= ~FOLL_WRITE;
+		#endif
 	return 0;
 }
 
