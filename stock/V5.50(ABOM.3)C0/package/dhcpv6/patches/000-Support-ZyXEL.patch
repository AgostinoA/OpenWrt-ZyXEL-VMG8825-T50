diff -Naur wide-dhcpv6-20080615.orig/cfparse.c wide-dhcpv6-20080615/cfparse.c
--- wide-dhcpv6-20080615.orig/cfparse.c	2007-03-21 17:53:10.000000000 +0800
+++ wide-dhcpv6-20080615/cfparse.c	1970-01-01 08:00:00.000000000 +0800
@@ -1,3156 +0,0 @@
-/* A Bison parser, made by GNU Bison 2.1.  */
-
-/* Skeleton parser for Yacc-like parsing with Bison,
-   Copyright (C) 1984, 1989, 1990, 2000, 2001, 2002, 2003, 2004, 2005 Free Software Foundation, Inc.
-
-   This program is free software; you can redistribute it and/or modify
-   it under the terms of the GNU General Public License as published by
-   the Free Software Foundation; either version 2, or (at your option)
-   any later version.
-
-   This program is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-   GNU General Public License for more details.
-
-   You should have received a copy of the GNU General Public License
-   along with this program; if not, write to the Free Software
-   Foundation, Inc., 51 Franklin Street, Fifth Floor,
-   Boston, MA 02110-1301, USA.  */
-
-/* As a special exception, when this file is copied by Bison into a
-   Bison output file, you may use that output file without restriction.
-   This special exception was added by the Free Software Foundation
-   in version 1.24 of Bison.  */
-
-/* Written by Richard Stallman by simplifying the original so called
-   ``semantic'' parser.  */
-
-/* All symbols defined below should begin with yy or YY, to avoid
-   infringing on user name space.  This should be done even for local
-   variables, as they might otherwise be expanded by user macros.
-   There are some unavoidable exceptions within include files to
-   define necessary library symbols; they are noted "INFRINGES ON
-   USER NAME SPACE" below.  */
-
-/* Identify Bison output.  */
-#define YYBISON 1
-
-/* Bison version.  */
-#define YYBISON_VERSION "2.1"
-
-/* Skeleton name.  */
-#define YYSKELETON_NAME "yacc.c"
-
-/* Pure parsers.  */
-#define YYPURE 0
-
-/* Using locations.  */
-#define YYLSP_NEEDED 0
-
-
-
-/* Tokens.  */
-#ifndef YYTOKENTYPE
-# define YYTOKENTYPE
-   /* Put the tokens into the symbol table, so that GDB and other debuggers
-      know about them.  */
-   enum yytokentype {
-     INTERFACE = 258,
-     IFNAME = 259,
-     PREFIX_INTERFACE = 260,
-     SLA_ID = 261,
-     SLA_LEN = 262,
-     DUID_ID = 263,
-     ID_ASSOC = 264,
-     IA_PD = 265,
-     IAID = 266,
-     IA_NA = 267,
-     ADDRESS = 268,
-     REQUEST = 269,
-     SEND = 270,
-     ALLOW = 271,
-     PREFERENCE = 272,
-     HOST = 273,
-     HOSTNAME = 274,
-     DUID = 275,
-     OPTION = 276,
-     RAPID_COMMIT = 277,
-     DNS_SERVERS = 278,
-     DNS_NAME = 279,
-     NTP_SERVERS = 280,
-     REFRESHTIME = 281,
-     SIP_SERVERS = 282,
-     SIP_NAME = 283,
-     NIS_SERVERS = 284,
-     NIS_NAME = 285,
-     NISP_SERVERS = 286,
-     NISP_NAME = 287,
-     BCMCS_SERVERS = 288,
-     BCMCS_NAME = 289,
-     INFO_ONLY = 290,
-     SCRIPT = 291,
-     DELAYEDKEY = 292,
-     AUTHENTICATION = 293,
-     PROTOCOL = 294,
-     ALGORITHM = 295,
-     DELAYED = 296,
-     RECONFIG = 297,
-     HMACMD5 = 298,
-     MONOCOUNTER = 299,
-     AUTHNAME = 300,
-     RDM = 301,
-     KEY = 302,
-     KEYINFO = 303,
-     REALM = 304,
-     KEYID = 305,
-     SECRET = 306,
-     KEYNAME = 307,
-     EXPIRE = 308,
-     ADDRPOOL = 309,
-     POOLNAME = 310,
-     RANGE = 311,
-     TO = 312,
-     ADDRESS_POOL = 313,
-     INCLUDE = 314,
-     NUMBER = 315,
-     SLASH = 316,
-     EOS = 317,
-     BCL = 318,
-     ECL = 319,
-     STRING = 320,
-     QSTRING = 321,
-     PREFIX = 322,
-     INFINITY = 323,
-     COMMA = 324
-   };
-#endif
-/* Tokens.  */
-#define INTERFACE 258
-#define IFNAME 259
-#define PREFIX_INTERFACE 260
-#define SLA_ID 261
-#define SLA_LEN 262
-#define DUID_ID 263
-#define ID_ASSOC 264
-#define IA_PD 265
-#define IAID 266
-#define IA_NA 267
-#define ADDRESS 268
-#define REQUEST 269
-#define SEND 270
-#define ALLOW 271
-#define PREFERENCE 272
-#define HOST 273
-#define HOSTNAME 274
-#define DUID 275
-#define OPTION 276
-#define RAPID_COMMIT 277
-#define DNS_SERVERS 278
-#define DNS_NAME 279
-#define NTP_SERVERS 280
-#define REFRESHTIME 281
-#define SIP_SERVERS 282
-#define SIP_NAME 283
-#define NIS_SERVERS 284
-#define NIS_NAME 285
-#define NISP_SERVERS 286
-#define NISP_NAME 287
-#define BCMCS_SERVERS 288
-#define BCMCS_NAME 289
-#define INFO_ONLY 290
-#define SCRIPT 291
-#define DELAYEDKEY 292
-#define AUTHENTICATION 293
-#define PROTOCOL 294
-#define ALGORITHM 295
-#define DELAYED 296
-#define RECONFIG 297
-#define HMACMD5 298
-#define MONOCOUNTER 299
-#define AUTHNAME 300
-#define RDM 301
-#define KEY 302
-#define KEYINFO 303
-#define REALM 304
-#define KEYID 305
-#define SECRET 306
-#define KEYNAME 307
-#define EXPIRE 308
-#define ADDRPOOL 309
-#define POOLNAME 310
-#define RANGE 311
-#define TO 312
-#define ADDRESS_POOL 313
-#define INCLUDE 314
-#define NUMBER 315
-#define SLASH 316
-#define EOS 317
-#define BCL 318
-#define ECL 319
-#define STRING 320
-#define QSTRING 321
-#define PREFIX 322
-#define INFINITY 323
-#define COMMA 324
-
-
-
-
-/* Copy the first part of user declarations.  */
-#line 31 "cfparse.y"
-
-#include <sys/types.h>
-#include <sys/socket.h>
-#include <sys/queue.h>
-#include <sys/time.h>
-
-#include <netinet/in.h>
-
-#include <arpa/inet.h>
-
-#include <stdlib.h>
-#include <string.h>
-
-#include "dhcp6.h"
-#include "config.h"
-#include "common.h"
-
-extern int lineno;
-extern int cfdebug;
-
-extern void yywarn __P((char *, ...))
-	__attribute__((__format__(__printf__, 1, 2)));
-extern void yyerror __P((char *, ...))
-	__attribute__((__format__(__printf__, 1, 2)));
-
-#define MAKE_NAMELIST(l, n, p) do { \
-	(l) = (struct cf_namelist *)malloc(sizeof(*(l))); \
-	if ((l) == NULL) { \
-		yywarn("can't allocate memory"); \
-		if (p) cleanup_cflist(p); \
-		return (-1); \
-	} \
-	memset((l), 0, sizeof(*(l))); \
-	l->line = lineno; \
-	l->name = (n); \
-	l->params = (p); \
-	} while (0)
-
-#define MAKE_CFLIST(l, t, pp, pl) do { \
-	(l) = (struct cf_list *)malloc(sizeof(*(l))); \
-	if ((l) == NULL) { \
-		yywarn("can't allocate memory"); \
-		if (pp) free(pp); \
-		if (pl) cleanup_cflist(pl); \
-		return (-1); \
-	} \
-	memset((l), 0, sizeof(*(l))); \
-	l->line = lineno; \
-	l->type = (t); \
-	l->ptr = (pp); \
-	l->list = (pl); \
-	l->tail = (l); \
-	} while (0)
-
-static struct cf_namelist *iflist_head, *hostlist_head, *iapdlist_head;
-static struct cf_namelist *addrpoollist_head;
-static struct cf_namelist *authinfolist_head, *keylist_head;
-static struct cf_namelist *ianalist_head;
-struct cf_list *cf_dns_list, *cf_dns_name_list, *cf_ntp_list;
-struct cf_list *cf_sip_list, *cf_sip_name_list;
-struct cf_list *cf_nis_list, *cf_nis_name_list;
-struct cf_list *cf_nisp_list, *cf_nisp_name_list;
-struct cf_list *cf_bcmcs_list, *cf_bcmcs_name_list;
-long long cf_refreshtime = -1;
-
-extern int yylex __P((void));
-extern int cfswitch_buffer __P((char *));
-static int add_namelist __P((struct cf_namelist *, struct cf_namelist **));
-static void cleanup __P((void));
-static void cleanup_namelist __P((struct cf_namelist *));
-static void cleanup_cflist __P((struct cf_list *));
-
-
-/* Enabling traces.  */
-#ifndef YYDEBUG
-# define YYDEBUG 0
-#endif
-
-/* Enabling verbose error messages.  */
-#ifdef YYERROR_VERBOSE
-# undef YYERROR_VERBOSE
-# define YYERROR_VERBOSE 1
-#else
-# define YYERROR_VERBOSE 0
-#endif
-
-/* Enabling the token table.  */
-#ifndef YYTOKEN_TABLE
-# define YYTOKEN_TABLE 0
-#endif
-
-#if ! defined (YYSTYPE) && ! defined (YYSTYPE_IS_DECLARED)
-#line 126 "cfparse.y"
-typedef union YYSTYPE {
-	long long num;
-	char* str;
-	struct cf_list *list;
-	struct dhcp6_prefix *prefix;
-	struct dhcp6_range *range;
-	struct dhcp6_poolspec *pool;
-} YYSTYPE;
-/* Line 196 of yacc.c.  */
-#line 305 "y.tab.c"
-# define yystype YYSTYPE /* obsolescent; will be withdrawn */
-# define YYSTYPE_IS_DECLARED 1
-# define YYSTYPE_IS_TRIVIAL 1
-#endif
-
-
-
-/* Copy the second part of user declarations.  */
-
-
-/* Line 219 of yacc.c.  */
-#line 317 "y.tab.c"
-
-#if ! defined (YYSIZE_T) && defined (__SIZE_TYPE__)
-# define YYSIZE_T __SIZE_TYPE__
-#endif
-#if ! defined (YYSIZE_T) && defined (size_t)
-# define YYSIZE_T size_t
-#endif
-#if ! defined (YYSIZE_T) && (defined (__STDC__) || defined (__cplusplus))
-# include <stddef.h> /* INFRINGES ON USER NAME SPACE */
-# define YYSIZE_T size_t
-#endif
-#if ! defined (YYSIZE_T)
-# define YYSIZE_T unsigned int
-#endif
-
-#ifndef YY_
-# if YYENABLE_NLS
-#  if ENABLE_NLS
-#   include <libintl.h> /* INFRINGES ON USER NAME SPACE */
-#   define YY_(msgid) dgettext ("bison-runtime", msgid)
-#  endif
-# endif
-# ifndef YY_
-#  define YY_(msgid) msgid
-# endif
-#endif
-
-#if ! defined (yyoverflow) || YYERROR_VERBOSE
-
-/* The parser invokes alloca or malloc; define the necessary symbols.  */
-
-# ifdef YYSTACK_USE_ALLOCA
-#  if YYSTACK_USE_ALLOCA
-#   ifdef __GNUC__
-#    define YYSTACK_ALLOC __builtin_alloca
-#   else
-#    define YYSTACK_ALLOC alloca
-#    if defined (__STDC__) || defined (__cplusplus)
-#     include <stdlib.h> /* INFRINGES ON USER NAME SPACE */
-#     define YYINCLUDED_STDLIB_H
-#    endif
-#   endif
-#  endif
-# endif
-
-# ifdef YYSTACK_ALLOC
-   /* Pacify GCC's `empty if-body' warning. */
-#  define YYSTACK_FREE(Ptr) do { /* empty */; } while (0)
-#  ifndef YYSTACK_ALLOC_MAXIMUM
-    /* The OS might guarantee only one guard page at the bottom of the stack,
-       and a page size can be as small as 4096 bytes.  So we cannot safely
-       invoke alloca (N) if N exceeds 4096.  Use a slightly smaller number
-       to allow for a few compiler-allocated temporary stack slots.  */
-#   define YYSTACK_ALLOC_MAXIMUM 4032 /* reasonable circa 2005 */
-#  endif
-# else
-#  define YYSTACK_ALLOC YYMALLOC
-#  define YYSTACK_FREE YYFREE
-#  ifndef YYSTACK_ALLOC_MAXIMUM
-#   define YYSTACK_ALLOC_MAXIMUM ((YYSIZE_T) -1)
-#  endif
-#  ifdef __cplusplus
-extern "C" {
-#  endif
-#  ifndef YYMALLOC
-#   define YYMALLOC malloc
-#   if (! defined (malloc) && ! defined (YYINCLUDED_STDLIB_H) \
-	&& (defined (__STDC__) || defined (__cplusplus)))
-void *malloc (YYSIZE_T); /* INFRINGES ON USER NAME SPACE */
-#   endif
-#  endif
-#  ifndef YYFREE
-#   define YYFREE free
-#   if (! defined (free) && ! defined (YYINCLUDED_STDLIB_H) \
-	&& (defined (__STDC__) || defined (__cplusplus)))
-void free (void *); /* INFRINGES ON USER NAME SPACE */
-#   endif
-#  endif
-#  ifdef __cplusplus
-}
-#  endif
-# endif
-#endif /* ! defined (yyoverflow) || YYERROR_VERBOSE */
-
-
-#if (! defined (yyoverflow) \
-     && (! defined (__cplusplus) \
-	 || (defined (YYSTYPE_IS_TRIVIAL) && YYSTYPE_IS_TRIVIAL)))
-
-/* A type that is properly aligned for any stack member.  */
-union yyalloc
-{
-  short int yyss;
-  YYSTYPE yyvs;
-  };
-
-/* The size of the maximum gap between one aligned stack and the next.  */
-# define YYSTACK_GAP_MAXIMUM (sizeof (union yyalloc) - 1)
-
-/* The size of an array large to enough to hold all stacks, each with
-   N elements.  */
-# define YYSTACK_BYTES(N) \
-     ((N) * (sizeof (short int) + sizeof (YYSTYPE))			\
-      + YYSTACK_GAP_MAXIMUM)
-
-/* Copy COUNT objects from FROM to TO.  The source and destination do
-   not overlap.  */
-# ifndef YYCOPY
-#  if defined (__GNUC__) && 1 < __GNUC__
-#   define YYCOPY(To, From, Count) \
-      __builtin_memcpy (To, From, (Count) * sizeof (*(From)))
-#  else
-#   define YYCOPY(To, From, Count)		\
-      do					\
-	{					\
-	  YYSIZE_T yyi;				\
-	  for (yyi = 0; yyi < (Count); yyi++)	\
-	    (To)[yyi] = (From)[yyi];		\
-	}					\
-      while (0)
-#  endif
-# endif
-
-/* Relocate STACK from its old location to the new one.  The
-   local variables YYSIZE and YYSTACKSIZE give the old and new number of
-   elements in the stack, and YYPTR gives the new location of the
-   stack.  Advance YYPTR to a properly aligned location for the next
-   stack.  */
-# define YYSTACK_RELOCATE(Stack)					\
-    do									\
-      {									\
-	YYSIZE_T yynewbytes;						\
-	YYCOPY (&yyptr->Stack, Stack, yysize);				\
-	Stack = &yyptr->Stack;						\
-	yynewbytes = yystacksize * sizeof (*Stack) + YYSTACK_GAP_MAXIMUM; \
-	yyptr += yynewbytes / sizeof (*yyptr);				\
-      }									\
-    while (0)
-
-#endif
-
-#if defined (__STDC__) || defined (__cplusplus)
-   typedef signed char yysigned_char;
-#else
-   typedef short int yysigned_char;
-#endif
-
-/* YYFINAL -- State number of the termination state. */
-#define YYFINAL  2
-/* YYLAST -- Last index in YYTABLE.  */
-#define YYLAST   227
-
-/* YYNTOKENS -- Number of terminals. */
-#define YYNTOKENS  70
-/* YYNNTS -- Number of nonterminals. */
-#define YYNNTS  36
-/* YYNRULES -- Number of rules. */
-#define YYNRULES  105
-/* YYNRULES -- Number of states. */
-#define YYNSTATES  231
-
-/* YYTRANSLATE(YYLEX) -- Bison symbol number corresponding to YYLEX.  */
-#define YYUNDEFTOK  2
-#define YYMAXUTOK   324
-
-#define YYTRANSLATE(YYX)						\
-  ((unsigned int) (YYX) <= YYMAXUTOK ? yytranslate[YYX] : YYUNDEFTOK)
-
-/* YYTRANSLATE[YYLEX] -- Bison symbol number corresponding to YYLEX.  */
-static const unsigned char yytranslate[] =
-{
-       0,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     1,     2,     3,     4,
-       5,     6,     7,     8,     9,    10,    11,    12,    13,    14,
-      15,    16,    17,    18,    19,    20,    21,    22,    23,    24,
-      25,    26,    27,    28,    29,    30,    31,    32,    33,    34,
-      35,    36,    37,    38,    39,    40,    41,    42,    43,    44,
-      45,    46,    47,    48,    49,    50,    51,    52,    53,    54,
-      55,    56,    57,    58,    59,    60,    61,    62,    63,    64,
-      65,    66,    67,    68,    69
-};
-
-#if YYDEBUG
-/* YYPRHS[YYN] -- Index of the first RHS symbol of rule number YYN in
-   YYRHS.  */
-static const unsigned short int yyprhs[] =
-{
-       0,     0,     3,     4,     7,     9,    11,    13,    15,    17,
-      19,    21,    23,    30,    37,    42,    47,    52,    57,    62,
-      67,    72,    77,    82,    87,    92,    97,   105,   112,   120,
-     127,   134,   141,   145,   152,   153,   156,   158,   159,   162,
-     166,   170,   173,   177,   181,   185,   189,   193,   197,   201,
-     205,   209,   211,   215,   217,   220,   223,   226,   228,   230,
-     232,   234,   236,   238,   240,   242,   244,   246,   248,   250,
-     254,   257,   261,   266,   272,   275,   279,   281,   283,   284,
-     287,   289,   293,   300,   301,   304,   308,   312,   313,   316,
-     320,   321,   324,   328,   332,   336,   340,   342,   344,   346,
-     348,   349,   352,   356,   360,   364
-};
-
-/* YYRHS -- A `-1'-separated list of the rules' RHS. */
-static const yysigned_char yyrhs[] =
-{
-      71,     0,    -1,    -1,    71,    72,    -1,    73,    -1,    74,
-      -1,    75,    -1,    76,    -1,    77,    -1,    78,    -1,    80,
-      -1,    79,    -1,     3,     4,    63,    83,    64,    62,    -1,
-      18,    19,    63,    83,    64,    62,    -1,    21,    23,    81,
-      62,    -1,    21,    24,    66,    62,    -1,    21,    25,    81,
-      62,    -1,    21,    27,    81,    62,    -1,    21,    28,    66,
-      62,    -1,    21,    29,    81,    62,    -1,    21,    30,    66,
-      62,    -1,    21,    31,    81,    62,    -1,    21,    32,    66,
-      62,    -1,    21,    33,    81,    62,    -1,    21,    34,    66,
-      62,    -1,    21,    26,    60,    62,    -1,     9,    10,    11,
-      63,    92,    64,    62,    -1,     9,    10,    63,    92,    64,
-      62,    -1,     9,    12,    11,    63,    97,    64,    62,    -1,
-       9,    12,    63,    97,    64,    62,    -1,    38,    45,    63,
-      99,    64,    62,    -1,    48,    52,    63,   104,    64,    62,
-      -1,    59,    66,    62,    -1,    54,    55,    63,    83,    64,
-      62,    -1,    -1,    81,    82,    -1,    65,    -1,    -1,    83,
-      84,    -1,    15,    85,    62,    -1,    14,    85,    62,    -1,
-      35,    62,    -1,    16,    86,    62,    -1,    20,     8,    62,
-      -1,    13,    88,    62,    -1,    67,    89,    62,    -1,    17,
-      60,    62,    -1,    36,    66,    62,    -1,    37,    65,    62,
-      -1,    56,    87,    62,    -1,    58,    90,    62,    -1,    86,
-      -1,    86,    69,    85,    -1,    22,    -1,    38,    45,    -1,
-      10,    60,    -1,    12,    60,    -1,    27,    -1,    28,    -1,
-      23,    -1,    24,    -1,    25,    -1,    26,    -1,    29,    -1,
-      30,    -1,    31,    -1,    32,    -1,    33,    -1,    34,    -1,
-      65,    57,    65,    -1,    65,    91,    -1,    65,    91,    91,
-      -1,    65,    61,    60,    91,    -1,    65,    61,    60,    91,
-      91,    -1,    65,    91,    -1,    65,    91,    91,    -1,    68,
-      -1,    60,    -1,    -1,    92,    93,    -1,    94,    -1,    67,
-      89,    62,    -1,     5,     4,    63,    95,    64,    62,    -1,
-      -1,    95,    96,    -1,     6,    60,    62,    -1,     7,    60,
-      62,    -1,    -1,    97,    98,    -1,    13,    88,    62,    -1,
-      -1,    99,   100,    -1,    39,   101,    62,    -1,    40,   102,
-      62,    -1,    46,   103,    62,    -1,    47,    65,    62,    -1,
-      41,    -1,    42,    -1,    43,    -1,    44,    -1,    -1,   104,
-     105,    -1,    49,    66,    62,    -1,    50,    60,    62,    -1,
-      51,    66,    62,    -1,    53,    66,    62,    -1
-};
-
-/* YYRLINE[YYN] -- source line where rule number YYN was defined.  */
-static const unsigned short int yyrline[] =
-{
-       0,   149,   149,   151,   155,   156,   157,   158,   159,   160,
-     161,   162,   166,   178,   190,   199,   214,   223,   232,   247,
-     256,   271,   280,   295,   304,   319,   348,   357,   371,   380,
-     397,   409,   421,   432,   444,   445,   463,   486,   487,   505,
-     513,   521,   529,   537,   545,   553,   561,   570,   578,   586,
-     594,   605,   609,   619,   627,   635,   643,   651,   659,   667,
-     675,   683,   691,   699,   707,   715,   723,   731,   739,   750,
-     781,   808,   841,   868,   901,   926,   957,   961,   968,   969,
-     987,   988,   999,  1009,  1010,  1028,  1036,  1047,  1048,  1066,
-    1077,  1078,  1096,  1104,  1112,  1120,  1131,  1132,  1136,  1140,
-    1144,  1145,  1163,  1171,  1179,  1187
-};
-#endif
-
-#if YYDEBUG || YYERROR_VERBOSE || YYTOKEN_TABLE
-/* YYTNAME[SYMBOL-NUM] -- String name of the symbol SYMBOL-NUM.
-   First, the terminals, then, starting at YYNTOKENS, nonterminals. */
-static const char *const yytname[] =
-{
-  "$end", "error", "$undefined", "INTERFACE", "IFNAME",
-  "PREFIX_INTERFACE", "SLA_ID", "SLA_LEN", "DUID_ID", "ID_ASSOC", "IA_PD",
-  "IAID", "IA_NA", "ADDRESS", "REQUEST", "SEND", "ALLOW", "PREFERENCE",
-  "HOST", "HOSTNAME", "DUID", "OPTION", "RAPID_COMMIT", "DNS_SERVERS",
-  "DNS_NAME", "NTP_SERVERS", "REFRESHTIME", "SIP_SERVERS", "SIP_NAME",
-  "NIS_SERVERS", "NIS_NAME", "NISP_SERVERS", "NISP_NAME", "BCMCS_SERVERS",
-  "BCMCS_NAME", "INFO_ONLY", "SCRIPT", "DELAYEDKEY", "AUTHENTICATION",
-  "PROTOCOL", "ALGORITHM", "DELAYED", "RECONFIG", "HMACMD5", "MONOCOUNTER",
-  "AUTHNAME", "RDM", "KEY", "KEYINFO", "REALM", "KEYID", "SECRET",
-  "KEYNAME", "EXPIRE", "ADDRPOOL", "POOLNAME", "RANGE", "TO",
-  "ADDRESS_POOL", "INCLUDE", "NUMBER", "SLASH", "EOS", "BCL", "ECL",
-  "STRING", "QSTRING", "PREFIX", "INFINITY", "COMMA", "$accept",
-  "statements", "statement", "interface_statement", "host_statement",
-  "option_statement", "ia_statement", "authentication_statement",
-  "key_statement", "include_statement", "addrpool_statement",
-  "address_list", "address_list_ent", "declarations", "declaration",
-  "dhcpoption_list", "dhcpoption", "rangeparam", "addressparam",
-  "prefixparam", "poolparam", "duration", "iapdconf_list", "iapdconf",
-  "prefix_interface", "ifparams", "ifparam", "ianaconf_list", "ianaconf",
-  "authparam_list", "authparam", "authproto", "authalg", "authrdm",
-  "keyparam_list", "keyparam", 0
-};
-#endif
-
-# ifdef YYPRINT
-/* YYTOKNUM[YYLEX-NUM] -- Internal token number corresponding to
-   token YYLEX-NUM.  */
-static const unsigned short int yytoknum[] =
-{
-       0,   256,   257,   258,   259,   260,   261,   262,   263,   264,
-     265,   266,   267,   268,   269,   270,   271,   272,   273,   274,
-     275,   276,   277,   278,   279,   280,   281,   282,   283,   284,
-     285,   286,   287,   288,   289,   290,   291,   292,   293,   294,
-     295,   296,   297,   298,   299,   300,   301,   302,   303,   304,
-     305,   306,   307,   308,   309,   310,   311,   312,   313,   314,
-     315,   316,   317,   318,   319,   320,   321,   322,   323,   324
-};
-# endif
-
-/* YYR1[YYN] -- Symbol number of symbol that rule YYN derives.  */
-static const unsigned char yyr1[] =
-{
-       0,    70,    71,    71,    72,    72,    72,    72,    72,    72,
-      72,    72,    73,    74,    75,    75,    75,    75,    75,    75,
-      75,    75,    75,    75,    75,    75,    76,    76,    76,    76,
-      77,    78,    79,    80,    81,    81,    82,    83,    83,    84,
-      84,    84,    84,    84,    84,    84,    84,    84,    84,    84,
-      84,    85,    85,    86,    86,    86,    86,    86,    86,    86,
-      86,    86,    86,    86,    86,    86,    86,    86,    86,    87,
-      88,    88,    89,    89,    90,    90,    91,    91,    92,    92,
-      93,    93,    94,    95,    95,    96,    96,    97,    97,    98,
-      99,    99,   100,   100,   100,   100,   101,   101,   102,   103,
-     104,   104,   105,   105,   105,   105
-};
-
-/* YYR2[YYN] -- Number of symbols composing right hand side of rule YYN.  */
-static const unsigned char yyr2[] =
-{
-       0,     2,     0,     2,     1,     1,     1,     1,     1,     1,
-       1,     1,     6,     6,     4,     4,     4,     4,     4,     4,
-       4,     4,     4,     4,     4,     4,     7,     6,     7,     6,
-       6,     6,     3,     6,     0,     2,     1,     0,     2,     3,
-       3,     2,     3,     3,     3,     3,     3,     3,     3,     3,
-       3,     1,     3,     1,     2,     2,     2,     1,     1,     1,
-       1,     1,     1,     1,     1,     1,     1,     1,     1,     3,
-       2,     3,     4,     5,     2,     3,     1,     1,     0,     2,
-       1,     3,     6,     0,     2,     3,     3,     0,     2,     3,
-       0,     2,     3,     3,     3,     3,     1,     1,     1,     1,
-       0,     2,     3,     3,     3,     3
-};
-
-/* YYDEFACT[STATE-NAME] -- Default rule to reduce with in state
-   STATE-NUM when YYTABLE doesn't specify something else to do.  Zero
-   means the default is an error.  */
-static const unsigned char yydefact[] =
-{
-       2,     0,     1,     0,     0,     0,     0,     0,     0,     0,
-       0,     3,     4,     5,     6,     7,     8,     9,    11,    10,
-       0,     0,     0,     0,    34,     0,    34,     0,    34,     0,
-      34,     0,    34,     0,    34,     0,     0,     0,     0,     0,
-      37,     0,    78,     0,    87,    37,     0,     0,     0,     0,
-       0,     0,     0,     0,     0,     0,     0,     0,    90,   100,
-      37,    32,     0,    78,     0,    87,     0,     0,    14,    36,
-      35,    15,    16,    25,    17,    18,    19,    20,    21,    22,
-      23,    24,     0,     0,     0,     0,     0,     0,     0,     0,
-       0,     0,     0,     0,     0,     0,     0,     0,    38,     0,
-       0,     0,     0,    79,    80,     0,     0,     0,    88,     0,
-       0,     0,     0,     0,     0,    91,     0,     0,     0,     0,
-       0,   101,     0,     0,     0,     0,     0,    53,    59,    60,
-      61,    62,    57,    58,    63,    64,    65,    66,    67,    68,
-       0,     0,    51,     0,     0,     0,     0,    41,     0,     0,
-       0,     0,     0,     0,    12,     0,     0,     0,     0,    27,
-       0,     0,     0,    29,    13,    96,    97,     0,    98,     0,
-      99,     0,     0,    30,     0,     0,     0,     0,    31,    33,
-      77,    76,    70,    44,    55,    56,    54,    40,     0,    39,
-      42,    46,    43,    47,    48,     0,    49,    74,    50,     0,
-      45,    26,    83,    81,    28,    89,    92,    93,    94,    95,
-     102,   103,   104,   105,    71,    52,    69,    75,     0,     0,
-      72,     0,     0,     0,    84,    73,     0,     0,    82,    85,
-      86
-};
-
-/* YYDEFGOTO[NTERM-NUM]. */
-static const short int yydefgoto[] =
-{
-      -1,     1,    11,    12,    13,    14,    15,    16,    17,    18,
-      19,    46,    70,    62,    98,   141,   142,   151,   124,   156,
-     153,   182,    64,   103,   104,   219,   224,    66,   108,    82,
-     115,   167,   169,   171,    83,   121
-};
-
-/* YYPACT[STATE-NUM] -- Index in YYTABLE of the portion describing
-   STATE-NUM.  */
-#define YYPACT_NINF -152
-static const short int yypact[] =
-{
-    -152,     4,  -152,     8,    64,    -4,   119,   -28,   -14,   -26,
-     -22,  -152,  -152,  -152,  -152,  -152,  -152,  -152,  -152,  -152,
-     -15,    -6,     5,    21,  -152,    -7,  -152,     0,  -152,    27,
-    -152,    32,  -152,    34,  -152,    36,    40,    41,    42,    37,
-    -152,    43,  -152,    44,  -152,  -152,   -51,    46,   -25,    55,
-     -12,    56,    16,    58,    20,    59,    30,    60,  -152,  -152,
-    -152,  -152,    19,  -152,    -3,  -152,     6,    74,  -152,  -152,
-    -152,  -152,  -152,  -152,  -152,  -152,  -152,  -152,  -152,  -152,
-    -152,  -152,    33,   -23,    99,    31,   146,   146,   146,    63,
-     116,    65,    62,    61,    66,    68,    67,    72,  -152,    -2,
-     121,    77,    72,  -152,  -152,     7,    31,    78,  -152,    92,
-     -18,   117,   115,    96,   100,  -152,    98,   105,   101,   120,
-     123,  -152,   125,   -50,   126,   122,   129,  -152,  -152,  -152,
-    -152,  -152,  -152,  -152,  -152,  -152,  -152,  -152,  -152,  -152,
-     136,   128,   114,   130,   131,   132,   133,  -152,   134,   135,
-     141,   137,   -50,   138,  -152,   140,   142,   143,   139,  -152,
-     144,   145,   147,  -152,  -152,  -152,  -152,   148,  -152,   149,
-    -152,   150,   151,  -152,   152,   153,   154,   155,  -152,  -152,
-    -152,  -152,   -50,  -152,  -152,  -152,  -152,  -152,   146,  -152,
-    -152,  -152,  -152,  -152,  -152,   156,  -152,   -50,  -152,   158,
-    -152,  -152,  -152,  -152,  -152,  -152,  -152,  -152,  -152,  -152,
-    -152,  -152,  -152,  -152,  -152,  -152,  -152,  -152,   -50,     2,
-     -50,   159,   160,   161,  -152,  -152,   162,   163,  -152,  -152,
-    -152
-};
-
-/* YYPGOTO[NTERM-NUM].  */
-static const short int yypgoto[] =
-{
-    -152,  -152,  -152,  -152,  -152,  -152,  -152,  -152,  -152,  -152,
-    -152,    17,  -152,   -39,  -152,   -87,   103,  -152,    97,   106,
-    -152,  -151,   164,  -152,  -152,  -152,  -152,   157,  -152,  -152,
-    -152,  -152,  -152,  -152,  -152,  -152
-};
-
-/* YYTABLE[YYPACT[STATE-NUM]].  What to do in state STATE-NUM.  If
-   positive, shift that token.  If negative, reduce the rule which
-   number is the opposite.  If zero, do what YYDEFACT says.
-   If YYTABLE_NINF, syntax error.  */
-#define YYTABLE_NINF -1
-static const unsigned char yytable[] =
-{
-     143,   197,   100,   100,     2,    41,    67,     3,   221,   222,
-     180,    68,    20,     4,    69,    23,    43,    36,   181,   106,
-     106,    84,     5,   165,   166,     6,   116,   117,   118,    38,
-     119,   214,    85,    86,    87,    88,    89,    72,    37,    90,
-      69,   120,     7,    48,    39,    50,   217,    52,    40,    54,
-      74,    56,     8,    69,    91,    92,    93,    42,     9,    47,
-      49,   101,   157,    10,   102,   102,   223,   220,    44,   225,
-     107,   161,   110,   111,    21,    94,    22,    95,    76,   112,
-     113,    69,    78,    96,    45,    69,    97,    85,    86,    87,
-      88,    89,    80,    51,    90,    69,   123,   114,    53,    61,
-      55,   215,    57,    58,    59,    60,    63,    65,    71,    91,
-      92,    93,    85,    86,    87,    88,    89,    73,    75,    90,
-      77,    79,    81,   145,   146,   158,   149,   147,   148,   154,
-      94,   150,    95,   152,    91,    92,    93,   155,   109,   159,
-     163,    97,    24,    25,    26,    27,    28,    29,    30,    31,
-      32,    33,    34,    35,   164,    94,   125,    95,   126,   170,
-     168,   172,   173,   122,   174,   175,    97,   176,   127,   128,
-     129,   130,   131,   132,   133,   134,   135,   136,   137,   138,
-     139,   186,   184,   188,   140,   178,   177,   179,   183,   185,
-     187,   144,   189,   190,   191,   192,   193,   194,   195,   196,
-     198,   199,   202,   162,   200,   201,   203,   204,   160,   205,
-     206,   207,   208,   209,   210,   211,   212,   213,   218,   226,
-     227,   216,   105,   228,   229,   230,     0,    99
-};
-
-static const short int yycheck[] =
-{
-      87,   152,     5,     5,     0,    11,    45,     3,     6,     7,
-      60,    62,     4,     9,    65,    19,    11,    45,    68,    13,
-      13,    60,    18,    41,    42,    21,    49,    50,    51,    55,
-      53,   182,    13,    14,    15,    16,    17,    62,    52,    20,
-      65,    64,    38,    26,    66,    28,   197,    30,    63,    32,
-      62,    34,    48,    65,    35,    36,    37,    63,    54,    66,
-      60,    64,    64,    59,    67,    67,    64,   218,    63,   220,
-      64,    64,    39,    40,    10,    56,    12,    58,    62,    46,
-      47,    65,    62,    64,    63,    65,    67,    13,    14,    15,
-      16,    17,    62,    66,    20,    65,    65,    64,    66,    62,
-      66,   188,    66,    63,    63,    63,    63,    63,    62,    35,
-      36,    37,    13,    14,    15,    16,    17,    62,    62,    20,
-      62,    62,    62,    60,     8,     4,    65,    62,    66,    62,
-      56,    65,    58,    65,    35,    36,    37,    65,    64,    62,
-      62,    67,    23,    24,    25,    26,    27,    28,    29,    30,
-      31,    32,    33,    34,    62,    56,    10,    58,    12,    44,
-      43,    65,    62,    64,    66,    60,    67,    66,    22,    23,
-      24,    25,    26,    27,    28,    29,    30,    31,    32,    33,
-      34,    45,    60,    69,    38,    62,    66,    62,    62,    60,
-      62,    88,    62,    62,    62,    62,    62,    62,    57,    62,
-      62,    61,    63,   106,    62,    62,    62,    62,   102,    62,
-      62,    62,    62,    62,    62,    62,    62,    62,    60,    60,
-      60,    65,    65,    62,    62,    62,    -1,    63
-};
-
-/* YYSTOS[STATE-NUM] -- The (internal number of the) accessing
-   symbol of state STATE-NUM.  */
-static const unsigned char yystos[] =
-{
-       0,    71,     0,     3,     9,    18,    21,    38,    48,    54,
-      59,    72,    73,    74,    75,    76,    77,    78,    79,    80,
-       4,    10,    12,    19,    23,    24,    25,    26,    27,    28,
-      29,    30,    31,    32,    33,    34,    45,    52,    55,    66,
-      63,    11,    63,    11,    63,    63,    81,    66,    81,    60,
-      81,    66,    81,    66,    81,    66,    81,    66,    63,    63,
-      63,    62,    83,    63,    92,    63,    97,    83,    62,    65,
-      82,    62,    62,    62,    62,    62,    62,    62,    62,    62,
-      62,    62,    99,   104,    83,    13,    14,    15,    16,    17,
-      20,    35,    36,    37,    56,    58,    64,    67,    84,    92,
-       5,    64,    67,    93,    94,    97,    13,    64,    98,    64,
-      39,    40,    46,    47,    64,   100,    49,    50,    51,    53,
-      64,   105,    64,    65,    88,    10,    12,    22,    23,    24,
-      25,    26,    27,    28,    29,    30,    31,    32,    33,    34,
-      38,    85,    86,    85,    86,    60,     8,    62,    66,    65,
-      65,    87,    65,    90,    62,    65,    89,    64,     4,    62,
-      89,    64,    88,    62,    62,    41,    42,   101,    43,   102,
-      44,   103,    65,    62,    66,    60,    66,    66,    62,    62,
-      60,    68,    91,    62,    60,    60,    45,    62,    69,    62,
-      62,    62,    62,    62,    62,    57,    62,    91,    62,    61,
-      62,    62,    63,    62,    62,    62,    62,    62,    62,    62,
-      62,    62,    62,    62,    91,    85,    65,    91,    60,    95,
-      91,     6,     7,    64,    96,    91,    60,    60,    62,    62,
-      62
-};
-
-#define yyerrok		(yyerrstatus = 0)
-#define yyclearin	(yychar = YYEMPTY)
-#define YYEMPTY		(-2)
-#define YYEOF		0
-
-#define YYACCEPT	goto yyacceptlab
-#define YYABORT		goto yyabortlab
-#define YYERROR		goto yyerrorlab
-
-
-/* Like YYERROR except do call yyerror.  This remains here temporarily
-   to ease the transition to the new meaning of YYERROR, for GCC.
-   Once GCC version 2 has supplanted version 1, this can go.  */
-
-#define YYFAIL		goto yyerrlab
-
-#define YYRECOVERING()  (!!yyerrstatus)
-
-#define YYBACKUP(Token, Value)					\
-do								\
-  if (yychar == YYEMPTY && yylen == 1)				\
-    {								\
-      yychar = (Token);						\
-      yylval = (Value);						\
-      yytoken = YYTRANSLATE (yychar);				\
-      YYPOPSTACK;						\
-      goto yybackup;						\
-    }								\
-  else								\
-    {								\
-      yyerror (YY_("syntax error: cannot back up")); \
-      YYERROR;							\
-    }								\
-while (0)
-
-
-#define YYTERROR	1
-#define YYERRCODE	256
-
-
-/* YYLLOC_DEFAULT -- Set CURRENT to span from RHS[1] to RHS[N].
-   If N is 0, then set CURRENT to the empty location which ends
-   the previous symbol: RHS[0] (always defined).  */
-
-#define YYRHSLOC(Rhs, K) ((Rhs)[K])
-#ifndef YYLLOC_DEFAULT
-# define YYLLOC_DEFAULT(Current, Rhs, N)				\
-    do									\
-      if (N)								\
-	{								\
-	  (Current).first_line   = YYRHSLOC (Rhs, 1).first_line;	\
-	  (Current).first_column = YYRHSLOC (Rhs, 1).first_column;	\
-	  (Current).last_line    = YYRHSLOC (Rhs, N).last_line;		\
-	  (Current).last_column  = YYRHSLOC (Rhs, N).last_column;	\
-	}								\
-      else								\
-	{								\
-	  (Current).first_line   = (Current).last_line   =		\
-	    YYRHSLOC (Rhs, 0).last_line;				\
-	  (Current).first_column = (Current).last_column =		\
-	    YYRHSLOC (Rhs, 0).last_column;				\
-	}								\
-    while (0)
-#endif
-
-
-/* YY_LOCATION_PRINT -- Print the location on the stream.
-   This macro was not mandated originally: define only if we know
-   we won't break user code: when these are the locations we know.  */
-
-#ifndef YY_LOCATION_PRINT
-# if YYLTYPE_IS_TRIVIAL
-#  define YY_LOCATION_PRINT(File, Loc)			\
-     fprintf (File, "%d.%d-%d.%d",			\
-              (Loc).first_line, (Loc).first_column,	\
-              (Loc).last_line,  (Loc).last_column)
-# else
-#  define YY_LOCATION_PRINT(File, Loc) ((void) 0)
-# endif
-#endif
-
-
-/* YYLEX -- calling `yylex' with the right arguments.  */
-
-#ifdef YYLEX_PARAM
-# define YYLEX yylex (YYLEX_PARAM)
-#else
-# define YYLEX yylex ()
-#endif
-
-/* Enable debugging if requested.  */
-#if YYDEBUG
-
-# ifndef YYFPRINTF
-#  include <stdio.h> /* INFRINGES ON USER NAME SPACE */
-#  define YYFPRINTF fprintf
-# endif
-
-# define YYDPRINTF(Args)			\
-do {						\
-  if (yydebug)					\
-    YYFPRINTF Args;				\
-} while (0)
-
-# define YY_SYMBOL_PRINT(Title, Type, Value, Location)		\
-do {								\
-  if (yydebug)							\
-    {								\
-      YYFPRINTF (stderr, "%s ", Title);				\
-      yysymprint (stderr,					\
-                  Type, Value);	\
-      YYFPRINTF (stderr, "\n");					\
-    }								\
-} while (0)
-
-/*------------------------------------------------------------------.
-| yy_stack_print -- Print the state stack from its BOTTOM up to its |
-| TOP (included).                                                   |
-`------------------------------------------------------------------*/
-
-#if defined (__STDC__) || defined (__cplusplus)
-static void
-yy_stack_print (short int *bottom, short int *top)
-#else
-static void
-yy_stack_print (bottom, top)
-    short int *bottom;
-    short int *top;
-#endif
-{
-  YYFPRINTF (stderr, "Stack now");
-  for (/* Nothing. */; bottom <= top; ++bottom)
-    YYFPRINTF (stderr, " %d", *bottom);
-  YYFPRINTF (stderr, "\n");
-}
-
-# define YY_STACK_PRINT(Bottom, Top)				\
-do {								\
-  if (yydebug)							\
-    yy_stack_print ((Bottom), (Top));				\
-} while (0)
-
-
-/*------------------------------------------------.
-| Report that the YYRULE is going to be reduced.  |
-`------------------------------------------------*/
-
-#if defined (__STDC__) || defined (__cplusplus)
-static void
-yy_reduce_print (int yyrule)
-#else
-static void
-yy_reduce_print (yyrule)
-    int yyrule;
-#endif
-{
-  int yyi;
-  unsigned long int yylno = yyrline[yyrule];
-  YYFPRINTF (stderr, "Reducing stack by rule %d (line %lu), ",
-             yyrule - 1, yylno);
-  /* Print the symbols being reduced, and their result.  */
-  for (yyi = yyprhs[yyrule]; 0 <= yyrhs[yyi]; yyi++)
-    YYFPRINTF (stderr, "%s ", yytname[yyrhs[yyi]]);
-  YYFPRINTF (stderr, "-> %s\n", yytname[yyr1[yyrule]]);
-}
-
-# define YY_REDUCE_PRINT(Rule)		\
-do {					\
-  if (yydebug)				\
-    yy_reduce_print (Rule);		\
-} while (0)
-
-/* Nonzero means print parse trace.  It is left uninitialized so that
-   multiple parsers can coexist.  */
-int yydebug;
-#else /* !YYDEBUG */
-# define YYDPRINTF(Args)
-# define YY_SYMBOL_PRINT(Title, Type, Value, Location)
-# define YY_STACK_PRINT(Bottom, Top)
-# define YY_REDUCE_PRINT(Rule)
-#endif /* !YYDEBUG */
-
-
-/* YYINITDEPTH -- initial size of the parser's stacks.  */
-#ifndef	YYINITDEPTH
-# define YYINITDEPTH 200
-#endif
-
-/* YYMAXDEPTH -- maximum size the stacks can grow to (effective only
-   if the built-in stack extension method is used).
-
-   Do not make this value too large; the results are undefined if
-   YYSTACK_ALLOC_MAXIMUM < YYSTACK_BYTES (YYMAXDEPTH)
-   evaluated with infinite-precision integer arithmetic.  */
-
-#ifndef YYMAXDEPTH
-# define YYMAXDEPTH 10000
-#endif
-
-
-
-#if YYERROR_VERBOSE
-
-# ifndef yystrlen
-#  if defined (__GLIBC__) && defined (_STRING_H)
-#   define yystrlen strlen
-#  else
-/* Return the length of YYSTR.  */
-static YYSIZE_T
-#   if defined (__STDC__) || defined (__cplusplus)
-yystrlen (const char *yystr)
-#   else
-yystrlen (yystr)
-     const char *yystr;
-#   endif
-{
-  const char *yys = yystr;
-
-  while (*yys++ != '\0')
-    continue;
-
-  return yys - yystr - 1;
-}
-#  endif
-# endif
-
-# ifndef yystpcpy
-#  if defined (__GLIBC__) && defined (_STRING_H) && defined (_GNU_SOURCE)
-#   define yystpcpy stpcpy
-#  else
-/* Copy YYSRC to YYDEST, returning the address of the terminating '\0' in
-   YYDEST.  */
-static char *
-#   if defined (__STDC__) || defined (__cplusplus)
-yystpcpy (char *yydest, const char *yysrc)
-#   else
-yystpcpy (yydest, yysrc)
-     char *yydest;
-     const char *yysrc;
-#   endif
-{
-  char *yyd = yydest;
-  const char *yys = yysrc;
-
-  while ((*yyd++ = *yys++) != '\0')
-    continue;
-
-  return yyd - 1;
-}
-#  endif
-# endif
-
-# ifndef yytnamerr
-/* Copy to YYRES the contents of YYSTR after stripping away unnecessary
-   quotes and backslashes, so that it's suitable for yyerror.  The
-   heuristic is that double-quoting is unnecessary unless the string
-   contains an apostrophe, a comma, or backslash (other than
-   backslash-backslash).  YYSTR is taken from yytname.  If YYRES is
-   null, do not copy; instead, return the length of what the result
-   would have been.  */
-static YYSIZE_T
-yytnamerr (char *yyres, const char *yystr)
-{
-  if (*yystr == '"')
-    {
-      size_t yyn = 0;
-      char const *yyp = yystr;
-
-      for (;;)
-	switch (*++yyp)
-	  {
-	  case '\'':
-	  case ',':
-	    goto do_not_strip_quotes;
-
-	  case '\\':
-	    if (*++yyp != '\\')
-	      goto do_not_strip_quotes;
-	    /* Fall through.  */
-	  default:
-	    if (yyres)
-	      yyres[yyn] = *yyp;
-	    yyn++;
-	    break;
-
-	  case '"':
-	    if (yyres)
-	      yyres[yyn] = '\0';
-	    return yyn;
-	  }
-    do_not_strip_quotes: ;
-    }
-
-  if (! yyres)
-    return yystrlen (yystr);
-
-  return yystpcpy (yyres, yystr) - yyres;
-}
-# endif
-
-#endif /* YYERROR_VERBOSE */
-
-
-
-#if YYDEBUG
-/*--------------------------------.
-| Print this symbol on YYOUTPUT.  |
-`--------------------------------*/
-
-#if defined (__STDC__) || defined (__cplusplus)
-static void
-yysymprint (FILE *yyoutput, int yytype, YYSTYPE *yyvaluep)
-#else
-static void
-yysymprint (yyoutput, yytype, yyvaluep)
-    FILE *yyoutput;
-    int yytype;
-    YYSTYPE *yyvaluep;
-#endif
-{
-  /* Pacify ``unused variable'' warnings.  */
-  (void) yyvaluep;
-
-  if (yytype < YYNTOKENS)
-    YYFPRINTF (yyoutput, "token %s (", yytname[yytype]);
-  else
-    YYFPRINTF (yyoutput, "nterm %s (", yytname[yytype]);
-
-
-# ifdef YYPRINT
-  if (yytype < YYNTOKENS)
-    YYPRINT (yyoutput, yytoknum[yytype], *yyvaluep);
-# endif
-  switch (yytype)
-    {
-      default:
-        break;
-    }
-  YYFPRINTF (yyoutput, ")");
-}
-
-#endif /* ! YYDEBUG */
-/*-----------------------------------------------.
-| Release the memory associated to this symbol.  |
-`-----------------------------------------------*/
-
-#if defined (__STDC__) || defined (__cplusplus)
-static void
-yydestruct (const char *yymsg, int yytype, YYSTYPE *yyvaluep)
-#else
-static void
-yydestruct (yymsg, yytype, yyvaluep)
-    const char *yymsg;
-    int yytype;
-    YYSTYPE *yyvaluep;
-#endif
-{
-  /* Pacify ``unused variable'' warnings.  */
-  (void) yyvaluep;
-
-  if (!yymsg)
-    yymsg = "Deleting";
-  YY_SYMBOL_PRINT (yymsg, yytype, yyvaluep, yylocationp);
-
-  switch (yytype)
-    {
-
-      default:
-        break;
-    }
-}
-
-
-/* Prevent warnings from -Wmissing-prototypes.  */
-
-#ifdef YYPARSE_PARAM
-# if defined (__STDC__) || defined (__cplusplus)
-int yyparse (void *YYPARSE_PARAM);
-# else
-int yyparse ();
-# endif
-#else /* ! YYPARSE_PARAM */
-#if defined (__STDC__) || defined (__cplusplus)
-int yyparse (void);
-#else
-int yyparse ();
-#endif
-#endif /* ! YYPARSE_PARAM */
-
-
-
-/* The look-ahead symbol.  */
-int yychar;
-
-/* The semantic value of the look-ahead symbol.  */
-YYSTYPE yylval;
-
-/* Number of syntax errors so far.  */
-int yynerrs;
-
-
-
-/*----------.
-| yyparse.  |
-`----------*/
-
-#ifdef YYPARSE_PARAM
-# if defined (__STDC__) || defined (__cplusplus)
-int yyparse (void *YYPARSE_PARAM)
-# else
-int yyparse (YYPARSE_PARAM)
-  void *YYPARSE_PARAM;
-# endif
-#else /* ! YYPARSE_PARAM */
-#if defined (__STDC__) || defined (__cplusplus)
-int
-yyparse (void)
-#else
-int
-yyparse ()
-    ;
-#endif
-#endif
-{
-  
-  int yystate;
-  int yyn;
-  int yyresult;
-  /* Number of tokens to shift before error messages enabled.  */
-  int yyerrstatus;
-  /* Look-ahead token as an internal (translated) token number.  */
-  int yytoken = 0;
-
-  /* Three stacks and their tools:
-     `yyss': related to states,
-     `yyvs': related to semantic values,
-     `yyls': related to locations.
-
-     Refer to the stacks thru separate pointers, to allow yyoverflow
-     to reallocate them elsewhere.  */
-
-  /* The state stack.  */
-  short int yyssa[YYINITDEPTH];
-  short int *yyss = yyssa;
-  short int *yyssp;
-
-  /* The semantic value stack.  */
-  YYSTYPE yyvsa[YYINITDEPTH];
-  YYSTYPE *yyvs = yyvsa;
-  YYSTYPE *yyvsp;
-
-
-
-#define YYPOPSTACK   (yyvsp--, yyssp--)
-
-  YYSIZE_T yystacksize = YYINITDEPTH;
-
-  /* The variables used to return semantic value and location from the
-     action routines.  */
-  YYSTYPE yyval;
-
-
-  /* When reducing, the number of symbols on the RHS of the reduced
-     rule.  */
-  int yylen;
-
-  YYDPRINTF ((stderr, "Starting parse\n"));
-
-  yystate = 0;
-  yyerrstatus = 0;
-  yynerrs = 0;
-  yychar = YYEMPTY;		/* Cause a token to be read.  */
-
-  /* Initialize stack pointers.
-     Waste one element of value and location stack
-     so that they stay on the same level as the state stack.
-     The wasted elements are never initialized.  */
-
-  yyssp = yyss;
-  yyvsp = yyvs;
-
-  goto yysetstate;
-
-/*------------------------------------------------------------.
-| yynewstate -- Push a new state, which is found in yystate.  |
-`------------------------------------------------------------*/
- yynewstate:
-  /* In all cases, when you get here, the value and location stacks
-     have just been pushed. so pushing a state here evens the stacks.
-     */
-  yyssp++;
-
- yysetstate:
-  *yyssp = yystate;
-
-  if (yyss + yystacksize - 1 <= yyssp)
-    {
-      /* Get the current used size of the three stacks, in elements.  */
-      YYSIZE_T yysize = yyssp - yyss + 1;
-
-#ifdef yyoverflow
-      {
-	/* Give user a chance to reallocate the stack. Use copies of
-	   these so that the &'s don't force the real ones into
-	   memory.  */
-	YYSTYPE *yyvs1 = yyvs;
-	short int *yyss1 = yyss;
-
-
-	/* Each stack pointer address is followed by the size of the
-	   data in use in that stack, in bytes.  This used to be a
-	   conditional around just the two extra args, but that might
-	   be undefined if yyoverflow is a macro.  */
-	yyoverflow (YY_("memory exhausted"),
-		    &yyss1, yysize * sizeof (*yyssp),
-		    &yyvs1, yysize * sizeof (*yyvsp),
-
-		    &yystacksize);
-
-	yyss = yyss1;
-	yyvs = yyvs1;
-      }
-#else /* no yyoverflow */
-# ifndef YYSTACK_RELOCATE
-      goto yyexhaustedlab;
-# else
-      /* Extend the stack our own way.  */
-      if (YYMAXDEPTH <= yystacksize)
-	goto yyexhaustedlab;
-      yystacksize *= 2;
-      if (YYMAXDEPTH < yystacksize)
-	yystacksize = YYMAXDEPTH;
-
-      {
-	short int *yyss1 = yyss;
-	union yyalloc *yyptr =
-	  (union yyalloc *) YYSTACK_ALLOC (YYSTACK_BYTES (yystacksize));
-	if (! yyptr)
-	  goto yyexhaustedlab;
-	YYSTACK_RELOCATE (yyss);
-	YYSTACK_RELOCATE (yyvs);
-
-#  undef YYSTACK_RELOCATE
-	if (yyss1 != yyssa)
-	  YYSTACK_FREE (yyss1);
-      }
-# endif
-#endif /* no yyoverflow */
-
-      yyssp = yyss + yysize - 1;
-      yyvsp = yyvs + yysize - 1;
-
-
-      YYDPRINTF ((stderr, "Stack size increased to %lu\n",
-		  (unsigned long int) yystacksize));
-
-      if (yyss + yystacksize - 1 <= yyssp)
-	YYABORT;
-    }
-
-  YYDPRINTF ((stderr, "Entering state %d\n", yystate));
-
-  goto yybackup;
-
-/*-----------.
-| yybackup.  |
-`-----------*/
-yybackup:
-
-/* Do appropriate processing given the current state.  */
-/* Read a look-ahead token if we need one and don't already have one.  */
-/* yyresume: */
-
-  /* First try to decide what to do without reference to look-ahead token.  */
-
-  yyn = yypact[yystate];
-  if (yyn == YYPACT_NINF)
-    goto yydefault;
-
-  /* Not known => get a look-ahead token if don't already have one.  */
-
-  /* YYCHAR is either YYEMPTY or YYEOF or a valid look-ahead symbol.  */
-  if (yychar == YYEMPTY)
-    {
-      YYDPRINTF ((stderr, "Reading a token: "));
-      yychar = YYLEX;
-    }
-
-  if (yychar <= YYEOF)
-    {
-      yychar = yytoken = YYEOF;
-      YYDPRINTF ((stderr, "Now at end of input.\n"));
-    }
-  else
-    {
-      yytoken = YYTRANSLATE (yychar);
-      YY_SYMBOL_PRINT ("Next token is", yytoken, &yylval, &yylloc);
-    }
-
-  /* If the proper action on seeing token YYTOKEN is to reduce or to
-     detect an error, take that action.  */
-  yyn += yytoken;
-  if (yyn < 0 || YYLAST < yyn || yycheck[yyn] != yytoken)
-    goto yydefault;
-  yyn = yytable[yyn];
-  if (yyn <= 0)
-    {
-      if (yyn == 0 || yyn == YYTABLE_NINF)
-	goto yyerrlab;
-      yyn = -yyn;
-      goto yyreduce;
-    }
-
-  if (yyn == YYFINAL)
-    YYACCEPT;
-
-  /* Shift the look-ahead token.  */
-  YY_SYMBOL_PRINT ("Shifting", yytoken, &yylval, &yylloc);
-
-  /* Discard the token being shifted unless it is eof.  */
-  if (yychar != YYEOF)
-    yychar = YYEMPTY;
-
-  *++yyvsp = yylval;
-
-
-  /* Count tokens shifted since error; after three, turn off error
-     status.  */
-  if (yyerrstatus)
-    yyerrstatus--;
-
-  yystate = yyn;
-  goto yynewstate;
-
-
-/*-----------------------------------------------------------.
-| yydefault -- do the default action for the current state.  |
-`-----------------------------------------------------------*/
-yydefault:
-  yyn = yydefact[yystate];
-  if (yyn == 0)
-    goto yyerrlab;
-  goto yyreduce;
-
-
-/*-----------------------------.
-| yyreduce -- Do a reduction.  |
-`-----------------------------*/
-yyreduce:
-  /* yyn is the number of a rule to reduce with.  */
-  yylen = yyr2[yyn];
-
-  /* If YYLEN is nonzero, implement the default value of the action:
-     `$$ = $1'.
-
-     Otherwise, the following line sets YYVAL to garbage.
-     This behavior is undocumented and Bison
-     users should not rely upon it.  Assigning to YYVAL
-     unconditionally makes the parser a bit smaller, and it avoids a
-     GCC warning that YYVAL may be used uninitialized.  */
-  yyval = yyvsp[1-yylen];
-
-
-  YY_REDUCE_PRINT (yyn);
-  switch (yyn)
-    {
-        case 12:
-#line 167 "cfparse.y"
-    {
-		struct cf_namelist *ifl;
-
-		MAKE_NAMELIST(ifl, (yyvsp[-4].str), (yyvsp[-2].list));
-
-		if (add_namelist(ifl, &iflist_head))
-			return (-1);
-	}
-    break;
-
-  case 13:
-#line 179 "cfparse.y"
-    {
-		struct cf_namelist *host;
-
-		MAKE_NAMELIST(host, (yyvsp[-4].str), (yyvsp[-2].list));
-
-		if (add_namelist(host, &hostlist_head))
-			return (-1);
-	}
-    break;
-
-  case 14:
-#line 191 "cfparse.y"
-    {
-			if (cf_dns_list == NULL)
-				cf_dns_list = (yyvsp[-1].list);
-			else {
-				cf_dns_list->tail->next = (yyvsp[-1].list);
-				cf_dns_list->tail = (yyvsp[-1].list)->tail;
-			}
-		}
-    break;
-
-  case 15:
-#line 200 "cfparse.y"
-    {
-			struct cf_list *l;
-
-			MAKE_CFLIST(l, CFLISTENT_GENERIC, (yyvsp[-1].str), NULL);
-
-			if (cf_dns_name_list == NULL) {
-				cf_dns_name_list = l;
-				cf_dns_name_list->tail = l;
-				cf_dns_name_list->next = NULL;
-			} else {
-				cf_dns_name_list->tail->next = l;
-				cf_dns_name_list->tail = l->tail;
-			}
-		}
-    break;
-
-  case 16:
-#line 215 "cfparse.y"
-    {
-			if (cf_ntp_list == NULL)
-				cf_ntp_list = (yyvsp[-1].list);
-			else {
-				cf_ntp_list->tail->next = (yyvsp[-1].list);
-				cf_ntp_list->tail = (yyvsp[-1].list)->tail;
-			}
-		}
-    break;
-
-  case 17:
-#line 224 "cfparse.y"
-    {
-			if (cf_sip_list == NULL)
-				cf_sip_list = (yyvsp[-1].list);
-			else {
-				cf_sip_list->tail->next = (yyvsp[-1].list);
-				cf_sip_list->tail = (yyvsp[-1].list)->tail;
-			}
-		}
-    break;
-
-  case 18:
-#line 233 "cfparse.y"
-    {
-			struct cf_list *l;
-
-			MAKE_CFLIST(l, CFLISTENT_GENERIC, (yyvsp[-1].str), NULL);
-
-			if (cf_sip_name_list == NULL) {
-				cf_sip_name_list = l;
-				cf_sip_name_list->tail = l;
-				cf_sip_name_list->next = NULL;
-			} else {
-				cf_sip_name_list->tail->next = l;
-				cf_sip_name_list->tail = l->tail;
-			}
-		}
-    break;
-
-  case 19:
-#line 248 "cfparse.y"
-    {
-			if (cf_nis_list == NULL)
-				cf_nis_list = (yyvsp[-1].list);
-			else {
-				cf_nis_list->tail->next = (yyvsp[-1].list);
-				cf_nis_list->tail = (yyvsp[-1].list)->tail;
-			}
-		}
-    break;
-
-  case 20:
-#line 257 "cfparse.y"
-    {
-			struct cf_list *l;
-
-			MAKE_CFLIST(l, CFLISTENT_GENERIC, (yyvsp[-1].str), NULL);
-
-			if (cf_nis_name_list == NULL) {
-				cf_nis_name_list = l;
-				cf_nis_name_list->tail = l;
-				cf_nis_name_list->next = NULL;
-			} else {
-				cf_nis_name_list->tail->next = l;
-				cf_nis_name_list->tail = l->tail;
-			}
-		}
-    break;
-
-  case 21:
-#line 272 "cfparse.y"
-    {
-			if (cf_nisp_list == NULL)
-				cf_nisp_list = (yyvsp[-1].list);
-			else {
-				cf_nisp_list->tail->next = (yyvsp[-1].list);
-				cf_nisp_list->tail = (yyvsp[-1].list)->tail;
-			}
-		}
-    break;
-
-  case 22:
-#line 281 "cfparse.y"
-    {
-			struct cf_list *l;
-
-			MAKE_CFLIST(l, CFLISTENT_GENERIC, (yyvsp[-1].str), NULL);
-
-			if (cf_nisp_name_list == NULL) {
-				cf_nisp_name_list = l;
-				cf_nisp_name_list->tail = l;
-				cf_nisp_name_list->next = NULL;
-			} else {
-				cf_nisp_name_list->tail->next = l;
-				cf_nisp_name_list->tail = l->tail;
-			}
-		}
-    break;
-
-  case 23:
-#line 296 "cfparse.y"
-    {
-			if (cf_bcmcs_list == NULL)
-				cf_bcmcs_list = (yyvsp[-1].list);
-			else {
-				cf_bcmcs_list->tail->next = (yyvsp[-1].list);
-				cf_bcmcs_list->tail = (yyvsp[-1].list)->tail;
-			}
-		}
-    break;
-
-  case 24:
-#line 305 "cfparse.y"
-    {
-			struct cf_list *l;
-
-			MAKE_CFLIST(l, CFLISTENT_GENERIC, (yyvsp[-1].str), NULL);
-
-			if (cf_bcmcs_name_list == NULL) {
-				cf_bcmcs_name_list = l;
-				cf_bcmcs_name_list->tail = l;
-				cf_bcmcs_name_list->next = NULL;
-			} else {
-				cf_bcmcs_name_list->tail->next = l;
-				cf_bcmcs_name_list->tail = l->tail;
-			}
-		}
-    break;
-
-  case 25:
-#line 320 "cfparse.y"
-    {
-			if (cf_refreshtime == -1) {
-				cf_refreshtime = (yyvsp[-1].num);
-				if (cf_refreshtime < -1 ||
-				    cf_refreshtime > 0xffffffff) {
-					/*
-					 * refresh time should not be negative
-					 * according to the lex definition,
-					 * but check it for safety.
-					 */
-					yyerror("refresh time is out of range");
-				}
-				if (cf_refreshtime < DHCP6_IRT_MINIMUM) {
-					/*
-					 * the value MUST NOT be smaller than
-					 * IRT_MINIMUM.
-					 */
-					yyerror("refresh time is too small "
-					    "(must not be smaller than %d)",
-					    DHCP6_IRT_MINIMUM);
-				}
-			} else {
-				yywarn("multiple refresh times (ignored)");
-			}
-		}
-    break;
-
-  case 26:
-#line 349 "cfparse.y"
-    {
-			struct cf_namelist *iapd;
-
-			MAKE_NAMELIST(iapd, (yyvsp[-4].str), (yyvsp[-2].list));
-
-			if (add_namelist(iapd, &iapdlist_head))
-				return (-1);
-		}
-    break;
-
-  case 27:
-#line 358 "cfparse.y"
-    {
-			struct cf_namelist *iapd;
-			char *zero;
-
-			if ((zero = strdup("0")) == NULL) {
-				yywarn("can't allocate memory");
-				return (-1);
-			}
-			MAKE_NAMELIST(iapd, zero, (yyvsp[-2].list));
-
-			if (add_namelist(iapd, &iapdlist_head))
-				return (-1);
-		}
-    break;
-
-  case 28:
-#line 372 "cfparse.y"
-    {
-			struct cf_namelist *iana;
-
-			MAKE_NAMELIST(iana, (yyvsp[-4].str), (yyvsp[-2].list));
-
-			if (add_namelist(iana, &ianalist_head))
-				return (-1);
-		}
-    break;
-
-  case 29:
-#line 381 "cfparse.y"
-    {
-			struct cf_namelist *iana;
-			char *zero;
-
-			if ((zero = strdup("0")) == NULL) {
-				yywarn("can't allocate memory");
-				return (-1);
-			}
-			MAKE_NAMELIST(iana, zero, (yyvsp[-2].list));
-
-			if (add_namelist(iana, &ianalist_head))
-				return (-1);
-		}
-    break;
-
-  case 30:
-#line 398 "cfparse.y"
-    {
-		struct cf_namelist *authinfo;
-
-		MAKE_NAMELIST(authinfo, (yyvsp[-4].str), (yyvsp[-2].list));
-
-		if (add_namelist(authinfo, &authinfolist_head))
-			return (-1);
-	}
-    break;
-
-  case 31:
-#line 410 "cfparse.y"
-    {
-		struct cf_namelist *key;
-
-		MAKE_NAMELIST(key, (yyvsp[-4].str), (yyvsp[-2].list));
-
-		if (add_namelist(key, &keylist_head))
-			return (-1);
-	}
-    break;
-
-  case 32:
-#line 422 "cfparse.y"
-    {
-		if (cfswitch_buffer((yyvsp[-1].str))) {
-			free((yyvsp[-1].str));
-			return (-1);
-		}
-		free((yyvsp[-1].str));
-	}
-    break;
-
-  case 33:
-#line 433 "cfparse.y"
-    {
-		struct cf_namelist *pool;
-
-		MAKE_NAMELIST(pool, (yyvsp[-4].str), (yyvsp[-2].list));
-
-		if (add_namelist(pool, &addrpoollist_head))
-			return (-1);
-	}
-    break;
-
-  case 34:
-#line 444 "cfparse.y"
-    { (yyval.list) = NULL; }
-    break;
-
-  case 35:
-#line 446 "cfparse.y"
-    {
-			struct cf_list *head;
-
-			if ((head = (yyvsp[-1].list)) == NULL) {
-				(yyvsp[0].list)->next = NULL;
-				(yyvsp[0].list)->tail = (yyvsp[0].list);
-				head = (yyvsp[0].list);
-			} else {
-				head->tail->next = (yyvsp[0].list);
-				head->tail = (yyvsp[0].list)->tail;
-			}
-
-			(yyval.list) = head;
-		}
-    break;
-
-  case 36:
-#line 464 "cfparse.y"
-    {
-		struct cf_list *l;
-		struct in6_addr a0, *a;
-
-		if (inet_pton(AF_INET6, (yyvsp[0].str), &a0) != 1) {
-			yywarn("invalid IPv6 address: %s", (yyvsp[0].str));
-			free((yyvsp[0].str));
-			return (-1);
-		}
-		if ((a = malloc(sizeof(*a))) == NULL) {
-			yywarn("can't allocate memory");
-			return (-1);
-		}
-		*a = a0;
-
-		MAKE_CFLIST(l, CFLISTENT_GENERIC, a, NULL);
-
-		(yyval.list) = l;
-	}
-    break;
-
-  case 37:
-#line 486 "cfparse.y"
-    { (yyval.list) = NULL; }
-    break;
-
-  case 38:
-#line 488 "cfparse.y"
-    {
-			struct cf_list *head;
-
-			if ((head = (yyvsp[-1].list)) == NULL) {
-				(yyvsp[0].list)->next = NULL;
-				(yyvsp[0].list)->tail = (yyvsp[0].list);
-				head = (yyvsp[0].list);
-			} else {
-				head->tail->next = (yyvsp[0].list);
-				head->tail = (yyvsp[0].list)->tail;
-			}
-
-			(yyval.list) = head;
-		}
-    break;
-
-  case 39:
-#line 506 "cfparse.y"
-    {
-			struct cf_list *l;
-
-			MAKE_CFLIST(l, DECL_SEND, NULL, (yyvsp[-1].list));
-
-			(yyval.list) = l;
-		}
-    break;
-
-  case 40:
-#line 514 "cfparse.y"
-    {
-			struct cf_list *l;
-
-			MAKE_CFLIST(l, DECL_REQUEST, NULL, (yyvsp[-1].list));
-
-			(yyval.list) = l;
-		}
-    break;
-
-  case 41:
-#line 522 "cfparse.y"
-    {
-			struct cf_list *l;
-
-			MAKE_CFLIST(l, DECL_INFO_ONLY, NULL, NULL);
-			/* no value */
-			(yyval.list) = l;
-		}
-    break;
-
-  case 42:
-#line 530 "cfparse.y"
-    {
-			struct cf_list *l;
-
-			MAKE_CFLIST(l, DECL_ALLOW, NULL, (yyvsp[-1].list));
-
-			(yyval.list) = l;
-		}
-    break;
-
-  case 43:
-#line 538 "cfparse.y"
-    {
-			struct cf_list *l;
-
-			MAKE_CFLIST(l, DECL_DUID, (yyvsp[-1].str), NULL);
-
-			(yyval.list) = l;
-		}
-    break;
-
-  case 44:
-#line 546 "cfparse.y"
-    {
-			struct cf_list *l;
-
-			MAKE_CFLIST(l, DECL_ADDRESS, (yyvsp[-1].prefix),NULL);
-
-			(yyval.list) = l;
-		}
-    break;
-
-  case 45:
-#line 554 "cfparse.y"
-    {
-			struct cf_list *l;
-
-			MAKE_CFLIST(l, DECL_PREFIX, (yyvsp[-1].prefix), NULL);
-
-			(yyval.list) = l;
-		}
-    break;
-
-  case 46:
-#line 562 "cfparse.y"
-    {
-			struct cf_list *l;
-
-			MAKE_CFLIST(l, DECL_PREFERENCE, NULL, NULL);
-			l->num = (yyvsp[-1].num);
-
-			(yyval.list) = l;
-		}
-    break;
-
-  case 47:
-#line 571 "cfparse.y"
-    {
-			struct cf_list *l;
-
-			MAKE_CFLIST(l, DECL_SCRIPT, (yyvsp[-1].str), NULL);
-
-			(yyval.list) = l;
-		}
-    break;
-
-  case 48:
-#line 579 "cfparse.y"
-    {
-			struct cf_list *l;
-
-			MAKE_CFLIST(l, DECL_DELAYEDKEY, (yyvsp[-1].str), NULL);
-
-			(yyval.list) = l;
-		}
-    break;
-
-  case 49:
-#line 587 "cfparse.y"
-    {
-			struct cf_list *l;
-
-			MAKE_CFLIST(l, DECL_RANGE, (yyvsp[-1].range), NULL);
-
-			(yyval.list) = l;
-		}
-    break;
-
-  case 50:
-#line 595 "cfparse.y"
-    {
-			struct cf_list *l;
-
-			MAKE_CFLIST(l, DECL_ADDRESSPOOL, (yyvsp[-1].pool), NULL);
-
-			(yyval.list) = l;
-		}
-    break;
-
-  case 51:
-#line 606 "cfparse.y"
-    {
-			(yyval.list) = (yyvsp[0].list);
-		}
-    break;
-
-  case 52:
-#line 610 "cfparse.y"
-    {
-			(yyvsp[-2].list)->next = (yyvsp[0].list);
-			(yyvsp[-2].list)->tail = (yyvsp[0].list)->tail;
-
-			(yyval.list) = (yyvsp[-2].list);
-		}
-    break;
-
-  case 53:
-#line 620 "cfparse.y"
-    {
-			struct cf_list *l;
-
-			MAKE_CFLIST(l, DHCPOPT_RAPID_COMMIT, NULL, NULL);
-			/* no value */
-			(yyval.list) = l;
-		}
-    break;
-
-  case 54:
-#line 628 "cfparse.y"
-    {
-			struct cf_list *l;
-
-			MAKE_CFLIST(l, DHCPOPT_AUTHINFO, NULL, NULL);
-			l->ptr = (yyvsp[0].str);
-			(yyval.list) = l;
-		}
-    break;
-
-  case 55:
-#line 636 "cfparse.y"
-    {
-			struct cf_list *l;
-
-			MAKE_CFLIST(l, DHCPOPT_IA_PD, NULL, NULL);
-			l->num = (yyvsp[0].num);
-			(yyval.list) = l;
-		}
-    break;
-
-  case 56:
-#line 644 "cfparse.y"
-    {
-			struct cf_list *l;
-
-			MAKE_CFLIST(l, DHCPOPT_IA_NA, NULL, NULL);
-			l->num = (yyvsp[0].num);
-			(yyval.list) = l;
-		}
-    break;
-
-  case 57:
-#line 652 "cfparse.y"
-    {
-			struct cf_list *l;
-
-			MAKE_CFLIST(l, DHCPOPT_SIP, NULL, NULL);
-			/* currently no value */
-			(yyval.list) = l;
-		}
-    break;
-
-  case 58:
-#line 660 "cfparse.y"
-    {
-			struct cf_list *l;
-
-			MAKE_CFLIST(l, DHCPOPT_SIPNAME, NULL, NULL);
-			/* currently no value */
-			(yyval.list) = l;
-		}
-    break;
-
-  case 59:
-#line 668 "cfparse.y"
-    {
-			struct cf_list *l;
-
-			MAKE_CFLIST(l, DHCPOPT_DNS, NULL, NULL);
-			/* currently no value */
-			(yyval.list) = l;
-		}
-    break;
-
-  case 60:
-#line 676 "cfparse.y"
-    {
-			struct cf_list *l;
-
-			MAKE_CFLIST(l, DHCPOPT_DNSNAME, NULL, NULL);
-			/* currently no value */
-			(yyval.list) = l;
-		}
-    break;
-
-  case 61:
-#line 684 "cfparse.y"
-    {
-			struct cf_list *l;
-
-			MAKE_CFLIST(l, DHCPOPT_NTP, NULL, NULL);
-			/* currently no value */
-			(yyval.list) = l;
-		}
-    break;
-
-  case 62:
-#line 692 "cfparse.y"
-    {
-			struct cf_list *l;
-
-			MAKE_CFLIST(l, DHCPOPT_REFRESHTIME, NULL, NULL);
-			/* currently no value */
-			(yyval.list) = l;
-		}
-    break;
-
-  case 63:
-#line 700 "cfparse.y"
-    {
-			struct cf_list *l;
-
-			MAKE_CFLIST(l, DHCPOPT_NIS, NULL, NULL);
-			/* currently no value */
-			(yyval.list) = l;
-		}
-    break;
-
-  case 64:
-#line 708 "cfparse.y"
-    {
-			struct cf_list *l;
-
-			MAKE_CFLIST(l, DHCPOPT_NISNAME, NULL, NULL);
-			/* currently no value */
-			(yyval.list) = l;
-		}
-    break;
-
-  case 65:
-#line 716 "cfparse.y"
-    {
-			struct cf_list *l;
-
-			MAKE_CFLIST(l, DHCPOPT_NISP, NULL, NULL);
-			/* currently no value */
-			(yyval.list) = l;
-		}
-    break;
-
-  case 66:
-#line 724 "cfparse.y"
-    {
-			struct cf_list *l;
-
-			MAKE_CFLIST(l, DHCPOPT_NISPNAME, NULL, NULL);
-			/* currently no value */
-			(yyval.list) = l;
-		}
-    break;
-
-  case 67:
-#line 732 "cfparse.y"
-    {
-			struct cf_list *l;
-
-			MAKE_CFLIST(l, DHCPOPT_BCMCS, NULL, NULL);
-			/* currently no value */
-			(yyval.list) = l;
-		}
-    break;
-
-  case 68:
-#line 740 "cfparse.y"
-    {
-			struct cf_list *l;
-
-			MAKE_CFLIST(l, DHCPOPT_BCMCSNAME, NULL, NULL);
-			/* currently no value */
-			(yyval.list) = l;
-		}
-    break;
-
-  case 69:
-#line 751 "cfparse.y"
-    {
-			struct dhcp6_range range0, *range;		
-
-			memset(&range0, 0, sizeof(range0));
-			if (inet_pton(AF_INET6, (yyvsp[-2].str), &range0.min) != 1) {
-				yywarn("invalid IPv6 address: %s", (yyvsp[-2].str));
-				free((yyvsp[-2].str));
-				free((yyvsp[0].str));
-				return (-1);
-			}
-			if (inet_pton(AF_INET6, (yyvsp[0].str), &range0.max) != 1) {
-				yywarn("invalid IPv6 address: %s", (yyvsp[0].str));
-				free((yyvsp[-2].str));
-				free((yyvsp[0].str));
-				return (-1);
-			}
-			free((yyvsp[-2].str));
-			free((yyvsp[0].str));
-
-			if ((range = malloc(sizeof(*range))) == NULL) {
-				yywarn("can't allocate memory");
-				return (-1);
-			}
-			*range = range0;
-
-			(yyval.range) = range;
-		}
-    break;
-
-  case 70:
-#line 782 "cfparse.y"
-    {
-			struct dhcp6_prefix pconf0, *pconf;		
-
-			memset(&pconf0, 0, sizeof(pconf0));
-			if (inet_pton(AF_INET6, (yyvsp[-1].str), &pconf0.addr) != 1) {
-				yywarn("invalid IPv6 address: %s", (yyvsp[-1].str));
-				free((yyvsp[-1].str));
-				return (-1);
-			}
-			free((yyvsp[-1].str));
-			/* validate other parameters later */
-			pconf0.plen = 128; /* XXX this field is ignored */
-			if ((yyvsp[0].num) < 0)
-				pconf0.pltime = DHCP6_DURATION_INFINITE;
-			else
-				pconf0.pltime = (u_int32_t)(yyvsp[0].num);
-			pconf0.vltime = pconf0.pltime;
-
-			if ((pconf = malloc(sizeof(*pconf))) == NULL) {
-				yywarn("can't allocate memory");
-				return (-1);
-			}
-			*pconf = pconf0;
-
-			(yyval.prefix) = pconf;
-		}
-    break;
-
-  case 71:
-#line 809 "cfparse.y"
-    {
-			struct dhcp6_prefix pconf0, *pconf;		
-
-			memset(&pconf0, 0, sizeof(pconf0));
-			if (inet_pton(AF_INET6, (yyvsp[-2].str), &pconf0.addr) != 1) {
-				yywarn("invalid IPv6 address: %s", (yyvsp[-2].str));
-				free((yyvsp[-2].str));
-				return (-1);
-			}
-			free((yyvsp[-2].str));
-			/* validate other parameters later */
-			pconf0.plen = 128; /* XXX */
-			if ((yyvsp[-1].num) < 0)
-				pconf0.pltime = DHCP6_DURATION_INFINITE;
-			else
-				pconf0.pltime = (u_int32_t)(yyvsp[-1].num);
-			if ((yyvsp[0].num) < 0)
-				pconf0.vltime = DHCP6_DURATION_INFINITE;
-			else
-				pconf0.vltime = (u_int32_t)(yyvsp[0].num);
-
-			if ((pconf = malloc(sizeof(*pconf))) == NULL) {
-				yywarn("can't allocate memory");
-				return (-1);
-			}
-			*pconf = pconf0;
-
-			(yyval.prefix) = pconf;
-		}
-    break;
-
-  case 72:
-#line 842 "cfparse.y"
-    {
-			struct dhcp6_prefix pconf0, *pconf;		
-
-			memset(&pconf0, 0, sizeof(pconf0));
-			if (inet_pton(AF_INET6, (yyvsp[-3].str), &pconf0.addr) != 1) {
-				yywarn("invalid IPv6 address: %s", (yyvsp[-3].str));
-				free((yyvsp[-3].str));
-				return (-1);
-			}
-			free((yyvsp[-3].str));
-			/* validate other parameters later */
-			pconf0.plen = (yyvsp[-1].num);
-			if ((yyvsp[0].num) < 0)
-				pconf0.pltime = DHCP6_DURATION_INFINITE;
-			else
-				pconf0.pltime = (u_int32_t)(yyvsp[0].num);
-			pconf0.vltime = pconf0.pltime;
-
-			if ((pconf = malloc(sizeof(*pconf))) == NULL) {
-				yywarn("can't allocate memory");
-				return (-1);
-			}
-			*pconf = pconf0;
-
-			(yyval.prefix) = pconf;
-		}
-    break;
-
-  case 73:
-#line 869 "cfparse.y"
-    {
-			struct dhcp6_prefix pconf0, *pconf;		
-
-			memset(&pconf0, 0, sizeof(pconf0));
-			if (inet_pton(AF_INET6, (yyvsp[-4].str), &pconf0.addr) != 1) {
-				yywarn("invalid IPv6 address: %s", (yyvsp[-4].str));
-				free((yyvsp[-4].str));
-				return (-1);
-			}
-			free((yyvsp[-4].str));
-			/* validate other parameters later */
-			pconf0.plen = (yyvsp[-2].num);
-			if ((yyvsp[-1].num) < 0)
-				pconf0.pltime = DHCP6_DURATION_INFINITE;
-			else
-				pconf0.pltime = (u_int32_t)(yyvsp[-1].num);
-			if ((yyvsp[0].num) < 0)
-				pconf0.vltime = DHCP6_DURATION_INFINITE;
-			else
-				pconf0.vltime = (u_int32_t)(yyvsp[0].num);
-
-			if ((pconf = malloc(sizeof(*pconf))) == NULL) {
-				yywarn("can't allocate memory");
-				return (-1);
-			}
-			*pconf = pconf0;
-
-			(yyval.prefix) = pconf;
-		}
-    break;
-
-  case 74:
-#line 902 "cfparse.y"
-    {
-			struct dhcp6_poolspec* pool;		
-
-			if ((pool = malloc(sizeof(*pool))) == NULL) {
-				yywarn("can't allocate memory");
-				free((yyvsp[-1].str));
-				return (-1);
-			}
-			if ((pool->name = strdup((yyvsp[-1].str))) == NULL) {
-				yywarn("can't allocate memory");
-				free((yyvsp[-1].str));
-				return (-1);
-			}
-			free((yyvsp[-1].str));
-
-			/* validate other parameters later */
-			if ((yyvsp[0].num) < 0)
-				pool->pltime = DHCP6_DURATION_INFINITE;
-			else
-				pool->pltime = (u_int32_t)(yyvsp[0].num);
-			pool->vltime = pool->pltime;
-
-			(yyval.pool) = pool;
-		}
-    break;
-
-  case 75:
-#line 927 "cfparse.y"
-    {
-			struct dhcp6_poolspec* pool;		
-
-			if ((pool = malloc(sizeof(*pool))) == NULL) {
-				yywarn("can't allocate memory");
-				free((yyvsp[-2].str));
-				return (-1);
-			}
-			if ((pool->name = strdup((yyvsp[-2].str))) == NULL) {
-				yywarn("can't allocate memory");
-				free((yyvsp[-2].str));
-				return (-1);
-			}
-			free((yyvsp[-2].str));
-
-			/* validate other parameters later */
-			if ((yyvsp[-1].num) < 0)
-				pool->pltime = DHCP6_DURATION_INFINITE;
-			else
-				pool->pltime = (u_int32_t)(yyvsp[-1].num);
-			if ((yyvsp[0].num) < 0)
-				pool->vltime = DHCP6_DURATION_INFINITE;
-			else
-				pool->vltime = (u_int32_t)(yyvsp[0].num);
-
-			(yyval.pool) = pool;
-		}
-    break;
-
-  case 76:
-#line 958 "cfparse.y"
-    {
-			(yyval.num) = -1;
-		}
-    break;
-
-  case 77:
-#line 962 "cfparse.y"
-    {
-			(yyval.num) = (yyvsp[0].num);
-		}
-    break;
-
-  case 78:
-#line 968 "cfparse.y"
-    { (yyval.list) = NULL; }
-    break;
-
-  case 79:
-#line 970 "cfparse.y"
-    {
-			struct cf_list *head;
-
-			if ((head = (yyvsp[-1].list)) == NULL) {
-				(yyvsp[0].list)->next = NULL;
-				(yyvsp[0].list)->tail = (yyvsp[0].list);
-				head = (yyvsp[0].list);
-			} else {
-				head->tail->next = (yyvsp[0].list);
-				head->tail = (yyvsp[0].list)->tail;
-			}
-
-			(yyval.list) = head;
-		}
-    break;
-
-  case 80:
-#line 987 "cfparse.y"
-    { (yyval.list) = (yyvsp[0].list); }
-    break;
-
-  case 81:
-#line 989 "cfparse.y"
-    {
-			struct cf_list *l;
-
-			MAKE_CFLIST(l, IACONF_PREFIX, (yyvsp[-1].prefix), NULL);
-
-			(yyval.list) = l;
-		}
-    break;
-
-  case 82:
-#line 1000 "cfparse.y"
-    {
-		struct cf_list *ifl;
-
-		MAKE_CFLIST(ifl, IACONF_PIF, (yyvsp[-4].str), (yyvsp[-2].list));
-		(yyval.list) = ifl;
-	}
-    break;
-
-  case 83:
-#line 1009 "cfparse.y"
-    { (yyval.list) = NULL; }
-    break;
-
-  case 84:
-#line 1011 "cfparse.y"
-    {
-			struct cf_list *head;
-
-			if ((head = (yyvsp[-1].list)) == NULL) {
-				(yyvsp[0].list)->next = NULL;
-				(yyvsp[0].list)->tail = (yyvsp[0].list);
-				head = (yyvsp[0].list);
-			} else {
-				head->tail->next = (yyvsp[0].list);
-				head->tail = (yyvsp[0].list)->tail;
-			}
-
-			(yyval.list) = head;
-		}
-    break;
-
-  case 85:
-#line 1029 "cfparse.y"
-    {
-			struct cf_list *l;
-
-			MAKE_CFLIST(l, IFPARAM_SLA_ID, NULL, NULL);
-			l->num = (yyvsp[-1].num);
-			(yyval.list) = l;
-		}
-    break;
-
-  case 86:
-#line 1037 "cfparse.y"
-    {
-			struct cf_list *l;
-
-			MAKE_CFLIST(l, IFPARAM_SLA_LEN, NULL, NULL);
-			l->num = (yyvsp[-1].num);
-			(yyval.list) = l;
-		}
-    break;
-
-  case 87:
-#line 1047 "cfparse.y"
-    { (yyval.list) = NULL; }
-    break;
-
-  case 88:
-#line 1049 "cfparse.y"
-    {
-			struct cf_list *head;
-
-			if ((head = (yyvsp[-1].list)) == NULL) {
-				(yyvsp[0].list)->next = NULL;
-				(yyvsp[0].list)->tail = (yyvsp[0].list);
-				head = (yyvsp[0].list);
-			} else {
-				head->tail->next = (yyvsp[0].list);
-				head->tail = (yyvsp[0].list)->tail;
-			}
-
-			(yyval.list) = head;
-		}
-    break;
-
-  case 89:
-#line 1067 "cfparse.y"
-    {
-			struct cf_list *l;
-
-			MAKE_CFLIST(l, IACONF_ADDR, (yyvsp[-1].prefix), NULL);
-
-			(yyval.list) = l;
-		}
-    break;
-
-  case 90:
-#line 1077 "cfparse.y"
-    { (yyval.list) = NULL; }
-    break;
-
-  case 91:
-#line 1079 "cfparse.y"
-    {
-			struct cf_list *head;
-
-			if ((head = (yyvsp[-1].list)) == NULL) {
-				(yyvsp[0].list)->next = NULL;
-				(yyvsp[0].list)->tail = (yyvsp[0].list);
-				head = (yyvsp[0].list);
-			} else {
-				head->tail->next = (yyvsp[0].list);
-				head->tail = (yyvsp[0].list)->tail;
-			}
-
-			(yyval.list) = head;
-		}
-    break;
-
-  case 92:
-#line 1097 "cfparse.y"
-    {
-			struct cf_list *l;
-
-			MAKE_CFLIST(l, AUTHPARAM_PROTO, NULL, NULL);
-			l->num = (yyvsp[-1].num);
-			(yyval.list) = l;
-		}
-    break;
-
-  case 93:
-#line 1105 "cfparse.y"
-    {
-			struct cf_list *l;
-
-			MAKE_CFLIST(l, AUTHPARAM_ALG, NULL, NULL);
-			l->num = (yyvsp[-1].num);
-			(yyval.list) = l;
-		}
-    break;
-
-  case 94:
-#line 1113 "cfparse.y"
-    {
-			struct cf_list *l;
-
-			MAKE_CFLIST(l, AUTHPARAM_RDM, NULL, NULL);
-			l->num = (yyvsp[-1].num);
-			(yyval.list) = l;
-		}
-    break;
-
-  case 95:
-#line 1121 "cfparse.y"
-    {
-			struct cf_list *l;
-
-			MAKE_CFLIST(l, AUTHPARAM_KEY, NULL, NULL);
-			l->ptr = (yyvsp[-1].str);
-			(yyval.list) = l;
-		}
-    break;
-
-  case 96:
-#line 1131 "cfparse.y"
-    { (yyval.num) = DHCP6_AUTHPROTO_DELAYED; }
-    break;
-
-  case 97:
-#line 1132 "cfparse.y"
-    { (yyval.num) = DHCP6_AUTHPROTO_RECONFIG; }
-    break;
-
-  case 98:
-#line 1136 "cfparse.y"
-    { (yyval.num) = DHCP6_AUTHALG_HMACMD5; }
-    break;
-
-  case 99:
-#line 1140 "cfparse.y"
-    { (yyval.num) = DHCP6_AUTHRDM_MONOCOUNTER; }
-    break;
-
-  case 100:
-#line 1144 "cfparse.y"
-    { (yyval.list) = NULL; }
-    break;
-
-  case 101:
-#line 1146 "cfparse.y"
-    {
-			struct cf_list *head;
-
-			if ((head = (yyvsp[-1].list)) == NULL) {
-				(yyvsp[0].list)->next = NULL;
-				(yyvsp[0].list)->tail = (yyvsp[0].list);
-				head = (yyvsp[0].list);
-			} else {
-				head->tail->next = (yyvsp[0].list);
-				head->tail = (yyvsp[0].list)->tail;
-			}
-
-			(yyval.list) = head;
-		}
-    break;
-
-  case 102:
-#line 1164 "cfparse.y"
-    {
-			struct cf_list *l;
-
-			MAKE_CFLIST(l, KEYPARAM_REALM, NULL, NULL);
-			l->ptr = (yyvsp[-1].str);
-			(yyval.list) = l;
-		}
-    break;
-
-  case 103:
-#line 1172 "cfparse.y"
-    {
-			struct cf_list *l;
-
-			MAKE_CFLIST(l, KEYPARAM_KEYID, NULL, NULL);
-			l->num = (yyvsp[-1].num);
-			(yyval.list) = l;
-		}
-    break;
-
-  case 104:
-#line 1180 "cfparse.y"
-    {
-			struct cf_list *l;
-
-			MAKE_CFLIST(l, KEYPARAM_SECRET, NULL, NULL);
-			l->ptr = (yyvsp[-1].str);
-			(yyval.list) = l;
-		}
-    break;
-
-  case 105:
-#line 1188 "cfparse.y"
-    {
-			struct cf_list *l;
-
-			MAKE_CFLIST(l, KEYPARAM_EXPIRE, NULL, NULL);
-			l->ptr = (yyvsp[-1].str);
-			(yyval.list) = l;
-		}
-    break;
-
-
-      default: break;
-    }
-
-/* Line 1126 of yacc.c.  */
-#line 2744 "y.tab.c"
-
-  yyvsp -= yylen;
-  yyssp -= yylen;
-
-
-  YY_STACK_PRINT (yyss, yyssp);
-
-  *++yyvsp = yyval;
-
-
-  /* Now `shift' the result of the reduction.  Determine what state
-     that goes to, based on the state we popped back to and the rule
-     number reduced by.  */
-
-  yyn = yyr1[yyn];
-
-  yystate = yypgoto[yyn - YYNTOKENS] + *yyssp;
-  if (0 <= yystate && yystate <= YYLAST && yycheck[yystate] == *yyssp)
-    yystate = yytable[yystate];
-  else
-    yystate = yydefgoto[yyn - YYNTOKENS];
-
-  goto yynewstate;
-
-
-/*------------------------------------.
-| yyerrlab -- here on detecting error |
-`------------------------------------*/
-yyerrlab:
-  /* If not already recovering from an error, report this error.  */
-  if (!yyerrstatus)
-    {
-      ++yynerrs;
-#if YYERROR_VERBOSE
-      yyn = yypact[yystate];
-
-      if (YYPACT_NINF < yyn && yyn < YYLAST)
-	{
-	  int yytype = YYTRANSLATE (yychar);
-	  YYSIZE_T yysize0 = yytnamerr (0, yytname[yytype]);
-	  YYSIZE_T yysize = yysize0;
-	  YYSIZE_T yysize1;
-	  int yysize_overflow = 0;
-	  char *yymsg = 0;
-#	  define YYERROR_VERBOSE_ARGS_MAXIMUM 5
-	  char const *yyarg[YYERROR_VERBOSE_ARGS_MAXIMUM];
-	  int yyx;
-
-#if 0
-	  /* This is so xgettext sees the translatable formats that are
-	     constructed on the fly.  */
-	  YY_("syntax error, unexpected %s");
-	  YY_("syntax error, unexpected %s, expecting %s");
-	  YY_("syntax error, unexpected %s, expecting %s or %s");
-	  YY_("syntax error, unexpected %s, expecting %s or %s or %s");
-	  YY_("syntax error, unexpected %s, expecting %s or %s or %s or %s");
-#endif
-	  char *yyfmt;
-	  char const *yyf;
-	  static char const yyunexpected[] = "syntax error, unexpected %s";
-	  static char const yyexpecting[] = ", expecting %s";
-	  static char const yyor[] = " or %s";
-	  char yyformat[sizeof yyunexpected
-			+ sizeof yyexpecting - 1
-			+ ((YYERROR_VERBOSE_ARGS_MAXIMUM - 2)
-			   * (sizeof yyor - 1))];
-	  char const *yyprefix = yyexpecting;
-
-	  /* Start YYX at -YYN if negative to avoid negative indexes in
-	     YYCHECK.  */
-	  int yyxbegin = yyn < 0 ? -yyn : 0;
-
-	  /* Stay within bounds of both yycheck and yytname.  */
-	  int yychecklim = YYLAST - yyn;
-	  int yyxend = yychecklim < YYNTOKENS ? yychecklim : YYNTOKENS;
-	  int yycount = 1;
-
-	  yyarg[0] = yytname[yytype];
-	  yyfmt = yystpcpy (yyformat, yyunexpected);
-
-	  for (yyx = yyxbegin; yyx < yyxend; ++yyx)
-	    if (yycheck[yyx + yyn] == yyx && yyx != YYTERROR)
-	      {
-		if (yycount == YYERROR_VERBOSE_ARGS_MAXIMUM)
-		  {
-		    yycount = 1;
-		    yysize = yysize0;
-		    yyformat[sizeof yyunexpected - 1] = '\0';
-		    break;
-		  }
-		yyarg[yycount++] = yytname[yyx];
-		yysize1 = yysize + yytnamerr (0, yytname[yyx]);
-		yysize_overflow |= yysize1 < yysize;
-		yysize = yysize1;
-		yyfmt = yystpcpy (yyfmt, yyprefix);
-		yyprefix = yyor;
-	      }
-
-	  yyf = YY_(yyformat);
-	  yysize1 = yysize + yystrlen (yyf);
-	  yysize_overflow |= yysize1 < yysize;
-	  yysize = yysize1;
-
-	  if (!yysize_overflow && yysize <= YYSTACK_ALLOC_MAXIMUM)
-	    yymsg = (char *) YYSTACK_ALLOC (yysize);
-	  if (yymsg)
-	    {
-	      /* Avoid sprintf, as that infringes on the user's name space.
-		 Don't have undefined behavior even if the translation
-		 produced a string with the wrong number of "%s"s.  */
-	      char *yyp = yymsg;
-	      int yyi = 0;
-	      while ((*yyp = *yyf))
-		{
-		  if (*yyp == '%' && yyf[1] == 's' && yyi < yycount)
-		    {
-		      yyp += yytnamerr (yyp, yyarg[yyi++]);
-		      yyf += 2;
-		    }
-		  else
-		    {
-		      yyp++;
-		      yyf++;
-		    }
-		}
-	      yyerror (yymsg);
-	      YYSTACK_FREE (yymsg);
-	    }
-	  else
-	    {
-	      yyerror (YY_("syntax error"));
-	      goto yyexhaustedlab;
-	    }
-	}
-      else
-#endif /* YYERROR_VERBOSE */
-	yyerror (YY_("syntax error"));
-    }
-
-
-
-  if (yyerrstatus == 3)
-    {
-      /* If just tried and failed to reuse look-ahead token after an
-	 error, discard it.  */
-
-      if (yychar <= YYEOF)
-        {
-	  /* Return failure if at end of input.  */
-	  if (yychar == YYEOF)
-	    YYABORT;
-        }
-      else
-	{
-	  yydestruct ("Error: discarding", yytoken, &yylval);
-	  yychar = YYEMPTY;
-	}
-    }
-
-  /* Else will try to reuse look-ahead token after shifting the error
-     token.  */
-  goto yyerrlab1;
-
-
-/*---------------------------------------------------.
-| yyerrorlab -- error raised explicitly by YYERROR.  |
-`---------------------------------------------------*/
-yyerrorlab:
-
-  /* Pacify compilers like GCC when the user code never invokes
-     YYERROR and the label yyerrorlab therefore never appears in user
-     code.  */
-  if (0)
-     goto yyerrorlab;
-
-yyvsp -= yylen;
-  yyssp -= yylen;
-  yystate = *yyssp;
-  goto yyerrlab1;
-
-
-/*-------------------------------------------------------------.
-| yyerrlab1 -- common code for both syntax error and YYERROR.  |
-`-------------------------------------------------------------*/
-yyerrlab1:
-  yyerrstatus = 3;	/* Each real token shifted decrements this.  */
-
-  for (;;)
-    {
-      yyn = yypact[yystate];
-      if (yyn != YYPACT_NINF)
-	{
-	  yyn += YYTERROR;
-	  if (0 <= yyn && yyn <= YYLAST && yycheck[yyn] == YYTERROR)
-	    {
-	      yyn = yytable[yyn];
-	      if (0 < yyn)
-		break;
-	    }
-	}
-
-      /* Pop the current state because it cannot handle the error token.  */
-      if (yyssp == yyss)
-	YYABORT;
-
-
-      yydestruct ("Error: popping", yystos[yystate], yyvsp);
-      YYPOPSTACK;
-      yystate = *yyssp;
-      YY_STACK_PRINT (yyss, yyssp);
-    }
-
-  if (yyn == YYFINAL)
-    YYACCEPT;
-
-  *++yyvsp = yylval;
-
-
-  /* Shift the error token. */
-  YY_SYMBOL_PRINT ("Shifting", yystos[yyn], yyvsp, yylsp);
-
-  yystate = yyn;
-  goto yynewstate;
-
-
-/*-------------------------------------.
-| yyacceptlab -- YYACCEPT comes here.  |
-`-------------------------------------*/
-yyacceptlab:
-  yyresult = 0;
-  goto yyreturn;
-
-/*-----------------------------------.
-| yyabortlab -- YYABORT comes here.  |
-`-----------------------------------*/
-yyabortlab:
-  yyresult = 1;
-  goto yyreturn;
-
-#ifndef yyoverflow
-/*-------------------------------------------------.
-| yyexhaustedlab -- memory exhaustion comes here.  |
-`-------------------------------------------------*/
-yyexhaustedlab:
-  yyerror (YY_("memory exhausted"));
-  yyresult = 2;
-  /* Fall through.  */
-#endif
-
-yyreturn:
-  if (yychar != YYEOF && yychar != YYEMPTY)
-     yydestruct ("Cleanup: discarding lookahead",
-		 yytoken, &yylval);
-  while (yyssp != yyss)
-    {
-      yydestruct ("Cleanup: popping",
-		  yystos[*yyssp], yyvsp);
-      YYPOPSTACK;
-    }
-#ifndef yyoverflow
-  if (yyss != yyssa)
-    YYSTACK_FREE (yyss);
-#endif
-  return yyresult;
-}
-
-
-#line 1197 "cfparse.y"
-
-/* supplement routines for configuration */
-static int
-add_namelist(new, headp)
-	struct cf_namelist *new, **headp;
-{
-	struct cf_namelist *n;
-	
-	/* check for duplicated configuration */
-	for (n = *headp; n; n = n->next) {
-		if (strcmp(n->name, new->name) == 0) {
-			yywarn("duplicated name: %s (ignored)",
-			       new->name);
-			cleanup_namelist(new);
-			return (0);
-		}
-	}
-
-	new->next = *headp;
-	*headp = new;
-
-	return (0);
-}
-
-/* free temporary resources */
-static void
-cleanup()
-{
-	cleanup_namelist(iflist_head);
-	iflist_head = NULL;
-	cleanup_namelist(hostlist_head);
-	hostlist_head = NULL;
-	cleanup_namelist(iapdlist_head);
-	iapdlist_head = NULL;
-	cleanup_namelist(ianalist_head);
-	ianalist_head = NULL;
-	cleanup_namelist(authinfolist_head);
-	authinfolist_head = NULL;
-	cleanup_namelist(keylist_head);
-	keylist_head = NULL;
-	cleanup_namelist(addrpoollist_head);
-	addrpoollist_head = NULL;
-
-	cleanup_cflist(cf_sip_list);
-	cf_sip_list = NULL;
-	cleanup_cflist(cf_sip_name_list);
-	cf_sip_name_list = NULL;
-	cleanup_cflist(cf_dns_list);
-	cf_dns_list = NULL;
-	cleanup_cflist(cf_dns_name_list);
-	cf_dns_name_list = NULL;
-	cleanup_cflist(cf_ntp_list);
-	cf_ntp_list = NULL;
-	cleanup_cflist(cf_nis_list);
-	cf_nis_list = NULL;
-	cleanup_cflist(cf_nis_name_list);
-	cf_nis_name_list = NULL;
-	cleanup_cflist(cf_nisp_list);
-	cf_nisp_list = NULL;
-	cleanup_cflist(cf_nisp_name_list);
-	cf_nisp_name_list = NULL;
-	cleanup_cflist(cf_bcmcs_list);
-	cf_bcmcs_list = NULL;
-	cleanup_cflist(cf_bcmcs_name_list);
-	cf_bcmcs_name_list = NULL;
-}
-
-static void
-cleanup_namelist(head)
-	struct cf_namelist *head;
-{
-	struct cf_namelist *ifp, *ifp_next;
-
-	for (ifp = head; ifp; ifp = ifp_next) {
-		ifp_next = ifp->next;
-		cleanup_cflist(ifp->params);
-		free(ifp->name);
-		free(ifp);
-	}
-}
-
-static void
-cleanup_cflist(p)
-	struct cf_list *p;
-{
-	struct cf_list *n;
-
-	if (p == NULL)
-		return;
-
-	n = p->next;
-	if (p->type == DECL_ADDRESSPOOL) {
-		free(((struct dhcp6_poolspec *)p->ptr)->name);
-	}
-	if (p->ptr)
-		free(p->ptr);
-	if (p->list)
-		cleanup_cflist(p->list);
-	free(p);
-
-	cleanup_cflist(n);
-}
-
-#define config_fail() \
-	do { cleanup(); configure_cleanup(); return (-1); } while(0)
-
-int
-cf_post_config()
-{
-	if (configure_keys(keylist_head))
-		config_fail();
-
-	if (configure_authinfo(authinfolist_head))
-		config_fail();
-
-	if (configure_ia(iapdlist_head, IATYPE_PD))
-		config_fail();
-
-	if (configure_ia(ianalist_head, IATYPE_NA))
-		config_fail();
-
-	if (configure_pool(addrpoollist_head))
-		config_fail();
-
-	if (configure_interface(iflist_head))
-		config_fail();
-
-	if (configure_host(hostlist_head))
-		config_fail();
-
-	if (configure_global_option())
-		config_fail();
-
-	configure_commit();
-	cleanup();
-	return (0);
-}
-#undef config_fail
-
-void
-cf_init()
-{
-	iflist_head = NULL;
-}
-
diff -Naur wide-dhcpv6-20080615.orig/cftoken.c wide-dhcpv6-20080615/cftoken.c
--- wide-dhcpv6-20080615.orig/cftoken.c	2007-03-21 17:53:10.000000000 +0800
+++ wide-dhcpv6-20080615/cftoken.c	1970-01-01 08:00:00.000000000 +0800
@@ -1,2583 +0,0 @@
-/* A lexical scanner generated by flex */
-
-/* Scanner skeleton version:
- * $Header: /home/daffy/u0/vern/flex/RCS/flex.skl,v 2.91 96/09/10 16:58:48 vern Exp $
- * $FreeBSD: src/usr.bin/lex/flex.skl,v 1.8 2004/01/06 19:03:44 nectar Exp $
- */
-
-#if defined(__FreeBSD__)
-#include <sys/cdefs.h>
-#else
-#define __unused
-#endif
-
-#define FLEX_SCANNER
-#define YY_FLEX_MAJOR_VERSION 2
-#define YY_FLEX_MINOR_VERSION 5
-
-#include <stdio.h>
-
-
-/* cfront 1.2 defines "c_plusplus" instead of "__cplusplus" */
-#ifdef c_plusplus
-#ifndef __cplusplus
-#define __cplusplus
-#endif
-#endif
-
-
-#ifdef __cplusplus
-
-#include <stdlib.h>
-#include <unistd.h>
-
-/* Use prototypes in function declarations. */
-#define YY_USE_PROTOS
-
-/* The "const" storage-class-modifier is valid. */
-#define YY_USE_CONST
-
-#else	/* ! __cplusplus */
-
-#if __STDC__
-
-#define YY_USE_PROTOS
-#define YY_USE_CONST
-
-#endif	/* __STDC__ */
-#endif	/* ! __cplusplus */
-
-#ifdef __TURBOC__
- #pragma warn -rch
- #pragma warn -use
-#include <io.h>
-#include <stdlib.h>
-#define YY_USE_CONST
-#define YY_USE_PROTOS
-#endif
-
-#ifdef YY_USE_CONST
-#define yyconst const
-#else
-#define yyconst
-#endif
-
-
-#ifdef YY_USE_PROTOS
-#define YY_PROTO(proto) proto
-#else
-#define YY_PROTO(proto) ()
-#endif
-
-/* Returned upon end-of-file. */
-#define YY_NULL 0
-
-/* Promotes a possibly negative, possibly signed char to an unsigned
- * integer for use as an array index.  If the signed char is negative,
- * we want to instead treat it as an 8-bit unsigned char, hence the
- * double cast.
- */
-#define YY_SC_TO_UI(c) ((unsigned int) (unsigned char) c)
-
-/* Enter a start condition.  This macro really ought to take a parameter,
- * but we do it the disgusting crufty way forced on us by the ()-less
- * definition of BEGIN.
- */
-#define BEGIN yy_start = 1 + 2 *
-
-/* Translate the current start state into a value that can be later handed
- * to BEGIN to return to the state.  The YYSTATE alias is for lex
- * compatibility.
- */
-#define YY_START ((yy_start - 1) / 2)
-#define YYSTATE YY_START
-
-/* Action number for EOF rule of a given start state. */
-#define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)
-
-/* Special action meaning "start processing a new file". */
-#define YY_NEW_FILE yyrestart( yyin )
-
-#define YY_END_OF_BUFFER_CHAR 0
-
-/* Size of default input buffer. */
-#define YY_BUF_SIZE 16384
-
-typedef struct yy_buffer_state *YY_BUFFER_STATE;
-
-extern int yyleng;
-extern FILE *yyin, *yyout;
-
-#define EOB_ACT_CONTINUE_SCAN 0
-#define EOB_ACT_END_OF_FILE 1
-#define EOB_ACT_LAST_MATCH 2
-
-/* The funky do-while in the following #define is used to turn the definition
- * int a single C statement (which needs a semi-colon terminator).  This
- * avoids problems with code like:
- *
- * 	if ( condition_holds )
- *		yyless( 5 );
- *	else
- *		do_something_else();
- *
- * Prior to using the do-while the compiler would get upset at the
- * "else" because it interpreted the "if" statement as being all
- * done when it reached the ';' after the yyless() call.
- */
-
-/* Return all but the first 'n' matched characters back to the input stream. */
-
-#define yyless(n) \
-	do \
-		{ \
-		/* Undo effects of setting up yytext. */ \
-		*yy_cp = yy_hold_char; \
-		YY_RESTORE_YY_MORE_OFFSET \
-		yy_c_buf_p = yy_cp = yy_bp + n - YY_MORE_ADJ; \
-		YY_DO_BEFORE_ACTION; /* set up yytext again */ \
-		} \
-	while ( 0 )
-
-#define unput(c) yyunput( c, yytext_ptr )
-
-/* The following is because we cannot portably get our hands on size_t
- * (without autoconf's help, which isn't available because we want
- * flex-generated scanners to compile on their own).
- */
-typedef unsigned int yy_size_t;
-
-
-struct yy_buffer_state
-	{
-	FILE *yy_input_file;
-
-	char *yy_ch_buf;		/* input buffer */
-	char *yy_buf_pos;		/* current position in input buffer */
-
-	/* Size of input buffer in bytes, not including room for EOB
-	 * characters.
-	 */
-	yy_size_t yy_buf_size;
-
-	/* Number of characters read into yy_ch_buf, not including EOB
-	 * characters.
-	 */
-	int yy_n_chars;
-
-	/* Whether we "own" the buffer - i.e., we know we created it,
-	 * and can realloc() it to grow it, and should free() it to
-	 * delete it.
-	 */
-	int yy_is_our_buffer;
-
-	/* Whether this is an "interactive" input source; if so, and
-	 * if we're using stdio for input, then we want to use getc()
-	 * instead of fread(), to make sure we stop fetching input after
-	 * each newline.
-	 */
-	int yy_is_interactive;
-
-	/* Whether we're considered to be at the beginning of a line.
-	 * If so, '^' rules will be active on the next match, otherwise
-	 * not.
-	 */
-	int yy_at_bol;
-
-	/* Whether to try to fill the input buffer when we reach the
-	 * end of it.
-	 */
-	int yy_fill_buffer;
-
-	int yy_buffer_status;
-#define YY_BUFFER_NEW 0
-#define YY_BUFFER_NORMAL 1
-	/* When an EOF's been seen but there's still some text to process
-	 * then we mark the buffer as YY_EOF_PENDING, to indicate that we
-	 * shouldn't try reading from the input source any more.  We might
-	 * still have a bunch of tokens to match, though, because of
-	 * possible backing-up.
-	 *
-	 * When we actually see the EOF, we change the status to "new"
-	 * (via yyrestart()), so that the user can continue scanning by
-	 * just pointing yyin at a new input file.
-	 */
-#define YY_BUFFER_EOF_PENDING 2
-	};
-
-static YY_BUFFER_STATE yy_current_buffer = 0;
-
-/* We provide macros for accessing buffer states in case in the
- * future we want to put the buffer states in a more general
- * "scanner state".
- */
-#define YY_CURRENT_BUFFER yy_current_buffer
-
-
-/* yy_hold_char holds the character lost when yytext is formed. */
-static char yy_hold_char;
-
-static int yy_n_chars;		/* number of characters read into yy_ch_buf */
-
-
-int yyleng;
-
-/* Points to current character in buffer. */
-static char *yy_c_buf_p = (char *) 0;
-static int yy_init = 1;		/* whether we need to initialize */
-static int yy_start = 0;	/* start state number */
-
-/* Flag which is used to allow yywrap()'s to do buffer switches
- * instead of setting up a fresh yyin.  A bit of a hack ...
- */
-static int yy_did_buffer_switch_on_eof;
-
-void yyrestart YY_PROTO(( FILE *input_file ));
-
-void yy_switch_to_buffer YY_PROTO(( YY_BUFFER_STATE new_buffer ));
-void yy_load_buffer_state YY_PROTO(( void ));
-YY_BUFFER_STATE yy_create_buffer YY_PROTO(( FILE *file, int size ));
-void yy_delete_buffer YY_PROTO(( YY_BUFFER_STATE b ));
-void yy_init_buffer YY_PROTO(( YY_BUFFER_STATE b, FILE *file ));
-void yy_flush_buffer YY_PROTO(( YY_BUFFER_STATE b ));
-#define YY_FLUSH_BUFFER yy_flush_buffer( yy_current_buffer )
-
-YY_BUFFER_STATE yy_scan_buffer YY_PROTO(( char *base, yy_size_t size ));
-YY_BUFFER_STATE yy_scan_string YY_PROTO(( yyconst char *yy_str ));
-YY_BUFFER_STATE yy_scan_bytes YY_PROTO(( yyconst char *bytes, int len ));
-
-static void *yy_flex_alloc YY_PROTO(( yy_size_t ));
-static void *yy_flex_realloc YY_PROTO(( void *, yy_size_t )) __unused;
-static void yy_flex_free YY_PROTO(( void * ));
-
-#define yy_new_buffer yy_create_buffer
-
-#define yy_set_interactive(is_interactive) \
-	{ \
-	if ( ! yy_current_buffer ) \
-		yy_current_buffer = yy_create_buffer( yyin, YY_BUF_SIZE ); \
-	yy_current_buffer->yy_is_interactive = is_interactive; \
-	}
-
-#define yy_set_bol(at_bol) \
-	{ \
-	if ( ! yy_current_buffer ) \
-		yy_current_buffer = yy_create_buffer( yyin, YY_BUF_SIZE ); \
-	yy_current_buffer->yy_at_bol = at_bol; \
-	}
-
-#define YY_AT_BOL() (yy_current_buffer->yy_at_bol)
-
-typedef unsigned char YY_CHAR;
-FILE *yyin = (FILE *) 0, *yyout = (FILE *) 0;
-typedef int yy_state_type;
-extern char *yytext;
-#define yytext_ptr yytext
-
-static yy_state_type yy_get_previous_state YY_PROTO(( void ));
-static yy_state_type yy_try_NUL_trans YY_PROTO(( yy_state_type current_state ));
-static int yy_get_next_buffer YY_PROTO(( void ));
-static void yy_fatal_error YY_PROTO(( yyconst char msg[] ));
-
-/* Done after the current pattern has been matched and before the
- * corresponding action - sets up yytext.
- */
-#define YY_DO_BEFORE_ACTION \
-	yytext_ptr = yy_bp; \
-	yyleng = (int) (yy_cp - yy_bp); \
-	yy_hold_char = *yy_cp; \
-	*yy_cp = '\0'; \
-	yy_c_buf_p = yy_cp;
-
-#define YY_NUM_RULES 81
-#define YY_END_OF_BUFFER 82
-static yyconst short int yy_accept[517] =
-    {   0,
-        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
-        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
-        0,    0,    0,    0,   82,   81,   71,   72,   81,   73,
-       76,   80,   80,   75,   74,   77,   78,   79,   80,   80,
-       80,   80,   80,   80,   80,   80,   80,   80,   80,   80,
-       80,   80,   80,    2,    2,    2,    4,    4,    4,   74,
-       80,   80,   42,   80,   80,   43,   49,   49,   49,   62,
-       62,   62,   81,    6,    6,    6,   81,   71,    0,   70,
-       73,   80,   74,   80,   74,   80,   80,   80,   80,   80,
-       80,   80,   80,   80,   80,   80,   80,   80,   80,   80,
-
-       80,   80,   80,   80,   80,   80,   80,   80,   80,   80,
-       80,   80,   80,   17,    2,    2,    2,    2,    4,    4,
-        4,    4,    8,    8,   42,   80,   42,   41,   40,   49,
-       49,   49,   49,   62,   62,   62,   62,    0,   66,    6,
-        6,    6,    6,    0,   69,   80,   80,   80,   80,   80,
-       80,   80,   80,   80,   80,   80,   80,   80,   80,   80,
-       80,   80,   53,   80,   80,   80,   80,   80,   80,   80,
-       80,   80,   52,   80,   80,   80,   80,   80,   80,   80,
-       80,   80,   80,   80,   80,   80,   80,   80,   80,   80,
-       80,    7,   80,   80,    3,   80,   80,   80,   80,   80,
-
-       80,   80,   80,   80,   80,   80,   80,   80,    5,   80,
-       80,   80,   80,   80,   80,   80,   80,   80,   80,   15,
-       80,   80,   80,   80,   80,   80,   80,   38,   80,   80,
-       80,   80,   80,   80,   80,   22,   21,   80,   80,   80,
-       80,   80,   64,   80,   80,   80,   80,   80,   80,   80,
-       80,   80,   80,   16,   80,   63,   80,   80,   80,   80,
-       80,   80,   80,   80,    8,   80,   80,   80,   80,   80,
-       80,   80,   80,   67,   80,   80,   80,   80,   80,   80,
-       80,   80,   80,   80,   80,   80,   80,   80,   19,   80,
-       10,   80,   80,   80,   80,   80,   12,   65,   80,   45,
-
-       80,   80,   59,    9,   80,   80,   80,   54,   80,   80,
-       58,   80,   68,   80,   80,   80,   61,   80,   80,   80,
-       80,   80,   80,   80,   80,   80,   80,   80,   80,   14,
-       80,   46,   57,   80,   80,   80,   80,   80,   80,   56,
-       39,   47,   80,   80,   80,   80,   80,   80,   80,   80,
-       80,   80,   50,   80,   55,   80,   80,   80,   51,   80,
-       80,   80,   80,   80,    1,   80,   80,   80,   80,   80,
-       80,   80,   80,   80,   80,   80,   80,   80,   80,   13,
-       80,   80,   80,   80,   80,   80,   80,   80,   11,   80,
-       80,   80,   80,   80,   80,   80,   24,   80,   60,   80,
-
-       80,   80,   80,   27,   80,   80,   34,   80,   18,   80,
-       80,   80,   80,   80,   80,   80,   80,   80,   80,   20,
-       80,   80,   80,   80,   80,   80,   80,   80,   80,   80,
-       80,   80,   80,   80,   80,   48,   80,   80,   80,   80,
-       80,   80,   80,   80,   80,   80,   80,   80,   80,   80,
-       80,   80,   80,   29,   80,   80,   80,   80,   80,   80,
-       80,   80,   80,   80,   80,   37,   80,   80,   31,   80,
-       80,   44,   80,   80,   80,   80,   80,   80,   80,   80,
-       80,   80,   80,   80,   80,   80,   28,   80,   80,   80,
-       25,   80,   80,   80,   23,   80,   30,   80,   80,   32,
-
-       80,   80,   80,   80,   80,   80,   80,   80,   80,   35,
-       80,   26,   80,   36,   33,    0
-    } ;
-
-static yyconst int yy_ec[256] =
-    {   0,
-        1,    1,    1,    1,    1,    1,    1,    1,    2,    3,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    2,    1,    4,    5,    1,    1,    1,    1,    1,
-        1,    1,    1,    6,    7,    8,    9,   10,   10,   10,
-       10,   10,   11,   10,   10,   10,   10,   12,   13,    1,
-        1,    1,    1,    1,   14,   15,   16,   17,   15,   15,
-       18,   19,   18,   18,   18,   18,   20,   18,   18,   18,
-       18,   18,   18,   18,   18,   18,   18,   18,   18,   18,
-        1,    1,    1,    1,   18,    1,   21,   22,   23,   24,
-
-       25,   26,   27,   28,   29,   18,   30,   31,   32,   33,
-       34,   35,   36,   37,   38,   39,   40,   41,   42,   43,
-       44,   18,   45,    1,   46,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1
-    } ;
-
-static yyconst int yy_meta[47] =
-    {   0,
-        1,    1,    2,    1,    1,    1,    3,    3,    1,    3,
-        3,    3,    1,    3,    3,    3,    3,    3,    3,    3,
-        3,    3,    3,    3,    3,    3,    3,    3,    3,    3,
-        3,    3,    3,    3,    3,    3,    3,    3,    3,    3,
-        3,    3,    3,    3,    1,    1
-    } ;
-
-static yyconst short int yy_base[533] =
-    {   0,
-        0,   46,   74,    0,  113,  159,    0,    0,  205,  251,
-      288,    0,    8,   25,  314,  360,  406,  452,  767,  766,
-      498,  544,  765,  764,  767,  772,  764,  772,  761,    0,
-      772,    0,    4,  772,   12,  772,  772,  772,  744,    0,
-      740,    4,  719,    0,    4,  736,  726,   32,  724,    5,
-       41,   44,  724,    0,   16,   66,    0,   53,   70,  583,
-       74,   76,  117,  736,  732,  772,    0,   78,  121,    0,
-       90,  125,  751,    0,  127,  131,  750,  751,  748,  772,
-        0,    0,  133,  135,  139,  737,  726,   41,  710,  716,
-      716,  714,  716,  709,  722,  704,  734,  733,   71,  695,
-
-      705,  699,  701,  696,  700,  123,  118,  701,  150,  695,
-       97,  696,  709,    0,    0,  144,  164,  169,    0,  171,
-      173,  177,  181,  717,  184,  186,  190,    0,    0,    0,
-      192,  209,  213,    0,  215,  217,  221,  724,  772,    0,
-      223,  225,  229,  723,  772,  710,  688,  690,  689,  694,
-      698,  699,  698,  694,  688,  693,  676,  208,  693,  682,
-      183,  687,  682,  676,  223,  702,  679,  676,  680,  666,
-      677,  674,    0,  671,  667,  663,  659,  669,  660,  672,
-      688,  687,  600,   10,  668,  655,  649,  665,  651,  644,
-      658,    0,  649,  215,    0,  664,  660,  645,  642,  648,
-
-      643,  642,  166,  655,  128,  670,  638,  641,    0,   54,
-      640,  641,  613,  604,  602,  605,  604,  585,  594,    0,
-      580,  213,  617,  593,  595,  565,  573,    0,  568,  589,
-      570,  559,  563,  555,  562,    0,    0,  547,  560,  554,
-      550,  555,    0,  554,  545,  544,  552,  225,  551,  542,
-      537,  530,  549,    0,  564,    0,  544,  531,  530,  528,
-      527,  540,  540,  538,  550,  544,  549,  521,  519,  517,
-      513,  518,  534,    0,  516,  528,  504,  512,  497,  514,
-      513,  499,  492,  499,  493,  495,  503,  490,    0,  501,
-      518,  490,  500,  493,  493,  481,    0,    0,  482,    0,
-
-      485,  506,    0,  509,  487,  485,  488,  482,  477,  494,
-        0,  473,    0,  451,  455,  470,    0,  459,  470,  449,
-      457,  451,  446,  453,  456,  453,  449,  455,  442,    0,
-      439,    0,    0,  444,  446,  454,  439,  450,  453,    0,
-        0,    0,  444,  447,  432,  441,  444,  447,  426,  441,
-      441,  426,    0,  418,    0,  420,  423,  413,    0,  425,
-      404,  400,  411,  408,    0,  416,  407,  402,  409,  412,
-      399,  410,  395,  401,  400,  394,  396,  390,  403,    0,
-      402,  393,  388,  417,  416,  389,  384,  382,    0,  393,
-      384,  379,  396,  371,  372,  363,  392,  391,    0,  364,
-
-      224,  389,  388,    0,  357,  354,    0,  244,    0,  358,
-      384,  352,  355,  367,  363,  352,  352,  245,  358,    0,
-      359,  348,  348,  246,  355,  346,  346,  353,  344,  354,
-      350,  338,  346,  334,  325,    0,  332,  321,  317,  322,
-      327,  314,  329,  317,  324,  315,  323,  308,  323,  319,
-      310,  300,  296,    0,  314,  309,  312,  299,  314,  309,
-      308,  303,  294,  309,  304,    0,  290,  293,    0,  296,
-      279,    0,  269,  273,  276,  271,  258,  256,  286,  254,
-      258,  252,  282,  250,  254,  248,    0,  252,  246,  276,
-        0,  249,  243,  273,    0,  258,    0,  245,  256,    0,
-
-      243,  243,  253,  241,  251,  246,  214,  213,  146,    0,
-      131,    0,  115,    0,    0,  772,  643,  646,  649,  652,
-      655,  658,  661,  664,  131,  102,   87,   18,    9,  667,
-        4,  670
-    } ;
-
-static yyconst short int yy_def[533] =
-    {   0,
-      517,  517,    2,    3,  518,  518,    2,    2,  519,  519,
-        2,   11,    2,    2,  520,  520,  521,  521,    2,    2,
-      522,  522,    2,    2,  516,  516,  516,  516,  523,  524,
-      516,  525,  525,  516,  525,  516,  516,  516,  525,  525,
-      525,  525,  525,  525,  525,  525,  525,  525,  525,  525,
-      525,  525,  525,  526,  526,  526,  527,  527,  527,  525,
-       60,  525,  525,  525,  525,  516,  528,  528,  528,  529,
-      529,  529,  530,  531,  531,  531,  532,  516,  523,  516,
-      524,  525,  525,  525,  525,  525,  525,  525,  525,  525,
-      525,  525,  525,  525,  525,  525,  525,  525,  525,  525,
-
-      525,  525,  525,  525,  525,  525,  525,  525,  525,  525,
-      525,  525,  525,  525,  526,  526,  526,  526,  527,  527,
-      527,  527,  525,  525,  525,  525,  525,  525,  525,  528,
-      528,  528,  528,  529,  529,  529,  529,  530,  516,  531,
-      531,  531,  531,  532,  516,  525,  525,  525,  525,  525,
-      525,  525,  525,  525,  525,  525,  525,  525,  525,  525,
-      525,  525,  525,  525,  525,  525,  525,  525,  525,  525,
-      525,  525,  525,  525,  525,  525,  525,  525,  525,  525,
-      525,  525,  525,  525,  525,  525,  525,  525,  525,  525,
-      525,  525,  525,  525,  525,  525,  525,  525,  525,  525,
-
-      525,  525,  525,  525,  525,  525,  525,  525,  525,  525,
-      525,  525,  525,  525,  525,  525,  525,  525,  525,  525,
-      525,  525,  525,  525,  525,  525,  525,  525,  525,  525,
-      525,  525,  525,  525,  525,  525,  525,  525,  525,  525,
-      525,  525,  525,  525,  525,  525,  525,  525,  525,  525,
-      525,  525,  525,  525,  525,  525,  525,  525,  525,  525,
-      525,  525,  525,  525,  525,  525,  525,  525,  525,  525,
-      525,  525,  525,  525,  525,  525,  525,  525,  525,  525,
-      525,  525,  525,  525,  525,  525,  525,  525,  525,  525,
-      525,  525,  525,  525,  525,  525,  525,  525,  525,  525,
-
-      525,  525,  525,  525,  525,  525,  525,  525,  525,  525,
-      525,  525,  525,  525,  525,  525,  525,  525,  525,  525,
-      525,  525,  525,  525,  525,  525,  525,  525,  525,  525,
-      525,  525,  525,  525,  525,  525,  525,  525,  525,  525,
-      525,  525,  525,  525,  525,  525,  525,  525,  525,  525,
-      525,  525,  525,  525,  525,  525,  525,  525,  525,  525,
-      525,  525,  525,  525,  525,  525,  525,  525,  525,  525,
-      525,  525,  525,  525,  525,  525,  525,  525,  525,  525,
-      525,  525,  525,  525,  525,  525,  525,  525,  525,  525,
-      525,  525,  525,  525,  525,  525,  525,  525,  525,  525,
-
-      525,  525,  525,  525,  525,  525,  525,  525,  525,  525,
-      525,  525,  525,  525,  525,  525,  525,  525,  525,  525,
-      525,  525,  525,  525,  525,  525,  525,  525,  525,  525,
-      525,  525,  525,  525,  525,  525,  525,  525,  525,  525,
-      525,  525,  525,  525,  525,  525,  525,  525,  525,  525,
-      525,  525,  525,  525,  525,  525,  525,  525,  525,  525,
-      525,  525,  525,  525,  525,  525,  525,  525,  525,  525,
-      525,  525,  525,  525,  525,  525,  525,  525,  525,  525,
-      525,  525,  525,  525,  525,  525,  525,  525,  525,  525,
-      525,  525,  525,  525,  525,  525,  525,  525,  525,  525,
-
-      525,  525,  525,  525,  525,  525,  525,  525,  525,  525,
-      525,  525,  525,  525,  525,    0,  516,  516,  516,  516,
-      516,  516,  516,  516,  516,  516,  516,  516,  516,  516,
-      516,  516
-    } ;
-
-static yyconst short int yy_nxt[819] =
-    {   0,
-       26,   27,   28,   29,   30,   31,  140,   33,   34,   35,
-       35,  134,   36,   83,   83,   62,  224,   63,   63,   84,
-      130,   85,   85,   87,   97,  116,  116,   98,   91,  225,
-       88,   95,   62,   96,   63,   63,   99,   92,  105,   89,
-       64,  106,   65,   93,   37,   38,   26,   27,   28,   29,
-       30,   31,   66,   33,   34,   35,   35,   64,   36,   65,
-      102,  107,  120,  120,  108,  109,  110,  148,  111,   66,
-      103,  149,  112,  117,  113,  118,  118,  121,  251,  122,
-      122,   82,  252,  124,  124,  125,  125,  131,  131,  119,
-       37,   38,   39,  160,   40,   41,  161,   42,   43,  135,
-
-      135,   44,   45,   46,  115,   47,   48,   49,   50,  162,
-       51,   52,   53,   26,   27,   28,   29,   30,   31,  179,
-       55,   34,   56,   56,  126,   36,  127,  127,  132,  180,
-      133,  133,  136,   82,  137,  137,  141,  141,  142,  515,
-      143,  143,   83,   83,   83,   83,   84,  169,   85,   85,
-      171,  246,  172,  116,  116,  514,  170,   37,   38,   26,
-       27,   28,   29,   30,   31,  247,   55,   34,   56,   56,
-      174,   36,  175,  116,  116,  176,  117,  513,  118,  118,
-      120,  120,  120,  120,  121,  177,  122,  122,   84,  243,
-       85,   85,  183,  125,  125,  125,  125,  126,  244,  127,
-
-      127,  131,  131,   37,   38,   26,   27,   28,   29,   30,
-       31,  200,   58,   34,   59,   59,  201,   36,  131,  131,
-      132,  234,  133,  133,  135,  135,  135,  135,  136,  205,
-      137,  137,  141,  141,  141,  141,  142,  512,  143,  143,
-      196,  263,  197,  264,  415,  511,  235,  416,  286,   37,
-       38,   26,   27,   28,   29,   30,   31,  206,   58,   34,
-       59,   59,  287,   36,  421,  431,  437,  422,  432,  438,
-      510,  509,  508,  507,  506,  505,  504,  503,  502,  501,
-      500,  499,  498,  497,  496,  495,  494,  493,  492,  491,
-      490,  489,  488,  487,  486,   37,   38,   60,   60,  485,
-
-      484,   61,   61,   61,   61,  483,  482,  481,   61,   61,
-       61,   61,   61,   61,   26,   27,   28,   29,   30,   31,
-      480,   68,   34,   69,   69,  479,   36,  478,  477,  476,
-      475,  474,  473,  472,  471,  470,  469,  468,  467,  466,
-      465,  464,  463,  462,  461,  460,  459,  458,  457,  456,
-      455,  454,  453,  452,  451,  450,  449,  448,   37,   38,
-       26,   27,   28,   29,   30,   31,  447,   68,   34,   69,
-       69,  446,   36,  445,  444,  443,  442,  441,  440,  439,
-      436,  435,  434,  433,  430,  429,  428,  427,  426,  425,
-      424,  423,  420,  419,  418,  417,  414,  413,  412,  411,
-
-      410,  409,  408,  407,   37,   38,   26,   27,   28,   29,
-       30,   31,  406,   71,   34,   72,   72,  405,   36,  404,
-      403,  402,  401,  400,  399,  398,  397,  396,  395,  394,
-      393,  392,  391,  390,  389,  388,  387,  386,  385,  384,
-      383,  382,  381,  380,  379,  378,  377,  376,  375,  374,
-       37,   38,   26,   27,   28,   29,   30,   31,  373,   71,
-       34,   72,   72,  372,   36,  371,  370,  369,  368,  367,
-      366,  365,  364,  363,  362,  361,  360,  359,  358,  357,
-      356,  355,  354,  353,  352,  351,  350,  349,  348,  347,
-      346,  345,  344,  343,  342,  341,   37,   38,   26,   27,
-
-       28,   29,   30,   31,  340,   75,   34,   76,   76,  339,
-       36,  338,  337,  336,  335,  334,  333,  332,  331,  330,
-      329,  328,  327,  326,  325,  324,  323,  322,  321,  320,
-      319,  318,  317,  316,  315,  314,  313,  312,  311,  310,
-      309,  308,   37,   38,   26,   27,   28,   29,   30,   31,
-      307,   75,   34,   76,   76,  306,   36,  305,  304,  303,
-      302,  183,  301,  300,  299,  298,  297,  296,  295,  294,
-      293,  292,  291,  290,  289,  288,  285,  284,  283,  282,
-      281,  280,  279,  278,  277,  276,  275,  274,   37,   38,
-       84,  273,  123,  123,  272,  271,  124,  124,  124,  124,
-
-      270,  269,  268,  124,  124,  124,  124,  124,  124,  223,
-      223,  267,  266,  223,  223,  223,  223,  262,  261,  260,
-      223,  223,  223,  223,  223,  223,  265,  265,  259,  258,
-      265,  265,  265,  265,  257,  256,  255,  265,  265,  265,
-      265,  265,  265,   32,   32,   32,   54,   54,   54,   57,
-       57,   57,   67,   67,   67,   70,   70,   70,   74,   74,
-       74,   79,   79,   79,   81,  254,   81,  138,  138,  138,
-      144,  144,  144,  253,  250,  249,  248,  245,  242,  241,
-      240,  239,  238,  237,  236,  233,  232,  231,  230,  229,
-      228,  227,  226,  222,  221,  220,  219,  218,  217,  216,
-
-      215,  214,  213,  212,  211,  210,  209,  208,  207,  204,
-      203,  202,  199,  198,  195,  194,  193,  192,  191,  190,
-      189,  188,  187,  186,  185,  184,  145,  139,  183,  182,
-      181,  178,  173,  168,  167,  166,  165,  164,  163,  159,
-      158,  157,  156,  155,  154,  153,  152,  151,  150,  147,
-      146,   80,   78,  145,  139,  129,  128,  114,  104,  101,
-      100,   94,   90,   86,   80,   78,  516,   77,   77,   73,
-       73,   25,  516,  516,  516,  516,  516,  516,  516,  516,
-      516,  516,  516,  516,  516,  516,  516,  516,  516,  516,
-      516,  516,  516,  516,  516,  516,  516,  516,  516,  516,
-
-      516,  516,  516,  516,  516,  516,  516,  516,  516,  516,
-      516,  516,  516,  516,  516,  516,  516,  516
-    } ;
-
-static yyconst short int yy_chk[819] =
-    {   0,
-        1,    1,    1,    1,    1,    1,  531,    1,    1,    1,
-        1,  529,    1,   33,   33,   13,  184,   13,   13,   35,
-      528,   35,   35,   40,   45,   55,   55,   45,   42,  184,
-       40,   44,   14,   44,   14,   14,   45,   42,   50,   40,
-       13,   50,   13,   42,    1,    1,    2,    2,    2,    2,
-        2,    2,   13,    2,    2,    2,    2,   14,    2,   14,
-       48,   51,   58,   58,   51,   51,   52,   88,   52,   14,
-       48,   88,   52,   56,   52,   56,   56,   59,  210,   59,
-       59,   61,  210,   61,   61,   62,   62,   68,   68,  527,
-        2,    2,    3,   99,    3,    3,   99,    3,    3,   71,
-
-       71,    3,    3,    3,  526,    3,    3,    3,    3,   99,
-        3,    3,    3,    5,    5,    5,    5,    5,    5,  111,
-        5,    5,    5,    5,   63,    5,   63,   63,   69,  111,
-       69,   69,   72,  525,   72,   72,   75,   75,   76,  513,
-       76,   76,   83,   83,   84,   84,   85,  106,   85,   85,
-      107,  205,  107,  116,  116,  511,  106,    5,    5,    6,
-        6,    6,    6,    6,    6,  205,    6,    6,    6,    6,
-      109,    6,  109,  117,  117,  109,  118,  509,  118,  118,
-      120,  120,  121,  121,  122,  109,  122,  122,  123,  203,
-      123,  123,  123,  125,  125,  126,  126,  127,  203,  127,
-
-      127,  131,  131,    6,    6,    9,    9,    9,    9,    9,
-        9,  161,    9,    9,    9,    9,  161,    9,  132,  132,
-      133,  194,  133,  133,  135,  135,  136,  136,  137,  165,
-      137,  137,  141,  141,  142,  142,  143,  508,  143,  143,
-      158,  222,  158,  222,  401,  507,  194,  401,  248,    9,
-        9,   10,   10,   10,   10,   10,   10,  165,   10,   10,
-       10,   10,  248,   10,  408,  418,  424,  408,  418,  424,
-      506,  505,  504,  503,  502,  501,  499,  498,  496,  494,
-      493,  492,  490,  489,  488,  486,  485,  484,  483,  482,
-      481,  480,  479,  478,  477,   10,   10,   11,   11,  476,
-
-      475,   11,   11,   11,   11,  474,  473,  471,   11,   11,
-       11,   11,   11,   11,   15,   15,   15,   15,   15,   15,
-      470,   15,   15,   15,   15,  468,   15,  467,  465,  464,
-      463,  462,  461,  460,  459,  458,  457,  456,  455,  453,
-      452,  451,  450,  449,  448,  447,  446,  445,  444,  443,
-      442,  441,  440,  439,  438,  437,  435,  434,   15,   15,
-       16,   16,   16,   16,   16,   16,  433,   16,   16,   16,
-       16,  432,   16,  431,  430,  429,  428,  427,  426,  425,
-      423,  422,  421,  419,  417,  416,  415,  414,  413,  412,
-      411,  410,  406,  405,  403,  402,  400,  398,  397,  396,
-
-      395,  394,  393,  392,   16,   16,   17,   17,   17,   17,
-       17,   17,  391,   17,   17,   17,   17,  390,   17,  388,
-      387,  386,  385,  384,  383,  382,  381,  379,  378,  377,
-      376,  375,  374,  373,  372,  371,  370,  369,  368,  367,
-      366,  364,  363,  362,  361,  360,  358,  357,  356,  354,
-       17,   17,   18,   18,   18,   18,   18,   18,  352,   18,
-       18,   18,   18,  351,   18,  350,  349,  348,  347,  346,
-      345,  344,  343,  339,  338,  337,  336,  335,  334,  331,
-      329,  328,  327,  326,  325,  324,  323,  322,  321,  320,
-      319,  318,  316,  315,  314,  312,   18,   18,   21,   21,
-
-       21,   21,   21,   21,  310,   21,   21,   21,   21,  309,
-       21,  308,  307,  306,  305,  304,  302,  301,  299,  296,
-      295,  294,  293,  292,  291,  290,  288,  287,  286,  285,
-      284,  283,  282,  281,  280,  279,  278,  277,  276,  275,
-      273,  272,   21,   21,   22,   22,   22,   22,   22,   22,
-      271,   22,   22,   22,   22,  270,   22,  269,  268,  267,
-      266,  265,  264,  263,  262,  261,  260,  259,  258,  257,
-      255,  253,  252,  251,  250,  249,  247,  246,  245,  244,
-      242,  241,  240,  239,  238,  235,  234,  233,   22,   22,
-       60,  232,   60,   60,  231,  230,   60,   60,   60,   60,
-
-      229,  227,  226,   60,   60,   60,   60,   60,   60,  183,
-      183,  225,  224,  183,  183,  183,  183,  221,  219,  218,
-      183,  183,  183,  183,  183,  183,  223,  223,  217,  216,
-      223,  223,  223,  223,  215,  214,  213,  223,  223,  223,
-      223,  223,  223,  517,  517,  517,  518,  518,  518,  519,
-      519,  519,  520,  520,  520,  521,  521,  521,  522,  522,
-      522,  523,  523,  523,  524,  212,  524,  530,  530,  530,
-      532,  532,  532,  211,  208,  207,  206,  204,  202,  201,
-      200,  199,  198,  197,  196,  193,  191,  190,  189,  188,
-      187,  186,  185,  182,  181,  180,  179,  178,  177,  176,
-
-      175,  174,  172,  171,  170,  169,  168,  167,  166,  164,
-      163,  162,  160,  159,  157,  156,  155,  154,  153,  152,
-      151,  150,  149,  148,  147,  146,  144,  138,  124,  113,
-      112,  110,  108,  105,  104,  103,  102,  101,  100,   98,
-       97,   96,   95,   94,   93,   92,   91,   90,   89,   87,
-       86,   79,   78,   77,   73,   65,   64,   53,   49,   47,
-       46,   43,   41,   39,   29,   27,   25,   24,   23,   20,
-       19,  516,  516,  516,  516,  516,  516,  516,  516,  516,
-      516,  516,  516,  516,  516,  516,  516,  516,  516,  516,
-      516,  516,  516,  516,  516,  516,  516,  516,  516,  516,
-
-      516,  516,  516,  516,  516,  516,  516,  516,  516,  516,
-      516,  516,  516,  516,  516,  516,  516,  516
-    } ;
-
-static yy_state_type yy_last_accepting_state;
-static char *yy_last_accepting_cpos;
-
-/* The intent behind this definition is that it'll catch
- * any uses of REJECT which flex missed.
- */
-#define REJECT reject_used_but_not_detected
-#define yymore() yymore_used_but_not_detected
-#define YY_MORE_ADJ 0
-#define YY_RESTORE_YY_MORE_OFFSET
-char *yytext;
-#line 1 "cftoken.l"
-#define INITIAL 0
-/*	$KAME: cftoken.l,v 1.35 2005/01/12 06:06:11 suz Exp $	*/
-#line 4 "cftoken.l"
-/*
- * Copyright (C) 2002 WIDE Project.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. Neither the name of the project nor the names of its contributors
- *    may be used to endorse or promote products derived from this software
- *    without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- */
-#include <sys/types.h>
-#include <sys/param.h>
-#include <sys/socket.h>
-#include <sys/queue.h>
-#include <sys/time.h>
-
-#include <netinet/in.h>
-
-#include <errno.h>
-#include <syslog.h>
-#include <string.h>
-#ifdef HAVE_STDARG_H
-#include <stdarg.h>
-#else
-#include <varargs.h>
-#endif
-
-#include "dhcp6.h"
-#include "config.h"
-#include "common.h"
-#include "y.tab.h"
-
-#define YY_NO_UNPUT 1
-
-char *configfilename;
-int lineno = 1;
-
-
-/* Recursion limit for includes */
-#define MAX_INCLUDE_DEPTH 10
-
-static struct include_stack {
-	char *path;
-	YY_BUFFER_STATE state;
-	int lineno;
-} incstack[MAX_INCLUDE_DEPTH];
-int incstackp = 0;
-
-
-static int yy_first_time = 1;
-static int yyerrorcount = 0;
- 
-#ifndef NOCONFIG_DEBUG
-#define YYDEBUG 1
-
-int cfdebug = 1;
-#else
-int cfdebug = 0;
-#endif
-
-extern int yyparse __P((void));
-extern int cf_post_config __P((void));
-
-static void cfdebug_print __P((char *, char *, int));
-
-#define DP(str) if (cfdebug) cfdebug_print(str, yytext, yyleng)
-#define DECHO if (cfdebug) cfdebug_print(NULL, yytext, yyleng);
-#define DNOECHO if (cfdebug) cfdebug_print(NULL, "****", yyleng);
-/* abbreviations */
-#define S_CNF 1
-
-#define S_IFACE 2
-
-#define S_PREF 3
-
-#define S_HOST 4
-
-#define S_DUID 5
-
-#define S_IA 6
-
-#define S_AUTH 7
-
-#define S_KEY 8
-
-#define S_SECRET 9
-
-#define S_ADDRPOOL 10
-
-#define S_INCL 11
-
-#line 835 "lex.yy.c"
-
-/* Macros after this point can all be overridden by user definitions in
- * section 1.
- */
-
-#ifndef YY_SKIP_YYWRAP
-#ifdef __cplusplus
-extern "C" int yywrap YY_PROTO(( void ));
-#else
-extern int yywrap YY_PROTO(( void ));
-#endif
-#endif
-
-#ifndef YY_NO_UNPUT
-static void yyunput YY_PROTO(( int c, char *buf_ptr ));
-#endif
-
-#ifndef yytext_ptr
-static void yy_flex_strncpy YY_PROTO(( char *, yyconst char *, int ));
-#endif
-
-#ifdef YY_NEED_STRLEN
-static int yy_flex_strlen YY_PROTO(( yyconst char * ));
-#endif
-
-#ifndef YY_NO_INPUT
-#ifdef __cplusplus
-static int yyinput YY_PROTO(( void ));
-#else
-static int input YY_PROTO(( void ));
-#endif
-#endif
-
-#if YY_STACK_USED
-static int yy_start_stack_ptr = 0;
-static int yy_start_stack_depth = 0;
-static int *yy_start_stack = 0;
-#ifndef YY_NO_PUSH_STATE
-static void yy_push_state YY_PROTO(( int new_state ));
-#endif
-#ifndef YY_NO_POP_STATE
-static void yy_pop_state YY_PROTO(( void ));
-#endif
-#ifndef YY_NO_TOP_STATE
-static int yy_top_state YY_PROTO(( void ));
-#endif
-
-#else
-#define YY_NO_PUSH_STATE 1
-#define YY_NO_POP_STATE 1
-#define YY_NO_TOP_STATE 1
-#endif
-
-#ifdef YY_MALLOC_DECL
-YY_MALLOC_DECL
-#else
-#if __STDC__
-#ifndef __cplusplus
-#include <stdlib.h>
-#endif
-#else
-/* Just try to get by without declaring the routines.  This will fail
- * miserably on non-ANSI systems for which sizeof(size_t) != sizeof(int)
- * or sizeof(void*) != sizeof(int).
- */
-#endif
-#endif
-
-/* Amount of stuff to slurp up with each read. */
-#ifndef YY_READ_BUF_SIZE
-#define YY_READ_BUF_SIZE 8192
-#endif
-
-/* Copy whatever the last rule matched to the standard output. */
-
-#ifndef ECHO
-/* This used to be an fputs(), but since the string might contain NUL's,
- * we now use fwrite().
- */
-#define ECHO (void) fwrite( yytext, yyleng, 1, yyout )
-#endif
-
-/* Gets input and stuffs it into "buf".  number of characters read, or YY_NULL,
- * is returned in "result".
- */
-#ifndef YY_INPUT
-#define YY_INPUT(buf,result,max_size) \
-	if ( yy_current_buffer->yy_is_interactive ) \
-		{ \
-		int c = '*', n; \
-		for ( n = 0; n < max_size && \
-			     (c = getc( yyin )) != EOF && c != '\n'; ++n ) \
-			buf[n] = (char) c; \
-		if ( c == '\n' ) \
-			buf[n++] = (char) c; \
-		if ( c == EOF && ferror( yyin ) ) \
-			YY_FATAL_ERROR( "input in flex scanner failed" ); \
-		result = n; \
-		} \
-	else if ( ((result = fread( buf, 1, max_size, yyin )) == 0) \
-		  && ferror( yyin ) ) \
-		YY_FATAL_ERROR( "input in flex scanner failed" );
-#endif
-
-/* No semi-colon after return; correct usage is to write "yyterminate();" -
- * we don't want an extra ';' after the "return" because that will cause
- * some compilers to complain about unreachable statements.
- */
-#ifndef yyterminate
-#define yyterminate() return YY_NULL
-#endif
-
-/* Number of entries by which start-condition stack grows. */
-#ifndef YY_START_STACK_INCR
-#define YY_START_STACK_INCR 25
-#endif
-
-/* Report a fatal error. */
-#ifndef YY_FATAL_ERROR
-#define YY_FATAL_ERROR(msg) yy_fatal_error( msg )
-#endif
-
-/* Default declaration of generated scanner - a define so the user can
- * easily add parameters.
- */
-#ifndef YY_DECL
-#define YY_DECL int yylex YY_PROTO(( void ))
-#endif
-
-/* Code executed at the beginning of each rule, after yytext and yyleng
- * have been set up.
- */
-#ifndef YY_USER_ACTION
-#define YY_USER_ACTION
-#endif
-
-/* Code executed at the end of each rule. */
-#ifndef YY_BREAK
-#define YY_BREAK break;
-#endif
-
-#define YY_RULE_SETUP \
-	YY_USER_ACTION
-
-YY_DECL
-	{
-	register yy_state_type yy_current_state;
-	register char *yy_cp, *yy_bp;
-	register int yy_act;
-
-#line 124 "cftoken.l"
-
-
-	if (yy_first_time) {
-		BEGIN S_CNF;
-		yy_first_time = 0;
-	}
-
-	/* interface configuration */
-#line 995 "lex.yy.c"
-
-	if ( yy_init )
-		{
-		yy_init = 0;
-
-#ifdef YY_USER_INIT
-		YY_USER_INIT;
-#endif
-
-		if ( ! yy_start )
-			yy_start = 1;	/* first start state */
-
-		if ( ! yyin )
-			yyin = stdin;
-
-		if ( ! yyout )
-			yyout = stdout;
-
-		if ( ! yy_current_buffer )
-			yy_current_buffer =
-				yy_create_buffer( yyin, YY_BUF_SIZE );
-
-		yy_load_buffer_state();
-		}
-
-	while ( 1 )		/* loops until end-of-file is reached */
-		{
-		yy_cp = yy_c_buf_p;
-
-		/* Support of yytext. */
-		*yy_cp = yy_hold_char;
-
-		/* yy_bp points to the position in yy_ch_buf of the start of
-		 * the current run.
-		 */
-		yy_bp = yy_cp;
-
-		yy_current_state = yy_start;
-yy_match:
-		do
-			{
-			register YY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)];
-			if ( yy_accept[yy_current_state] )
-				{
-				yy_last_accepting_state = yy_current_state;
-				yy_last_accepting_cpos = yy_cp;
-				}
-			while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
-				{
-				yy_current_state = (int) yy_def[yy_current_state];
-				if ( yy_current_state >= 517 )
-					yy_c = yy_meta[(unsigned int) yy_c];
-				}
-			yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
-			++yy_cp;
-			}
-		while ( yy_base[yy_current_state] != 772 );
-
-yy_find_action:
-		yy_act = yy_accept[yy_current_state];
-		if ( yy_act == 0 )
-			{ /* have to back up */
-			yy_cp = yy_last_accepting_cpos;
-			yy_current_state = yy_last_accepting_state;
-			yy_act = yy_accept[yy_current_state];
-			}
-
-		YY_DO_BEFORE_ACTION;
-
-
-do_action:	/* This label is used only to access EOF actions. */
-
-
-		switch ( yy_act )
-	{ /* beginning of action switch */
-			case 0: /* must back up */
-			/* undo the effects of YY_DO_BEFORE_ACTION */
-			*yy_cp = yy_hold_char;
-			yy_cp = yy_last_accepting_cpos;
-			yy_current_state = yy_last_accepting_state;
-			goto yy_find_action;
-
-case 1:
-YY_RULE_SETUP
-#line 132 "cftoken.l"
-{ DECHO; BEGIN S_IFACE; return (INTERFACE); }
-	YY_BREAK
-case 2:
-YY_RULE_SETUP
-#line 133 "cftoken.l"
-{
-	DECHO;
-	yylval.str = strdup(yytext);
-	BEGIN S_CNF;
-	return (IFNAME);
-}
-	YY_BREAK
-/* host configuration */
-case 3:
-YY_RULE_SETUP
-#line 141 "cftoken.l"
-{ DECHO; BEGIN S_HOST; return (HOST); }
-	YY_BREAK
-case 4:
-YY_RULE_SETUP
-#line 142 "cftoken.l"
-{
-	DECHO;
-	yylval.str = strdup(yytext);
-	BEGIN S_CNF;
-	return (HOSTNAME);
-}
-	YY_BREAK
-/* address pool configuration */
-case 5:
-YY_RULE_SETUP
-#line 150 "cftoken.l"
-{ DECHO; BEGIN S_ADDRPOOL; return (ADDRPOOL); }  
-	YY_BREAK
-case 6:
-YY_RULE_SETUP
-#line 152 "cftoken.l"
-{
-	DECHO;
-	yylval.str = strdup(yytext);
-	BEGIN S_CNF;
-	return (POOLNAME);
-}
-	YY_BREAK
-case 7:
-YY_RULE_SETUP
-#line 159 "cftoken.l"
-{ DECHO; BEGIN S_DUID; return (DUID); }
-	YY_BREAK
-case 8:
-YY_RULE_SETUP
-#line 160 "cftoken.l"
-{
-	DECHO;
-	yylval.str = strdup(yytext);
-	BEGIN S_CNF;
-	return (DUID_ID);
-}
-	YY_BREAK
-case 9:
-YY_RULE_SETUP
-#line 167 "cftoken.l"
-{ DECHO; return (ADDRESS); }
-	YY_BREAK
-case 10:
-YY_RULE_SETUP
-#line 169 "cftoken.l"
-{ DECHO; return (PREFIX); }
-	YY_BREAK
-case 11:
-YY_RULE_SETUP
-#line 171 "cftoken.l"
-{ DECHO; return (PREFERENCE); }
-	YY_BREAK
-case 12:
-YY_RULE_SETUP
-#line 173 "cftoken.l"
-{ DECHO; return (SCRIPT); }
-	YY_BREAK
-case 13:
-YY_RULE_SETUP
-#line 175 "cftoken.l"
-{ DECHO; return (DELAYEDKEY); }
-	YY_BREAK
-/* request */
-case 14:
-YY_RULE_SETUP
-#line 178 "cftoken.l"
-{ DECHO; return (REQUEST); }
-	YY_BREAK
-/* send */
-case 15:
-YY_RULE_SETUP
-#line 181 "cftoken.l"
-{ DECHO; return (SEND); }
-	YY_BREAK
-/* range */
-case 16:
-YY_RULE_SETUP
-#line 184 "cftoken.l"
-{ DECHO; return (RANGE); }
-	YY_BREAK
-case 17:
-YY_RULE_SETUP
-#line 185 "cftoken.l"
-{ DECHO; return (TO); }
-	YY_BREAK
-/* address-pool */
-case 18:
-YY_RULE_SETUP
-#line 188 "cftoken.l"
-{ DECHO; return (ADDRESS_POOL); }
-	YY_BREAK
-/* DHCP options */
-case 19:
-YY_RULE_SETUP
-#line 191 "cftoken.l"
-{ DECHO; return (OPTION); }
-	YY_BREAK
-case 20:
-YY_RULE_SETUP
-#line 193 "cftoken.l"
-{ DECHO; return (RAPID_COMMIT); }
-	YY_BREAK
-case 21:
-YY_RULE_SETUP
-#line 194 "cftoken.l"
-{ DECHO; return (IA_PD); }
-	YY_BREAK
-case 22:
-YY_RULE_SETUP
-#line 195 "cftoken.l"
-{ DECHO; return (IA_NA); }
-	YY_BREAK
-case 23:
-YY_RULE_SETUP
-#line 196 "cftoken.l"
-{ DECHO; return (DNS_SERVERS); }
-	YY_BREAK
-case 24:
-YY_RULE_SETUP
-#line 197 "cftoken.l"
-{ DECHO; return (DNS_NAME); }
-	YY_BREAK
-case 25:
-YY_RULE_SETUP
-#line 198 "cftoken.l"
-{ DECHO; return (SIP_SERVERS); }
-	YY_BREAK
-case 26:
-YY_RULE_SETUP
-#line 199 "cftoken.l"
-{ DECHO; return (SIP_NAME); }
-	YY_BREAK
-case 27:
-YY_RULE_SETUP
-#line 200 "cftoken.l"
-{ DECHO; return (NTP_SERVERS); }
-	YY_BREAK
-case 28:
-YY_RULE_SETUP
-#line 201 "cftoken.l"
-{ DECHO; return (NIS_SERVERS); }
-	YY_BREAK
-case 29:
-YY_RULE_SETUP
-#line 202 "cftoken.l"
-{ DECHO; return (NIS_NAME); }
-	YY_BREAK
-case 30:
-YY_RULE_SETUP
-#line 203 "cftoken.l"
-{ DECHO; return (NISP_SERVERS); }
-	YY_BREAK
-case 31:
-YY_RULE_SETUP
-#line 204 "cftoken.l"
-{ DECHO; return (NISP_NAME); }
-	YY_BREAK
-case 32:
-YY_RULE_SETUP
-#line 205 "cftoken.l"
-{ DECHO; return (BCMCS_SERVERS); }
-	YY_BREAK
-case 33:
-YY_RULE_SETUP
-#line 206 "cftoken.l"
-{ DECHO; return (BCMCS_NAME); }
-	YY_BREAK
-case 34:
-YY_RULE_SETUP
-#line 207 "cftoken.l"
-{ DECHO; return (REFRESHTIME); }
-	YY_BREAK
-/* provided for a backward compatibility to WIDE-DHCPv6 before Oct 1 2006 */
-case 35:
-YY_RULE_SETUP
-#line 210 "cftoken.l"
-{ DECHO; return (NIS_NAME); }
-	YY_BREAK
-case 36:
-YY_RULE_SETUP
-#line 211 "cftoken.l"
-{ DECHO; return (NISP_NAME); }	
-	YY_BREAK
-/* generic options */
-case 37:
-YY_RULE_SETUP
-#line 214 "cftoken.l"
-{ DECHO; return (INFO_ONLY); }
-	YY_BREAK
-case 38:
-YY_RULE_SETUP
-#line 216 "cftoken.l"
-{ DECHO; return (ALLOW); }
-	YY_BREAK
-/* identity association */
-case 39:
-YY_RULE_SETUP
-#line 219 "cftoken.l"
-{ DECHO; BEGIN S_IA; return(ID_ASSOC); }
-	YY_BREAK
-case 40:
-YY_RULE_SETUP
-#line 220 "cftoken.l"
-{ DECHO; return(IA_PD); }
-	YY_BREAK
-case 41:
-YY_RULE_SETUP
-#line 221 "cftoken.l"
-{ DECHO; return(IA_NA); }
-	YY_BREAK
-case 42:
-YY_RULE_SETUP
-#line 222 "cftoken.l"
-{ DECHO; yylval.str = strdup(yytext); return(IAID); }
-	YY_BREAK
-case 43:
-YY_RULE_SETUP
-#line 223 "cftoken.l"
-{ DP("begin of closure"); BEGIN S_CNF; return (BCL); }
-	YY_BREAK
-/*
-	 * interface parameters for delegated prefix configuration.
-	 * when lex reads an interface name, the state will be back to
-	 * S_CNF.
-	 */
-case 44:
-YY_RULE_SETUP
-#line 230 "cftoken.l"
-{ DECHO; BEGIN S_IFACE; return (PREFIX_INTERFACE); }
-	YY_BREAK
-case 45:
-YY_RULE_SETUP
-#line 231 "cftoken.l"
-{ DECHO; return (SLA_ID); }
-	YY_BREAK
-case 46:
-YY_RULE_SETUP
-#line 232 "cftoken.l"
-{ DECHO; return (SLA_LEN); }
-	YY_BREAK
-/* duration */
-case 47:
-YY_RULE_SETUP
-#line 235 "cftoken.l"
-{ DECHO; return (INFINITY); }
-	YY_BREAK
-/* authentication option */
-case 48:
-YY_RULE_SETUP
-#line 238 "cftoken.l"
-{ DECHO; BEGIN S_AUTH; return (AUTHENTICATION); }
-	YY_BREAK
-case 49:
-YY_RULE_SETUP
-#line 239 "cftoken.l"
-{
-	DECHO;
-	yylval.str = strdup(yytext);
-	BEGIN S_CNF;
-	return (AUTHNAME);
-}
-	YY_BREAK
-/* authentication parameters */
-case 50:
-YY_RULE_SETUP
-#line 247 "cftoken.l"
-{ DECHO; return (PROTOCOL); };
-	YY_BREAK
-case 51:
-YY_RULE_SETUP
-#line 248 "cftoken.l"
-{ DECHO; return (ALGORITHM); };
-	YY_BREAK
-case 52:
-YY_RULE_SETUP
-#line 249 "cftoken.l"
-{ DECHO; return (RDM); };
-	YY_BREAK
-case 53:
-YY_RULE_SETUP
-#line 250 "cftoken.l"
-{ DECHO; return (KEY); };
-	YY_BREAK
-/* authentication protocols */
-case 54:
-YY_RULE_SETUP
-#line 253 "cftoken.l"
-{ DECHO; return (DELAYED); };
-	YY_BREAK
-case 55:
-YY_RULE_SETUP
-#line 254 "cftoken.l"
-{ DECHO; return (RECONFIG); };
-	YY_BREAK
-/* authentication algorithms */
-case 56:
-YY_RULE_SETUP
-#line 257 "cftoken.l"
-{ DECHO; return (HMACMD5); };
-	YY_BREAK
-case 57:
-YY_RULE_SETUP
-#line 258 "cftoken.l"
-{ DECHO; return (HMACMD5); };
-	YY_BREAK
-case 58:
-YY_RULE_SETUP
-#line 259 "cftoken.l"
-{ DECHO; return (HMACMD5); };
-	YY_BREAK
-case 59:
-YY_RULE_SETUP
-#line 260 "cftoken.l"
-{ DECHO; return (HMACMD5); };
-	YY_BREAK
-/* authentication RDM */
-case 60:
-YY_RULE_SETUP
-#line 263 "cftoken.l"
-{ DECHO; return (MONOCOUNTER); };
-	YY_BREAK
-/* secret keys */
-case 61:
-YY_RULE_SETUP
-#line 266 "cftoken.l"
-{ DECHO; BEGIN S_KEY; return (KEYINFO); }
-	YY_BREAK
-case 62:
-YY_RULE_SETUP
-#line 267 "cftoken.l"
-{
-	DECHO;
-	yylval.str = strdup(yytext);
-	BEGIN S_CNF;
-	return (KEYNAME);
-}
-	YY_BREAK
-/* key parameters */
-case 63:
-YY_RULE_SETUP
-#line 275 "cftoken.l"
-{ DECHO; return (REALM); }
-	YY_BREAK
-case 64:
-YY_RULE_SETUP
-#line 276 "cftoken.l"
-{ DECHO; return (KEYID); }
-	YY_BREAK
-case 65:
-YY_RULE_SETUP
-#line 277 "cftoken.l"
-{ DECHO; BEGIN S_SECRET; return (SECRET); }
-	YY_BREAK
-case 66:
-YY_RULE_SETUP
-#line 278 "cftoken.l"
-{
-	DNOECHO;
-	yylval.str = strdup(yytext);
-	BEGIN S_CNF;
-	return (QSTRING);
-}
-	YY_BREAK
-case 67:
-YY_RULE_SETUP
-#line 284 "cftoken.l"
-{ DECHO; return (EXPIRE); }
-	YY_BREAK
-/* include */
-case 68:
-YY_RULE_SETUP
-#line 287 "cftoken.l"
-{ DECHO; BEGIN S_INCL; return (INCLUDE); }
-	YY_BREAK
-case 69:
-YY_RULE_SETUP
-#line 288 "cftoken.l"
-{
-	DECHO;
-	yylval.str = strdup(yytext);
-	BEGIN S_CNF;
-	return (QSTRING);
-}
-	YY_BREAK
-/* quoted string */
-case 70:
-YY_RULE_SETUP
-#line 296 "cftoken.l"
-{
-		DECHO;
-		yylval.str = strdup(yytext);
-		return (QSTRING);
-	}
-	YY_BREAK
-/* misc */
-case 71:
-YY_RULE_SETUP
-#line 303 "cftoken.l"
-{ ; }
-	YY_BREAK
-case 72:
-YY_RULE_SETUP
-#line 304 "cftoken.l"
-{ lineno++; }
-	YY_BREAK
-case 73:
-YY_RULE_SETUP
-#line 305 "cftoken.l"
-{ DP("comment"); }
-	YY_BREAK
-case 74:
-YY_RULE_SETUP
-#line 306 "cftoken.l"
-{
-	DECHO;
-	yylval.num = strtoll(yytext, NULL, 10);
-	return (NUMBER);
-}
-	YY_BREAK
-case 75:
-YY_RULE_SETUP
-#line 311 "cftoken.l"
-{ DECHO; return (SLASH); }
-	YY_BREAK
-case 76:
-YY_RULE_SETUP
-#line 312 "cftoken.l"
-{ DECHO; return (COMMA); }
-	YY_BREAK
-case 77:
-YY_RULE_SETUP
-#line 313 "cftoken.l"
-{ DP("end of sentence"); return (EOS); }
-	YY_BREAK
-case 78:
-YY_RULE_SETUP
-#line 314 "cftoken.l"
-{ DP("begin of closure"); return (BCL); }
-	YY_BREAK
-case 79:
-YY_RULE_SETUP
-#line 315 "cftoken.l"
-{ DP("end of closure"); return (ECL); }
-	YY_BREAK
-/* generic string */
-case 80:
-YY_RULE_SETUP
-#line 318 "cftoken.l"
-{
-		DECHO;
-		yylval.str = strdup(yytext);
-		return (STRING);
-	}
-	YY_BREAK
-case YY_STATE_EOF(INITIAL):
-case YY_STATE_EOF(S_CNF):
-case YY_STATE_EOF(S_IFACE):
-case YY_STATE_EOF(S_PREF):
-case YY_STATE_EOF(S_HOST):
-case YY_STATE_EOF(S_DUID):
-case YY_STATE_EOF(S_IA):
-case YY_STATE_EOF(S_AUTH):
-case YY_STATE_EOF(S_KEY):
-case YY_STATE_EOF(S_SECRET):
-case YY_STATE_EOF(S_ADDRPOOL):
-case YY_STATE_EOF(S_INCL):
-#line 324 "cftoken.l"
-{
-		if (--incstackp < 0)
-			yyterminate();
-		else {
-			yy_delete_buffer(YY_CURRENT_BUFFER);
-			free(incstack[incstackp + 1].path);
-			configfilename = incstack[incstackp].path;
-			lineno = incstack[incstackp].lineno;
-			yy_switch_to_buffer(incstack[incstackp].state);
-		}
-	}
-	YY_BREAK
-case 81:
-YY_RULE_SETUP
-#line 336 "cftoken.l"
-ECHO;
-	YY_BREAK
-#line 1587 "lex.yy.c"
-
-	case YY_END_OF_BUFFER:
-		{
-		/* Amount of text matched not including the EOB char. */
-		int yy_amount_of_matched_text = (int) (yy_cp - yytext_ptr) - 1;
-
-		/* Undo the effects of YY_DO_BEFORE_ACTION. */
-		*yy_cp = yy_hold_char;
-		YY_RESTORE_YY_MORE_OFFSET
-
-		if ( yy_current_buffer->yy_buffer_status == YY_BUFFER_NEW )
-			{
-			/* We're scanning a new file or input source.  It's
-			 * possible that this happened because the user
-			 * just pointed yyin at a new source and called
-			 * yylex().  If so, then we have to assure
-			 * consistency between yy_current_buffer and our
-			 * globals.  Here is the right place to do so, because
-			 * this is the first action (other than possibly a
-			 * back-up) that will match for the new input source.
-			 */
-			yy_n_chars = yy_current_buffer->yy_n_chars;
-			yy_current_buffer->yy_input_file = yyin;
-			yy_current_buffer->yy_buffer_status = YY_BUFFER_NORMAL;
-			}
-
-		/* Note that here we test for yy_c_buf_p "<=" to the position
-		 * of the first EOB in the buffer, since yy_c_buf_p will
-		 * already have been incremented past the NUL character
-		 * (since all states make transitions on EOB to the
-		 * end-of-buffer state).  Contrast this with the test
-		 * in input().
-		 */
-		if ( yy_c_buf_p <= &yy_current_buffer->yy_ch_buf[yy_n_chars] )
-			{ /* This was really a NUL. */
-			yy_state_type yy_next_state;
-
-			yy_c_buf_p = yytext_ptr + yy_amount_of_matched_text;
-
-			yy_current_state = yy_get_previous_state();
-
-			/* Okay, we're now positioned to make the NUL
-			 * transition.  We couldn't have
-			 * yy_get_previous_state() go ahead and do it
-			 * for us because it doesn't know how to deal
-			 * with the possibility of jamming (and we don't
-			 * want to build jamming into it because then it
-			 * will run more slowly).
-			 */
-
-			yy_next_state = yy_try_NUL_trans( yy_current_state );
-
-			yy_bp = yytext_ptr + YY_MORE_ADJ;
-
-			if ( yy_next_state )
-				{
-				/* Consume the NUL. */
-				yy_cp = ++yy_c_buf_p;
-				yy_current_state = yy_next_state;
-				goto yy_match;
-				}
-
-			else
-				{
-				yy_cp = yy_c_buf_p;
-				goto yy_find_action;
-				}
-			}
-
-		else switch ( yy_get_next_buffer() )
-			{
-			case EOB_ACT_END_OF_FILE:
-				{
-				yy_did_buffer_switch_on_eof = 0;
-
-				if ( yywrap() )
-					{
-					/* Note: because we've taken care in
-					 * yy_get_next_buffer() to have set up
-					 * yytext, we can now set up
-					 * yy_c_buf_p so that if some total
-					 * hoser (like flex itself) wants to
-					 * call the scanner after we return the
-					 * YY_NULL, it'll still work - another
-					 * YY_NULL will get returned.
-					 */
-					yy_c_buf_p = yytext_ptr + YY_MORE_ADJ;
-
-					yy_act = YY_STATE_EOF(YY_START);
-					goto do_action;
-					}
-
-				else
-					{
-					if ( ! yy_did_buffer_switch_on_eof )
-						YY_NEW_FILE;
-					}
-				break;
-				}
-
-			case EOB_ACT_CONTINUE_SCAN:
-				yy_c_buf_p =
-					yytext_ptr + yy_amount_of_matched_text;
-
-				yy_current_state = yy_get_previous_state();
-
-				yy_cp = yy_c_buf_p;
-				yy_bp = yytext_ptr + YY_MORE_ADJ;
-				goto yy_match;
-
-			case EOB_ACT_LAST_MATCH:
-				yy_c_buf_p =
-				&yy_current_buffer->yy_ch_buf[yy_n_chars];
-
-				yy_current_state = yy_get_previous_state();
-
-				yy_cp = yy_c_buf_p;
-				yy_bp = yytext_ptr + YY_MORE_ADJ;
-				goto yy_find_action;
-			}
-		break;
-		}
-
-	default:
-		YY_FATAL_ERROR(
-			"fatal flex scanner internal error--no action found" );
-	} /* end of action switch */
-		} /* end of scanning one token */
-	} /* end of yylex */
-
-
-/* yy_get_next_buffer - try to read in a new buffer
- *
- * Returns a code representing an action:
- *	EOB_ACT_LAST_MATCH -
- *	EOB_ACT_CONTINUE_SCAN - continue scanning from current position
- *	EOB_ACT_END_OF_FILE - end of file
- */
-
-static int yy_get_next_buffer()
-	{
-	register char *dest = yy_current_buffer->yy_ch_buf;
-	register char *source = yytext_ptr;
-	register int number_to_move, i;
-	int ret_val;
-
-	if ( yy_c_buf_p > &yy_current_buffer->yy_ch_buf[yy_n_chars + 1] )
-		YY_FATAL_ERROR(
-		"fatal flex scanner internal error--end of buffer missed" );
-
-	if ( yy_current_buffer->yy_fill_buffer == 0 )
-		{ /* Don't try to fill the buffer, so this is an EOF. */
-		if ( yy_c_buf_p - yytext_ptr - YY_MORE_ADJ == 1 )
-			{
-			/* We matched a single character, the EOB, so
-			 * treat this as a final EOF.
-			 */
-			return EOB_ACT_END_OF_FILE;
-			}
-
-		else
-			{
-			/* We matched some text prior to the EOB, first
-			 * process it.
-			 */
-			return EOB_ACT_LAST_MATCH;
-			}
-		}
-
-	/* Try to read more data. */
-
-	/* First move last chars to start of buffer. */
-	number_to_move = (int) (yy_c_buf_p - yytext_ptr) - 1;
-
-	for ( i = 0; i < number_to_move; ++i )
-		*(dest++) = *(source++);
-
-	if ( yy_current_buffer->yy_buffer_status == YY_BUFFER_EOF_PENDING )
-		/* don't do the read, it's not guaranteed to return an EOF,
-		 * just force an EOF
-		 */
-		yy_current_buffer->yy_n_chars = yy_n_chars = 0;
-
-	else
-		{
-		int num_to_read =
-			yy_current_buffer->yy_buf_size - number_to_move - 1;
-
-		while ( num_to_read <= 0 )
-			{ /* Not enough room in the buffer - grow it. */
-#ifdef YY_USES_REJECT
-			YY_FATAL_ERROR(
-"input buffer overflow, can't enlarge buffer because scanner uses REJECT" );
-#else
-
-			/* just a shorter name for the current buffer */
-			YY_BUFFER_STATE b = yy_current_buffer;
-
-			int yy_c_buf_p_offset =
-				(int) (yy_c_buf_p - b->yy_ch_buf);
-
-			if ( b->yy_is_our_buffer )
-				{
-				int new_size = b->yy_buf_size * 2;
-
-				if ( new_size <= 0 )
-					b->yy_buf_size += b->yy_buf_size / 8;
-				else
-					b->yy_buf_size *= 2;
-
-				b->yy_ch_buf = (char *)
-					/* Include room in for 2 EOB chars. */
-					yy_flex_realloc( (void *) b->yy_ch_buf,
-							 b->yy_buf_size + 2 );
-				}
-			else
-				/* Can't grow it, we don't own it. */
-				b->yy_ch_buf = 0;
-
-			if ( ! b->yy_ch_buf )
-				YY_FATAL_ERROR(
-				"fatal error - scanner input buffer overflow" );
-
-			yy_c_buf_p = &b->yy_ch_buf[yy_c_buf_p_offset];
-
-			num_to_read = yy_current_buffer->yy_buf_size -
-						number_to_move - 1;
-#endif
-			}
-
-		if ( num_to_read > YY_READ_BUF_SIZE )
-			num_to_read = YY_READ_BUF_SIZE;
-
-		/* Read in more data. */
-		YY_INPUT( (&yy_current_buffer->yy_ch_buf[number_to_move]),
-			yy_n_chars, num_to_read );
-
-		yy_current_buffer->yy_n_chars = yy_n_chars;
-		}
-
-	if ( yy_n_chars == 0 )
-		{
-		if ( number_to_move == YY_MORE_ADJ )
-			{
-			ret_val = EOB_ACT_END_OF_FILE;
-			yyrestart( yyin );
-			}
-
-		else
-			{
-			ret_val = EOB_ACT_LAST_MATCH;
-			yy_current_buffer->yy_buffer_status =
-				YY_BUFFER_EOF_PENDING;
-			}
-		}
-
-	else
-		ret_val = EOB_ACT_CONTINUE_SCAN;
-
-	yy_n_chars += number_to_move;
-	yy_current_buffer->yy_ch_buf[yy_n_chars] = YY_END_OF_BUFFER_CHAR;
-	yy_current_buffer->yy_ch_buf[yy_n_chars + 1] = YY_END_OF_BUFFER_CHAR;
-
-	yytext_ptr = &yy_current_buffer->yy_ch_buf[0];
-
-	return ret_val;
-	}
-
-
-/* yy_get_previous_state - get the state just before the EOB char was reached */
-
-static yy_state_type yy_get_previous_state()
-	{
-	register yy_state_type yy_current_state;
-	register char *yy_cp;
-
-	yy_current_state = yy_start;
-
-	for ( yy_cp = yytext_ptr + YY_MORE_ADJ; yy_cp < yy_c_buf_p; ++yy_cp )
-		{
-		register YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);
-		if ( yy_accept[yy_current_state] )
-			{
-			yy_last_accepting_state = yy_current_state;
-			yy_last_accepting_cpos = yy_cp;
-			}
-		while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
-			{
-			yy_current_state = (int) yy_def[yy_current_state];
-			if ( yy_current_state >= 517 )
-				yy_c = yy_meta[(unsigned int) yy_c];
-			}
-		yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
-		}
-
-	return yy_current_state;
-	}
-
-
-/* yy_try_NUL_trans - try to make a transition on the NUL character
- *
- * synopsis
- *	next_state = yy_try_NUL_trans( current_state );
- */
-
-#ifdef YY_USE_PROTOS
-static yy_state_type yy_try_NUL_trans( yy_state_type yy_current_state )
-#else
-static yy_state_type yy_try_NUL_trans( yy_current_state )
-yy_state_type yy_current_state;
-#endif
-	{
-	register int yy_is_jam;
-	register char *yy_cp = yy_c_buf_p;
-
-	register YY_CHAR yy_c = 1;
-	if ( yy_accept[yy_current_state] )
-		{
-		yy_last_accepting_state = yy_current_state;
-		yy_last_accepting_cpos = yy_cp;
-		}
-	while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
-		{
-		yy_current_state = (int) yy_def[yy_current_state];
-		if ( yy_current_state >= 517 )
-			yy_c = yy_meta[(unsigned int) yy_c];
-		}
-	yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
-	yy_is_jam = (yy_current_state == 516);
-
-	return yy_is_jam ? 0 : yy_current_state;
-	}
-
-
-#ifndef YY_NO_UNPUT
-#ifdef YY_USE_PROTOS
-static void yyunput( int c, register char *yy_bp )
-#else
-static void yyunput( c, yy_bp )
-int c;
-register char *yy_bp;
-#endif
-	{
-	register char *yy_cp = yy_c_buf_p;
-
-	/* undo effects of setting up yytext */
-	*yy_cp = yy_hold_char;
-
-	if ( yy_cp < yy_current_buffer->yy_ch_buf + 2 )
-		{ /* need to shift things up to make room */
-		/* +2 for EOB chars. */
-		register int number_to_move = yy_n_chars + 2;
-		register char *dest = &yy_current_buffer->yy_ch_buf[
-					yy_current_buffer->yy_buf_size + 2];
-		register char *source =
-				&yy_current_buffer->yy_ch_buf[number_to_move];
-
-		while ( source > yy_current_buffer->yy_ch_buf )
-			*--dest = *--source;
-
-		yy_cp += (int) (dest - source);
-		yy_bp += (int) (dest - source);
-		yy_current_buffer->yy_n_chars =
-			yy_n_chars = yy_current_buffer->yy_buf_size;
-
-		if ( yy_cp < yy_current_buffer->yy_ch_buf + 2 )
-			YY_FATAL_ERROR( "flex scanner push-back overflow" );
-		}
-
-	*--yy_cp = (char) c;
-
-
-	yytext_ptr = yy_bp;
-	yy_hold_char = *yy_cp;
-	yy_c_buf_p = yy_cp;
-	}
-#endif	/* ifndef YY_NO_UNPUT */
-
-
-#ifdef __cplusplus
-static int yyinput()
-#else
-static int input()
-#endif
-	{
-	int c;
-
-	*yy_c_buf_p = yy_hold_char;
-
-	if ( *yy_c_buf_p == YY_END_OF_BUFFER_CHAR )
-		{
-		/* yy_c_buf_p now points to the character we want to return.
-		 * If this occurs *before* the EOB characters, then it's a
-		 * valid NUL; if not, then we've hit the end of the buffer.
-		 */
-		if ( yy_c_buf_p < &yy_current_buffer->yy_ch_buf[yy_n_chars] )
-			/* This was really a NUL. */
-			*yy_c_buf_p = '\0';
-
-		else
-			{ /* need more input */
-			int offset = yy_c_buf_p - yytext_ptr;
-			++yy_c_buf_p;
-
-			switch ( yy_get_next_buffer() )
-				{
-				case EOB_ACT_LAST_MATCH:
-					/* This happens because yy_g_n_b()
-					 * sees that we've accumulated a
-					 * token and flags that we need to
-					 * try matching the token before
-					 * proceeding.  But for input(),
-					 * there's no matching to consider.
-					 * So convert the EOB_ACT_LAST_MATCH
-					 * to EOB_ACT_END_OF_FILE.
-					 */
-
-					/* Reset buffer status. */
-					yyrestart( yyin );
-
-					/* fall through */
-
-				case EOB_ACT_END_OF_FILE:
-					{
-					if ( yywrap() )
-						return EOF;
-
-					if ( ! yy_did_buffer_switch_on_eof )
-						YY_NEW_FILE;
-#ifdef __cplusplus
-					return yyinput();
-#else
-					return input();
-#endif
-					}
-
-				case EOB_ACT_CONTINUE_SCAN:
-					yy_c_buf_p = yytext_ptr + offset;
-					break;
-				}
-			}
-		}
-
-	c = *(unsigned char *) yy_c_buf_p;	/* cast for 8-bit char's */
-	*yy_c_buf_p = '\0';	/* preserve yytext */
-	yy_hold_char = *++yy_c_buf_p;
-
-
-	return c;
-	}
-
-
-#ifdef YY_USE_PROTOS
-void yyrestart( FILE *input_file )
-#else
-void yyrestart( input_file )
-FILE *input_file;
-#endif
-	{
-	if ( ! yy_current_buffer )
-		yy_current_buffer = yy_create_buffer( yyin, YY_BUF_SIZE );
-
-	yy_init_buffer( yy_current_buffer, input_file );
-	yy_load_buffer_state();
-	}
-
-
-#ifdef YY_USE_PROTOS
-void yy_switch_to_buffer( YY_BUFFER_STATE new_buffer )
-#else
-void yy_switch_to_buffer( new_buffer )
-YY_BUFFER_STATE new_buffer;
-#endif
-	{
-	if ( yy_current_buffer == new_buffer )
-		return;
-
-	if ( yy_current_buffer )
-		{
-		/* Flush out information for old buffer. */
-		*yy_c_buf_p = yy_hold_char;
-		yy_current_buffer->yy_buf_pos = yy_c_buf_p;
-		yy_current_buffer->yy_n_chars = yy_n_chars;
-		}
-
-	yy_current_buffer = new_buffer;
-	yy_load_buffer_state();
-
-	/* We don't actually know whether we did this switch during
-	 * EOF (yywrap()) processing, but the only time this flag
-	 * is looked at is after yywrap() is called, so it's safe
-	 * to go ahead and always set it.
-	 */
-	yy_did_buffer_switch_on_eof = 1;
-	}
-
-
-#ifdef YY_USE_PROTOS
-void yy_load_buffer_state( void )
-#else
-void yy_load_buffer_state()
-#endif
-	{
-	yy_n_chars = yy_current_buffer->yy_n_chars;
-	yytext_ptr = yy_c_buf_p = yy_current_buffer->yy_buf_pos;
-	yyin = yy_current_buffer->yy_input_file;
-	yy_hold_char = *yy_c_buf_p;
-	}
-
-
-#ifdef YY_USE_PROTOS
-YY_BUFFER_STATE yy_create_buffer( FILE *file, int size )
-#else
-YY_BUFFER_STATE yy_create_buffer( file, size )
-FILE *file;
-int size;
-#endif
-	{
-	YY_BUFFER_STATE b;
-
-	b = (YY_BUFFER_STATE) yy_flex_alloc( sizeof( struct yy_buffer_state ) );
-	if ( ! b )
-		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );
-
-	b->yy_buf_size = size;
-
-	/* yy_ch_buf has to be 2 characters longer than the size given because
-	 * we need to put in 2 end-of-buffer characters.
-	 */
-	b->yy_ch_buf = (char *) yy_flex_alloc( b->yy_buf_size + 2 );
-	if ( ! b->yy_ch_buf )
-		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );
-
-	b->yy_is_our_buffer = 1;
-
-	yy_init_buffer( b, file );
-
-	return b;
-	}
-
-
-#ifdef YY_USE_PROTOS
-void yy_delete_buffer( YY_BUFFER_STATE b )
-#else
-void yy_delete_buffer( b )
-YY_BUFFER_STATE b;
-#endif
-	{
-	if ( ! b )
-		return;
-
-	if ( b == yy_current_buffer )
-		yy_current_buffer = (YY_BUFFER_STATE) 0;
-
-	if ( b->yy_is_our_buffer )
-		yy_flex_free( (void *) b->yy_ch_buf );
-
-	yy_flex_free( (void *) b );
-	}
-
-
-#ifndef YY_ALWAYS_INTERACTIVE
-#ifndef YY_NEVER_INTERACTIVE
-extern int isatty YY_PROTO(( int ));
-#endif
-#endif
-
-#ifdef YY_USE_PROTOS
-void yy_init_buffer( YY_BUFFER_STATE b, FILE *file )
-#else
-void yy_init_buffer( b, file )
-YY_BUFFER_STATE b;
-FILE *file;
-#endif
-
-
-	{
-	yy_flush_buffer( b );
-
-	b->yy_input_file = file;
-	b->yy_fill_buffer = 1;
-
-#if YY_ALWAYS_INTERACTIVE
-	b->yy_is_interactive = 1;
-#else
-#if YY_NEVER_INTERACTIVE
-	b->yy_is_interactive = 0;
-#else
-	b->yy_is_interactive = file ? (isatty( fileno(file) ) > 0) : 0;
-#endif
-#endif
-	}
-
-
-#ifdef YY_USE_PROTOS
-void yy_flush_buffer( YY_BUFFER_STATE b )
-#else
-void yy_flush_buffer( b )
-YY_BUFFER_STATE b;
-#endif
-
-	{
-	if ( ! b )
-		return;
-
-	b->yy_n_chars = 0;
-
-	/* We always need two end-of-buffer characters.  The first causes
-	 * a transition to the end-of-buffer state.  The second causes
-	 * a jam in that state.
-	 */
-	b->yy_ch_buf[0] = YY_END_OF_BUFFER_CHAR;
-	b->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;
-
-	b->yy_buf_pos = &b->yy_ch_buf[0];
-
-	b->yy_at_bol = 1;
-	b->yy_buffer_status = YY_BUFFER_NEW;
-
-	if ( b == yy_current_buffer )
-		yy_load_buffer_state();
-	}
-
-
-#ifndef YY_NO_SCAN_BUFFER
-#ifdef YY_USE_PROTOS
-YY_BUFFER_STATE yy_scan_buffer( char *base, yy_size_t size )
-#else
-YY_BUFFER_STATE yy_scan_buffer( base, size )
-char *base;
-yy_size_t size;
-#endif
-	{
-	YY_BUFFER_STATE b;
-
-	if ( size < 2 ||
-	     base[size-2] != YY_END_OF_BUFFER_CHAR ||
-	     base[size-1] != YY_END_OF_BUFFER_CHAR )
-		/* They forgot to leave room for the EOB's. */
-		return 0;
-
-	b = (YY_BUFFER_STATE) yy_flex_alloc( sizeof( struct yy_buffer_state ) );
-	if ( ! b )
-		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_buffer()" );
-
-	b->yy_buf_size = size - 2;	/* "- 2" to take care of EOB's */
-	b->yy_buf_pos = b->yy_ch_buf = base;
-	b->yy_is_our_buffer = 0;
-	b->yy_input_file = 0;
-	b->yy_n_chars = b->yy_buf_size;
-	b->yy_is_interactive = 0;
-	b->yy_at_bol = 1;
-	b->yy_fill_buffer = 0;
-	b->yy_buffer_status = YY_BUFFER_NEW;
-
-	yy_switch_to_buffer( b );
-
-	return b;
-	}
-#endif
-
-
-#ifndef YY_NO_SCAN_STRING
-#ifdef YY_USE_PROTOS
-YY_BUFFER_STATE yy_scan_string( yyconst char *yy_str )
-#else
-YY_BUFFER_STATE yy_scan_string( yy_str )
-yyconst char *yy_str;
-#endif
-	{
-	int len;
-	for ( len = 0; yy_str[len]; ++len )
-		;
-
-	return yy_scan_bytes( yy_str, len );
-	}
-#endif
-
-
-#ifndef YY_NO_SCAN_BYTES
-#ifdef YY_USE_PROTOS
-YY_BUFFER_STATE yy_scan_bytes( yyconst char *bytes, int len )
-#else
-YY_BUFFER_STATE yy_scan_bytes( bytes, len )
-yyconst char *bytes;
-int len;
-#endif
-	{
-	YY_BUFFER_STATE b;
-	char *buf;
-	yy_size_t n;
-	int i;
-
-	/* Get memory for full buffer, including space for trailing EOB's. */
-	n = len + 2;
-	buf = (char *) yy_flex_alloc( n );
-	if ( ! buf )
-		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_bytes()" );
-
-	for ( i = 0; i < len; ++i )
-		buf[i] = bytes[i];
-
-	buf[len] = buf[len+1] = YY_END_OF_BUFFER_CHAR;
-
-	b = yy_scan_buffer( buf, n );
-	if ( ! b )
-		YY_FATAL_ERROR( "bad buffer in yy_scan_bytes()" );
-
-	/* It's okay to grow etc. this buffer, and we should throw it
-	 * away when we're done.
-	 */
-	b->yy_is_our_buffer = 1;
-
-	return b;
-	}
-#endif
-
-
-#ifndef YY_NO_PUSH_STATE
-#ifdef YY_USE_PROTOS
-static void yy_push_state( int new_state )
-#else
-static void yy_push_state( new_state )
-int new_state;
-#endif
-	{
-	if ( yy_start_stack_ptr >= yy_start_stack_depth )
-		{
-		yy_size_t new_size;
-
-		yy_start_stack_depth += YY_START_STACK_INCR;
-		new_size = yy_start_stack_depth * sizeof( int );
-
-		if ( ! yy_start_stack )
-			yy_start_stack = (int *) yy_flex_alloc( new_size );
-
-		else
-			yy_start_stack = (int *) yy_flex_realloc(
-					(void *) yy_start_stack, new_size );
-
-		if ( ! yy_start_stack )
-			YY_FATAL_ERROR(
-			"out of memory expanding start-condition stack" );
-		}
-
-	yy_start_stack[yy_start_stack_ptr++] = YY_START;
-
-	BEGIN(new_state);
-	}
-#endif
-
-
-#ifndef YY_NO_POP_STATE
-static void yy_pop_state()
-	{
-	if ( --yy_start_stack_ptr < 0 )
-		YY_FATAL_ERROR( "start-condition stack underflow" );
-
-	BEGIN(yy_start_stack[yy_start_stack_ptr]);
-	}
-#endif
-
-
-#ifndef YY_NO_TOP_STATE
-static int yy_top_state()
-	{
-	return yy_start_stack[yy_start_stack_ptr - 1];
-	}
-#endif
-
-#ifndef YY_EXIT_FAILURE
-#define YY_EXIT_FAILURE 2
-#endif
-
-#ifdef YY_USE_PROTOS
-static void yy_fatal_error( yyconst char msg[] )
-#else
-static void yy_fatal_error( msg )
-char msg[];
-#endif
-	{
-	(void) fprintf( stderr, "%s\n", msg );
-	exit( YY_EXIT_FAILURE );
-	}
-
-
-
-/* Redefine yyless() so it works in section 3 code. */
-
-#undef yyless
-#define yyless(n) \
-	do \
-		{ \
-		/* Undo effects of setting up yytext. */ \
-		yytext[yyleng] = yy_hold_char; \
-		yy_c_buf_p = yytext + n; \
-		yy_hold_char = *yy_c_buf_p; \
-		*yy_c_buf_p = '\0'; \
-		yyleng = n; \
-		} \
-	while ( 0 )
-
-
-/* Internal utility routines. */
-
-#ifndef yytext_ptr
-#ifdef YY_USE_PROTOS
-static void yy_flex_strncpy( char *s1, yyconst char *s2, int n )
-#else
-static void yy_flex_strncpy( s1, s2, n )
-char *s1;
-yyconst char *s2;
-int n;
-#endif
-	{
-	register int i;
-	for ( i = 0; i < n; ++i )
-		s1[i] = s2[i];
-	}
-#endif
-
-#ifdef YY_NEED_STRLEN
-#ifdef YY_USE_PROTOS
-static int yy_flex_strlen( yyconst char *s )
-#else
-static int yy_flex_strlen( s )
-yyconst char *s;
-#endif
-	{
-	register int n;
-	for ( n = 0; s[n]; ++n )
-		;
-
-	return n;
-	}
-#endif
-
-
-#ifdef YY_USE_PROTOS
-static void *yy_flex_alloc( yy_size_t size )
-#else
-static void *yy_flex_alloc( size )
-yy_size_t size;
-#endif
-	{
-	return (void *) malloc( size );
-	}
-
-#ifdef YY_USE_PROTOS
-static void *yy_flex_realloc( void *ptr, yy_size_t size )
-#else
-static void *yy_flex_realloc( ptr, size )
-void *ptr;
-yy_size_t size;
-#endif
-	{
-	/* The cast to (char *) in the following accommodates both
-	 * implementations that use char* generic pointers, and those
-	 * that use void* generic pointers.  It works with the latter
-	 * because both ANSI C and C++ allow castless assignment from
-	 * any pointer type to void*, and deal with argument conversions
-	 * as though doing an assignment.
-	 */
-	return (void *) realloc( (char *) ptr, size );
-	}
-
-#ifdef YY_USE_PROTOS
-static void yy_flex_free( void *ptr )
-#else
-static void yy_flex_free( ptr )
-void *ptr;
-#endif
-	{
-	free( ptr );
-	}
-
-#if YY_MAIN
-int main()
-	{
-	yylex();
-	return 0;
-	}
-#endif
-#line 336 "cftoken.l"
-
-static void
-cfdebug_print(w, t, l)
-	char *w, *t;
-	int l;
-{
-	if (w) {
-		dprintf(LOG_DEBUG, FNAME,
-		    "<%d>%s [%s] (%d)", yy_start, w, t, l);
-	} else {
-		dprintf(LOG_DEBUG, FNAME,
-		    "<%d>[%s] (%d)", yy_start, t, l);
-	}
-}
-
-static void
-yyerror0(int level, char *s, va_list ap)
-{
-	char ebuf[BUFSIZ], *bp, *ep;
-
-	bp = ebuf;
-	ep = ebuf + sizeof(ebuf);
-	bp += snprintf(bp, ep - bp, "%s %d: ", configfilename, lineno);
-	if (bp < ep)
-		bp += vsnprintf(bp, ep - bp, s, ap);
-
-	dprintf(level, FNAME, ebuf);
-}
-
-void
-yyerror(char *s, ...)
-{
-	va_list ap;
-#ifdef HAVE_STDARG_H
-	va_start(ap, s);
-#else
-	va_start(ap);
-#endif
-	yyerror0(LOG_ERR, s, ap);
-	va_end(ap);
-	yyerrorcount++;
-}
-
-void
-yywarn(char *s, ...)
-{
-	va_list ap;
-#ifdef HAVE_STDARG_H
-	va_start(ap, s);
-#else
-	va_start(ap);
-#endif
-	yyerror0(LOG_WARNING, s, ap);
-	va_end(ap);
-}
-
-int
-cfswitch_buffer(incl)
-	char *incl;
-{
-	char *path = qstrdup(incl);
-	FILE *fp;
-
-	if (incstackp >= MAX_INCLUDE_DEPTH) {
-		dprintf(LOG_ERR, FNAME, "cfparse: includes nested too deeply");
-		return (-1);
-	}
-	incstack[incstackp].path = configfilename;
-	incstack[incstackp].state = YY_CURRENT_BUFFER;
-	incstack[incstackp].lineno = lineno;
-
-	fp = fopen(path, "r");
-	if (fp == NULL) {
-		dprintf(LOG_ERR, FNAME, "cfparse: fopen(%s): %s",
-			path, strerror(errno));
-		if (errno == ENOENT)
-			return (0);
-		return (-1);
-	}
-	incstackp++;
-	configfilename = path;
-	lineno = 1;
-	yy_switch_to_buffer(yy_create_buffer(fp, YY_BUF_SIZE));
-
-	BEGIN(S_CNF);
-
-	return (0);
-}
-
-int
-cfparse(conf)
-	char *conf;
-{
-	configfilename = conf;
-	if ((yyin = fopen(configfilename, "r")) == NULL) {
-		dprintf(LOG_ERR, FNAME, "cfparse: fopen(%s): %s",
-			configfilename, strerror(errno));
-		if (errno == ENOENT)
-			return (0);
-		return (-1);
-	}
-
-	if (yyparse() || yyerrorcount) {
-		if (yyerrorcount) {
-			yyerror("fatal parse failure: exiting (%d errors)",
-				yyerrorcount);
-		} else
-			yyerror("fatal parse failure: exiting");
-		return (-1);
-	}
-
-	return (cf_post_config());
-}
diff -Naur wide-dhcpv6-20080615.orig/cftoken.l wide-dhcpv6-20080615/cftoken.l
--- wide-dhcpv6-20080615.orig/cftoken.l	2007-03-21 17:52:55.000000000 +0800
+++ wide-dhcpv6-20080615/cftoken.l	2013-12-30 16:11:43.000000000 +0800
@@ -104,7 +104,7 @@
 hexpair		{hexdigit}{hexdigit}
 hexstring	0[xX]{hexpair}+
 duid 		{hexpair}(:{hexpair})*
-ifname		{string}
+ifname		[a-zA-Z]+[0-9]+|[a-zA-Z\_]+[0-9\_]+[0-9]+|[a-zA-Z\.]+[0-9\.]+[0-9]+
 slash		\/
 bcl		\{
 ecl		\}
@@ -120,6 +120,7 @@
 %s S_SECRET
 %s S_ADDRPOOL
 %s S_INCL
+%option noyywrap
 
 %%
 %{
diff -Naur wide-dhcpv6-20080615.orig/common.c wide-dhcpv6-20080615/common.c
--- wide-dhcpv6-20080615.orig/common.c	2011-08-05 11:30:35.000000000 +0800
+++ wide-dhcpv6-20080615/common.c	2013-12-30 16:11:43.000000000 +0800
@@ -86,6 +86,16 @@
 #include <common.h>
 #include <timer.h>
 
+/*zyxel*/
+#include <stdbool.h>
+#include <json/json.h>
+
+#include "zcfg_common.h"
+#include "zcfg_fe_rdm_access.h"
+#include "zcfg_msg.h"
+
+struct json_object *dhcp6cMsg = NULL;
+
 #ifdef __linux__
 /* from /usr/include/linux/ipv6.h */
 
@@ -114,6 +124,38 @@
 static char *sprint_uint64 __P((char *, int, u_int64_t));
 static char *sprint_auth __P((struct dhcp6_optinfo *));
 
+zcfgRet_t dhcp6MsgSend(int msg_type, int payloadLen, const char *payload)
+{
+	zcfgRet_t ret;
+	void *sendBuf = NULL;
+	void *recvBuf = NULL;
+	zcfgMsg_t *sendMsgHdr = NULL;
+	char *recv_str = NULL;
+	int buf_size = 0;
+
+	buf_size = sizeof(zcfgMsg_t)+payloadLen;
+	sendBuf = malloc(buf_size);
+	sendMsgHdr = (zcfgMsg_t*)sendBuf;
+
+	sendMsgHdr->type = msg_type;
+	sendMsgHdr->length = payloadLen;
+	sendMsgHdr->srcEid = ZCFG_EID_UDHCP6C;
+	sendMsgHdr->dstEid = ZCFG_EID_ESMD;
+
+	if(payload != NULL)
+		memcpy(sendBuf+sizeof(zcfgMsg_t), payload, payloadLen);
+
+	ret = zcfgMsgSendAndGetReply(sendMsgHdr, (zcfgMsg_t **)&recvBuf, 0);
+
+	if(ret == ZCFG_SUCCESS) {
+		recv_str = (char *)recvBuf+sizeof(zcfgMsg_t);
+		printf("Receive message : %s\n", recv_str);
+		free(recvBuf);
+	}
+
+	return ret;
+}
+
 int
 dhcp6_copy_list(dst, src)
 	struct dhcp6_list *dst, *src;
@@ -999,18 +1041,17 @@
 	char tmpbuf[256];	/* DUID should be no more than 256 bytes */
 	int pos = 0;
 
+	dprintf(LOG_NOTICE, FNAME, "DUID file: %s", idfile);
+
 	if ((fp = fopen(idfile, "r")) == NULL && errno != ENOENT)
 		dprintf(LOG_NOTICE, FNAME, "failed to open DUID file: %s",
 		    idfile);
 
 	if (fp) {
-		//printf("get duid file\n");
 		pos = ftell(fp);
 		fseek(fp, 0L, SEEK_END);
 		len = ftell(fp);
-		fseek (fp, pos, SEEK_SET);
-
-		//printf("duid length is %d\n", len); 
+		fseek(fp, pos, SEEK_SET);
 #if 0
 		/* decode length */
 		if (fread(&len, sizeof(len), 1, fp) != 1) {
@@ -3259,104 +3300,56 @@
 	int pltime;
 	int vltime;
 {
-#ifdef __KAME__
-	struct in6_aliasreq req;
-#endif
-#ifdef __linux__
-	struct in6_ifreq req;
-	struct ifreq ifr;
-#endif
-#ifdef __sun__
-	struct lifreq req;
-#endif
 	unsigned long ioctl_cmd;
 	char *cmdstr;
 	int s;			/* XXX overhead */
+	char extAddr[48] = {0};
 
 	switch(cmd) {
 	case IFADDRCONF_ADD:
 		cmdstr = "add";
-#ifdef __KAME__
-		ioctl_cmd = SIOCAIFADDR_IN6;
-#endif
-#ifdef __linux__
-		ioctl_cmd = SIOCSIFADDR;
-#endif
-#ifdef __sun__
-		ioctl_cmd = SIOCLIFADDIF;
-#endif
 		break;
 	case IFADDRCONF_REMOVE:
 		cmdstr = "remove";
-#ifdef __KAME__
-		ioctl_cmd = SIOCDIFADDR_IN6;
-#endif
-#ifdef __linux__
-		ioctl_cmd = SIOCDIFADDR;
-#endif
-#ifdef __sun__
-		ioctl_cmd = SIOCLIFREMOVEIF;
-#endif
 		break;
 	default:
 		return (-1);
 	}
 
-	if ((s = socket(PF_INET6, SOCK_DGRAM, IPPROTO_UDP)) < 0) {
-		dprintf(LOG_ERR, FNAME, "can't open a temporary socket: %s",
-		    strerror(errno));
-		return (-1);
-	}
+	snprintf(extAddr, sizeof(extAddr), "%s/%d", addr2str((struct sockaddr *)addr), plen);
+	addAddrToMsg(cmd, ifname, extAddr, pltime, vltime);
 
-	memset(&req, 0, sizeof(req));
-#ifdef __KAME__
-	req.ifra_addr = *addr;
-	memcpy(req.ifra_name, ifname, sizeof(req.ifra_name));
-	(void)sa6_plen2mask(&req.ifra_prefixmask, plen);
-	/* XXX: should lifetimes be calculated based on the lease duration? */
-	req.ifra_lifetime.ia6t_vltime = vltime;
-	req.ifra_lifetime.ia6t_pltime = pltime;
-#endif
-#ifdef __linux__
-	memset(&ifr, 0, sizeof(ifr));
-	strncpy(ifr.ifr_name, ifname, IFNAMSIZ - 1);
-	if (ioctl(s, SIOGIFINDEX, &ifr) < 0) {
-		dprintf(LOG_NOTICE, FNAME, "failed to get the index of %s: %s",
-		    ifname, strerror(errno));
-		close(s); 
-		return (-1); 
-	}
-	memcpy(&req.ifr6_addr, &addr->sin6_addr, sizeof(struct in6_addr));
-	req.ifr6_prefixlen = plen;
-	req.ifr6_ifindex = ifr.ifr_ifindex;
-#endif
-#ifdef __sun__
-	strncpy(req.lifr_name, ifname, sizeof (req.lifr_name));
-#endif
-
-	if (ioctl(s, ioctl_cmd, &req)) {
-		dprintf(LOG_NOTICE, FNAME, "failed to %s an address on %s: %s",
-		    cmdstr, ifname, strerror(errno));
-		close(s);
-		return (-1);
-	}
+	close(s);
+	return (0);
+}
 
-#ifdef __sun__
-	memcpy(&req.lifr_addr, addr, sizeof (*addr));
-	if (ioctl(s, SIOCSLIFADDR, &req) == -1) {
-		dprintf(LOG_NOTICE, FNAME, "failed to %s new address on %s: %s",
-		    cmdstr, ifname, strerror(errno));
-		close(s);
-		return (-1);
+void addAddrToMsg(ifaddrconf_cmd_t cmd, const char *ifname, const char *addr, int pltime, int vltime)
+{
+	if(strncmp(ifname, "br", 2) == 0) { /* address of the PD interface */
+#if 0
+		snprintf(dhcp6cMsgBody.pdIfAddress, sizeof(dhcp6cMsgBody.pdIfAddress), "%s", addr);
+#endif
+		dprintf(LOG_ERR, FNAME, "%s : address of the PD interface\n", __FUNCTION__);
 	}
+	else  { /* address of the WAN interface */
+		json_object_object_add(dhcp6cMsg, "addrAssigned", json_object_new_boolean(true));
+		json_object_object_add(dhcp6cMsg, "addrCmd", json_object_new_int(cmd));
+		json_object_object_add(dhcp6cMsg, "ifname", json_object_new_string(ifname));
+		json_object_object_add(dhcp6cMsg, "addr", json_object_new_string(addr));
+		json_object_object_add(dhcp6cMsg, "addrPltime", json_object_new_int(pltime));
+		json_object_object_add(dhcp6cMsg, "addrVltime", json_object_new_int(vltime));
+#if 0
+        dhcp6cMsgBody.addrAssigned = TRUE;
+        dhcp6cMsgBody.addrCmd      = cmd;
+        snprintf(dhcp6cMsgBody.ifname, sizeof(dhcp6cMsgBody.ifname), "%s", ifname);
+        snprintf(dhcp6cMsgBody.address, sizeof(dhcp6cMsgBody.address), "%s", addr);
 #endif
+	}
 
-	dprintf(LOG_DEBUG, FNAME, "%s an address %s/%d on %s", cmdstr,
-	    addr2str((struct sockaddr *)addr), plen, ifname);
+	dprintf(LOG_NOTICE, FNAME, "DHCP6C_ADDR_CHANGED");
 
-	close(s);
-	return (0);
-}
+	return;
+}  /* End of sendAddrEventMessage() */
 
 int
 safefile(path)
diff -Naur wide-dhcpv6-20080615.orig/common.h wide-dhcpv6-20080615/common.h
--- wide-dhcpv6-20080615.orig/common.h	2007-03-21 17:52:57.000000000 +0800
+++ wide-dhcpv6-20080615/common.h	2014-01-28 19:26:44.325087367 +0800
@@ -155,7 +155,6 @@
 extern int in6_addrscopebyif __P((struct in6_addr *, char *));
 extern int in6_scope __P((struct in6_addr *));
 extern void setloglevel __P((int));
-extern void dprintf __P((int, const char *, const char *, ...));
 extern int get_duid __P((char *, struct duid *));
 extern void dhcp6_init_options __P((struct dhcp6_optinfo *));
 extern void dhcp6_clear_options __P((struct dhcp6_optinfo *));
diff -Naur wide-dhcpv6-20080615.orig/config.log wide-dhcpv6-20080615/config.log
--- wide-dhcpv6-20080615.orig/config.log	1970-01-01 08:00:00.000000000 +0800
+++ wide-dhcpv6-20080615/config.log	2013-12-30 16:11:43.000000000 +0800
@@ -0,0 +1,1409 @@
+This file contains any messages produced by compilers while
+running configure, to aid debugging if configure makes a mistake.
+
+It was created by configure, which was
+generated by GNU Autoconf 2.59.  Invocation command line was
+
+  $ ./configure 
+
+## --------- ##
+## Platform. ##
+## --------- ##
+
+hostname = jerry-desktop
+uname -m = i686
+uname -r = 2.6.31-14-generic
+uname -s = Linux
+uname -v = #48-Ubuntu SMP Fri Oct 16 14:04:26 UTC 2009
+
+/usr/bin/uname -p = unknown
+/bin/uname -X     = unknown
+
+/bin/arch              = unknown
+/usr/bin/arch -k       = unknown
+/usr/convex/getsysinfo = unknown
+hostinfo               = unknown
+/bin/machine           = unknown
+/usr/bin/oslevel       = unknown
+/bin/universe          = unknown
+
+PATH: /usr/local/sbin
+PATH: /usr/local/bin
+PATH: /usr/sbin
+PATH: /usr/bin
+PATH: /sbin
+PATH: /bin
+PATH: /usr/games
+
+
+## ----------- ##
+## Core tests. ##
+## ----------- ##
+
+configure:1338: checking for a BSD-compatible install
+configure:1393: result: /usr/bin/install -c
+configure:1404: checking whether make sets $(MAKE)
+configure:1424: result: yes
+configure:1479: checking for gcc
+configure:1495: found /usr/bin/gcc
+configure:1505: result: gcc
+configure:1749: checking for C compiler version
+configure:1752: gcc --version </dev/null >&5
+gcc (Ubuntu 4.4.1-4ubuntu9) 4.4.1
+Copyright (C) 2009 Free Software Foundation, Inc.
+This is free software; see the source for copying conditions.  There is NO
+warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+
+configure:1755: $? = 0
+configure:1757: gcc -v </dev/null >&5
+Using built-in specs.
+Target: i486-linux-gnu
+Configured with: ../src/configure -v --with-pkgversion='Ubuntu 4.4.1-4ubuntu9' --with-bugurl=file:///usr/share/doc/gcc-4.4/README.Bugs --enable-languages=c,c++,fortran,objc,obj-c++ --prefix=/usr --enable-shared --enable-multiarch --enable-linker-build-id --with-system-zlib --libexecdir=/usr/lib --without-included-gettext --enable-threads=posix --with-gxx-include-dir=/usr/include/c++/4.4 --program-suffix=-4.4 --enable-nls --enable-clocale=gnu --enable-libstdcxx-debug --enable-objc-gc --enable-targets=all --disable-werror --with-arch-32=i486 --with-tune=generic --enable-checking=release --build=i486-linux-gnu --host=i486-linux-gnu --target=i486-linux-gnu
+Thread model: posix
+gcc version 4.4.1 (Ubuntu 4.4.1-4ubuntu9) 
+configure:1760: $? = 0
+configure:1762: gcc -V </dev/null >&5
+gcc: '-V' option must have argument
+configure:1765: $? = 1
+configure:1788: checking for C compiler default output file name
+configure:1791: gcc    conftest.c  >&5
+configure:1794: $? = 0
+configure:1840: result: a.out
+configure:1845: checking whether the C compiler works
+configure:1851: ./a.out
+configure:1854: $? = 0
+configure:1871: result: yes
+configure:1878: checking whether we are cross compiling
+configure:1880: result: no
+configure:1883: checking for suffix of executables
+configure:1885: gcc -o conftest    conftest.c  >&5
+configure:1888: $? = 0
+configure:1913: result: 
+configure:1919: checking for suffix of object files
+configure:1940: gcc -c   conftest.c >&5
+configure:1943: $? = 0
+configure:1965: result: o
+configure:1969: checking whether we are using the GNU C compiler
+configure:1993: gcc -c   conftest.c >&5
+configure:1999: $? = 0
+configure:2003: test -z 
+			 || test ! -s conftest.err
+configure:2006: $? = 0
+configure:2009: test -s conftest.o
+configure:2012: $? = 0
+configure:2025: result: yes
+configure:2031: checking whether gcc accepts -g
+configure:2052: gcc -c -g  conftest.c >&5
+configure:2058: $? = 0
+configure:2062: test -z 
+			 || test ! -s conftest.err
+configure:2065: $? = 0
+configure:2068: test -s conftest.o
+configure:2071: $? = 0
+configure:2082: result: yes
+configure:2099: checking for gcc option to accept ANSI C
+configure:2169: gcc  -c -g -O2  conftest.c >&5
+configure:2175: $? = 0
+configure:2179: test -z 
+			 || test ! -s conftest.err
+configure:2182: $? = 0
+configure:2185: test -s conftest.o
+configure:2188: $? = 0
+configure:2206: result: none needed
+configure:2224: gcc -c -g -O2  conftest.c >&5
+conftest.c:2: error: expected '=', ',', ';', 'asm' or '__attribute__' before 'me'
+configure:2230: $? = 1
+configure: failed program was:
+| #ifndef __cplusplus
+|   choke me
+| #endif
+configure:2368: checking how to run the C preprocessor
+configure:2403: gcc -E  conftest.c
+configure:2409: $? = 0
+configure:2441: gcc -E  conftest.c
+conftest.c:9:28: error: ac_nonexistent.h: No such file or directory
+configure:2447: $? = 1
+configure: failed program was:
+| /* confdefs.h.  */
+| 
+| #define PACKAGE_NAME ""
+| #define PACKAGE_TARNAME ""
+| #define PACKAGE_VERSION ""
+| #define PACKAGE_STRING ""
+| #define PACKAGE_BUGREPORT ""
+| /* end confdefs.h.  */
+| #include <ac_nonexistent.h>
+configure:2486: result: gcc -E
+configure:2510: gcc -E  conftest.c
+configure:2516: $? = 0
+configure:2548: gcc -E  conftest.c
+conftest.c:9:28: error: ac_nonexistent.h: No such file or directory
+configure:2554: $? = 1
+configure: failed program was:
+| /* confdefs.h.  */
+| 
+| #define PACKAGE_NAME ""
+| #define PACKAGE_TARNAME ""
+| #define PACKAGE_VERSION ""
+| #define PACKAGE_STRING ""
+| #define PACKAGE_BUGREPORT ""
+| /* end confdefs.h.  */
+| #include <ac_nonexistent.h>
+configure:2601: checking for bison
+configure:2617: found /usr/bin/bison
+configure:2627: result: bison -y
+configure:2643: checking for flex
+configure:2659: found /usr/bin/flex
+configure:2669: result: flex
+configure:2682: checking for yywrap in -lfl
+configure:2712: gcc -o conftest -g -O2   conftest.c -lfl   >&5
+configure:2718: $? = 0
+configure:2722: test -z 
+			 || test ! -s conftest.err
+configure:2725: $? = 0
+configure:2728: test -s conftest
+configure:2731: $? = 0
+configure:2744: result: yes
+configure:2822: checking lex output file root
+configure:2833: flex conftest.l
+configure:2836: $? = 0
+configure:2848: result: lex.yy
+configure:2853: checking whether yytext is a pointer
+configure:2869: gcc -o conftest -g -O2   conftest.c  -lfl >&5
+configure:2875: $? = 0
+configure:2879: test -z 
+			 || test ! -s conftest.err
+configure:2882: $? = 0
+configure:2885: test -s conftest
+configure:2888: $? = 0
+configure:2902: result: yes
+configure:2923: checking for sys/queue.h
+configure:2941: gcc -c -g -O2 -I$(srcdir)  conftest.c >&5
+configure:2947: $? = 0
+configure:2951: test -z 
+			 || test ! -s conftest.err
+configure:2954: $? = 0
+configure:2957: test -s conftest.o
+configure:2960: $? = 0
+configure:2962: result: yes
+configure:2975: checking for egrep
+configure:2985: result: grep -E
+configure:3009: checking for getaddrinfo/getnameinfo library
+configure:3011: result: regular
+configure:3104: checking for getaddrinfo
+configure:3161: gcc -o conftest -g -O2 -I$(srcdir)   conftest.c  >&5
+configure:3167: $? = 0
+configure:3171: test -z 
+			 || test ! -s conftest.err
+configure:3174: $? = 0
+configure:3177: test -s conftest
+configure:3180: $? = 0
+configure:3192: result: yes
+configure:3216: checking for getnameinfo
+configure:3273: gcc -o conftest -g -O2 -I$(srcdir)   conftest.c  >&5
+configure:3279: $? = 0
+configure:3283: test -z 
+			 || test ! -s conftest.err
+configure:3286: $? = 0
+configure:3289: test -s conftest
+configure:3292: $? = 0
+configure:3304: result: yes
+configure:3328: checking for getifaddrs
+configure:3385: gcc -o conftest -g -O2 -I$(srcdir)   conftest.c  >&5
+configure:3391: $? = 0
+configure:3395: test -z 
+			 || test ! -s conftest.err
+configure:3398: $? = 0
+configure:3401: test -s conftest
+configure:3404: $? = 0
+configure:3416: result: yes
+configure:3440: checking for if_nametoindex
+configure:3497: gcc -o conftest -g -O2 -I$(srcdir)   conftest.c  >&5
+configure:3503: $? = 0
+configure:3507: test -z 
+			 || test ! -s conftest.err
+configure:3510: $? = 0
+configure:3513: test -s conftest
+configure:3516: $? = 0
+configure:3528: result: yes
+configure:3543: checking for strlcpy
+configure:3600: gcc -o conftest -g -O2 -I$(srcdir)   conftest.c  >&5
+/tmp/cc6lwbyn.o: In function `main':
+/home/jerry/broadcom/VMG5313/userspace/zyxel/public/apps/dhcpv6/conftest.c:53: undefined reference to `strlcpy'
+/tmp/cc6lwbyn.o:(.data+0x0): undefined reference to `strlcpy'
+collect2: ld returned 1 exit status
+configure:3606: $? = 1
+configure: failed program was:
+| /* confdefs.h.  */
+| 
+| #define PACKAGE_NAME ""
+| #define PACKAGE_TARNAME ""
+| #define PACKAGE_VERSION ""
+| #define PACKAGE_STRING ""
+| #define PACKAGE_BUGREPORT ""
+| #define YYTEXT_POINTER 1
+| #define HAVE_GETADDRINFO 1
+| #define HAVE_GETNAMEINFO 1
+| #define HAVE_GETIFADDRS 1
+| #define HAVE_IF_NAMETOINDEX 1
+| /* end confdefs.h.  */
+| /* Define strlcpy to an innocuous variant, in case <limits.h> declares strlcpy.
+|    For example, HP-UX 11i <limits.h> declares gettimeofday.  */
+| #define strlcpy innocuous_strlcpy
+| 
+| /* System header to define __stub macros and hopefully few prototypes,
+|     which can conflict with char strlcpy (); below.
+|     Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
+|     <limits.h> exists even on freestanding compilers.  */
+| 
+| #ifdef __STDC__
+| # include <limits.h>
+| #else
+| # include <assert.h>
+| #endif
+| 
+| #undef strlcpy
+| 
+| /* Override any gcc2 internal prototype to avoid an error.  */
+| #ifdef __cplusplus
+| extern "C"
+| {
+| #endif
+| /* We use char because int might match the return type of a gcc2
+|    builtin and then its argument prototype would still apply.  */
+| char strlcpy ();
+| /* The GNU C library defines this for functions which it implements
+|     to always fail with ENOSYS.  Some functions are actually named
+|     something starting with __ and the normal name is an alias.  */
+| #if defined (__stub_strlcpy) || defined (__stub___strlcpy)
+| choke me
+| #else
+| char (*f) () = strlcpy;
+| #endif
+| #ifdef __cplusplus
+| }
+| #endif
+| 
+| int
+| main ()
+| {
+| return f != strlcpy;
+|   ;
+|   return 0;
+| }
+configure:3631: result: no
+configure:3543: checking for strlcat
+configure:3600: gcc -o conftest -g -O2 -I$(srcdir)   conftest.c  >&5
+/tmp/ccc9dgWI.o: In function `main':
+/home/jerry/broadcom/VMG5313/userspace/zyxel/public/apps/dhcpv6/conftest.c:53: undefined reference to `strlcat'
+/tmp/ccc9dgWI.o:(.data+0x0): undefined reference to `strlcat'
+collect2: ld returned 1 exit status
+configure:3606: $? = 1
+configure: failed program was:
+| /* confdefs.h.  */
+| 
+| #define PACKAGE_NAME ""
+| #define PACKAGE_TARNAME ""
+| #define PACKAGE_VERSION ""
+| #define PACKAGE_STRING ""
+| #define PACKAGE_BUGREPORT ""
+| #define YYTEXT_POINTER 1
+| #define HAVE_GETADDRINFO 1
+| #define HAVE_GETNAMEINFO 1
+| #define HAVE_GETIFADDRS 1
+| #define HAVE_IF_NAMETOINDEX 1
+| /* end confdefs.h.  */
+| /* Define strlcat to an innocuous variant, in case <limits.h> declares strlcat.
+|    For example, HP-UX 11i <limits.h> declares gettimeofday.  */
+| #define strlcat innocuous_strlcat
+| 
+| /* System header to define __stub macros and hopefully few prototypes,
+|     which can conflict with char strlcat (); below.
+|     Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
+|     <limits.h> exists even on freestanding compilers.  */
+| 
+| #ifdef __STDC__
+| # include <limits.h>
+| #else
+| # include <assert.h>
+| #endif
+| 
+| #undef strlcat
+| 
+| /* Override any gcc2 internal prototype to avoid an error.  */
+| #ifdef __cplusplus
+| extern "C"
+| {
+| #endif
+| /* We use char because int might match the return type of a gcc2
+|    builtin and then its argument prototype would still apply.  */
+| char strlcat ();
+| /* The GNU C library defines this for functions which it implements
+|     to always fail with ENOSYS.  Some functions are actually named
+|     something starting with __ and the normal name is an alias.  */
+| #if defined (__stub_strlcat) || defined (__stub___strlcat)
+| choke me
+| #else
+| char (*f) () = strlcat;
+| #endif
+| #ifdef __cplusplus
+| }
+| #endif
+| 
+| int
+| main ()
+| {
+| return f != strlcat;
+|   ;
+|   return 0;
+| }
+configure:3631: result: no
+configure:3655: checking for daemon
+configure:3712: gcc -o conftest -g -O2 -I$(srcdir)   conftest.c  >&5
+configure:3718: $? = 0
+configure:3722: test -z 
+			 || test ! -s conftest.err
+configure:3725: $? = 0
+configure:3728: test -s conftest
+configure:3731: $? = 0
+configure:3743: result: yes
+configure:3767: checking for warnx
+configure:3824: gcc -o conftest -g -O2 -I$(srcdir)   conftest.c  >&5
+configure:3830: $? = 0
+configure:3834: test -z 
+			 || test ! -s conftest.err
+configure:3837: $? = 0
+configure:3840: test -s conftest
+configure:3843: $? = 0
+configure:3855: result: yes
+configure:3876: checking for ANSI C header files
+configure:3901: gcc -c -g -O2 -I$(srcdir)  conftest.c >&5
+configure:3907: $? = 0
+configure:3911: test -z 
+			 || test ! -s conftest.err
+configure:3914: $? = 0
+configure:3917: test -s conftest.o
+configure:3920: $? = 0
+configure:4009: gcc -o conftest -g -O2 -I$(srcdir)   conftest.c  >&5
+conftest.c: In function 'main':
+conftest.c:33: warning: incompatible implicit declaration of built-in function 'exit'
+configure:4012: $? = 0
+configure:4014: ./conftest
+configure:4017: $? = 0
+configure:4032: result: yes
+configure:4056: checking for sys/types.h
+configure:4072: gcc -c -g -O2 -I$(srcdir)  conftest.c >&5
+configure:4078: $? = 0
+configure:4082: test -z 
+			 || test ! -s conftest.err
+configure:4085: $? = 0
+configure:4088: test -s conftest.o
+configure:4091: $? = 0
+configure:4102: result: yes
+configure:4056: checking for sys/stat.h
+configure:4072: gcc -c -g -O2 -I$(srcdir)  conftest.c >&5
+configure:4078: $? = 0
+configure:4082: test -z 
+			 || test ! -s conftest.err
+configure:4085: $? = 0
+configure:4088: test -s conftest.o
+configure:4091: $? = 0
+configure:4102: result: yes
+configure:4056: checking for stdlib.h
+configure:4072: gcc -c -g -O2 -I$(srcdir)  conftest.c >&5
+configure:4078: $? = 0
+configure:4082: test -z 
+			 || test ! -s conftest.err
+configure:4085: $? = 0
+configure:4088: test -s conftest.o
+configure:4091: $? = 0
+configure:4102: result: yes
+configure:4056: checking for string.h
+configure:4072: gcc -c -g -O2 -I$(srcdir)  conftest.c >&5
+configure:4078: $? = 0
+configure:4082: test -z 
+			 || test ! -s conftest.err
+configure:4085: $? = 0
+configure:4088: test -s conftest.o
+configure:4091: $? = 0
+configure:4102: result: yes
+configure:4056: checking for memory.h
+configure:4072: gcc -c -g -O2 -I$(srcdir)  conftest.c >&5
+configure:4078: $? = 0
+configure:4082: test -z 
+			 || test ! -s conftest.err
+configure:4085: $? = 0
+configure:4088: test -s conftest.o
+configure:4091: $? = 0
+configure:4102: result: yes
+configure:4056: checking for strings.h
+configure:4072: gcc -c -g -O2 -I$(srcdir)  conftest.c >&5
+configure:4078: $? = 0
+configure:4082: test -z 
+			 || test ! -s conftest.err
+configure:4085: $? = 0
+configure:4088: test -s conftest.o
+configure:4091: $? = 0
+configure:4102: result: yes
+configure:4056: checking for inttypes.h
+configure:4072: gcc -c -g -O2 -I$(srcdir)  conftest.c >&5
+configure:4078: $? = 0
+configure:4082: test -z 
+			 || test ! -s conftest.err
+configure:4085: $? = 0
+configure:4088: test -s conftest.o
+configure:4091: $? = 0
+configure:4102: result: yes
+configure:4056: checking for stdint.h
+configure:4072: gcc -c -g -O2 -I$(srcdir)  conftest.c >&5
+configure:4078: $? = 0
+configure:4082: test -z 
+			 || test ! -s conftest.err
+configure:4085: $? = 0
+configure:4088: test -s conftest.o
+configure:4091: $? = 0
+configure:4102: result: yes
+configure:4056: checking for unistd.h
+configure:4072: gcc -c -g -O2 -I$(srcdir)  conftest.c >&5
+configure:4078: $? = 0
+configure:4082: test -z 
+			 || test ! -s conftest.err
+configure:4085: $? = 0
+configure:4088: test -s conftest.o
+configure:4091: $? = 0
+configure:4102: result: yes
+configure:4133: checking fcntl.h usability
+configure:4145: gcc -c -g -O2 -I$(srcdir)  conftest.c >&5
+configure:4151: $? = 0
+configure:4155: test -z 
+			 || test ! -s conftest.err
+configure:4158: $? = 0
+configure:4161: test -s conftest.o
+configure:4164: $? = 0
+configure:4174: result: yes
+configure:4178: checking fcntl.h presence
+configure:4188: gcc -E  conftest.c
+configure:4194: $? = 0
+configure:4214: result: yes
+configure:4249: checking for fcntl.h
+configure:4256: result: yes
+configure:4133: checking sys/ioctl.h usability
+configure:4145: gcc -c -g -O2 -I$(srcdir)  conftest.c >&5
+configure:4151: $? = 0
+configure:4155: test -z 
+			 || test ! -s conftest.err
+configure:4158: $? = 0
+configure:4161: test -s conftest.o
+configure:4164: $? = 0
+configure:4174: result: yes
+configure:4178: checking sys/ioctl.h presence
+configure:4188: gcc -E  conftest.c
+configure:4194: $? = 0
+configure:4214: result: yes
+configure:4249: checking for sys/ioctl.h
+configure:4256: result: yes
+configure:4133: checking sys/time.h usability
+configure:4145: gcc -c -g -O2 -I$(srcdir)  conftest.c >&5
+configure:4151: $? = 0
+configure:4155: test -z 
+			 || test ! -s conftest.err
+configure:4158: $? = 0
+configure:4161: test -s conftest.o
+configure:4164: $? = 0
+configure:4174: result: yes
+configure:4178: checking sys/time.h presence
+configure:4188: gcc -E  conftest.c
+configure:4194: $? = 0
+configure:4214: result: yes
+configure:4249: checking for sys/time.h
+configure:4256: result: yes
+configure:4133: checking syslog.h usability
+configure:4145: gcc -c -g -O2 -I$(srcdir)  conftest.c >&5
+configure:4151: $? = 0
+configure:4155: test -z 
+			 || test ! -s conftest.err
+configure:4158: $? = 0
+configure:4161: test -s conftest.o
+configure:4164: $? = 0
+configure:4174: result: yes
+configure:4178: checking syslog.h presence
+configure:4188: gcc -E  conftest.c
+configure:4194: $? = 0
+configure:4214: result: yes
+configure:4249: checking for syslog.h
+configure:4256: result: yes
+configure:4124: checking for unistd.h
+configure:4129: result: yes
+configure:4133: checking ifaddrs.h usability
+configure:4145: gcc -c -g -O2 -I$(srcdir)  conftest.c >&5
+configure:4151: $? = 0
+configure:4155: test -z 
+			 || test ! -s conftest.err
+configure:4158: $? = 0
+configure:4161: test -s conftest.o
+configure:4164: $? = 0
+configure:4174: result: yes
+configure:4178: checking ifaddrs.h presence
+configure:4188: gcc -E  conftest.c
+configure:4194: $? = 0
+configure:4214: result: yes
+configure:4249: checking for ifaddrs.h
+configure:4256: result: yes
+configure:4269: checking for socklen_t
+configure:4288: gcc -c -g -O2 -I$(srcdir)  conftest.c >&5
+configure:4294: $? = 0
+configure:4298: test -z 
+			 || test ! -s conftest.err
+configure:4301: $? = 0
+configure:4304: test -s conftest.o
+configure:4307: $? = 0
+configure:4309: result: yes
+configure:4386: checking for an ANSI C-conforming const
+configure:4453: gcc -c -g -O2 -I$(srcdir)  conftest.c >&5
+configure:4459: $? = 0
+configure:4463: test -z 
+			 || test ! -s conftest.err
+configure:4466: $? = 0
+configure:4469: test -s conftest.o
+configure:4472: $? = 0
+configure:4483: result: yes
+configure:4493: checking for size_t
+configure:4517: gcc -c -g -O2 -I$(srcdir)  conftest.c >&5
+configure:4523: $? = 0
+configure:4527: test -z 
+			 || test ! -s conftest.err
+configure:4530: $? = 0
+configure:4533: test -s conftest.o
+configure:4536: $? = 0
+configure:4547: result: yes
+configure:4559: checking whether time.h and sys/time.h may both be included
+configure:4584: gcc -c -g -O2 -I$(srcdir)  conftest.c >&5
+configure:4590: $? = 0
+configure:4594: test -z 
+			 || test ! -s conftest.err
+configure:4597: $? = 0
+configure:4600: test -s conftest.o
+configure:4603: $? = 0
+configure:4614: result: yes
+configure:4624: checking whether struct tm is in sys/time.h or time.h
+configure:4647: gcc -c -g -O2 -I$(srcdir)  conftest.c >&5
+configure:4653: $? = 0
+configure:4657: test -z 
+			 || test ! -s conftest.err
+configure:4660: $? = 0
+configure:4663: test -s conftest.o
+configure:4666: $? = 0
+configure:4677: result: time.h
+configure:4687: checking for struct tm.tm_zone
+configure:4713: gcc -c -g -O2 -I$(srcdir)  conftest.c >&5
+configure:4719: $? = 0
+configure:4723: test -z 
+			 || test ! -s conftest.err
+configure:4726: $? = 0
+configure:4729: test -s conftest.o
+configure:4732: $? = 0
+configure:4792: result: yes
+configure:4877: checking for sig_atomic_t
+configure:4903: gcc -c -g -O2 -I$(srcdir)  conftest.c >&5
+configure:4909: $? = 0
+configure:4913: test -z 
+			 || test ! -s conftest.err
+configure:4916: $? = 0
+configure:4919: test -s conftest.o
+configure:4922: $? = 0
+configure:4933: result: yes
+configure:4951: checking whether getpgrp requires zero arguments
+configure:4973: gcc -c -g -O2 -I$(srcdir)  conftest.c >&5
+conftest.c: In function 'main':
+conftest.c:73: error: too many arguments to function 'getpgrp'
+configure:4979: $? = 1
+configure: failed program was:
+| /* confdefs.h.  */
+| 
+| #define PACKAGE_NAME ""
+| #define PACKAGE_TARNAME ""
+| #define PACKAGE_VERSION ""
+| #define PACKAGE_STRING ""
+| #define PACKAGE_BUGREPORT ""
+| #define YYTEXT_POINTER 1
+| #define HAVE_GETADDRINFO 1
+| #define HAVE_GETNAMEINFO 1
+| #define HAVE_GETIFADDRS 1
+| #define HAVE_IF_NAMETOINDEX 1
+| #define HAVE_DAEMON 1
+| #define HAVE_WARNX 1
+| #define STDC_HEADERS 1
+| #define HAVE_SYS_TYPES_H 1
+| #define HAVE_SYS_STAT_H 1
+| #define HAVE_STDLIB_H 1
+| #define HAVE_STRING_H 1
+| #define HAVE_MEMORY_H 1
+| #define HAVE_STRINGS_H 1
+| #define HAVE_INTTYPES_H 1
+| #define HAVE_STDINT_H 1
+| #define HAVE_UNISTD_H 1
+| #define HAVE_FCNTL_H 1
+| #define HAVE_SYS_IOCTL_H 1
+| #define HAVE_SYS_TIME_H 1
+| #define HAVE_SYSLOG_H 1
+| #define HAVE_UNISTD_H 1
+| #define HAVE_IFADDRS_H 1
+| #define TIME_WITH_SYS_TIME 1
+| #define HAVE_STRUCT_TM_TM_ZONE 1
+| #define HAVE_TM_ZONE 1
+| #define HAVE_SIG_ATOMIC_T 1
+| /* end confdefs.h.  */
+| #include <stdio.h>
+| #if HAVE_SYS_TYPES_H
+| # include <sys/types.h>
+| #endif
+| #if HAVE_SYS_STAT_H
+| # include <sys/stat.h>
+| #endif
+| #if STDC_HEADERS
+| # include <stdlib.h>
+| # include <stddef.h>
+| #else
+| # if HAVE_STDLIB_H
+| #  include <stdlib.h>
+| # endif
+| #endif
+| #if HAVE_STRING_H
+| # if !STDC_HEADERS && HAVE_MEMORY_H
+| #  include <memory.h>
+| # endif
+| # include <string.h>
+| #endif
+| #if HAVE_STRINGS_H
+| # include <strings.h>
+| #endif
+| #if HAVE_INTTYPES_H
+| # include <inttypes.h>
+| #else
+| # if HAVE_STDINT_H
+| #  include <stdint.h>
+| # endif
+| #endif
+| #if HAVE_UNISTD_H
+| # include <unistd.h>
+| #endif
+| int
+| main ()
+| {
+| getpgrp (0);
+|   ;
+|   return 0;
+| }
+configure:5004: result: yes
+configure:5015: checking whether gcc needs -traditional
+configure:5057: result: no
+configure:5064: checking whether setpgrp takes no argument
+configure:5096: gcc -o conftest -g -O2 -I$(srcdir)   conftest.c  >&5
+conftest.c: In function 'main':
+conftest.c:47: warning: incompatible implicit declaration of built-in function 'exit'
+conftest.c:47: error: too many arguments to function 'setpgrp'
+configure:5099: $? = 1
+configure: program exited with status 1
+configure: failed program was:
+| /* confdefs.h.  */
+| 
+| #define PACKAGE_NAME ""
+| #define PACKAGE_TARNAME ""
+| #define PACKAGE_VERSION ""
+| #define PACKAGE_STRING ""
+| #define PACKAGE_BUGREPORT ""
+| #define YYTEXT_POINTER 1
+| #define HAVE_GETADDRINFO 1
+| #define HAVE_GETNAMEINFO 1
+| #define HAVE_GETIFADDRS 1
+| #define HAVE_IF_NAMETOINDEX 1
+| #define HAVE_DAEMON 1
+| #define HAVE_WARNX 1
+| #define STDC_HEADERS 1
+| #define HAVE_SYS_TYPES_H 1
+| #define HAVE_SYS_STAT_H 1
+| #define HAVE_STDLIB_H 1
+| #define HAVE_STRING_H 1
+| #define HAVE_MEMORY_H 1
+| #define HAVE_STRINGS_H 1
+| #define HAVE_INTTYPES_H 1
+| #define HAVE_STDINT_H 1
+| #define HAVE_UNISTD_H 1
+| #define HAVE_FCNTL_H 1
+| #define HAVE_SYS_IOCTL_H 1
+| #define HAVE_SYS_TIME_H 1
+| #define HAVE_SYSLOG_H 1
+| #define HAVE_UNISTD_H 1
+| #define HAVE_IFADDRS_H 1
+| #define TIME_WITH_SYS_TIME 1
+| #define HAVE_STRUCT_TM_TM_ZONE 1
+| #define HAVE_TM_ZONE 1
+| #define HAVE_SIG_ATOMIC_T 1
+| #define GETPGRP_VOID 1
+| /* end confdefs.h.  */
+| #if HAVE_UNISTD_H
+| # include <unistd.h>
+| #endif
+| 
+| int
+| main ()
+| {
+| /* If this system has a BSD-style setpgrp which takes arguments,
+|   setpgrp(1, 1) will fail with ESRCH and return -1, in that case
+|   exit successfully. */
+|   exit (setpgrp (1,1) == -1 ? 0 : 1);
+|   ;
+|   return 0;
+| }
+configure:5118: result: yes
+configure:5128: checking return type of signal handlers
+configure:5159: gcc -c -g -O2 -I$(srcdir)  conftest.c >&5
+configure:5165: $? = 0
+configure:5169: test -z 
+			 || test ! -s conftest.err
+configure:5172: $? = 0
+configure:5175: test -s conftest.o
+configure:5178: $? = 0
+configure:5189: result: void
+configure:5203: checking for mktime
+configure:5260: gcc -o conftest -g -O2 -I$(srcdir)   conftest.c  >&5
+configure:5266: $? = 0
+configure:5270: test -z 
+			 || test ! -s conftest.err
+configure:5273: $? = 0
+configure:5276: test -s conftest
+configure:5279: $? = 0
+configure:5291: result: yes
+configure:5203: checking for select
+configure:5260: gcc -o conftest -g -O2 -I$(srcdir)   conftest.c  >&5
+configure:5266: $? = 0
+configure:5270: test -z 
+			 || test ! -s conftest.err
+configure:5273: $? = 0
+configure:5276: test -s conftest
+configure:5279: $? = 0
+configure:5291: result: yes
+configure:5203: checking for socket
+configure:5260: gcc -o conftest -g -O2 -I$(srcdir)   conftest.c  >&5
+configure:5266: $? = 0
+configure:5270: test -z 
+			 || test ! -s conftest.err
+configure:5273: $? = 0
+configure:5276: test -s conftest
+configure:5279: $? = 0
+configure:5291: result: yes
+configure:5305: checking for clock_gettime
+configure:5362: gcc -o conftest -g -O2 -I$(srcdir)   conftest.c  >&5
+/tmp/ccuiKDli.o: In function `main':
+/home/jerry/broadcom/VMG5313/userspace/zyxel/public/apps/dhcpv6/conftest.c:81: undefined reference to `clock_gettime'
+/tmp/ccuiKDli.o:(.data+0x0): undefined reference to `clock_gettime'
+collect2: ld returned 1 exit status
+configure:5368: $? = 1
+configure: failed program was:
+| /* confdefs.h.  */
+| 
+| #define PACKAGE_NAME ""
+| #define PACKAGE_TARNAME ""
+| #define PACKAGE_VERSION ""
+| #define PACKAGE_STRING ""
+| #define PACKAGE_BUGREPORT ""
+| #define YYTEXT_POINTER 1
+| #define HAVE_GETADDRINFO 1
+| #define HAVE_GETNAMEINFO 1
+| #define HAVE_GETIFADDRS 1
+| #define HAVE_IF_NAMETOINDEX 1
+| #define HAVE_DAEMON 1
+| #define HAVE_WARNX 1
+| #define STDC_HEADERS 1
+| #define HAVE_SYS_TYPES_H 1
+| #define HAVE_SYS_STAT_H 1
+| #define HAVE_STDLIB_H 1
+| #define HAVE_STRING_H 1
+| #define HAVE_MEMORY_H 1
+| #define HAVE_STRINGS_H 1
+| #define HAVE_INTTYPES_H 1
+| #define HAVE_STDINT_H 1
+| #define HAVE_UNISTD_H 1
+| #define HAVE_FCNTL_H 1
+| #define HAVE_SYS_IOCTL_H 1
+| #define HAVE_SYS_TIME_H 1
+| #define HAVE_SYSLOG_H 1
+| #define HAVE_UNISTD_H 1
+| #define HAVE_IFADDRS_H 1
+| #define TIME_WITH_SYS_TIME 1
+| #define HAVE_STRUCT_TM_TM_ZONE 1
+| #define HAVE_TM_ZONE 1
+| #define HAVE_SIG_ATOMIC_T 1
+| #define GETPGRP_VOID 1
+| #define SETPGRP_VOID 1
+| #define RETSIGTYPE void
+| #define HAVE_MKTIME 1
+| #define HAVE_SELECT 1
+| #define HAVE_SOCKET 1
+| /* end confdefs.h.  */
+| /* Define clock_gettime to an innocuous variant, in case <limits.h> declares clock_gettime.
+|    For example, HP-UX 11i <limits.h> declares gettimeofday.  */
+| #define clock_gettime innocuous_clock_gettime
+| 
+| /* System header to define __stub macros and hopefully few prototypes,
+|     which can conflict with char clock_gettime (); below.
+|     Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
+|     <limits.h> exists even on freestanding compilers.  */
+| 
+| #ifdef __STDC__
+| # include <limits.h>
+| #else
+| # include <assert.h>
+| #endif
+| 
+| #undef clock_gettime
+| 
+| /* Override any gcc2 internal prototype to avoid an error.  */
+| #ifdef __cplusplus
+| extern "C"
+| {
+| #endif
+| /* We use char because int might match the return type of a gcc2
+|    builtin and then its argument prototype would still apply.  */
+| char clock_gettime ();
+| /* The GNU C library defines this for functions which it implements
+|     to always fail with ENOSYS.  Some functions are actually named
+|     something starting with __ and the normal name is an alias.  */
+| #if defined (__stub_clock_gettime) || defined (__stub___clock_gettime)
+| choke me
+| #else
+| char (*f) () = clock_gettime;
+| #endif
+| #ifdef __cplusplus
+| }
+| #endif
+| 
+| int
+| main ()
+| {
+| return f != clock_gettime;
+|   ;
+|   return 0;
+| }
+configure:5393: result: no
+configure:5404: checking for local DB directory
+configure:5414: result: /var/db
+configure:5422: checking for arc4random
+configure:5479: gcc -o conftest -g -O2 -I$(srcdir)   conftest.c  >&5
+/tmp/ccgKbU6x.o: In function `main':
+/home/jerry/broadcom/VMG5313/userspace/zyxel/public/apps/dhcpv6/conftest.c:81: undefined reference to `arc4random'
+/tmp/ccgKbU6x.o:(.data+0x0): undefined reference to `arc4random'
+collect2: ld returned 1 exit status
+configure:5485: $? = 1
+configure: failed program was:
+| /* confdefs.h.  */
+| 
+| #define PACKAGE_NAME ""
+| #define PACKAGE_TARNAME ""
+| #define PACKAGE_VERSION ""
+| #define PACKAGE_STRING ""
+| #define PACKAGE_BUGREPORT ""
+| #define YYTEXT_POINTER 1
+| #define HAVE_GETADDRINFO 1
+| #define HAVE_GETNAMEINFO 1
+| #define HAVE_GETIFADDRS 1
+| #define HAVE_IF_NAMETOINDEX 1
+| #define HAVE_DAEMON 1
+| #define HAVE_WARNX 1
+| #define STDC_HEADERS 1
+| #define HAVE_SYS_TYPES_H 1
+| #define HAVE_SYS_STAT_H 1
+| #define HAVE_STDLIB_H 1
+| #define HAVE_STRING_H 1
+| #define HAVE_MEMORY_H 1
+| #define HAVE_STRINGS_H 1
+| #define HAVE_INTTYPES_H 1
+| #define HAVE_STDINT_H 1
+| #define HAVE_UNISTD_H 1
+| #define HAVE_FCNTL_H 1
+| #define HAVE_SYS_IOCTL_H 1
+| #define HAVE_SYS_TIME_H 1
+| #define HAVE_SYSLOG_H 1
+| #define HAVE_UNISTD_H 1
+| #define HAVE_IFADDRS_H 1
+| #define TIME_WITH_SYS_TIME 1
+| #define HAVE_STRUCT_TM_TM_ZONE 1
+| #define HAVE_TM_ZONE 1
+| #define HAVE_SIG_ATOMIC_T 1
+| #define GETPGRP_VOID 1
+| #define SETPGRP_VOID 1
+| #define RETSIGTYPE void
+| #define HAVE_MKTIME 1
+| #define HAVE_SELECT 1
+| #define HAVE_SOCKET 1
+| /* end confdefs.h.  */
+| /* Define arc4random to an innocuous variant, in case <limits.h> declares arc4random.
+|    For example, HP-UX 11i <limits.h> declares gettimeofday.  */
+| #define arc4random innocuous_arc4random
+| 
+| /* System header to define __stub macros and hopefully few prototypes,
+|     which can conflict with char arc4random (); below.
+|     Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
+|     <limits.h> exists even on freestanding compilers.  */
+| 
+| #ifdef __STDC__
+| # include <limits.h>
+| #else
+| # include <assert.h>
+| #endif
+| 
+| #undef arc4random
+| 
+| /* Override any gcc2 internal prototype to avoid an error.  */
+| #ifdef __cplusplus
+| extern "C"
+| {
+| #endif
+| /* We use char because int might match the return type of a gcc2
+|    builtin and then its argument prototype would still apply.  */
+| char arc4random ();
+| /* The GNU C library defines this for functions which it implements
+|     to always fail with ENOSYS.  Some functions are actually named
+|     something starting with __ and the normal name is an alias.  */
+| #if defined (__stub_arc4random) || defined (__stub___arc4random)
+| choke me
+| #else
+| char (*f) () = arc4random;
+| #endif
+| #ifdef __cplusplus
+| }
+| #endif
+| 
+| int
+| main ()
+| {
+| return f != arc4random;
+|   ;
+|   return 0;
+| }
+configure:5510: result: no
+configure:5531: checking if --enable-pedant option is specified
+configure:5542: result: no
+configure:5545: checking ANSI predeclared __func__
+configure:5563: gcc -c -g -O2 -I$(srcdir)  conftest.c >&5
+conftest.c: In function 'func':
+conftest.c:46: warning: incompatible implicit declaration of built-in function 'printf'
+configure:5569: $? = 0
+configure:5573: test -z 
+			 || test ! -s conftest.err
+configure:5576: $? = 0
+configure:5579: test -s conftest.o
+configure:5582: $? = 0
+configure:5584: result: yes
+configure:5665: checking checking the existence TAILQ_FOREACH_REVERSE
+configure:5686: result: yes
+configure:5696: checking argument order of TAILQ_FOREACH_REVERSE
+configure:5728: gcc -c -g -O2 -I$(srcdir)  conftest.c >&5
+In file included from /usr/include/stdio.h:907,
+                 from conftest.c:48:
+/usr/include/bits/stdio.h: In function 'main':
+/usr/include/bits/stdio.h:46: error: nested function 'getchar' declared 'extern'
+/usr/include/bits/stdio.h:45: error: static declaration of 'getchar' follows non-static declaration
+/usr/include/stdio.h:520: note: previous declaration of 'getchar' was here
+/usr/include/bits/stdio.h:55: error: nested function 'fgetc_unlocked' declared 'extern'
+/usr/include/bits/stdio.h:54: error: static declaration of 'fgetc_unlocked' follows non-static declaration
+/usr/include/stdio.h:543: note: previous declaration of 'fgetc_unlocked' was here
+/usr/include/bits/stdio.h:65: error: nested function 'getc_unlocked' declared 'extern'
+/usr/include/bits/stdio.h:64: error: static declaration of 'getc_unlocked' follows non-static declaration
+/usr/include/stdio.h:532: note: previous declaration of 'getc_unlocked' was here
+/usr/include/bits/stdio.h:72: error: nested function 'getchar_unlocked' declared 'extern'
+/usr/include/bits/stdio.h:71: error: static declaration of 'getchar_unlocked' follows non-static declaration
+/usr/include/stdio.h:533: note: previous declaration of 'getchar_unlocked' was here
+/usr/include/bits/stdio.h:81: error: nested function 'putchar' declared 'extern'
+/usr/include/bits/stdio.h:80: error: static declaration of 'putchar' follows non-static declaration
+/usr/include/bits/stdio.h:90: error: nested function 'fputc_unlocked' declared 'extern'
+/usr/include/bits/stdio.h:89: error: static declaration of 'fputc_unlocked' follows non-static declaration
+/usr/include/bits/stdio.h:100: error: nested function 'putc_unlocked' declared 'extern'
+/usr/include/bits/stdio.h:99: error: static declaration of 'putc_unlocked' follows non-static declaration
+/usr/include/bits/stdio.h:107: error: nested function 'putchar_unlocked' declared 'extern'
+/usr/include/bits/stdio.h:106: error: static declaration of 'putchar_unlocked' follows non-static declaration
+/usr/include/bits/stdio.h:127: error: nested function 'feof_unlocked' declared 'extern'
+/usr/include/bits/stdio.h:126: error: static declaration of 'feof_unlocked' follows non-static declaration
+/usr/include/stdio.h:809: note: previous declaration of 'feof_unlocked' was here
+/usr/include/bits/stdio.h:134: error: nested function 'ferror_unlocked' declared 'extern'
+/usr/include/bits/stdio.h:133: error: static declaration of 'ferror_unlocked' follows non-static declaration
+/usr/include/stdio.h:810: note: previous declaration of 'ferror_unlocked' was here
+In file included from /usr/include/stdio.h:910,
+                 from conftest.c:48:
+/usr/include/bits/stdio2.h:33: error: nested function 'sprintf' declared 'extern'
+/usr/include/bits/stdio2.h:32: error: static declaration of 'sprintf' follows non-static declaration
+/usr/include/bits/stdio2.h:46: error: nested function 'vsprintf' declared 'extern'
+/usr/include/bits/stdio2.h:44: error: static declaration of 'vsprintf' follows non-static declaration
+/usr/include/bits/stdio2.h:64: error: nested function 'snprintf' declared 'extern'
+/usr/include/bits/stdio2.h:62: error: static declaration of 'snprintf' follows non-static declaration
+/usr/include/bits/stdio2.h:77: error: nested function 'vsnprintf' declared 'extern'
+/usr/include/bits/stdio2.h:75: error: static declaration of 'vsnprintf' follows non-static declaration
+/usr/include/bits/stdio2.h:97: error: nested function 'fprintf' declared 'extern'
+/usr/include/bits/stdio2.h:96: error: static declaration of 'fprintf' follows non-static declaration
+/usr/include/bits/stdio2.h:104: error: nested function 'printf' declared 'extern'
+/usr/include/bits/stdio2.h:103: error: static declaration of 'printf' follows non-static declaration
+/usr/include/bits/stdio2.h:116: error: nested function 'vprintf' declared 'extern'
+/usr/include/bits/stdio2.h:115: error: static declaration of 'vprintf' follows non-static declaration
+/usr/include/bits/stdio2.h:127: error: nested function 'vfprintf' declared 'extern'
+/usr/include/bits/stdio2.h:125: error: static declaration of 'vfprintf' follows non-static declaration
+/usr/include/bits/stdio2.h:227: error: nested function 'gets' declared 'extern'
+/usr/include/bits/stdio2.h:226: error: static declaration of 'gets' follows non-static declaration
+/usr/include/stdio.h:612: note: previous declaration of 'gets' was here
+/usr/include/bits/stdio2.h:246: error: nested function 'fgets' declared 'extern'
+/usr/include/bits/stdio2.h:245: error: static declaration of 'fgets' follows non-static declaration
+/usr/include/stdio.h:604: note: previous declaration of 'fgets' was here
+/usr/include/bits/stdio2.h:276: error: nested function 'fread' declared 'extern'
+/usr/include/bits/stdio2.h:274: error: static declaration of 'fread' follows non-static declaration
+/usr/include/stdio.h:682: note: previous declaration of 'fread' was here
+/usr/include/bits/stdio2.h:337: error: nested function 'fread_unlocked' declared 'extern'
+/usr/include/bits/stdio2.h:335: error: static declaration of 'fread_unlocked' follows non-static declaration
+/usr/include/stdio.h:710: note: previous declaration of 'fread_unlocked' was here
+configure:5734: $? = 1
+configure: failed program was:
+| /* confdefs.h.  */
+| 
+| #define PACKAGE_NAME ""
+| #define PACKAGE_TARNAME ""
+| #define PACKAGE_VERSION ""
+| #define PACKAGE_STRING ""
+| #define PACKAGE_BUGREPORT ""
+| #define YYTEXT_POINTER 1
+| #define HAVE_GETADDRINFO 1
+| #define HAVE_GETNAMEINFO 1
+| #define HAVE_GETIFADDRS 1
+| #define HAVE_IF_NAMETOINDEX 1
+| #define HAVE_DAEMON 1
+| #define HAVE_WARNX 1
+| #define STDC_HEADERS 1
+| #define HAVE_SYS_TYPES_H 1
+| #define HAVE_SYS_STAT_H 1
+| #define HAVE_STDLIB_H 1
+| #define HAVE_STRING_H 1
+| #define HAVE_MEMORY_H 1
+| #define HAVE_STRINGS_H 1
+| #define HAVE_INTTYPES_H 1
+| #define HAVE_STDINT_H 1
+| #define HAVE_UNISTD_H 1
+| #define HAVE_FCNTL_H 1
+| #define HAVE_SYS_IOCTL_H 1
+| #define HAVE_SYS_TIME_H 1
+| #define HAVE_SYSLOG_H 1
+| #define HAVE_UNISTD_H 1
+| #define HAVE_IFADDRS_H 1
+| #define TIME_WITH_SYS_TIME 1
+| #define HAVE_STRUCT_TM_TM_ZONE 1
+| #define HAVE_TM_ZONE 1
+| #define HAVE_SIG_ATOMIC_T 1
+| #define GETPGRP_VOID 1
+| #define SETPGRP_VOID 1
+| #define RETSIGTYPE void
+| #define HAVE_MKTIME 1
+| #define HAVE_SELECT 1
+| #define HAVE_SOCKET 1
+| #define HAVE_ANSI_FUNC 1
+| /* end confdefs.h.  */
+| 
+| int
+| main ()
+| {
+| 
+| 	#include <stdio.h>
+| 	#include <sys/queue.h>
+| 
+| 	TAILQ_HEAD(tailhead, entry) head = TAILQ_HEAD_INITIALIZER(head);
+| 	struct entry {
+| 		TAILQ_ENTRY(entry) entries;
+| 	} *p;
+| 
+| 	int i;
+| 	struct tailhead *headp;
+| 
+| 	TAILQ_FOREACH_REVERSE(p, headp, tailhead, entries) {
+| 	}
+| 
+|   ;
+|   return 0;
+| }
+configure:5759: result: old
+configure:5769: checking if you have a length field in struct sockaddr*
+configure:5796: gcc -c -g -O2 -I$(srcdir)  conftest.c >&5
+conftest.c: In function 'main':
+conftest.c:53: error: 'struct sockaddr' has no member named 'sa_len'
+configure:5802: $? = 1
+configure: failed program was:
+| /* confdefs.h.  */
+| 
+| #define PACKAGE_NAME ""
+| #define PACKAGE_TARNAME ""
+| #define PACKAGE_VERSION ""
+| #define PACKAGE_STRING ""
+| #define PACKAGE_BUGREPORT ""
+| #define YYTEXT_POINTER 1
+| #define HAVE_GETADDRINFO 1
+| #define HAVE_GETNAMEINFO 1
+| #define HAVE_GETIFADDRS 1
+| #define HAVE_IF_NAMETOINDEX 1
+| #define HAVE_DAEMON 1
+| #define HAVE_WARNX 1
+| #define STDC_HEADERS 1
+| #define HAVE_SYS_TYPES_H 1
+| #define HAVE_SYS_STAT_H 1
+| #define HAVE_STDLIB_H 1
+| #define HAVE_STRING_H 1
+| #define HAVE_MEMORY_H 1
+| #define HAVE_STRINGS_H 1
+| #define HAVE_INTTYPES_H 1
+| #define HAVE_STDINT_H 1
+| #define HAVE_UNISTD_H 1
+| #define HAVE_FCNTL_H 1
+| #define HAVE_SYS_IOCTL_H 1
+| #define HAVE_SYS_TIME_H 1
+| #define HAVE_SYSLOG_H 1
+| #define HAVE_UNISTD_H 1
+| #define HAVE_IFADDRS_H 1
+| #define TIME_WITH_SYS_TIME 1
+| #define HAVE_STRUCT_TM_TM_ZONE 1
+| #define HAVE_TM_ZONE 1
+| #define HAVE_SIG_ATOMIC_T 1
+| #define GETPGRP_VOID 1
+| #define SETPGRP_VOID 1
+| #define RETSIGTYPE void
+| #define HAVE_MKTIME 1
+| #define HAVE_SELECT 1
+| #define HAVE_SOCKET 1
+| #define HAVE_ANSI_FUNC 1
+| #define HAVE_TAILQ_FOREACH_REVERSE_OLD 1
+| /* end confdefs.h.  */
+| 
+|  #include <sys/types.h>
+|  #include <sys/socket.h>
+| 
+| int
+| main ()
+| {
+| 
+|  struct sockaddr a;
+|  a.sa_len = 1;
+| 
+|   ;
+|   return 0;
+| }
+configure:5827: result: no
+configure:5837: checking the owner of the programs
+configure:5847: result: bin
+configure:5851: checking the group owner of the programs
+configure:5861: result: bin
+configure:5879: checking stdarg.h usability
+configure:5891: gcc -c -g -O2 -I$(srcdir)  conftest.c >&5
+configure:5897: $? = 0
+configure:5901: test -z 
+			 || test ! -s conftest.err
+configure:5904: $? = 0
+configure:5907: test -s conftest.o
+configure:5910: $? = 0
+configure:5920: result: yes
+configure:5924: checking stdarg.h presence
+configure:5934: gcc -E  conftest.c
+configure:5940: $? = 0
+configure:5960: result: yes
+configure:5995: checking for stdarg.h
+configure:6002: result: yes
+configure:6143: creating ./config.status
+
+## ---------------------- ##
+## Running config.status. ##
+## ---------------------- ##
+
+This file was extended by config.status, which was
+generated by GNU Autoconf 2.59.  Invocation command line was
+
+  CONFIG_FILES    = 
+  CONFIG_HEADERS  = 
+  CONFIG_LINKS    = 
+  CONFIG_COMMANDS = 
+  $ ./config.status 
+
+on jerry-desktop
+
+config.status:649: creating Makefile
+
+## ---------------- ##
+## Cache variables. ##
+## ---------------- ##
+
+ac_cv_c_compiler_gnu=yes
+ac_cv_c_const=yes
+ac_cv_env_CC_set=
+ac_cv_env_CC_value=
+ac_cv_env_CFLAGS_set=
+ac_cv_env_CFLAGS_value=
+ac_cv_env_CPPFLAGS_set=
+ac_cv_env_CPPFLAGS_value=
+ac_cv_env_CPP_set=
+ac_cv_env_CPP_value=
+ac_cv_env_LDFLAGS_set=
+ac_cv_env_LDFLAGS_value=
+ac_cv_env_build_alias_set=
+ac_cv_env_build_alias_value=
+ac_cv_env_host_alias_set=
+ac_cv_env_host_alias_value=
+ac_cv_env_target_alias_set=
+ac_cv_env_target_alias_value=
+ac_cv_exeext=
+ac_cv_func_arc4random=no
+ac_cv_func_clock_gettime=no
+ac_cv_func_daemon=yes
+ac_cv_func_getaddrinfo=yes
+ac_cv_func_getifaddrs=yes
+ac_cv_func_getnameinfo=yes
+ac_cv_func_getpgrp_void=yes
+ac_cv_func_if_nametoindex=yes
+ac_cv_func_mktime=yes
+ac_cv_func_select=yes
+ac_cv_func_setpgrp_void=yes
+ac_cv_func_socket=yes
+ac_cv_func_strlcat=no
+ac_cv_func_strlcpy=no
+ac_cv_func_warnx=yes
+ac_cv_header_fcntl_h=yes
+ac_cv_header_ifaddrs_h=yes
+ac_cv_header_inttypes_h=yes
+ac_cv_header_memory_h=yes
+ac_cv_header_stdarg_h=yes
+ac_cv_header_stdc=yes
+ac_cv_header_stdint_h=yes
+ac_cv_header_stdlib_h=yes
+ac_cv_header_string_h=yes
+ac_cv_header_strings_h=yes
+ac_cv_header_sys_ioctl_h=yes
+ac_cv_header_sys_stat_h=yes
+ac_cv_header_sys_time_h=yes
+ac_cv_header_sys_types_h=yes
+ac_cv_header_syslog_h=yes
+ac_cv_header_time=yes
+ac_cv_header_unistd_h=yes
+ac_cv_lib_fl_yywrap=yes
+ac_cv_member_struct_tm_tm_zone=yes
+ac_cv_objext=o
+ac_cv_path_install='/usr/bin/install -c'
+ac_cv_prog_CPP='gcc -E'
+ac_cv_prog_LEX=flex
+ac_cv_prog_YACC='bison -y'
+ac_cv_prog_ac_ct_CC=gcc
+ac_cv_prog_cc_g=yes
+ac_cv_prog_cc_stdc=
+ac_cv_prog_egrep='grep -E'
+ac_cv_prog_gcc_traditional=no
+ac_cv_prog_lex_root=lex.yy
+ac_cv_prog_lex_yytext_pointer=yes
+ac_cv_prog_make_make_set=yes
+ac_cv_struct_tm=time.h
+ac_cv_type_sig_atomic_t=yes
+ac_cv_type_signal=void
+ac_cv_type_size_t=yes
+ts_cv_sa_len=no
+
+## ----------------- ##
+## Output variables. ##
+## ----------------- ##
+
+CC='gcc'
+CFLAGS='-g -O2 -I$(srcdir)'
+CPP='gcc -E'
+CPPFLAGS=''
+DEFS='-DPACKAGE_NAME=\"\" -DPACKAGE_TARNAME=\"\" -DPACKAGE_VERSION=\"\" -DPACKAGE_STRING=\"\" -DPACKAGE_BUGREPORT=\"\" -DYYTEXT_POINTER=1 -DHAVE_GETADDRINFO=1 -DHAVE_GETNAMEINFO=1 -DHAVE_GETIFADDRS=1 -DHAVE_IF_NAMETOINDEX=1 -DHAVE_DAEMON=1 -DHAVE_WARNX=1 -DSTDC_HEADERS=1 -DHAVE_SYS_TYPES_H=1 -DHAVE_SYS_STAT_H=1 -DHAVE_STDLIB_H=1 -DHAVE_STRING_H=1 -DHAVE_MEMORY_H=1 -DHAVE_STRINGS_H=1 -DHAVE_INTTYPES_H=1 -DHAVE_STDINT_H=1 -DHAVE_UNISTD_H=1 -DHAVE_FCNTL_H=1 -DHAVE_SYS_IOCTL_H=1 -DHAVE_SYS_TIME_H=1 -DHAVE_SYSLOG_H=1 -DHAVE_UNISTD_H=1 -DHAVE_IFADDRS_H=1 -DTIME_WITH_SYS_TIME=1 -DHAVE_STRUCT_TM_TM_ZONE=1 -DHAVE_TM_ZONE=1 -DHAVE_SIG_ATOMIC_T=1 -DGETPGRP_VOID=1 -DSETPGRP_VOID=1 -DRETSIGTYPE=void -DHAVE_MKTIME=1 -DHAVE_SELECT=1 -DHAVE_SOCKET=1 -DHAVE_ANSI_FUNC=1 -DHAVE_TAILQ_FOREACH_REVERSE_OLD=1 -DHAVE_STDARG_H=1 '
+ECHO_C=''
+ECHO_N='-n'
+ECHO_T=''
+EGREP='grep -E'
+EXEEXT=''
+INSTALL_DATA='${INSTALL} -m 644'
+INSTALL_PROGRAM='${INSTALL}'
+INSTALL_SCRIPT='${INSTALL}'
+LDFLAGS=''
+LEX='flex'
+LEXLIB='-lfl'
+LEX_OUTPUT_ROOT='lex.yy'
+LIBOBJS=' strlcpy$U.o strlcat$U.o arc4random$U.o'
+LIBS=''
+LTLIBOBJS=' strlcpy$U.lo strlcat$U.lo arc4random$U.lo'
+OBJEXT='o'
+PACKAGE_BUGREPORT=''
+PACKAGE_NAME=''
+PACKAGE_STRING=''
+PACKAGE_TARNAME=''
+PACKAGE_VERSION=''
+PATH_SEPARATOR=':'
+SET_MAKE=''
+SHELL='/bin/sh'
+YACC='bison -y'
+ac_ct_CC='gcc'
+bindir='${exec_prefix}/bin'
+build_alias=''
+datadir='${prefix}/share'
+exec_prefix='${prefix}'
+group='bin'
+host_alias=''
+includedir='${prefix}/include'
+infodir='${prefix}/info'
+libdir='${exec_prefix}/lib'
+libexecdir='${exec_prefix}/libexec'
+localdbdir='/var/db'
+localstatedir='${prefix}/var'
+mandir='${prefix}/man'
+oldincludedir='/usr/include'
+prefix='/usr/local'
+program_transform_name='s,x,x,'
+sbindir='${exec_prefix}/sbin'
+sharedstatedir='${prefix}/com'
+sysconfdir='${prefix}/etc'
+target_alias=''
+user='bin'
+
+## ----------- ##
+## confdefs.h. ##
+## ----------- ##
+
+#define GETPGRP_VOID 1
+#define HAVE_ANSI_FUNC 1
+#define HAVE_DAEMON 1
+#define HAVE_FCNTL_H 1
+#define HAVE_GETADDRINFO 1
+#define HAVE_GETIFADDRS 1
+#define HAVE_GETNAMEINFO 1
+#define HAVE_IFADDRS_H 1
+#define HAVE_IF_NAMETOINDEX 1
+#define HAVE_INTTYPES_H 1
+#define HAVE_MEMORY_H 1
+#define HAVE_MKTIME 1
+#define HAVE_SELECT 1
+#define HAVE_SIG_ATOMIC_T 1
+#define HAVE_SOCKET 1
+#define HAVE_STDARG_H 1
+#define HAVE_STDINT_H 1
+#define HAVE_STDLIB_H 1
+#define HAVE_STRINGS_H 1
+#define HAVE_STRING_H 1
+#define HAVE_STRUCT_TM_TM_ZONE 1
+#define HAVE_SYSLOG_H 1
+#define HAVE_SYS_IOCTL_H 1
+#define HAVE_SYS_STAT_H 1
+#define HAVE_SYS_TIME_H 1
+#define HAVE_SYS_TYPES_H 1
+#define HAVE_TAILQ_FOREACH_REVERSE_OLD 1
+#define HAVE_TM_ZONE 1
+#define HAVE_UNISTD_H 1
+#define HAVE_UNISTD_H 1
+#define HAVE_WARNX 1
+#define PACKAGE_BUGREPORT ""
+#define PACKAGE_NAME ""
+#define PACKAGE_STRING ""
+#define PACKAGE_TARNAME ""
+#define PACKAGE_VERSION ""
+#define RETSIGTYPE void
+#define SETPGRP_VOID 1
+#define STDC_HEADERS 1
+#define TIME_WITH_SYS_TIME 1
+#define YYTEXT_POINTER 1
+
+configure: exit 0
diff -Naur wide-dhcpv6-20080615.orig/config.status wide-dhcpv6-20080615/config.status
--- wide-dhcpv6-20080615.orig/config.status	1970-01-01 08:00:00.000000000 +0800
+++ wide-dhcpv6-20080615/config.status	2013-12-30 16:11:43.000000000 +0800
@@ -0,0 +1,723 @@
+#! /bin/sh
+# Generated by configure.
+# Run this file to recreate the current configuration.
+# Compiler output produced by configure, useful for debugging
+# configure, is in config.log if it exists.
+
+debug=false
+ac_cs_recheck=false
+ac_cs_silent=false
+SHELL=${CONFIG_SHELL-/bin/sh}
+## --------------------- ##
+## M4sh Initialization.  ##
+## --------------------- ##
+
+# Be Bourne compatible
+if test -n "${ZSH_VERSION+set}" && (emulate sh) >/dev/null 2>&1; then
+  emulate sh
+  NULLCMD=:
+  # Zsh 3.x and 4.x performs word splitting on ${1+"$@"}, which
+  # is contrary to our usage.  Disable this feature.
+  alias -g '${1+"$@"}'='"$@"'
+elif test -n "${BASH_VERSION+set}" && (set -o posix) >/dev/null 2>&1; then
+  set -o posix
+fi
+DUALCASE=1; export DUALCASE # for MKS sh
+
+# Support unset when possible.
+if ( (MAIL=60; unset MAIL) || exit) >/dev/null 2>&1; then
+  as_unset=unset
+else
+  as_unset=false
+fi
+
+
+# Work around bugs in pre-3.0 UWIN ksh.
+$as_unset ENV MAIL MAILPATH
+PS1='$ '
+PS2='> '
+PS4='+ '
+
+# NLS nuisances.
+for as_var in \
+  LANG LANGUAGE LC_ADDRESS LC_ALL LC_COLLATE LC_CTYPE LC_IDENTIFICATION \
+  LC_MEASUREMENT LC_MESSAGES LC_MONETARY LC_NAME LC_NUMERIC LC_PAPER \
+  LC_TELEPHONE LC_TIME
+do
+  if (set +x; test -z "`(eval $as_var=C; export $as_var) 2>&1`"); then
+    eval $as_var=C; export $as_var
+  else
+    $as_unset $as_var
+  fi
+done
+
+# Required to use basename.
+if expr a : '\(a\)' >/dev/null 2>&1; then
+  as_expr=expr
+else
+  as_expr=false
+fi
+
+if (basename /) >/dev/null 2>&1 && test "X`basename / 2>&1`" = "X/"; then
+  as_basename=basename
+else
+  as_basename=false
+fi
+
+
+# Name of the executable.
+as_me=`$as_basename "$0" ||
+$as_expr X/"$0" : '.*/\([^/][^/]*\)/*$' \| \
+	 X"$0" : 'X\(//\)$' \| \
+	 X"$0" : 'X\(/\)$' \| \
+	 .     : '\(.\)' 2>/dev/null ||
+echo X/"$0" |
+    sed '/^.*\/\([^/][^/]*\)\/*$/{ s//\1/; q; }
+  	  /^X\/\(\/\/\)$/{ s//\1/; q; }
+  	  /^X\/\(\/\).*/{ s//\1/; q; }
+  	  s/.*/./; q'`
+
+
+# PATH needs CR, and LINENO needs CR and PATH.
+# Avoid depending upon Character Ranges.
+as_cr_letters='abcdefghijklmnopqrstuvwxyz'
+as_cr_LETTERS='ABCDEFGHIJKLMNOPQRSTUVWXYZ'
+as_cr_Letters=$as_cr_letters$as_cr_LETTERS
+as_cr_digits='0123456789'
+as_cr_alnum=$as_cr_Letters$as_cr_digits
+
+# The user is always right.
+if test "${PATH_SEPARATOR+set}" != set; then
+  echo "#! /bin/sh" >conf$$.sh
+  echo  "exit 0"   >>conf$$.sh
+  chmod +x conf$$.sh
+  if (PATH="/nonexistent;."; conf$$.sh) >/dev/null 2>&1; then
+    PATH_SEPARATOR=';'
+  else
+    PATH_SEPARATOR=:
+  fi
+  rm -f conf$$.sh
+fi
+
+
+  as_lineno_1=$LINENO
+  as_lineno_2=$LINENO
+  as_lineno_3=`(expr $as_lineno_1 + 1) 2>/dev/null`
+  test "x$as_lineno_1" != "x$as_lineno_2" &&
+  test "x$as_lineno_3"  = "x$as_lineno_2"  || {
+  # Find who we are.  Look in the path if we contain no path at all
+  # relative or not.
+  case $0 in
+    *[\\/]* ) as_myself=$0 ;;
+    *) as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  test -r "$as_dir/$0" && as_myself=$as_dir/$0 && break
+done
+
+       ;;
+  esac
+  # We did not find ourselves, most probably we were run as `sh COMMAND'
+  # in which case we are not to be found in the path.
+  if test "x$as_myself" = x; then
+    as_myself=$0
+  fi
+  if test ! -f "$as_myself"; then
+    { { echo "$as_me:$LINENO: error: cannot find myself; rerun with an absolute path" >&5
+echo "$as_me: error: cannot find myself; rerun with an absolute path" >&2;}
+   { (exit 1); exit 1; }; }
+  fi
+  case $CONFIG_SHELL in
+  '')
+    as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in /bin$PATH_SEPARATOR/usr/bin$PATH_SEPARATOR$PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  for as_base in sh bash ksh sh5; do
+	 case $as_dir in
+	 /*)
+	   if ("$as_dir/$as_base" -c '
+  as_lineno_1=$LINENO
+  as_lineno_2=$LINENO
+  as_lineno_3=`(expr $as_lineno_1 + 1) 2>/dev/null`
+  test "x$as_lineno_1" != "x$as_lineno_2" &&
+  test "x$as_lineno_3"  = "x$as_lineno_2" ') 2>/dev/null; then
+	     $as_unset BASH_ENV || test "${BASH_ENV+set}" != set || { BASH_ENV=; export BASH_ENV; }
+	     $as_unset ENV || test "${ENV+set}" != set || { ENV=; export ENV; }
+	     CONFIG_SHELL=$as_dir/$as_base
+	     export CONFIG_SHELL
+	     exec "$CONFIG_SHELL" "$0" ${1+"$@"}
+	   fi;;
+	 esac
+       done
+done
+;;
+  esac
+
+  # Create $as_me.lineno as a copy of $as_myself, but with $LINENO
+  # uniformly replaced by the line number.  The first 'sed' inserts a
+  # line-number line before each line; the second 'sed' does the real
+  # work.  The second script uses 'N' to pair each line-number line
+  # with the numbered line, and appends trailing '-' during
+  # substitution so that $LINENO is not a special case at line end.
+  # (Raja R Harinath suggested sed '=', and Paul Eggert wrote the
+  # second 'sed' script.  Blame Lee E. McMahon for sed's syntax.  :-)
+  sed '=' <$as_myself |
+    sed '
+      N
+      s,$,-,
+      : loop
+      s,^\(['$as_cr_digits']*\)\(.*\)[$]LINENO\([^'$as_cr_alnum'_]\),\1\2\1\3,
+      t loop
+      s,-$,,
+      s,^['$as_cr_digits']*\n,,
+    ' >$as_me.lineno &&
+  chmod +x $as_me.lineno ||
+    { { echo "$as_me:$LINENO: error: cannot create $as_me.lineno; rerun with a POSIX shell" >&5
+echo "$as_me: error: cannot create $as_me.lineno; rerun with a POSIX shell" >&2;}
+   { (exit 1); exit 1; }; }
+
+  # Don't try to exec as it changes $[0], causing all sort of problems
+  # (the dirname of $[0] is not the place where we might find the
+  # original and so on.  Autoconf is especially sensible to this).
+  . ./$as_me.lineno
+  # Exit status is that of the last command.
+  exit
+}
+
+
+case `echo "testing\c"; echo 1,2,3`,`echo -n testing; echo 1,2,3` in
+  *c*,-n*) ECHO_N= ECHO_C='
+' ECHO_T='	' ;;
+  *c*,*  ) ECHO_N=-n ECHO_C= ECHO_T= ;;
+  *)       ECHO_N= ECHO_C='\c' ECHO_T= ;;
+esac
+
+if expr a : '\(a\)' >/dev/null 2>&1; then
+  as_expr=expr
+else
+  as_expr=false
+fi
+
+rm -f conf$$ conf$$.exe conf$$.file
+echo >conf$$.file
+if ln -s conf$$.file conf$$ 2>/dev/null; then
+  # We could just check for DJGPP; but this test a) works b) is more generic
+  # and c) will remain valid once DJGPP supports symlinks (DJGPP 2.04).
+  if test -f conf$$.exe; then
+    # Don't use ln at all; we don't have any links
+    as_ln_s='cp -p'
+  else
+    as_ln_s='ln -s'
+  fi
+elif ln conf$$.file conf$$ 2>/dev/null; then
+  as_ln_s=ln
+else
+  as_ln_s='cp -p'
+fi
+rm -f conf$$ conf$$.exe conf$$.file
+
+if mkdir -p . 2>/dev/null; then
+  as_mkdir_p=:
+else
+  test -d ./-p && rmdir ./-p
+  as_mkdir_p=false
+fi
+
+as_executable_p="test -f"
+
+# Sed expression to map a string onto a valid CPP name.
+as_tr_cpp="eval sed 'y%*$as_cr_letters%P$as_cr_LETTERS%;s%[^_$as_cr_alnum]%_%g'"
+
+# Sed expression to map a string onto a valid variable name.
+as_tr_sh="eval sed 'y%*+%pp%;s%[^_$as_cr_alnum]%_%g'"
+
+
+# IFS
+# We need space, tab and new line, in precisely that order.
+as_nl='
+'
+IFS=" 	$as_nl"
+
+# CDPATH.
+$as_unset CDPATH
+
+exec 6>&1
+
+# Open the log real soon, to keep \$[0] and so on meaningful, and to
+# report actual input values of CONFIG_FILES etc. instead of their
+# values after options handling.  Logging --version etc. is OK.
+exec 5>>config.log
+{
+  echo
+  sed 'h;s/./-/g;s/^.../## /;s/...$/ ##/;p;x;p;x' <<_ASBOX
+## Running $as_me. ##
+_ASBOX
+} >&5
+cat >&5 <<_CSEOF
+
+This file was extended by $as_me, which was
+generated by GNU Autoconf 2.59.  Invocation command line was
+
+  CONFIG_FILES    = $CONFIG_FILES
+  CONFIG_HEADERS  = $CONFIG_HEADERS
+  CONFIG_LINKS    = $CONFIG_LINKS
+  CONFIG_COMMANDS = $CONFIG_COMMANDS
+  $ $0 $@
+
+_CSEOF
+echo "on `(hostname || uname -n) 2>/dev/null | sed 1q`" >&5
+echo >&5
+config_files=" Makefile"
+
+ac_cs_usage="\
+\`$as_me' instantiates files from templates according to the
+current configuration.
+
+Usage: $0 [OPTIONS] [FILE]...
+
+  -h, --help       print this help, then exit
+  -V, --version    print version number, then exit
+  -q, --quiet      do not print progress messages
+  -d, --debug      don't remove temporary files
+      --recheck    update $as_me by reconfiguring in the same conditions
+  --file=FILE[:TEMPLATE]
+		   instantiate the configuration file FILE
+
+Configuration files:
+$config_files
+
+Report bugs to <bug-autoconf@gnu.org>."
+ac_cs_version="\
+config.status
+configured by ./configure, generated by GNU Autoconf 2.59,
+  with options \"\"
+
+Copyright (C) 2003 Free Software Foundation, Inc.
+This config.status script is free software; the Free Software Foundation
+gives unlimited permission to copy, distribute and modify it."
+srcdir=.
+INSTALL="/usr/bin/install -c"
+# If no file are specified by the user, then we need to provide default
+# value.  By we need to know if files were specified by the user.
+ac_need_defaults=:
+while test $# != 0
+do
+  case $1 in
+  --*=*)
+    ac_option=`expr "x$1" : 'x\([^=]*\)='`
+    ac_optarg=`expr "x$1" : 'x[^=]*=\(.*\)'`
+    ac_shift=:
+    ;;
+  -*)
+    ac_option=$1
+    ac_optarg=$2
+    ac_shift=shift
+    ;;
+  *) # This is not an option, so the user has probably given explicit
+     # arguments.
+     ac_option=$1
+     ac_need_defaults=false;;
+  esac
+
+  case $ac_option in
+  # Handling of the options.
+  -recheck | --recheck | --rechec | --reche | --rech | --rec | --re | --r)
+    ac_cs_recheck=: ;;
+  --version | --vers* | -V )
+    echo "$ac_cs_version"; exit 0 ;;
+  --he | --h)
+    # Conflict between --help and --header
+    { { echo "$as_me:$LINENO: error: ambiguous option: $1
+Try \`$0 --help' for more information." >&5
+echo "$as_me: error: ambiguous option: $1
+Try \`$0 --help' for more information." >&2;}
+   { (exit 1); exit 1; }; };;
+  --help | --hel | -h )
+    echo "$ac_cs_usage"; exit 0 ;;
+  --debug | --d* | -d )
+    debug=: ;;
+  --file | --fil | --fi | --f )
+    $ac_shift
+    CONFIG_FILES="$CONFIG_FILES $ac_optarg"
+    ac_need_defaults=false;;
+  --header | --heade | --head | --hea )
+    $ac_shift
+    CONFIG_HEADERS="$CONFIG_HEADERS $ac_optarg"
+    ac_need_defaults=false;;
+  -q | -quiet | --quiet | --quie | --qui | --qu | --q \
+  | -silent | --silent | --silen | --sile | --sil | --si | --s)
+    ac_cs_silent=: ;;
+
+  # This is an error.
+  -*) { { echo "$as_me:$LINENO: error: unrecognized option: $1
+Try \`$0 --help' for more information." >&5
+echo "$as_me: error: unrecognized option: $1
+Try \`$0 --help' for more information." >&2;}
+   { (exit 1); exit 1; }; } ;;
+
+  *) ac_config_targets="$ac_config_targets $1" ;;
+
+  esac
+  shift
+done
+
+ac_configure_extra_args=
+
+if $ac_cs_silent; then
+  exec 6>/dev/null
+  ac_configure_extra_args="$ac_configure_extra_args --silent"
+fi
+
+if $ac_cs_recheck; then
+  echo "running /bin/sh ./configure "  $ac_configure_extra_args " --no-create --no-recursion" >&6
+  exec /bin/sh ./configure  $ac_configure_extra_args --no-create --no-recursion
+fi
+
+for ac_config_target in $ac_config_targets
+do
+  case "$ac_config_target" in
+  # Handling of arguments.
+  "Makefile" ) CONFIG_FILES="$CONFIG_FILES Makefile" ;;
+  *) { { echo "$as_me:$LINENO: error: invalid argument: $ac_config_target" >&5
+echo "$as_me: error: invalid argument: $ac_config_target" >&2;}
+   { (exit 1); exit 1; }; };;
+  esac
+done
+
+# If the user did not use the arguments to specify the items to instantiate,
+# then the envvar interface is used.  Set only those that are not.
+# We use the long form for the default assignment because of an extremely
+# bizarre bug on SunOS 4.1.3.
+if $ac_need_defaults; then
+  test "${CONFIG_FILES+set}" = set || CONFIG_FILES=$config_files
+fi
+
+# Have a temporary directory for convenience.  Make it in the build tree
+# simply because there is no reason to put it here, and in addition,
+# creating and moving files from /tmp can sometimes cause problems.
+# Create a temporary directory, and hook for its removal unless debugging.
+$debug ||
+{
+  trap 'exit_status=$?; rm -rf $tmp && exit $exit_status' 0
+  trap '{ (exit 1); exit 1; }' 1 2 13 15
+}
+
+# Create a (secure) tmp directory for tmp files.
+
+{
+  tmp=`(umask 077 && mktemp -d -q "./confstatXXXXXX") 2>/dev/null` &&
+  test -n "$tmp" && test -d "$tmp"
+}  ||
+{
+  tmp=./confstat$$-$RANDOM
+  (umask 077 && mkdir $tmp)
+} ||
+{
+   echo "$me: cannot create a temporary directory in ." >&2
+   { (exit 1); exit 1; }
+}
+
+
+#
+# CONFIG_FILES section.
+#
+
+# No need to generate the scripts if there are no CONFIG_FILES.
+# This happens for instance when ./config.status config.h
+if test -n "$CONFIG_FILES"; then
+  # Protect against being on the right side of a sed subst in config.status.
+  sed 's/,@/@@/; s/@,/@@/; s/,;t t$/@;t t/; /@;t t$/s/[\\&,]/\\&/g;
+   s/@@/,@/; s/@@/@,/; s/@;t t$/,;t t/' >$tmp/subs.sed <<\CEOF
+s,@SHELL@,/bin/sh,;t t
+s,@PATH_SEPARATOR@,:,;t t
+s,@PACKAGE_NAME@,,;t t
+s,@PACKAGE_TARNAME@,,;t t
+s,@PACKAGE_VERSION@,,;t t
+s,@PACKAGE_STRING@,,;t t
+s,@PACKAGE_BUGREPORT@,,;t t
+s,@exec_prefix@,${prefix},;t t
+s,@prefix@,/usr/local,;t t
+s,@program_transform_name@,s,x,x,,;t t
+s,@bindir@,${exec_prefix}/bin,;t t
+s,@sbindir@,${exec_prefix}/sbin,;t t
+s,@libexecdir@,${exec_prefix}/libexec,;t t
+s,@datadir@,${prefix}/share,;t t
+s,@sysconfdir@,${prefix}/etc,;t t
+s,@sharedstatedir@,${prefix}/com,;t t
+s,@localstatedir@,${prefix}/var,;t t
+s,@libdir@,${exec_prefix}/lib,;t t
+s,@includedir@,${prefix}/include,;t t
+s,@oldincludedir@,/usr/include,;t t
+s,@infodir@,${prefix}/info,;t t
+s,@mandir@,${prefix}/man,;t t
+s,@build_alias@,,;t t
+s,@host_alias@,,;t t
+s,@target_alias@,,;t t
+s,@DEFS@,-DPACKAGE_NAME=\"\" -DPACKAGE_TARNAME=\"\" -DPACKAGE_VERSION=\"\" -DPACKAGE_STRING=\"\" -DPACKAGE_BUGREPORT=\"\" -DYYTEXT_POINTER=1 -DHAVE_GETADDRINFO=1 -DHAVE_GETNAMEINFO=1 -DHAVE_GETIFADDRS=1 -DHAVE_IF_NAMETOINDEX=1 -DHAVE_DAEMON=1 -DHAVE_WARNX=1 -DSTDC_HEADERS=1 -DHAVE_SYS_TYPES_H=1 -DHAVE_SYS_STAT_H=1 -DHAVE_STDLIB_H=1 -DHAVE_STRING_H=1 -DHAVE_MEMORY_H=1 -DHAVE_STRINGS_H=1 -DHAVE_INTTYPES_H=1 -DHAVE_STDINT_H=1 -DHAVE_UNISTD_H=1 -DHAVE_FCNTL_H=1 -DHAVE_SYS_IOCTL_H=1 -DHAVE_SYS_TIME_H=1 -DHAVE_SYSLOG_H=1 -DHAVE_UNISTD_H=1 -DHAVE_IFADDRS_H=1 -DTIME_WITH_SYS_TIME=1 -DHAVE_STRUCT_TM_TM_ZONE=1 -DHAVE_TM_ZONE=1 -DHAVE_SIG_ATOMIC_T=1 -DGETPGRP_VOID=1 -DSETPGRP_VOID=1 -DRETSIGTYPE=void -DHAVE_MKTIME=1 -DHAVE_SELECT=1 -DHAVE_SOCKET=1 -DHAVE_ANSI_FUNC=1 -DHAVE_TAILQ_FOREACH_REVERSE_OLD=1 -DHAVE_STDARG_H=1 ,;t t
+s,@ECHO_C@,,;t t
+s,@ECHO_N@,-n,;t t
+s,@ECHO_T@,,;t t
+s,@LIBS@,,;t t
+s,@INSTALL_PROGRAM@,${INSTALL},;t t
+s,@INSTALL_SCRIPT@,${INSTALL},;t t
+s,@INSTALL_DATA@,${INSTALL} -m 644,;t t
+s,@SET_MAKE@,,;t t
+s,@CC@,gcc,;t t
+s,@CFLAGS@,-g -O2 -I$(srcdir),;t t
+s,@LDFLAGS@,,;t t
+s,@CPPFLAGS@,,;t t
+s,@ac_ct_CC@,gcc,;t t
+s,@EXEEXT@,,;t t
+s,@OBJEXT@,o,;t t
+s,@CPP@,gcc -E,;t t
+s,@YACC@,bison -y,;t t
+s,@LEX@,flex,;t t
+s,@LEXLIB@,-lfl,;t t
+s,@LEX_OUTPUT_ROOT@,lex.yy,;t t
+s,@EGREP@,grep -E,;t t
+s,@LIBOBJS@, strlcpy$U.o strlcat$U.o arc4random$U.o,;t t
+s,@localdbdir@,/var/db,;t t
+s,@user@,bin,;t t
+s,@group@,bin,;t t
+s,@LTLIBOBJS@, strlcpy$U.lo strlcat$U.lo arc4random$U.lo,;t t
+CEOF
+
+  # Split the substitutions into bite-sized pieces for seds with
+  # small command number limits, like on Digital OSF/1 and HP-UX.
+  ac_max_sed_lines=48
+  ac_sed_frag=1 # Number of current file.
+  ac_beg=1 # First line for current file.
+  ac_end=$ac_max_sed_lines # Line after last line for current file.
+  ac_more_lines=:
+  ac_sed_cmds=
+  while $ac_more_lines; do
+    if test $ac_beg -gt 1; then
+      sed "1,${ac_beg}d; ${ac_end}q" $tmp/subs.sed >$tmp/subs.frag
+    else
+      sed "${ac_end}q" $tmp/subs.sed >$tmp/subs.frag
+    fi
+    if test ! -s $tmp/subs.frag; then
+      ac_more_lines=false
+    else
+      # The purpose of the label and of the branching condition is to
+      # speed up the sed processing (if there are no `@' at all, there
+      # is no need to browse any of the substitutions).
+      # These are the two extra sed commands mentioned above.
+      (echo ':t
+  /@[a-zA-Z_][a-zA-Z_0-9]*@/!b' && cat $tmp/subs.frag) >$tmp/subs-$ac_sed_frag.sed
+      if test -z "$ac_sed_cmds"; then
+	ac_sed_cmds="sed -f $tmp/subs-$ac_sed_frag.sed"
+      else
+	ac_sed_cmds="$ac_sed_cmds | sed -f $tmp/subs-$ac_sed_frag.sed"
+      fi
+      ac_sed_frag=`expr $ac_sed_frag + 1`
+      ac_beg=$ac_end
+      ac_end=`expr $ac_end + $ac_max_sed_lines`
+    fi
+  done
+  if test -z "$ac_sed_cmds"; then
+    ac_sed_cmds=cat
+  fi
+fi # test -n "$CONFIG_FILES"
+
+for ac_file in : $CONFIG_FILES; do test "x$ac_file" = x: && continue
+  # Support "outfile[:infile[:infile...]]", defaulting infile="outfile.in".
+  case $ac_file in
+  - | *:- | *:-:* ) # input from stdin
+	cat >$tmp/stdin
+	ac_file_in=`echo "$ac_file" | sed 's,[^:]*:,,'`
+	ac_file=`echo "$ac_file" | sed 's,:.*,,'` ;;
+  *:* ) ac_file_in=`echo "$ac_file" | sed 's,[^:]*:,,'`
+	ac_file=`echo "$ac_file" | sed 's,:.*,,'` ;;
+  * )   ac_file_in=$ac_file.in ;;
+  esac
+
+  # Compute @srcdir@, @top_srcdir@, and @INSTALL@ for subdirectories.
+  ac_dir=`(dirname "$ac_file") 2>/dev/null ||
+$as_expr X"$ac_file" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
+	 X"$ac_file" : 'X\(//\)[^/]' \| \
+	 X"$ac_file" : 'X\(//\)$' \| \
+	 X"$ac_file" : 'X\(/\)' \| \
+	 .     : '\(.\)' 2>/dev/null ||
+echo X"$ac_file" |
+    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{ s//\1/; q; }
+  	  /^X\(\/\/\)[^/].*/{ s//\1/; q; }
+  	  /^X\(\/\/\)$/{ s//\1/; q; }
+  	  /^X\(\/\).*/{ s//\1/; q; }
+  	  s/.*/./; q'`
+  { if $as_mkdir_p; then
+    mkdir -p "$ac_dir"
+  else
+    as_dir="$ac_dir"
+    as_dirs=
+    while test ! -d "$as_dir"; do
+      as_dirs="$as_dir $as_dirs"
+      as_dir=`(dirname "$as_dir") 2>/dev/null ||
+$as_expr X"$as_dir" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
+	 X"$as_dir" : 'X\(//\)[^/]' \| \
+	 X"$as_dir" : 'X\(//\)$' \| \
+	 X"$as_dir" : 'X\(/\)' \| \
+	 .     : '\(.\)' 2>/dev/null ||
+echo X"$as_dir" |
+    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{ s//\1/; q; }
+  	  /^X\(\/\/\)[^/].*/{ s//\1/; q; }
+  	  /^X\(\/\/\)$/{ s//\1/; q; }
+  	  /^X\(\/\).*/{ s//\1/; q; }
+  	  s/.*/./; q'`
+    done
+    test ! -n "$as_dirs" || mkdir $as_dirs
+  fi || { { echo "$as_me:$LINENO: error: cannot create directory \"$ac_dir\"" >&5
+echo "$as_me: error: cannot create directory \"$ac_dir\"" >&2;}
+   { (exit 1); exit 1; }; }; }
+
+  ac_builddir=.
+
+if test "$ac_dir" != .; then
+  ac_dir_suffix=/`echo "$ac_dir" | sed 's,^\.[\\/],,'`
+  # A "../" for each directory in $ac_dir_suffix.
+  ac_top_builddir=`echo "$ac_dir_suffix" | sed 's,/[^\\/]*,../,g'`
+else
+  ac_dir_suffix= ac_top_builddir=
+fi
+
+case $srcdir in
+  .)  # No --srcdir option.  We are building in place.
+    ac_srcdir=.
+    if test -z "$ac_top_builddir"; then
+       ac_top_srcdir=.
+    else
+       ac_top_srcdir=`echo $ac_top_builddir | sed 's,/$,,'`
+    fi ;;
+  [\\/]* | ?:[\\/]* )  # Absolute path.
+    ac_srcdir=$srcdir$ac_dir_suffix;
+    ac_top_srcdir=$srcdir ;;
+  *) # Relative path.
+    ac_srcdir=$ac_top_builddir$srcdir$ac_dir_suffix
+    ac_top_srcdir=$ac_top_builddir$srcdir ;;
+esac
+
+# Do not use `cd foo && pwd` to compute absolute paths, because
+# the directories may not exist.
+case `pwd` in
+.) ac_abs_builddir="$ac_dir";;
+*)
+  case "$ac_dir" in
+  .) ac_abs_builddir=`pwd`;;
+  [\\/]* | ?:[\\/]* ) ac_abs_builddir="$ac_dir";;
+  *) ac_abs_builddir=`pwd`/"$ac_dir";;
+  esac;;
+esac
+case $ac_abs_builddir in
+.) ac_abs_top_builddir=${ac_top_builddir}.;;
+*)
+  case ${ac_top_builddir}. in
+  .) ac_abs_top_builddir=$ac_abs_builddir;;
+  [\\/]* | ?:[\\/]* ) ac_abs_top_builddir=${ac_top_builddir}.;;
+  *) ac_abs_top_builddir=$ac_abs_builddir/${ac_top_builddir}.;;
+  esac;;
+esac
+case $ac_abs_builddir in
+.) ac_abs_srcdir=$ac_srcdir;;
+*)
+  case $ac_srcdir in
+  .) ac_abs_srcdir=$ac_abs_builddir;;
+  [\\/]* | ?:[\\/]* ) ac_abs_srcdir=$ac_srcdir;;
+  *) ac_abs_srcdir=$ac_abs_builddir/$ac_srcdir;;
+  esac;;
+esac
+case $ac_abs_builddir in
+.) ac_abs_top_srcdir=$ac_top_srcdir;;
+*)
+  case $ac_top_srcdir in
+  .) ac_abs_top_srcdir=$ac_abs_builddir;;
+  [\\/]* | ?:[\\/]* ) ac_abs_top_srcdir=$ac_top_srcdir;;
+  *) ac_abs_top_srcdir=$ac_abs_builddir/$ac_top_srcdir;;
+  esac;;
+esac
+
+
+  case $INSTALL in
+  [\\/$]* | ?:[\\/]* ) ac_INSTALL=$INSTALL ;;
+  *) ac_INSTALL=$ac_top_builddir$INSTALL ;;
+  esac
+
+  if test x"$ac_file" != x-; then
+    { echo "$as_me:$LINENO: creating $ac_file" >&5
+echo "$as_me: creating $ac_file" >&6;}
+    rm -f "$ac_file"
+  fi
+  # Let's still pretend it is `configure' which instantiates (i.e., don't
+  # use $as_me), people would be surprised to read:
+  #    /* config.h.  Generated by config.status.  */
+  if test x"$ac_file" = x-; then
+    configure_input=
+  else
+    configure_input="$ac_file.  "
+  fi
+  configure_input=$configure_input"Generated from `echo $ac_file_in |
+				     sed 's,.*/,,'` by configure."
+
+  # First look for the input files in the build tree, otherwise in the
+  # src tree.
+  ac_file_inputs=`IFS=:
+    for f in $ac_file_in; do
+      case $f in
+      -) echo $tmp/stdin ;;
+      [\\/$]*)
+	 # Absolute (can't be DOS-style, as IFS=:)
+	 test -f "$f" || { { echo "$as_me:$LINENO: error: cannot find input file: $f" >&5
+echo "$as_me: error: cannot find input file: $f" >&2;}
+   { (exit 1); exit 1; }; }
+	 echo "$f";;
+      *) # Relative
+	 if test -f "$f"; then
+	   # Build tree
+	   echo "$f"
+	 elif test -f "$srcdir/$f"; then
+	   # Source tree
+	   echo "$srcdir/$f"
+	 else
+	   # /dev/null tree
+	   { { echo "$as_me:$LINENO: error: cannot find input file: $f" >&5
+echo "$as_me: error: cannot find input file: $f" >&2;}
+   { (exit 1); exit 1; }; }
+	 fi;;
+      esac
+    done` || { (exit 1); exit 1; }
+  sed "/^[	 ]*VPATH[	 ]*=/{
+s/:*\$(srcdir):*/:/;
+s/:*\${srcdir}:*/:/;
+s/:*@srcdir@:*/:/;
+s/^\([^=]*=[	 ]*\):*/\1/;
+s/:*$//;
+s/^[^=]*=[	 ]*$//;
+}
+
+:t
+/@[a-zA-Z_][a-zA-Z_0-9]*@/!b
+s,@configure_input@,$configure_input,;t t
+s,@srcdir@,$ac_srcdir,;t t
+s,@abs_srcdir@,$ac_abs_srcdir,;t t
+s,@top_srcdir@,$ac_top_srcdir,;t t
+s,@abs_top_srcdir@,$ac_abs_top_srcdir,;t t
+s,@builddir@,$ac_builddir,;t t
+s,@abs_builddir@,$ac_abs_builddir,;t t
+s,@top_builddir@,$ac_top_builddir,;t t
+s,@abs_top_builddir@,$ac_abs_top_builddir,;t t
+s,@INSTALL@,$ac_INSTALL,;t t
+" $ac_file_inputs | (eval "$ac_sed_cmds") >$tmp/out
+  rm -f $tmp/stdin
+  if test x"$ac_file" != x-; then
+    mv $tmp/out $ac_file
+  else
+    cat $tmp/out
+    rm -f $tmp/out
+  fi
+
+done
+
+{ (exit 0); exit 0; }
diff -Naur wide-dhcpv6-20080615.orig/debug.h wide-dhcpv6-20080615/debug.h
--- wide-dhcpv6-20080615.orig/debug.h	1970-01-01 08:00:00.000000000 +0800
+++ wide-dhcpv6-20080615/debug.h	2014-01-24 14:07:41.000000000 +0800
@@ -0,0 +1,13 @@
+#ifndef MY_DEBUG_H_
+#define MY_DEBUG_H_
+
+/* First include stdio.h, which may contain the prototype for the external dprintf.
+ * We do not want that. We redefine dprintf to our local implementation. */
+#include <stdio.h>
+#define dprintf my_dprintf
+#ifndef __P
+# define __P(x) x
+#endif
+extern void my_dprintf __P((int, const char *, const char *, ...));
+
+#endif /* MY_DEBUG_H_ */
diff -Naur wide-dhcpv6-20080615.orig/dhcp6c.c wide-dhcpv6-20080615/dhcp6c.c
--- wide-dhcpv6-20080615.orig/dhcp6c.c	2008-06-15 15:48:41.000000000 +0800
+++ wide-dhcpv6-20080615/dhcp6c.c	2014-01-28 20:23:46.609177888 +0800
@@ -1,4 +1,3 @@
-/*	$KAME: dhcp6c.c,v 1.164 2006/01/10 02:46:09 jinmei Exp $	*/
 /*
  * Copyright (C) 1998 and 1999 WIDE Project.
  * All rights reserved.
@@ -79,6 +78,17 @@
 #include <prefixconf.h>
 #include <auth.h>
 
+/*zyxel*/
+#include "zcfg_common.h"
+#include "zcfg_fe_rdm_access.h"
+#include "zcfg_msg.h"
+
+#include <json/json.h>
+
+extern struct json_object *dhcp6cMsg;
+extern zcfgRet_t dhcp6MsgSend(int, int, const char *);
+/*end*/
+
 static int debug = 0;
 static int exit_ok = 0;
 static sig_atomic_t sig_flags = 0;
@@ -211,6 +221,7 @@
 	setloglevel(debug);
 
 	client6_init();
+dprintf(LOG_ERR, FNAME, "bp1 ");
 	while (argc-- > 0) { 
 		if ((ifp = ifinit(argv[0])) == NULL) {
 			dprintf(LOG_ERR, FNAME, "failed to initialize %s",
@@ -219,25 +230,26 @@
 		}
 		argv++;
 	}
-
+dprintf(LOG_ERR, FNAME, "bp2 ");
 	if (infreq_mode == 0 && (cfparse(conffile)) != 0) {
 		dprintf(LOG_ERR, FNAME, "failed to parse configuration file");
 		exit(1);
 	}
-
+dprintf(LOG_ERR, FNAME, "bp3 ");
 	if (foreground == 0 && infreq_mode == 0) {
 		if (daemon(0, 0) < 0)
 			err(1, "daemon");
 	}
-
+dprintf(LOG_ERR, FNAME, "bp4 ");
 	/* dump current PID */
 	pid = getpid();
 	if ((pidfp = fopen(pid_file, "w")) != NULL) {
 		fprintf(pidfp, "%d\n", pid);
 		fclose(pidfp);
 	}
-
+dprintf(LOG_ERR, FNAME, "bp5 ");
 	client6_startall(0);
+dprintf(LOG_ERR, FNAME, "bp6 ");
 	client6_mainloop();
 	exit(0);
 }
@@ -384,6 +396,7 @@
 client6_start(ifp)
 	struct dhcp6_if *ifp;
 {
+dprintf(LOG_ERR, FNAME, "client6_start");
 	struct dhcp6_event *ev;
 
 	/* make sure that the interface does not have a timer */
@@ -423,6 +436,7 @@
 client6_startall(isrestart)
 	int isrestart;
 {
+dprintf(LOG_ERR, FNAME, "client6_startall");
 	struct dhcp6_if *ifp;
 
 	for (ifp = dhcp6_if; ifp; ifp = ifp->next) {
@@ -510,10 +524,13 @@
 static void
 client6_mainloop()
 {
+dprintf(LOG_ERR, FNAME, "client6_mainloop");
 	struct timeval *w;
 	int ret, maxsock;
 	fd_set r;
 
+	zcfgEidInit(ZCFG_EID_UDHCP6C, "dhcp6c");
+
 	while(1) {
 		if (sig_flags)
 			process_signals();
@@ -585,6 +602,7 @@
 	char *ifbuf;
 	int ifbuflen;
 {
+dprintf(LOG_ERR, FNAME, "get_ifname");
 	char *bp = *bpp;
 	int len = *lenp, ifnamelen;
 	u_int32_t i32;
@@ -612,6 +630,7 @@
 	char *buf;
 	ssize_t len;
 {
+dprintf(LOG_ERR, FNAME, "client6_do_ctlcommand");
 	struct dhcp6ctl *ctlhead;
 	u_int16_t command, version;
 	u_int32_t p32, ts, ts0;
@@ -732,6 +751,7 @@
 static void
 client6_reload()
 {
+dprintf(LOG_ERR, FNAME, "client6_reload");
 	/* reload the configuration file */
 	if (cfparse(conffile) != 0) {
 		dprintf(LOG_WARNING, FNAME,
@@ -749,6 +769,7 @@
 	char *ifname;
 	u_int16_t command;
 {
+dprintf(LOG_ERR, FNAME, "client6_ifctl");
 	struct dhcp6_if *ifp;
 
 	if ((ifp = find_ifconfbyname(ifname)) == NULL) {
@@ -1147,6 +1168,7 @@
 client6_send(ev)
 	struct dhcp6_event *ev;
 {
+dprintf(LOG_ERR, FNAME, "client6_send");
 	struct dhcp6_if *ifp;
 	char buf[BUFSIZ];
 	struct sockaddr_in6 dst;
@@ -1388,6 +1410,7 @@
 static void
 client6_recv()
 {
+dprintf(LOG_ERR, FNAME, "client6_recv");
 	char rbuf[BUFSIZ], cmsgbuf[BUFSIZ];
 	struct msghdr mhdr;
 	struct iovec iov;
@@ -1481,6 +1504,7 @@
 	ssize_t len;
 	struct dhcp6_optinfo *optinfo;
 {
+dprintf(LOG_ERR, FNAME, "client6_recvadvert");
 	struct dhcp6_serverinfo *newserver, **sp;
 	struct dhcp6_event *ev;
 	struct dhcp6_eventdata *evd;
@@ -1702,6 +1726,10 @@
 	struct dhcp6_listval *lv;
 	struct dhcp6_event *ev;
 	int state;
+/*zyxel*/
+	char *msg = NULL;
+	int msgLen = 0;
+/*end*/ 
 
 	/* find the corresponding event based on the received xid */
 	ev = find_event_withid(ifp, ntohl(dh6->dh6_xid) & DH6_XIDMASK);
@@ -1761,6 +1789,9 @@
 		return (-1);
 	}
 
+	/*zyxel*/
+	dhcp6cMsg = json_object_new_object();
+
 	/*
 	 * The client MAY choose to report any status code or message from the
 	 * status code option in the Reply message.
@@ -1794,6 +1825,9 @@
 		}
 	}
 
+	/*zyxel*/
+	dhcp6sConfDnsListUpdate(optinfo);
+
 	if (!TAILQ_EMPTY(&optinfo->ntp_list)) {
 		struct dhcp6_listval *d;
 		int i = 0;
@@ -1888,6 +1922,14 @@
 		    &optinfo->serverID, ev->authparam);
 	}
 
+	//dprintf(LOG_ERR, FNAME, "json : %s\n", json_object_to_json_string(dhcp6cMsg));
+	json_object_object_add(dhcp6cMsg, "pidfile", json_object_new_string(pid_file)); //add pid_file information
+	msg = json_object_to_json_string(dhcp6cMsg);
+	msgLen = strlen(msg) + 1;
+
+	dhcp6MsgSend(ZCFG_MSG_DHCP6C_STATE_CHANGED, msgLen, msg);
+	json_object_put(dhcp6cMsg);
+
 	dhcp6_remove_event(ev);
 
 	if (state == DHCP6S_RELEASE) {
@@ -2146,3 +2188,61 @@
 
 	return;
 }
+
+/*zyxel*/
+int dhcp6sConfDnsListUpdate(struct dhcp6_optinfo *opt)
+{
+	struct dhcp6_listval *d;
+	char nameserver[128] = {0};
+	char domainName[64] = {0};
+
+	dprintf(LOG_ERR, FNAME, "%s : Enter\n", __FUNCTION__);
+
+	d = TAILQ_FIRST(&opt->dns_list);
+	if(d != NULL) {
+		sprintf(nameserver, "%s", in6addr2str(&d->val_addr6, 0));
+
+		d = TAILQ_NEXT(d, link);
+		if (d != NULL) {
+			strcat(nameserver, ",");
+			strcat(nameserver, in6addr2str(&d->val_addr6, 0));
+		}
+	}
+
+	d = TAILQ_FIRST(&opt->dnsname_list);
+	if(d != NULL) {
+		sprintf(domainName, "%s", d->val_vbuf.dv_buf);
+
+		/*
+		 * FIXME: last character in domainName is always '.'
+		 * Solution: always set to '\0', but better to figure out why!
+		 */
+		if (strlen(domainName) > 0) domainName[strlen(domainName)-1]='\0';
+	}
+
+	addDnsInfoToMsg(nameserver, domainName);
+
+	return 0;
+}
+
+void addDnsInfoToMsg(const char *nameserver, const char *domainName)
+{
+	if(nameserver && nameserver[0] != '\0') {
+#if 0
+		dhcp6cMsgBody.dnsAssigned = TRUE;
+		strcpy(dhcp6cMsgBody.nameserver, nameserver);
+#endif
+		json_object_object_add(dhcp6cMsg, "nameserver", json_object_new_string(nameserver));
+	}
+
+	if(domainName && domainName[0] != '\0') {
+#if 0
+		dhcp6cMsgBody.domainNameAssigned = TRUE;
+		strcpy(dhcp6cMsgBody.domainName, domainName);
+#endif
+		json_object_object_add(dhcp6cMsg, "domainName", json_object_new_string(domainName));
+	}
+
+	return;
+}
+/*end*/
diff -Naur wide-dhcpv6-20080615.orig/dhcp6s.conf.sample wide-dhcpv6-20080615/dhcp6s.conf.sample
--- wide-dhcpv6-20080615.orig/dhcp6s.conf.sample	2011-08-01 17:24:00.000000000 +0800
+++ wide-dhcpv6-20080615/dhcp6s.conf.sample	2013-12-30 16:11:43.000000000 +0800
@@ -4,10 +4,10 @@
 
 option domain-name-servers 2001:db8::35;
 
-#host kame {
-#	duid 00:01:00:01:aa:bb;
-#	prefix 2001:db8:1111::/48 infinity;
-#};
+host kame {
+	duid 00:01:00:01:aa:bb;
+	prefix 2001:db8:1111::/48 infinity;
+};
 
 # The followings are a sample configuration to provide an IPv6 address
 # from an address pool 2001:db8:1:2::1000-2000 for 3600[s].
@@ -16,7 +16,7 @@
 # stateless address configuration via RA, please set the autonomous-flag to
 # OFF in your RA configuration.
 
-interface lan {
+interface fxp0 {
 	address-pool pool1 3600;
 };
 
diff -Naur wide-dhcpv6-20080615.orig/ifaddrs.h wide-dhcpv6-20080615/ifaddrs.h
--- wide-dhcpv6-20080615.orig/ifaddrs.h	1970-01-01 08:00:00.000000000 +0800
+++ wide-dhcpv6-20080615/ifaddrs.h	2014-01-28 19:36:06.000000000 +0800
@@ -0,0 +1,45 @@
+/*
+ * Copyright (c) 2006 WIDE Project. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of the project nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ * 
+ * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#include <sys/types.h>
+#include <stdint.h>
+
+#undef ifa_broadaddr
+#undef ifa_dstaddr
+struct ifaddrs {
+	struct ifaddrs	*ifa_next;	/* Pointer to next struct */
+	char		*ifa_name;	/* Interface name */
+	uint64_t	ifa_flags;	/* Interface flags */
+	struct sockaddr	*ifa_addr;	/* Interface address */
+	struct sockaddr	*ifa_netmask;	/* Interface netmask */
+	struct sockaddr	*ifa_dstaddr;	/* P2P interface destination */
+};
+#define	ifa_broadaddr	ifa_dstaddr
+
+extern int getifaddrs(struct ifaddrs **);
+extern void freeifaddrs(struct ifaddrs *);
diff -Naur wide-dhcpv6-20080615.orig/if.c wide-dhcpv6-20080615/if.c
--- wide-dhcpv6-20080615.orig/if.c	2008-06-15 15:48:43.000000000 +0800
+++ wide-dhcpv6-20080615/if.c	2014-01-28 20:53:13.746054627 +0800
@@ -57,6 +57,7 @@
 ifinit(ifname)
 	char *ifname;
 {
+dprintf(LOG_ERR, FNAME, "ifinit: %s", ifname);
 	struct dhcp6_if *ifp;
 
 	if ((ifp = find_ifconfbyname(ifname)) != NULL) {
@@ -77,8 +78,10 @@
 		goto fail;
 	}
 
-	if (ifreset(ifp))
+	if (ifreset(ifp)){
 		goto fail;
+	dprintf(LOG_NOTICE, FNAME, "ifreset");	
+	}
 
 	TAILQ_INIT(&ifp->reqopt_list);
 	TAILQ_INIT(&ifp->iaconf_list);
@@ -92,6 +95,7 @@
 		struct sockaddr_in6 *sin6;
 
 		if (getifaddrs(&ifap) < 0) {
+dprintf(LOG_NOTICE, FNAME, "getifaddrs");
 			dprintf(LOG_ERR, FNAME, "getifaddrs failed: %s",
 			    strerror(errno));
 			goto fail;
@@ -121,7 +125,9 @@
 
   fail:
 	if (ifp->ifname != NULL)
+dprintf(LOG_NOTICE, FNAME, "fail: ifp->name: %s", ifp->ifname);
 		free(ifp->ifname);
+dprintf(LOG_NOTICE, FNAME, "fail: ifp->name: %s", ifp->ifname);
 	free(ifp);
 	return (NULL);
 }
diff -Naur wide-dhcpv6-20080615.orig/Makefile.in wide-dhcpv6-20080615/Makefile.in
--- wide-dhcpv6-20080615.orig/Makefile.in	2007-03-21 17:52:58.000000000 +0800
+++ wide-dhcpv6-20080615/Makefile.in	2014-01-28 20:06:46.897150916 +0800
@@ -29,6 +29,19 @@
 # $KAME: Makefile.in,v 1.45 2005/10/16 16:25:38 suz Exp $
 #
 
+ALLOWED_INCLUDE_PATHS = -I. -I..\
+                         -I$(BUILD_DIR)/userspace/public/include  \
+                         -I$(BUILD_DIR)/userspace/public/include/linux
+
+ALLOWED_INCLUDE_PATHS += -I$(INC_BRCMDRIVER_PUB_PATH)/$(BRCM_BOARD)  \
+                         -I$(INC_BRCMDRIVER_PRIV_PATH)/$(BRCM_BOARD) \
+                         -I$(INC_BRCMSHARED_PUB_PATH)/$(BRCM_BOARD)
+
+INC_PATH = $(ALLOWED_INCLUDE_PATHS)
+
+LIB_PATH = -L$(USRLIBDIR) -L$(INSTALL_DIR)/lib/public -L$(INSTALL_DIR)/lib/private
+LINK_LIB = -ljson -lzcfg_msg
+
 prefix=	@prefix@
 srcdir=	@srcdir@
 sysconfdir= @sysconfdir@
@@ -37,12 +50,12 @@
 group= @group@
 
 CFLAGS=	@CFLAGS@ @DEFS@ -DSYSCONFDIR=\"${sysconfdir}\" \
-	-DLOCALDBDIR=\"${localdbdir}\"
+	-DLOCALDBDIR=\"${localdbdir}\" $(EXTRA_CFLAGS)
 LDFLAGS=@LDFLAGS@
 LIBOBJS=@LIBOBJS@
 LIBS=	@LIBS@ @LEXLIB@
 CC=	@CC@
-TARGET=	dhcp6c dhcp6s dhcp6relay dhcp6ctl
+TARGET=	dhcp6c dhcp6s
 
 INSTALL=@INSTALL@
 INSTALL_PROGRAM=@INSTALL_PROGRAM@
@@ -65,13 +78,13 @@
 
 all:	$(TARGET)
 dhcp6c:	$(CLIENTOBJS) $(LIBOBJS)
-	$(CC) $(LDFLAGS) -o dhcp6c $(CLIENTOBJS) $(LIBOBJS) $(LIBS)
+	$(CC) $(LDFLAGS) -o dhcp6c $(INC_PATH) $(LIB_PATH) $(LINK_LIB) $(CLIENTOBJS) $(LIBOBJS) $(LIBS)
 dhcp6s:	$(SERVOBJS) $(LIBOBJS)
-	$(CC) $(LDFLAGS) -o dhcp6s $(SERVOBJS) $(LIBOBJS) $(LIBS)
+	$(CC) $(LDFLAGS) -o dhcp6s $(INC_PATH) $(LIB_PATH) $(LINK_LIB) $(SERVOBJS) $(LIBOBJS) $(LIBS)
 dhcp6relay: $(RELAYOBJS) $(LIBOBJS)
-	$(CC) $(LDFLAGS) -o $@ $(RELAYOBJS) $(LIBOBJS) $(LIBS)
+	$(CC) $(LDFLAGS) -o $@ $(INC_PATH) $(LIB_PATH) $(LINK_LIB) $(RELAYOBJS) $(LIBOBJS) $(LIBS)
 dhcp6ctl: $(CTLOBJS)
-	$(CC) $(LDFLAGS) -o $@ $(CTLOBJS) $(LIBOBJS) $(LIBS)
+	$(CC) $(LDFLAGS) -o $@ $(INC_PATH) $(LIB_PATH) $(LINK_LIB) $(CTLOBJS) $(LIBOBJS) $(LIBS)
 
 cfparse.c y.tab.h: cfparse.y
 	@YACC@ -d cfparse.y
diff -Naur wide-dhcpv6-20080615.orig/missing/getifaddrs.c wide-dhcpv6-20080615/missing/getifaddrs.c
--- wide-dhcpv6-20080615.orig/missing/getifaddrs.c	2007-03-21 17:52:53.000000000 +0800
+++ wide-dhcpv6-20080615/missing/getifaddrs.c	2014-02-06 16:23:13.766384119 +0800
@@ -30,15 +30,97 @@
 #include <stdlib.h>
 #include <errno.h>
 #include <string.h>
-#include <sys/sockio.h>
+//#include <sys/sockio.h>
 #include <sys/socket.h>
 #include <net/if.h>
 
+#include <stdint.h>
+#include <sys/ioctl.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <netinet/in.h>
+
 #include "ifaddrs.h"
+#include "sockio.h"
+
+/* Used by SIOCGLIFNUM. Uses same flags as in struct lifconf */
+struct lifnum {
+	sa_family_t	lifn_family;
+	int		lifn_flags;	/* request specific interfaces */
+	int		lifn_count;	/* Result */
+};
+
+/*
+ * Structure used in SIOCGLIFCONF request.
+ * Used to retrieve interface configuration
+ * for machine (useful for programs which
+ * must know all networks accessible) for a given address family.
+ * Using AF_UNSPEC will retrieve all address families.
+ */
+struct	lifconf {
+	sa_family_t	lifc_family;
+	int		lifc_flags;	/* request specific interfaces */
+	int		lifc_len;	/* size of associated buffer */
+	union {
+		caddr_t	lifcu_buf;
+		struct	lifreq *lifcu_req;
+	} lifc_lifcu;
+#define	lifc_buf lifc_lifcu.lifcu_buf	/* buffer address */
+#define	lifc_req lifc_lifcu.lifcu_req	/* array of structures returned */
+};
+
+struct	lifreq {
+	char	lifr_name[50];		/* if name, e.g. "en0" */
+	union {
+		int	lifru_addrlen;		/* for subnet/token etc */
+		uint64_t	lifru_ppa;		/* SIOCSLIFNAME */
+	} lifr_lifru1;
+#define	lifr_addrlen	lifr_lifru1.lifru_addrlen
+#define	lifr_ppa	lifr_lifru1.lifru_ppa	/* Driver's ppa */
+	uint64_t	lifr_movetoindex;		/* FAILOVER/FAILBACK ifindex */
+	union {
+		struct	sockaddr_storage lifru_addr;
+		struct	sockaddr_storage lifru_dstaddr;
+		struct	sockaddr_storage lifru_broadaddr;
+		struct	sockaddr_storage lifru_token;	/* With lifr_addrlen */
+		struct	sockaddr_storage lifru_subnet;	/* With lifr_addrlen */
+		int	lifru_index;		/* interface index */
+		uint64_t lifru_flags;		/* Flags for SIOC?LIFFLAGS */
+		int	lifru_metric;
+		uint64_t	lifru_mtu;
+		char	lifru_data[1];		/* interface dependent data */
+		char	lifru_enaddr[6];
+		int	lif_muxid[2];		/* mux id's for arp and ip */
+		//struct lif_nd_req	lifru_nd_req;
+		//struct lif_ifinfo_req	lifru_ifinfo_req;
+		char	lifru_groupname[50]; /* SIOC[GS]LIFGROUPNAME */
+		uint64_t	lifru_delay;		   /* SIOC[GS]LIFNOTIFYDELAY */
+	} lifr_lifru;
+
+#define	lifr_addr	lifr_lifru.lifru_addr	/* address */
+#define	lifr_dstaddr	lifr_lifru.lifru_dstaddr /* other end of p-to-p link */
+#define	lifr_broadaddr	lifr_lifru.lifru_broadaddr /* broadcast address */
+#define	lifr_token	lifr_lifru.lifru_token	/* address token */
+#define	lifr_subnet	lifr_lifru.lifru_subnet	/* subnet prefix */
+#define	lifr_index	lifr_lifru.lifru_index	/* interface index */
+#define	lifr_flags	lifr_lifru.lifru_flags	/* flags */
+#define	lifr_metric	lifr_lifru.lifru_metric	/* metric */
+#define	lifr_mtu	lifr_lifru.lifru_mtu	/* mtu */
+#define	lifr_data	lifr_lifru.lifru_data	/* for use by interface */
+#define	lifr_enaddr	lifr_lifru.lifru_enaddr	/* ethernet address */
+#define	lifr_index	lifr_lifru.lifru_index	/* interface index */
+#define	lifr_ip_muxid	lifr_lifru.lif_muxid[0]
+#define	lifr_arp_muxid	lifr_lifru.lif_muxid[1]
+#define	lifr_nd		lifr_lifru.lifru_nd_req	/* SIOCLIF*ND */
+#define	lifr_ifinfo	lifr_lifru.lifru_ifinfo_req /* SIOC[GS]LIFLNKINFO */
+#define	lifr_groupname	lifr_lifru.lifru_groupname
+#define	lifr_delay	lifr_lifru.lifru_delay
+};
 
 static int
-get_lifreq(int fd, struct lifreq **ifr_ret)
+get_lifreq(int fd, struct lifreq **ifr_ret)   //question?
 {
+
 	struct lifnum lifn;
 	struct lifconf lifc;
 	struct lifreq *lifrp;
@@ -55,7 +137,7 @@
 		lifrp = malloc(lifc.lifc_len);
 		if (lifrp == NULL)
 			return (-1);
-
+		
 		lifc.lifc_family = AF_UNSPEC;
 		lifc.lifc_flags = 0;
 		lifc.lifc_buf = (char *)lifrp;
@@ -76,7 +158,6 @@
 	(void) close(fd);
 
 	*ifr_ret = lifrp;
-
 	return (lifc.lifc_len / sizeof (*lifrp));
 }
 
@@ -169,6 +250,7 @@
 
 	if ((fd4 = socket(AF_INET, SOCK_DGRAM, 0)) == -1)
 		return (-1);
+	
 	if ((fd6 = socket(AF_INET6, SOCK_DGRAM, 0)) == -1 &&
 	    errno != EAFNOSUPPORT) {
 		(void) close(fd4);
@@ -176,8 +258,9 @@
 	}
 
 	if ((nif4 = get_lifreq(fd4, &ifr4)) == -1 ||
-	    (fd6 != -1 && (nif6 = get_lifreq(fd6, &ifr6)) == -1))
-		goto failure;
+	    (fd6 != -1 && (nif6 = get_lifreq(fd6, &ifr6)) == -1)){
+		//goto failure;
+	}
 
 	if (nif4 == 0 && nif6 == 0) {
 		*ifap = NULL;
@@ -193,6 +276,7 @@
 
 	if (populate(ifa, fd4, ifr4, nif4, AF_INET, &buf) == -1)
 		goto failure;
+	
 	if (nif4 > 0 && nif6 > 0)
 		ifa[nif4 - 1].ifa_next = ifa + nif4;
 	if (populate(ifa + nif4, fd6, ifr6, nif6, AF_INET6, &buf) == -1)
diff -Naur wide-dhcpv6-20080615.orig/missing/ifaddrs.h wide-dhcpv6-20080615/missing/ifaddrs.h
--- wide-dhcpv6-20080615.orig/missing/ifaddrs.h	2007-03-21 17:52:53.000000000 +0800
+++ wide-dhcpv6-20080615/missing/ifaddrs.h	2014-01-28 19:36:06.569102239 +0800
@@ -27,6 +27,7 @@
  */
 
 #include <sys/types.h>
+#include <stdint.h>
 
 #undef ifa_broadaddr
 #undef ifa_dstaddr
diff -Naur wide-dhcpv6-20080615.orig/missing/sockio.h wide-dhcpv6-20080615/missing/sockio.h
--- wide-dhcpv6-20080615.orig/missing/sockio.h	1970-01-01 08:00:00.000000000 +0800
+++ wide-dhcpv6-20080615/missing/sockio.h	2014-01-22 11:25:21.000000000 +0800
@@ -0,0 +1,346 @@
+/*
+ * CDDL HEADER START
+ *
+ * The contents of this file are subject to the terms of the
+ * Common Development and Distribution License (the "License").
+ * You may not use this file except in compliance with the License.
+ *
+ * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
+ * or http://www.opensolaris.org/os/licensing.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ *
+ * When distributing Covered Code, include this CDDL HEADER in each
+ * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
+ * If applicable, add the following below this CDDL HEADER, with the
+ * fields enclosed by brackets "[]" replaced with your own identifying
+ * information: Portions Copyright [yyyy] [name of copyright owner]
+ *
+ * CDDL HEADER END
+ */
+/*
+ * Copyright (c) 1989, 2010, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2014, OmniTI Computer Consulting, Inc. All rights reserved.
+ */
+
+/*        Copyright (c) 1983, 1984, 1985, 1986, 1987, 1988, 1989 AT&T        */
+/*          All Rights Reserved          */
+
+/*
+ * University Copyright- Copyright (c) 1982, 1986, 1988
+ * The Regents of the University of California
+ * All Rights Reserved
+ *
+ * University Acknowledgment- Portions of this document are derived from
+ * software developed by the University of California, Berkeley, and its
+ * contributors.
+ */
+
+#ifndef        _SYS_SOCKIO_H
+#define        _SYS_SOCKIO_H
+
+/*
+ * General socket ioctl definitions.
+ */
+
+//#include <sys/ioccom.h>
+
+#ifdef        __cplusplus
+extern "C" {
+#endif
+
+/* socket i/o controls */
+#define        SIOCSHIWAT        _IOW('s',  0, int)                /* set high watermark */
+#define        SIOCGHIWAT        _IOR('s',  1, int)                /* get high watermark */
+#define        SIOCSLOWAT        _IOW('s',  2, int)                /* set low watermark */
+#define        SIOCGLOWAT        _IOR('s',  3, int)                /* get low watermark */
+#define        SIOCATMARK        _IOR('s',  7, int)                /* at oob mark? */
+#define        SIOCSPGRP        _IOW('s',  8, int)                /* set process group */
+#define        SIOCGPGRP        _IOR('s',  9, int)                /* get process group */
+
+/*
+ * SIOCADDRT and SIOCDELRT ioctls need to be defined using _IOWN macro to
+ * make them datamodel independent.
+ */
+#define        SIOCADDRT        _IOWN('r', 10, 48)                /* add route */
+#define        SIOCDELRT        _IOWN('r', 11, 48)                /* delete route */
+
+/* For multicast routing. These might change in future release */
+#define        SIOCGETVIFCNT        _IOWR('r', 20, struct sioc_vif_req)
+                                                        /* get vif pkt count */
+#define        SIOCGETSGCNT        _IOWR('r', 21, struct sioc_sg_req)
+                                                        /* get s,g pkt count */
+#define        SIOCGETLSGCNT        _IOWR('r', 21, struct sioc_lsg_req)
+                                                        /* get s,g pkt count */
+
+/*
+ * Obsolete interface ioctls using struct ifreq that are supported
+ * for compatibility. New interface ioctls use struct lifreq.
+ */
+#define        SIOCSIFADDR        _IOW('i',  12, struct ifreq)        /* set if address */
+#define        SIOCGIFADDR        _IOWR('i', 13, struct ifreq)        /* get if address */
+#define        SIOCSIFDSTADDR        _IOW('i',  14, struct ifreq)        /* set p-p address */
+#define        SIOCGIFDSTADDR        _IOWR('i', 15, struct ifreq)        /* get p-p address */
+#define        SIOCSIFFLAGS        _IOW('i',  16, struct ifreq)        /* set if flags */
+#define        SIOCGIFFLAGS        _IOWR('i', 17, struct ifreq)        /* get if flags */
+#define        SIOCSIFMEM        _IOW('i',  18, struct ifreq)        /* set interface mem */
+#define        SIOCGIFMEM        _IOWR('i', 19, struct ifreq)        /* get interface mem */
+
+/*
+ * Needs to be defined using _IOWRN macro to make it datamodel independent.
+ * Argument is a struct ifconf.
+ */
+#define        O_SIOCGIFCONF        _IOWRN('i', 20, 8)                /* old get if list */
+
+#define        SIOCSIFMTU        _IOW('i',  21, struct ifreq)        /* set if mtu */
+#define        SIOCGIFMTU        _IOWR('i', 22, struct ifreq)        /* get if mtu */
+
+        /* from 4.3BSD */
+#define        SIOCGIFBRDADDR        _IOWR('i', 23, struct ifreq)        /* get broadcast addr */
+#define        SIOCSIFBRDADDR        _IOW('i',  24, struct ifreq)        /* set broadcast addr */
+#define        SIOCGIFNETMASK        _IOWR('i', 25, struct ifreq)        /* get subnetmask */
+#define        SIOCSIFNETMASK        _IOW('i',  26, struct ifreq)        /* set subnetmask */
+#define        SIOCGIFMETRIC        _IOWR('i', 27, struct ifreq)        /* get if metric */
+#define        SIOCSIFMETRIC        _IOW('i',  28, struct ifreq)        /* set if metric */
+
+#define        SIOCSARP        _IOW('i',  30, struct arpreq)        /* set arp entry */
+#define        SIOCGARP        _IOWR('i', 31, struct arpreq)        /* get arp entry */
+#define        SIOCDARP        _IOW('i',  32, struct arpreq)        /* delete arp entry */
+#define        SIOCUPPER        _IOW('i',  40, struct ifreq)        /* attach upper layer */
+#define        SIOCLOWER        _IOW('i',  41, struct ifreq)        /* attach lower layer */
+#define        SIOCSETSYNC        _IOW('i',  44, struct ifreq)        /* set syncmode */
+#define        SIOCGETSYNC        _IOWR('i', 45, struct ifreq)        /* get syncmode */
+#define        SIOCSSDSTATS        _IOWR('i', 46, struct ifreq)        /* sync data stats */
+#define        SIOCSSESTATS        _IOWR('i', 47, struct ifreq)        /* sync error stats */
+
+#define        SIOCSPROMISC        _IOW('i',  48, int)                /* request promisc */
+                                                        /* mode on/off */
+#define        SIOCADDMULTI        _IOW('i',  49, struct ifreq)        /* set m/c address */
+#define        SIOCDELMULTI        _IOW('i',  50, struct ifreq)        /* clr m/c address */
+
+/* STREAMS based socket emulation */
+
+#define        SIOCGETNAME        _IOR('s',  52, struct sockaddr)        /* getsockname */
+#define        SIOCGETPEER        _IOR('s',  53, struct sockaddr)        /* getpeername */
+#define        IF_UNITSEL        _IOW('s',  54, int)                /* set unit number */
+#define        SIOCXPROTO        _IO('s',   55)                        /* empty proto table */
+
+#define        SIOCIFDETACH        _IOW('i',  56, struct ifreq)        /* detach interface */
+#define        SIOCGENPSTATS        _IOWR('i', 57, struct ifreq)        /* get ENP stats */
+#define        SIOCX25XMT        _IOWR('i', 59, struct ifreq)        /* start a slp proc */
+                                                        /* in x25if */
+#define        SIOCX25RCV        _IOWR('i', 60, struct ifreq)        /* start a slp proc */
+                                                        /* in x25if */
+#define        SIOCX25TBL        _IOWR('i', 61, struct ifreq)        /* xfer lun table to */
+                                                        /* kernel */
+#define        SIOCSLGETREQ        _IOWR('i', 71, struct ifreq)        /* wait for switched */
+                                                        /* SLIP request */
+#define        SIOCSLSTAT        _IOW('i',  72, struct ifreq)        /* pass SLIP info to */
+                                                        /* kernel */
+#define        SIOCSIFNAME        _IOW('i',  73, struct ifreq)        /* set interface name */
+#define        SIOCGENADDR        _IOWR('i', 85, struct ifreq)        /* Get ethernet addr */
+#define        SIOCGIFNUM        _IOR('i',  87, int)                /* get number of ifs */
+
+#define        SIOCGIFMUXID        _IOWR('i', 88, struct ifreq)        /* get if muxid */
+#define        SIOCSIFMUXID        _IOW('i',  89, struct ifreq)        /* set if muxid */
+
+#define        SIOCGIFINDEX        _IOWR('i', 90, struct ifreq)        /* get if index */
+#define        SIOCSIFINDEX        _IOW('i',  91, struct ifreq)        /* set if index */
+#define        SIOCGIFCONF        _IOWRN('i', 92, 8)                /* get if list */
+
+/*
+ * New interface ioctls that use the struct lifreq. Can be used for
+ * both IPv4 and IPv6.
+ */
+#define        SIOCLIFREMOVEIF        _IOW('i',  110, struct lifreq)        /* delete logical */
+#define        SIOCLIFADDIF        _IOWR('i', 111, struct lifreq)        /* create logical */
+
+#define        SIOCSLIFADDR        _IOW('i',  112, struct lifreq)        /* set if address */
+#define        SIOCGLIFADDR        _IOWR('i', 113, struct lifreq)        /* get if address */
+#define        SIOCSLIFDSTADDR        _IOW('i',  114, struct lifreq)        /* set p-p address */
+#define        SIOCGLIFDSTADDR        _IOWR('i', 115, struct lifreq)        /* get p-p address */
+#define        SIOCSLIFFLAGS        _IOW('i',  116, struct lifreq)        /* set if flags */
+#define        SIOCGLIFFLAGS        _IOWR('i', 117, struct lifreq)        /* get if flags */
+
+/*
+ * Needs to be defined using _IOWRN macro to make it datamodel independent.
+ * Argument is a struct lifconf.
+ */
+#define        O_SIOCGLIFCONF        _IOWRN('i', 120, 16)                /* old get if list */
+#define        SIOCSLIFMTU        _IOW('i',  121, struct lifreq)        /* set if mtu */
+#define        SIOCGLIFMTU        _IOWR('i', 122, struct lifreq)        /* get if mtu */
+#define        SIOCGLIFBRDADDR        _IOWR('i', 123, struct lifreq)        /* get broadcast addr */
+#define        SIOCSLIFBRDADDR        _IOW('i',  124, struct lifreq)        /* set broadcast addr */
+#define        SIOCGLIFNETMASK        _IOWR('i', 125, struct lifreq)        /* get subnetmask */
+#define        SIOCSLIFNETMASK        _IOW('i',  126, struct lifreq)        /* set subnetmask */
+#define        SIOCGLIFMETRIC        _IOWR('i', 127, struct lifreq)        /* get if metric */
+#define        SIOCSLIFMETRIC        _IOW('i',  128, struct lifreq)        /* set if metric */
+#define        SIOCSLIFNAME        _IOWR('i', 129, struct lifreq)        /* set interface name */
+#define        SIOCGLIFNUM        _IOWR('i', 130, struct lifnum)        /* get number of ifs */
+#define        SIOCGLIFMUXID        _IOWR('i', 131, struct lifreq)        /* get if muxid */
+#define        SIOCSLIFMUXID        _IOW('i',  132, struct lifreq)        /* set if muxid */
+
+#define        SIOCGLIFINDEX        _IOWR('i', 133, struct lifreq)        /* get if index */
+#define        SIOCSLIFINDEX        _IOW('i',  134, struct lifreq)        /* set if index */
+
+#define        SIOCSLIFTOKEN        _IOW('i',  135, struct lifreq)        /* Set token for link */
+                                                        /* local address and */
+                                                        /* autoconf */
+#define        SIOCGLIFTOKEN        _IOWR('i', 136, struct lifreq)        /* Get token for link */
+                                                        /* local address and */
+                                                        /* autoconf */
+
+#define        SIOCSLIFSUBNET        _IOW('i',  137, struct lifreq)        /* set subnet prefix */
+#define        SIOCGLIFSUBNET        _IOWR('i', 138, struct lifreq)        /* get subnet prefix */
+
+#define        SIOCSLIFLNKINFO _IOW('i',  139, struct lifreq)        /* set link info */
+#define        SIOCGLIFLNKINFO _IOWR('i', 140, struct lifreq)        /* get link info */
+
+#define        SIOCLIFDELND        _IOW('i',  141, struct lifreq)        /* Delete ND entry */
+#define        SIOCLIFGETND        _IOWR('i', 142, struct lifreq)        /* Get ND entry */
+#define        SIOCLIFSETND        _IOW('i',  143, struct lifreq)        /* Set ND entry */
+
+/*
+ * Address querying ioctls.
+ */
+#define        SIOCTMYADDR        _IOWR('i', 144, struct sioc_addrreq)
+                                                        /* My address? */
+#define        SIOCTONLINK        _IOWR('i', 145, struct sioc_addrreq)
+                                                        /* Address on-link? */
+#define        SIOCTMYSITE        _IOWR('i', 146, struct sioc_addrreq)
+                                                        /* In this site? */
+
+/* 147-152 were SIOC*{TUNPARAM,IPSECONFIG} ioctls.  Feel free to re-use. */
+
+/*
+ * 153 can be reused (was consolidation-private SIOCLIFFAILOVER).
+ */
+
+/*
+ * IP Multipathing ioctls.
+ */
+#define        SIOCGLIFBINDING                _IOWR('i', 154, struct lifreq)
+#define        SIOCSLIFGROUPNAME        _IOW('i',  155, struct lifreq)
+#define        SIOCGLIFGROUPNAME        _IOWR('i', 156, struct lifreq)
+#define        SIOCGLIFGROUPINFO        _IOWR('i', 157, struct lifgroupinfo)
+
+/*
+ * Leave 158 - 160 unused; used to be SIOC*IFARP ioctls.
+ * However, 161 can be reused (was consolidation-private SIOCSLIFOINDEX).
+ */
+
+/*
+ * IOCTLS which provide an interface to the IPv6 address selection policy.
+ */
+#define        SIOCGIP6ADDRPOLICY        _IOWRN('i', 162, 0)
+#define        SIOCSIP6ADDRPOLICY        _IOWN('i', 163, 0)
+
+/*
+ * IOCTL for retrieving sorting info for a list of destination addrs.
+ * Use the _IOWRN macro to make it datamodel independent.  Argument
+ * is a struct dstinfo.
+ */
+#define        SIOCGDSTINFO        _IOWRN('i', 164, 0)
+#define        SIOCGLIFCONF        _IOWR('i', 165, 16)        /* get if list */
+
+/*
+ * Extended IOCTLS for manipulating ARP cache entries.
+ */
+#define        SIOCSXARP        _IOW('i', 166, struct xarpreq)        /* set an ARP entry */
+#define        SIOCGXARP        _IOWR('i', 167, struct xarpreq)        /* get an ARP entry */
+#define        SIOCDXARP        _IOW('i', 168, struct xarpreq)        /* delete ARP entry */
+
+/*
+ * IOCTL private to sockfs.
+ */
+#define        _SIOCSOCKFALLBACK _IOW('i', 169, 0)
+
+/*
+ * IOCTLs for getting and setting zone associated with an interface, and
+ * unplumbing interfaces associated with a given zone.
+ */
+#define        SIOCGLIFZONE        _IOWR('i', 170, struct lifreq)        /* get zone id */
+#define        SIOCSLIFZONE        _IOW('i', 171, struct lifreq)        /* set zone id */
+
+/*
+ * IOCTLS for handling SCTP options.
+ */
+#define        SIOCSCTPSOPT        _IOWN('i', 172, 16)        /* Set SCTP option */
+#define        SIOCSCTPGOPT        _IOWRN('i', 173, 16)        /* Get SCTP option */
+#define        SIOCSCTPPEELOFF        _IOWR('i', 174, int)        /* SCTP peeloff */
+
+/*
+ * IOCTLs for getting and setting the source address that is used for packets
+ * going out on the given interface.
+ */
+#define        SIOCGLIFUSESRC        _IOWR('i', 175, struct lifreq)        /* get src addr */
+#define        SIOCSLIFUSESRC        _IOW('i', 176, struct lifreq)        /* set src addr */
+
+/*
+ * IOCTL used to get all the interfaces that use the the specified interfaces'
+ * source address
+ */
+#define        SIOCGLIFSRCOF        _IOWRN('i', 177, 16)                /* source of */
+
+/*
+ * IOCTLs for source specific multicast; get or set a socket's
+ * source filter for a particular multicast group.  Argument is
+ * a struct group_filter.  Defined in RFC 3678.
+ */
+#define        SIOCGMSFILTER        _IOWR('i', 178, 0)
+#define        SIOCSMSFILTER        _IOW('i', 179, 0)
+/*
+ * IPv4-specific versions of the above; get or set a socket's source
+ * filter for a particular multicast group, for PF_INET sockets only.
+ * Argument is a struct ip_msfilter.
+ */
+#define        SIOCGIPMSFILTER        _IOWR('i', 180, 0)
+#define        SIOCSIPMSFILTER        _IOW('i', 181, 0)
+
+/*
+ * 182 can be reused (was consolidation-private SIOCSIPMPFAILBACK).
+ */
+
+#define        SIOCSENABLESDP        _IOWR('i', 183, int)    /*  Enable SDP */
+
+#define        SIOCSQPTR        _IOWR('i', 184, int)    /* set q_ptr of stream */
+
+/*
+ * SIOCGIFHWADDR and SIOCGLIFHWADDR (below) are available for PF_PACKET,
+ * PF_INET and PF_INET6 sockets.
+ */
+#define        SIOCGIFHWADDR        _IOWR('i', 185, struct ifreq)
+
+#define        SIOCGSTAMP        _IOWR('i', 186, struct timeval)        /* PF_PACKET */
+
+/*
+ * Private ioctl for Integrated Load Balancer.  The ioctl length varies.
+ */
+#define        SIOCILB                _IOWR('i', 187, 0)
+
+/*
+ * IOCTL's to get/set module specific or interface specific properties.
+ * Argument is a struct mod_ioc_prop_s. These ioctls are Consolidation Private.
+ */
+#define        SIOCGETPROP        _IOWRN('p', 188, 0)
+#define        SIOCSETPROP        _IOW('p', 189, 0)
+
+/*
+ * IOCTL used to check for the given ipif, whether DAD is in progress or
+ * DAD has completed. This ioctl is Consolidation Private.
+ */
+#define        SIOCGLIFDADSTATE        _IOWR('i', 190, struct lifreq)
+
+/*
+ * IOCTL used to generate an IPv6 address using the given prefix and the
+ * default token for the interface.
+ */
+#define        SIOCSLIFPREFIX                _IOWR('i', 191, struct lifreq)
+
+#define        SIOCGLIFHWADDR        _IOWR('i', 192, struct lifreq)
+
+#ifdef        __cplusplus
+}
+#endif
+
+#endif        /* _SYS_SOCKIO_H */
diff -Naur wide-dhcpv6-20080615.orig/missing/.svn/all-wcprops wide-dhcpv6-20080615/missing/.svn/all-wcprops
--- wide-dhcpv6-20080615.orig/missing/.svn/all-wcprops	1970-01-01 08:00:00.000000000 +0800
+++ wide-dhcpv6-20080615/missing/.svn/all-wcprops	2013-12-30 16:11:42.000000000 +0800
@@ -0,0 +1,59 @@
+K 25
+svn:wc:ra_dav:version-url
+V 95
+/svn/TPDC/Broadcom/!svn/ver/1706/412/Product/VMG5313/userspace/zyxel/public/apps/dhcpv6/missing
+END
+arc4random.c
+K 25
+svn:wc:ra_dav:version-url
+V 108
+/svn/TPDC/Broadcom/!svn/ver/1706/412/Product/VMG5313/userspace/zyxel/public/apps/dhcpv6/missing/arc4random.c
+END
+getifaddrs.c
+K 25
+svn:wc:ra_dav:version-url
+V 108
+/svn/TPDC/Broadcom/!svn/ver/1706/412/Product/VMG5313/userspace/zyxel/public/apps/dhcpv6/missing/getifaddrs.c
+END
+strlcat.c
+K 25
+svn:wc:ra_dav:version-url
+V 105
+/svn/TPDC/Broadcom/!svn/ver/1706/412/Product/VMG5313/userspace/zyxel/public/apps/dhcpv6/missing/strlcat.c
+END
+err.h
+K 25
+svn:wc:ra_dav:version-url
+V 101
+/svn/TPDC/Broadcom/!svn/ver/1706/412/Product/VMG5313/userspace/zyxel/public/apps/dhcpv6/missing/err.h
+END
+arc4random.h
+K 25
+svn:wc:ra_dav:version-url
+V 108
+/svn/TPDC/Broadcom/!svn/ver/1706/412/Product/VMG5313/userspace/zyxel/public/apps/dhcpv6/missing/arc4random.h
+END
+warnx.c
+K 25
+svn:wc:ra_dav:version-url
+V 103
+/svn/TPDC/Broadcom/!svn/ver/1706/412/Product/VMG5313/userspace/zyxel/public/apps/dhcpv6/missing/warnx.c
+END
+strlcpy.c
+K 25
+svn:wc:ra_dav:version-url
+V 105
+/svn/TPDC/Broadcom/!svn/ver/1706/412/Product/VMG5313/userspace/zyxel/public/apps/dhcpv6/missing/strlcpy.c
+END
+ifaddrs.h
+K 25
+svn:wc:ra_dav:version-url
+V 105
+/svn/TPDC/Broadcom/!svn/ver/1706/412/Product/VMG5313/userspace/zyxel/public/apps/dhcpv6/missing/ifaddrs.h
+END
+daemon.c
+K 25
+svn:wc:ra_dav:version-url
+V 104
+/svn/TPDC/Broadcom/!svn/ver/1706/412/Product/VMG5313/userspace/zyxel/public/apps/dhcpv6/missing/daemon.c
+END
diff -Naur wide-dhcpv6-20080615.orig/missing/.svn/entries wide-dhcpv6-20080615/missing/.svn/entries
--- wide-dhcpv6-20080615.orig/missing/.svn/entries	1970-01-01 08:00:00.000000000 +0800
+++ wide-dhcpv6-20080615/missing/.svn/entries	2013-12-30 16:11:42.000000000 +0800
@@ -0,0 +1,337 @@
+10
+
+dir
+4552
+http://svn.zyxel.com.tw/svn/TPDC/Broadcom/412/Product/VMG5313/userspace/zyxel/public/apps/dhcpv6/missing
+http://svn.zyxel.com.tw/svn/TPDC/Broadcom
+
+
+
+2013-04-24T01:26:48.626530Z
+1706
+jerry.lin4@zyxel.com.tw
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+b12e3367-17ef-584a-8d8e-8b73140cb9ea
+
+daemon.c
+file
+
+
+
+
+2013-12-30T08:11:42.989130Z
+2728ceac270a74ef7d7f01f4aaa9e106
+2013-04-24T01:26:48.626530Z
+1706
+jerry.lin4@zyxel.com.tw
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+1908
+
+arc4random.c
+file
+
+
+
+
+2013-12-30T08:11:42.989130Z
+fcd23caa13f68998d9ccd7beca97ec73
+2013-04-24T01:26:48.626530Z
+1706
+jerry.lin4@zyxel.com.tw
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+2140
+
+getifaddrs.c
+file
+
+
+
+
+2013-12-30T08:11:42.989130Z
+986e242dd8baed678f068fbfd608bc25
+2013-04-24T01:26:48.626530Z
+1706
+jerry.lin4@zyxel.com.tw
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+5564
+
+strlcat.c
+file
+
+
+
+
+2013-12-30T08:11:42.989130Z
+bdf2502667b480464d4ca5fe84fa4c71
+2013-04-24T01:26:48.626530Z
+1706
+jerry.lin4@zyxel.com.tw
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+2624
+
+sys
+dir
+
+err.h
+file
+
+
+
+
+2013-12-30T08:11:42.989130Z
+149cd571f1856e6ded5a0ec7d6465fc8
+2013-04-24T01:26:48.626530Z
+1706
+jerry.lin4@zyxel.com.tw
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+1723
+
+arc4random.h
+file
+
+
+
+
+2013-12-30T08:11:42.981130Z
+9dd4ac9d6242ebb441ac03ecb8528fd8
+2013-04-24T01:26:48.626530Z
+1706
+jerry.lin4@zyxel.com.tw
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+1731
+
+warnx.c
+file
+
+
+
+
+2013-12-30T08:11:42.989130Z
+cd6f6013770d788e49073083bad7c201
+2013-04-24T01:26:48.626530Z
+1706
+jerry.lin4@zyxel.com.tw
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+1981
+
+strlcpy.c
+file
+
+
+
+
+2013-12-30T08:11:42.989130Z
+61f7125ff1ddf1f931b2dbe9016f8255
+2013-04-24T01:26:48.626530Z
+1706
+jerry.lin4@zyxel.com.tw
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+2558
+
+ifaddrs.h
+file
+
+
+
+
+2013-12-30T08:11:42.989130Z
+569b78e91c597100c3cdc10f596aa3c4
+2013-04-24T01:26:48.626530Z
+1706
+jerry.lin4@zyxel.com.tw
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+2064
+
diff -Naur wide-dhcpv6-20080615.orig/missing/.svn/text-base/arc4random.c.svn-base wide-dhcpv6-20080615/missing/.svn/text-base/arc4random.c.svn-base
--- wide-dhcpv6-20080615.orig/missing/.svn/text-base/arc4random.c.svn-base	1970-01-01 08:00:00.000000000 +0800
+++ wide-dhcpv6-20080615/missing/.svn/text-base/arc4random.c.svn-base	2013-12-30 16:11:42.000000000 +0800
@@ -0,0 +1,67 @@
+/*	$KAME: arc4random.c,v 1.1 2003/01/22 01:30:36 jinmei Exp $	*/
+
+/*
+ * Copyright (C) 2000 WIDE Project.
+ * All rights reserved.
+ * 
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of the project nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ * 
+ * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+/*
+ * a stub function to make random() to return good random numbers.
+ */
+
+#include <sys/types.h>
+#include <sys/param.h>
+#include <sys/uio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <err.h>
+
+#include "arc4random.h"
+
+static int fd = -1;
+
+static void
+arc4random_init()
+{
+
+	fd = open("/dev/urandom", O_RDONLY, 0600);
+	if (fd < 0) {
+		err(1, "/dev/urandom");
+		/*NOTREACHED*/
+	}
+}
+
+u_int32_t
+arc4random()
+{
+	u_int32_t v;
+
+	if (fd < 0)
+		arc4random_init();
+	read(fd, &v, sizeof(v));
+	return v;
+}
diff -Naur wide-dhcpv6-20080615.orig/missing/.svn/text-base/arc4random.h.svn-base wide-dhcpv6-20080615/missing/.svn/text-base/arc4random.h.svn-base
--- wide-dhcpv6-20080615.orig/missing/.svn/text-base/arc4random.h.svn-base	1970-01-01 08:00:00.000000000 +0800
+++ wide-dhcpv6-20080615/missing/.svn/text-base/arc4random.h.svn-base	2013-12-30 16:11:42.000000000 +0800
@@ -0,0 +1,37 @@
+/*	$KAME: arc4random.h,v 1.1 2003/01/22 01:30:36 jinmei Exp $	*/
+
+/*
+ * Copyright (C) 2000 WIDE Project.
+ * All rights reserved.
+ * 
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of the project nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ * 
+ * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#ifdef __sun__
+#define	__P(x)	x
+typedef uint32_t u_int32_t;
+#endif
+
+extern u_int32_t arc4random __P((void));
diff -Naur wide-dhcpv6-20080615.orig/missing/.svn/text-base/daemon.c.svn-base wide-dhcpv6-20080615/missing/.svn/text-base/daemon.c.svn-base
--- wide-dhcpv6-20080615.orig/missing/.svn/text-base/daemon.c.svn-base	1970-01-01 08:00:00.000000000 +0800
+++ wide-dhcpv6-20080615/missing/.svn/text-base/daemon.c.svn-base	2013-12-30 16:11:42.000000000 +0800
@@ -0,0 +1,50 @@
+/*
+ * Copyright (c) 2006 WIDE Project. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of the project nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ * 
+ * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#include <sys/types.h>
+#include <unistd.h>
+#include <fcntl.h>
+
+int
+daemon(int nochdir, int noclose)
+{
+	if (fork() != 0)
+		_exit(0);
+	if (nochdir == 0)
+		(void) chdir("/");
+	if (noclose == 0) {
+		(void) close(0);
+		(void) open("/dev/null", O_RDWR);
+		(void) dup2(0, 1);
+		(void) dup2(0, 2);
+	}
+	(void) setsid();
+	if (fork() != 0)
+		_exit(0);
+	return (0);
+}
diff -Naur wide-dhcpv6-20080615.orig/missing/.svn/text-base/err.h.svn-base wide-dhcpv6-20080615/missing/.svn/text-base/err.h.svn-base
--- wide-dhcpv6-20080615.orig/missing/.svn/text-base/err.h.svn-base	1970-01-01 08:00:00.000000000 +0800
+++ wide-dhcpv6-20080615/missing/.svn/text-base/err.h.svn-base	2013-12-30 16:11:42.000000000 +0800
@@ -0,0 +1,34 @@
+/*
+ * Copyright (c) 2006 WIDE Project. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of the project nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ * 
+ * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+extern void err(int, const char *);
+/* PRINTFLIKE2 */
+extern void errx(int, const char *, ...);
+/* PRINTFLIKE1 */
+extern void warnx(const char *, ...);
+#define warn warnx
diff -Naur wide-dhcpv6-20080615.orig/missing/.svn/text-base/getifaddrs.c.svn-base wide-dhcpv6-20080615/missing/.svn/text-base/getifaddrs.c.svn-base
--- wide-dhcpv6-20080615.orig/missing/.svn/text-base/getifaddrs.c.svn-base	1970-01-01 08:00:00.000000000 +0800
+++ wide-dhcpv6-20080615/missing/.svn/text-base/getifaddrs.c.svn-base	2013-12-30 16:11:42.000000000 +0800
@@ -0,0 +1,217 @@
+/*
+ * Copyright (c) 2006 WIDE Project. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of the project nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ * 
+ * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#include <unistd.h>
+#include <stdlib.h>
+#include <errno.h>
+#include <string.h>
+#include <sys/sockio.h>
+#include <sys/socket.h>
+#include <net/if.h>
+
+#include "ifaddrs.h"
+
+static int
+get_lifreq(int fd, struct lifreq **ifr_ret)
+{
+	struct lifnum lifn;
+	struct lifconf lifc;
+	struct lifreq *lifrp;
+
+	lifn.lifn_family = AF_UNSPEC;
+	lifn.lifn_flags = 0;
+	if (ioctl(fd, SIOCGLIFNUM, &lifn) == -1)
+		lifn.lifn_count = 16;
+	else
+		lifn.lifn_count += 16;
+
+	for (;;) {
+		lifc.lifc_len = lifn.lifn_count * sizeof (*lifrp);
+		lifrp = malloc(lifc.lifc_len);
+		if (lifrp == NULL)
+			return (-1);
+
+		lifc.lifc_family = AF_UNSPEC;
+		lifc.lifc_flags = 0;
+		lifc.lifc_buf = (char *)lifrp;
+		if (ioctl(fd, SIOCGLIFCONF, &lifc) == -1) {
+			free(lifrp);
+			if (errno == EINVAL) {
+				lifn.lifn_count <<= 1;
+				continue;
+			}
+			(void) close(fd);
+			return (-1);
+		}
+		if (lifc.lifc_len < (lifn.lifn_count - 1) * sizeof (*lifrp))
+			break;
+		free(lifrp);
+		lifn.lifn_count <<= 1;
+	}
+	(void) close(fd);
+
+	*ifr_ret = lifrp;
+
+	return (lifc.lifc_len / sizeof (*lifrp));
+}
+
+static size_t
+nbytes(const struct lifreq *lifrp, int nlif, size_t socklen)
+{
+	size_t len = 0;
+	size_t slen;
+
+	while (nlif > 0) {
+		slen = strlen(lifrp->lifr_name) + 1;
+		len += sizeof (struct ifaddrs) + ((slen + 3) & ~3);
+		len += 3 * socklen;
+		lifrp++;
+		nlif--;
+	}
+	return (len);
+}
+
+static struct sockaddr *
+addrcpy(struct sockaddr_storage *addr, char **bufp)
+{
+	char *buf = *bufp;
+	size_t len;
+
+	len = addr->ss_family == AF_INET ? sizeof (struct sockaddr_in) :
+	    sizeof (struct sockaddr_in6);
+	(void) memcpy(buf, addr, len);
+	*bufp = buf + len;
+	return ((struct sockaddr *)buf);
+}
+
+static int
+populate(struct ifaddrs *ifa, int fd, struct lifreq *lifrp, int nlif, int af,
+    char **bufp)
+{
+	char *buf = *bufp;
+	size_t slen;
+
+	while (nlif > 0) {
+		ifa->ifa_next = (nlif > 1) ? ifa + 1 : NULL;
+		(void) strcpy(ifa->ifa_name = buf, lifrp->lifr_name);
+		slen = strlen(lifrp->lifr_name) + 1;
+		buf += (slen + 3) & ~3;
+		if (ioctl(fd, SIOCGLIFFLAGS, lifrp) == -1)
+			ifa->ifa_flags = 0;
+		else
+			ifa->ifa_flags = lifrp->lifr_flags;
+		if (ioctl(fd, SIOCGLIFADDR, lifrp) == -1)
+			ifa->ifa_addr = NULL;
+		else
+			ifa->ifa_addr = addrcpy(&lifrp->lifr_addr, &buf);
+		if (ioctl(fd, SIOCGLIFNETMASK, lifrp) == -1)
+			ifa->ifa_netmask = NULL;
+		else
+			ifa->ifa_netmask = addrcpy(&lifrp->lifr_addr, &buf);
+		if (ifa->ifa_flags & IFF_POINTOPOINT) {
+			if (ioctl(fd, SIOCGLIFDSTADDR, lifrp) == -1)
+				ifa->ifa_dstaddr = NULL;
+			else
+				ifa->ifa_dstaddr =
+				    addrcpy(&lifrp->lifr_dstaddr, &buf);
+		} else if (ifa->ifa_flags & IFF_BROADCAST) {
+			if (ioctl(fd, SIOCGLIFBRDADDR, lifrp) == -1)
+				ifa->ifa_broadaddr = NULL;
+			else
+				ifa->ifa_broadaddr =
+				    addrcpy(&lifrp->lifr_broadaddr, &buf);
+		} else {
+			ifa->ifa_dstaddr = NULL;
+		}
+
+		ifa++;
+		nlif--;
+		lifrp++;
+	}
+	*bufp = buf;
+	return (0);
+}
+
+int
+getifaddrs(struct ifaddrs **ifap)
+{
+	int fd4, fd6;
+	int nif4, nif6 = 0;
+	struct lifreq *ifr4 = NULL;
+	struct lifreq *ifr6 = NULL;
+	struct ifaddrs *ifa = NULL;
+	char *buf;
+
+	if ((fd4 = socket(AF_INET, SOCK_DGRAM, 0)) == -1)
+		return (-1);
+	if ((fd6 = socket(AF_INET6, SOCK_DGRAM, 0)) == -1 &&
+	    errno != EAFNOSUPPORT) {
+		(void) close(fd4);
+		return (-1);
+	}
+
+	if ((nif4 = get_lifreq(fd4, &ifr4)) == -1 ||
+	    (fd6 != -1 && (nif6 = get_lifreq(fd6, &ifr6)) == -1))
+		goto failure;
+
+	if (nif4 == 0 && nif6 == 0) {
+		*ifap = NULL;
+		return (0);
+	}
+
+	ifa = malloc(nbytes(ifr4, nif4, sizeof (struct sockaddr_in)) +
+	    nbytes(ifr6, nif6, sizeof (struct sockaddr_in6)));
+	if (ifa == NULL)
+		goto failure;
+
+	buf = (char *)(ifa + nif4 + nif6);
+
+	if (populate(ifa, fd4, ifr4, nif4, AF_INET, &buf) == -1)
+		goto failure;
+	if (nif4 > 0 && nif6 > 0)
+		ifa[nif4 - 1].ifa_next = ifa + nif4;
+	if (populate(ifa + nif4, fd6, ifr6, nif6, AF_INET6, &buf) == -1)
+		goto failure;
+
+	return (0);
+
+failure:
+	free(ifa);
+	(void) close(fd4);
+	if (fd6 != -1)
+		(void) close(fd6);
+	free(ifr4);
+	free(ifr6);
+	return (-1);
+}
+
+void
+freeifaddrs(struct ifaddrs *ifa)
+{
+	free(ifa);
+}
diff -Naur wide-dhcpv6-20080615.orig/missing/.svn/text-base/ifaddrs.h.svn-base wide-dhcpv6-20080615/missing/.svn/text-base/ifaddrs.h.svn-base
--- wide-dhcpv6-20080615.orig/missing/.svn/text-base/ifaddrs.h.svn-base	1970-01-01 08:00:00.000000000 +0800
+++ wide-dhcpv6-20080615/missing/.svn/text-base/ifaddrs.h.svn-base	2013-12-30 16:11:42.000000000 +0800
@@ -0,0 +1,44 @@
+/*
+ * Copyright (c) 2006 WIDE Project. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of the project nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ * 
+ * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#include <sys/types.h>
+
+#undef ifa_broadaddr
+#undef ifa_dstaddr
+struct ifaddrs {
+	struct ifaddrs	*ifa_next;	/* Pointer to next struct */
+	char		*ifa_name;	/* Interface name */
+	uint64_t	ifa_flags;	/* Interface flags */
+	struct sockaddr	*ifa_addr;	/* Interface address */
+	struct sockaddr	*ifa_netmask;	/* Interface netmask */
+	struct sockaddr	*ifa_dstaddr;	/* P2P interface destination */
+};
+#define	ifa_broadaddr	ifa_dstaddr
+
+extern int getifaddrs(struct ifaddrs **);
+extern void freeifaddrs(struct ifaddrs *);
diff -Naur wide-dhcpv6-20080615.orig/missing/.svn/text-base/strlcat.c.svn-base wide-dhcpv6-20080615/missing/.svn/text-base/strlcat.c.svn-base
--- wide-dhcpv6-20080615.orig/missing/.svn/text-base/strlcat.c.svn-base	1970-01-01 08:00:00.000000000 +0800
+++ wide-dhcpv6-20080615/missing/.svn/text-base/strlcat.c.svn-base	2013-12-30 16:11:42.000000000 +0800
@@ -0,0 +1,75 @@
+/*	$NetBSD: strlcat.c,v 1.5 1999/09/20 04:39:47 lukem Exp $	*/
+/*	from OpenBSD: strlcat.c,v 1.2 1999/06/17 16:28:58 millert Exp 	*/
+
+/*
+ * Copyright (c) 1998 Todd C. Miller <Todd.Miller@courtesan.com>
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
+ * AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL
+ * THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+ * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <sys/cdefs.h>
+#if defined(LIBC_SCCS) && !defined(lint)
+__RCSID("$NetBSD: strlcat.c,v 1.5 1999/09/20 04:39:47 lukem Exp $");
+#endif /* LIBC_SCCS and not lint */
+
+#include <sys/types.h>
+#include <assert.h>
+#include <string.h>
+
+/*
+ * Appends src to string dst of size siz (unlike strncat, siz is the
+ * full size of dst, not space left).  At most siz-1 characters
+ * will be copied.  Always NUL terminates (unless siz == 0).
+ * Returns strlen(src); if retval >= siz, truncation occurred.
+ */
+size_t
+strlcat(dst, src, siz)
+	char *dst;
+	const char *src;
+	size_t siz;
+{
+	register char *d = dst;
+	register const char *s = src;
+	register size_t n = siz;
+	size_t dlen;
+
+	/* Find the end of dst and adjust bytes left but don't go past end */
+	while (*d != '\0' && n-- != 0)
+		d++;
+	dlen = d - dst;
+	n = siz - dlen;
+
+	if (n == 0)
+		return(dlen + strlen(s));
+	while (*s != '\0') {
+		if (n != 1) {
+			*d++ = *s;
+			n--;
+		}
+		s++;
+	}
+	*d = '\0';
+
+	return(dlen + (s - src));	/* count does not include NUL */
+}
diff -Naur wide-dhcpv6-20080615.orig/missing/.svn/text-base/strlcpy.c.svn-base wide-dhcpv6-20080615/missing/.svn/text-base/strlcpy.c.svn-base
--- wide-dhcpv6-20080615.orig/missing/.svn/text-base/strlcpy.c.svn-base	1970-01-01 08:00:00.000000000 +0800
+++ wide-dhcpv6-20080615/missing/.svn/text-base/strlcpy.c.svn-base	2013-12-30 16:11:42.000000000 +0800
@@ -0,0 +1,72 @@
+/*	$NetBSD: strlcpy.c,v 1.5 1999/09/20 04:39:47 lukem Exp $	*/
+/*	from OpenBSD: strlcpy.c,v 1.4 1999/05/01 18:56:41 millert Exp 	*/
+
+/*
+ * Copyright (c) 1998 Todd C. Miller <Todd.Miller@courtesan.com>
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
+ * AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL
+ * THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+ * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <sys/cdefs.h>
+#if defined(LIBC_SCCS) && !defined(lint)
+__RCSID("$NetBSD: strlcpy.c,v 1.5 1999/09/20 04:39:47 lukem Exp $");
+#endif /* LIBC_SCCS and not lint */
+
+#include <sys/types.h>
+#include <assert.h>
+#include <string.h>
+
+/*
+ * Copy src to string dst of size siz.  At most siz-1 characters
+ * will be copied.  Always NUL terminates (unless siz == 0).
+ * Returns strlen(src); if retval >= siz, truncation occurred.
+ */
+size_t
+strlcpy(dst, src, siz)
+	char *dst;
+	const char *src;
+	size_t siz;
+{
+	register char *d = dst;
+	register const char *s = src;
+	register size_t n = siz;
+
+	/* Copy as many bytes as will fit */
+	if (n != 0 && --n != 0) {
+		do {
+			if ((*d++ = *s++) == 0)
+				break;
+		} while (--n != 0);
+	}
+
+	/* Not enough room in dst, add NUL and traverse rest of src */
+	if (n == 0) {
+		if (siz != 0)
+			*d = '\0';		/* NUL-terminate dst */
+		while (*s++)
+			;
+	}
+
+	return(s - src - 1);	/* count does not include NUL */
+}
diff -Naur wide-dhcpv6-20080615.orig/missing/.svn/text-base/warnx.c.svn-base wide-dhcpv6-20080615/missing/.svn/text-base/warnx.c.svn-base
--- wide-dhcpv6-20080615.orig/missing/.svn/text-base/warnx.c.svn-base	1970-01-01 08:00:00.000000000 +0800
+++ wide-dhcpv6-20080615/missing/.svn/text-base/warnx.c.svn-base	2013-12-30 16:11:42.000000000 +0800
@@ -0,0 +1,59 @@
+/*
+ * Copyright (c) 2006 WIDE Project. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of the project nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ * 
+ * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <stdarg.h>
+
+void
+err(int retv, const char *str)
+{
+	(void) fprintf(stderr, "%s\n", str);
+	exit(retv);
+}
+
+void
+errx(int retv, const char *fmt, ...)
+{
+	va_list args;
+
+	va_start(args, fmt);
+	(void) vfprintf(stderr, fmt, args);
+	va_end(args);
+	exit(retv);
+}
+
+void
+warnx(const char *fmt, ...)
+{
+	va_list args;
+
+	va_start(args, fmt);
+	(void) vfprintf(stderr, fmt, args);
+	va_end(args);
+}
diff -Naur wide-dhcpv6-20080615.orig/missing/sys/.svn/all-wcprops wide-dhcpv6-20080615/missing/sys/.svn/all-wcprops
--- wide-dhcpv6-20080615.orig/missing/sys/.svn/all-wcprops	1970-01-01 08:00:00.000000000 +0800
+++ wide-dhcpv6-20080615/missing/sys/.svn/all-wcprops	2013-12-30 16:11:42.000000000 +0800
@@ -0,0 +1,11 @@
+K 25
+svn:wc:ra_dav:version-url
+V 99
+/svn/TPDC/Broadcom/!svn/ver/1706/412/Product/VMG5313/userspace/zyxel/public/apps/dhcpv6/missing/sys
+END
+queue.h
+K 25
+svn:wc:ra_dav:version-url
+V 107
+/svn/TPDC/Broadcom/!svn/ver/1706/412/Product/VMG5313/userspace/zyxel/public/apps/dhcpv6/missing/sys/queue.h
+END
diff -Naur wide-dhcpv6-20080615.orig/missing/sys/.svn/entries wide-dhcpv6-20080615/missing/sys/.svn/entries
--- wide-dhcpv6-20080615.orig/missing/sys/.svn/entries	1970-01-01 08:00:00.000000000 +0800
+++ wide-dhcpv6-20080615/missing/sys/.svn/entries	2013-12-30 16:11:42.000000000 +0800
@@ -0,0 +1,62 @@
+10
+
+dir
+4552
+http://svn.zyxel.com.tw/svn/TPDC/Broadcom/412/Product/VMG5313/userspace/zyxel/public/apps/dhcpv6/missing/sys
+http://svn.zyxel.com.tw/svn/TPDC/Broadcom
+
+
+
+2013-04-24T01:26:48.626530Z
+1706
+jerry.lin4@zyxel.com.tw
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+b12e3367-17ef-584a-8d8e-8b73140cb9ea
+
+queue.h
+file
+
+
+
+
+2013-12-30T08:11:42.977130Z
+8214544b1a65ed0e1e672b0435582e92
+2013-04-24T01:26:48.626530Z
+1706
+jerry.lin4@zyxel.com.tw
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+4819
+
diff -Naur wide-dhcpv6-20080615.orig/missing/sys/.svn/text-base/queue.h.svn-base wide-dhcpv6-20080615/missing/sys/.svn/text-base/queue.h.svn-base
--- wide-dhcpv6-20080615.orig/missing/sys/.svn/text-base/queue.h.svn-base	1970-01-01 08:00:00.000000000 +0800
+++ wide-dhcpv6-20080615/missing/sys/.svn/text-base/queue.h.svn-base	2013-12-30 16:11:42.000000000 +0800
@@ -0,0 +1,137 @@
+/*
+ * Copyright (c) 1991, 1993
+ *	The Regents of the University of California.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. All advertising materials mentioning features or use of this software
+ *    must display the following acknowledgement:
+ *	This product includes software developed by the University of
+ *	California, Berkeley and its contributors.
+ * 4. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ * Adapted from FreeBSD sys/queue.h by James Carlson <james.d.carlson@sun.com>
+ *
+ *	@(#)queue.h	8.5 (Berkeley) 8/20/94
+ * $FreeBSD: src/sys/sys/queue.h,v 1.32.2.6 2001/12/18 10:09:02 ru Exp $
+ */
+
+/*
+ * Tail queue declarations.
+ */
+#define	TAILQ_HEAD(name, type)						\
+struct name {								\
+	struct type *tqh_first;	/* first element */			\
+	struct type **tqh_last;	/* addr of last next element */		\
+}
+
+#define	TAILQ_ENTRY(type)						\
+struct {								\
+	struct type *tqe_next;	/* next element */			\
+	struct type **tqe_prev;	/* address of previous next element */	\
+}
+
+/*
+ * Tail queue functions.
+ */
+#define	TAILQ_EMPTY(head)	((head)->tqh_first == NULL)
+
+#define	TAILQ_FIRST(head)	((head)->tqh_first)
+
+#define	TAILQ_INIT(head) do {						\
+	TAILQ_FIRST((head)) = NULL;					\
+	(head)->tqh_last = &TAILQ_FIRST((head));			\
+} while (0)
+
+#define	TAILQ_INSERT_HEAD(head, elm, field) do {			\
+	if ((TAILQ_NEXT((elm), field) = TAILQ_FIRST((head))) != NULL)	\
+		TAILQ_FIRST((head))->field.tqe_prev =			\
+		    &TAILQ_NEXT((elm), field);				\
+	else								\
+		(head)->tqh_last = &TAILQ_NEXT((elm), field);		\
+	TAILQ_FIRST((head)) = (elm);					\
+	(elm)->field.tqe_prev = &TAILQ_FIRST((head));			\
+} while (0)
+
+#define	TAILQ_INSERT_TAIL(head, elm, field) do {			\
+	TAILQ_NEXT((elm), field) = NULL;				\
+	(elm)->field.tqe_prev = (head)->tqh_last;			\
+	*(head)->tqh_last = (elm);					\
+	(head)->tqh_last = &TAILQ_NEXT((elm), field);			\
+} while (0)
+
+#define	TAILQ_LAST(head, headname)					\
+	(*(((struct headname *)((head)->tqh_last))->tqh_last))
+
+#define	TAILQ_NEXT(elm, field) ((elm)->field.tqe_next)
+
+#define	TAILQ_REMOVE(head, elm, field) do {				\
+	if ((TAILQ_NEXT((elm), field)) != NULL)				\
+		TAILQ_NEXT((elm), field)->field.tqe_prev = 		\
+		    (elm)->field.tqe_prev;				\
+	else								\
+		(head)->tqh_last = (elm)->field.tqe_prev;		\
+	*(elm)->field.tqe_prev = TAILQ_NEXT((elm), field);		\
+} while (0)
+
+/*
+ * List declarations.
+ */
+#define LIST_HEAD(name, type)						\
+struct name {								\
+	 struct type *lh_first;	/* first element */			\
+}
+
+#define LIST_ENTRY(type)						\
+struct {								\
+	 struct type *le_next;	/* next element */			\
+	 struct type **le_prev;	/* address of previous next element */	\
+}
+
+/*
+ * List functions.
+ */
+
+#define LIST_EMPTY(head)	((head)->lh_first == NULL)
+
+#define LIST_FIRST(head)	((head)->lh_first)
+
+#define LIST_INIT(head) do {						\
+	 LIST_FIRST((head)) = NULL;					\
+} while (0)
+
+#define LIST_INSERT_HEAD(head, elm, field) do {				\
+	 if ((LIST_NEXT((elm), field) = LIST_FIRST((head))) != NULL)	\
+		 LIST_FIRST((head))->field.le_prev = &LIST_NEXT((elm), field);\
+	 LIST_FIRST((head)) = (elm);					\
+	 (elm)->field.le_prev = &LIST_FIRST((head));			\
+} while (0)
+
+#define LIST_NEXT(elm, field)	((elm)->field.le_next)
+
+#define LIST_REMOVE(elm, field) do {					\
+	 if (LIST_NEXT((elm), field) != NULL)				\
+		 LIST_NEXT((elm), field)->field.le_prev =		\
+		     (elm)->field.le_prev;				\
+	 *(elm)->field.le_prev = LIST_NEXT((elm), field);		\
+} while (0)
diff -Naur wide-dhcpv6-20080615.orig/prefixconf.c wide-dhcpv6-20080615/prefixconf.c
--- wide-dhcpv6-20080615.orig/prefixconf.c	2007-03-21 17:52:55.000000000 +0800
+++ wide-dhcpv6-20080615/prefixconf.c	2013-12-30 16:11:43.000000000 +0800
@@ -60,6 +60,13 @@
 #include "dhcp6c_ia.h"
 #include "prefixconf.h"
 
+/*zyxel*/
+#include <stdbool.h>
+#include <json/json.h>
+
+extern struct json_object *dhcp6cMsg;
+/*zyxel end*/
+
 TAILQ_HEAD(siteprefix_list, siteprefix);
 struct iactl_pd {
 	struct iactl common;
@@ -249,6 +256,8 @@
 		break;
 	}
 
+	addPrefixInfoToMsg(IFADDRCONF_ADD, sp);
+
 	return (0);
 }
 
@@ -515,3 +524,21 @@
 	return (ifaddrconf(cmd, pconf->ifname, &ifpfx->ifaddr, ifpfx->plen, 
 	    ND6_INFINITE_LIFETIME, ND6_INFINITE_LIFETIME));
 }
+
+/*zyxel*/
+inline void addPrefixInfoToMsg(ifaddrconf_cmd_t cmd, struct siteprefix *sp)
+{
+	char prefix[48] = {0};
+
+	dprintf(LOG_ERR, FNAME, "%s : Enter\n", __FUNCTION__);
+
+	sprintf(prefix, "%s/%d", in6addr2str(&sp->prefix.addr, 0), sp->prefix.plen);
+
+	json_object_object_add(dhcp6cMsg, "prefixAssigned", json_object_new_boolean(true));
+	json_object_object_add(dhcp6cMsg, "prefixCmd", json_object_new_int(cmd));
+	json_object_object_add(dhcp6cMsg, "prefix", json_object_new_string(prefix)); 
+	json_object_object_add(dhcp6cMsg, "prefixPltime", json_object_new_int(sp->prefix.pltime));
+	json_object_object_add(dhcp6cMsg, "prefixVltime", json_object_new_int(sp->prefix.vltime));
+
+    return;
+} 
diff -Naur wide-dhcpv6-20080615.orig/y.tab.h wide-dhcpv6-20080615/y.tab.h
--- wide-dhcpv6-20080615.orig/y.tab.h	2007-03-21 17:53:10.000000000 +0800
+++ wide-dhcpv6-20080615/y.tab.h	1970-01-01 08:00:00.000000000 +0800
@@ -1,193 +0,0 @@
-/* A Bison parser, made by GNU Bison 2.1.  */
-
-/* Skeleton parser for Yacc-like parsing with Bison,
-   Copyright (C) 1984, 1989, 1990, 2000, 2001, 2002, 2003, 2004, 2005 Free Software Foundation, Inc.
-
-   This program is free software; you can redistribute it and/or modify
-   it under the terms of the GNU General Public License as published by
-   the Free Software Foundation; either version 2, or (at your option)
-   any later version.
-
-   This program is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-   GNU General Public License for more details.
-
-   You should have received a copy of the GNU General Public License
-   along with this program; if not, write to the Free Software
-   Foundation, Inc., 51 Franklin Street, Fifth Floor,
-   Boston, MA 02110-1301, USA.  */
-
-/* As a special exception, when this file is copied by Bison into a
-   Bison output file, you may use that output file without restriction.
-   This special exception was added by the Free Software Foundation
-   in version 1.24 of Bison.  */
-
-/* Tokens.  */
-#ifndef YYTOKENTYPE
-# define YYTOKENTYPE
-   /* Put the tokens into the symbol table, so that GDB and other debuggers
-      know about them.  */
-   enum yytokentype {
-     INTERFACE = 258,
-     IFNAME = 259,
-     PREFIX_INTERFACE = 260,
-     SLA_ID = 261,
-     SLA_LEN = 262,
-     DUID_ID = 263,
-     ID_ASSOC = 264,
-     IA_PD = 265,
-     IAID = 266,
-     IA_NA = 267,
-     ADDRESS = 268,
-     REQUEST = 269,
-     SEND = 270,
-     ALLOW = 271,
-     PREFERENCE = 272,
-     HOST = 273,
-     HOSTNAME = 274,
-     DUID = 275,
-     OPTION = 276,
-     RAPID_COMMIT = 277,
-     DNS_SERVERS = 278,
-     DNS_NAME = 279,
-     NTP_SERVERS = 280,
-     REFRESHTIME = 281,
-     SIP_SERVERS = 282,
-     SIP_NAME = 283,
-     NIS_SERVERS = 284,
-     NIS_NAME = 285,
-     NISP_SERVERS = 286,
-     NISP_NAME = 287,
-     BCMCS_SERVERS = 288,
-     BCMCS_NAME = 289,
-     INFO_ONLY = 290,
-     SCRIPT = 291,
-     DELAYEDKEY = 292,
-     AUTHENTICATION = 293,
-     PROTOCOL = 294,
-     ALGORITHM = 295,
-     DELAYED = 296,
-     RECONFIG = 297,
-     HMACMD5 = 298,
-     MONOCOUNTER = 299,
-     AUTHNAME = 300,
-     RDM = 301,
-     KEY = 302,
-     KEYINFO = 303,
-     REALM = 304,
-     KEYID = 305,
-     SECRET = 306,
-     KEYNAME = 307,
-     EXPIRE = 308,
-     ADDRPOOL = 309,
-     POOLNAME = 310,
-     RANGE = 311,
-     TO = 312,
-     ADDRESS_POOL = 313,
-     INCLUDE = 314,
-     NUMBER = 315,
-     SLASH = 316,
-     EOS = 317,
-     BCL = 318,
-     ECL = 319,
-     STRING = 320,
-     QSTRING = 321,
-     PREFIX = 322,
-     INFINITY = 323,
-     COMMA = 324
-   };
-#endif
-/* Tokens.  */
-#define INTERFACE 258
-#define IFNAME 259
-#define PREFIX_INTERFACE 260
-#define SLA_ID 261
-#define SLA_LEN 262
-#define DUID_ID 263
-#define ID_ASSOC 264
-#define IA_PD 265
-#define IAID 266
-#define IA_NA 267
-#define ADDRESS 268
-#define REQUEST 269
-#define SEND 270
-#define ALLOW 271
-#define PREFERENCE 272
-#define HOST 273
-#define HOSTNAME 274
-#define DUID 275
-#define OPTION 276
-#define RAPID_COMMIT 277
-#define DNS_SERVERS 278
-#define DNS_NAME 279
-#define NTP_SERVERS 280
-#define REFRESHTIME 281
-#define SIP_SERVERS 282
-#define SIP_NAME 283
-#define NIS_SERVERS 284
-#define NIS_NAME 285
-#define NISP_SERVERS 286
-#define NISP_NAME 287
-#define BCMCS_SERVERS 288
-#define BCMCS_NAME 289
-#define INFO_ONLY 290
-#define SCRIPT 291
-#define DELAYEDKEY 292
-#define AUTHENTICATION 293
-#define PROTOCOL 294
-#define ALGORITHM 295
-#define DELAYED 296
-#define RECONFIG 297
-#define HMACMD5 298
-#define MONOCOUNTER 299
-#define AUTHNAME 300
-#define RDM 301
-#define KEY 302
-#define KEYINFO 303
-#define REALM 304
-#define KEYID 305
-#define SECRET 306
-#define KEYNAME 307
-#define EXPIRE 308
-#define ADDRPOOL 309
-#define POOLNAME 310
-#define RANGE 311
-#define TO 312
-#define ADDRESS_POOL 313
-#define INCLUDE 314
-#define NUMBER 315
-#define SLASH 316
-#define EOS 317
-#define BCL 318
-#define ECL 319
-#define STRING 320
-#define QSTRING 321
-#define PREFIX 322
-#define INFINITY 323
-#define COMMA 324
-
-
-
-
-#if ! defined (YYSTYPE) && ! defined (YYSTYPE_IS_DECLARED)
-#line 126 "cfparse.y"
-typedef union YYSTYPE {
-	long long num;
-	char* str;
-	struct cf_list *list;
-	struct dhcp6_prefix *prefix;
-	struct dhcp6_range *range;
-	struct dhcp6_poolspec *pool;
-} YYSTYPE;
-/* Line 1447 of yacc.c.  */
-#line 185 "y.tab.h"
-# define yystype YYSTYPE /* obsolescent; will be withdrawn */
-# define YYSTYPE_IS_DECLARED 1
-# define YYSTYPE_IS_TRIVIAL 1
-#endif
-
-extern YYSTYPE yylval;
-
-
-
