Index: dnsmasq-2.78/src/dnsmasq.c
===================================================================
--- dnsmasq-2.78.orig/src/dnsmasq.c	2017-10-02 21:13:51.000000000 +0800
+++ dnsmasq-2.78/src/dnsmasq.c	2018-10-29 16:14:30.322730200 +0800
@@ -14,6 +14,8 @@
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
 
+
+
 /* Declare static char *compiler_opts  in config.h */
 #define DNSMASQ_COMPILE_OPTS
 
@@ -32,7 +34,7 @@
 static int read_event(int fd, struct event_desc *evp, char **msg);
 static void poll_resolv(int force, int do_reload, time_t now);
 
-int main (int argc, char **argv)
+int main(int argc, char **argv)
 {
   int bind_fallback = 0;
   time_t now;
@@ -53,7 +55,7 @@
   cap_user_data_t data = NULL;
   char *bound_device = NULL;
   int did_bind = 0;
-#endif 
+#endif
 #if defined(HAVE_DHCP) || defined(HAVE_DHCP6)
   struct dhcp_context *context;
   struct dhcp_relay *relay;
@@ -64,7 +66,7 @@
 
 #ifdef LOCALEDIR
   setlocale(LC_ALL, "");
-  bindtextdomain("dnsmasq", LOCALEDIR); 
+  bindtextdomain("dnsmasq", LOCALEDIR);
   textdomain("dnsmasq");
 #endif
 
@@ -82,55 +84,53 @@
   sigact.sa_handler = SIG_IGN;
   sigaction(SIGPIPE, &sigact, NULL);
 
-  umask(022); /* known umask, create leases and pid files as 0644 */
- 
-  rand_init(); /* Must precede read_opts() */
-  
+  umask(022);                   /* known umask, create leases and pid files as 0644 */
+
+  rand_init();                  /* Must precede read_opts() */
+
   read_opts(argc, argv, compile_opts);
- 
+
   if (daemon->edns_pktsz < PACKETSZ)
     daemon->edns_pktsz = PACKETSZ;
 
   /* Min buffer size: we check after adding each record, so there must be 
      memory for the largest packet, and the largest record so the
      min for DNS is PACKETSZ+MAXDNAME+RRFIXEDSZ which is < 1000.
-     This might be increased is EDNS packet size if greater than the minimum. */ 
+     This might be increased is EDNS packet size if greater than the minimum. */
   daemon->packet_buff_sz = daemon->edns_pktsz + MAXDNAME + RRFIXEDSZ;
   daemon->packet = safe_malloc(daemon->packet_buff_sz);
-  
+
   daemon->addrbuff = safe_malloc(ADDRSTRLEN);
   if (option_bool(OPT_EXTRALOG))
     daemon->addrbuff2 = safe_malloc(ADDRSTRLEN);
-  
+
 #ifdef HAVE_DNSSEC
-  if (option_bool(OPT_DNSSEC_VALID))
-    {
-      /* Note that both /000 and '.' are allowed within labels. These get
-	 represented in presentation format using NAME_ESCAPE as an escape
-	 character when in DNSSEC mode. 
-	 In theory, if all the characters in a name were /000 or
-	 '.' or NAME_ESCAPE then all would have to be escaped, so the 
-	 presentation format would be twice as long as the spec.
-
-	 daemon->namebuff was previously allocated by the option-reading
-	 code before we knew if we're in DNSSEC mode, so reallocate here. */
-      free(daemon->namebuff);
-      daemon->namebuff = safe_malloc(MAXDNAME * 2);
-      daemon->keyname = safe_malloc(MAXDNAME * 2);
-      daemon->workspacename = safe_malloc(MAXDNAME * 2);
-    }
+  if (option_bool(OPT_DNSSEC_VALID)) {
+    /* Note that both /000 and '.' are allowed within labels. These get
+       represented in presentation format using NAME_ESCAPE as an escape
+       character when in DNSSEC mode.
+       In theory, if all the characters in a name were /000 or
+       '.' or NAME_ESCAPE then all would have to be escaped, so the
+       presentation format would be twice as long as the spec.
+
+       daemon->namebuff was previously allocated by the option-reading
+       code before we knew if we're in DNSSEC mode, so reallocate here. */
+    free(daemon->namebuff);
+    daemon->namebuff = safe_malloc(MAXDNAME * 2);
+    daemon->keyname = safe_malloc(MAXDNAME * 2);
+    daemon->workspacename = safe_malloc(MAXDNAME * 2);
+  }
 #endif
 
 #ifdef HAVE_DHCP
-  if (!daemon->lease_file)
-    {
-      if (daemon->dhcp || daemon->dhcp6)
-	daemon->lease_file = LEASEFILE;
-    }
+  if (!daemon->lease_file) {
+    if (daemon->dhcp || daemon->dhcp6)
+      daemon->lease_file = LEASEFILE;
+  }
 #endif
-  
+
   /* Close any file descriptors we inherited apart from std{in|out|err} 
-     
+
      Ensure that at least stdin, stdout and stderr (fd 0, 1, 2) exist,
      otherwise file descriptors we create can end up being 0, 1, or 2 
      and then get accidentally closed later when we make 0, 1, and 2 
@@ -141,83 +141,90 @@
     if (i != STDOUT_FILENO && i != STDERR_FILENO && i != STDIN_FILENO)
       close(i);
     else
-      open("/dev/null", O_RDWR); 
+      open("/dev/null", O_RDWR);
 
 #ifndef HAVE_LINUX_NETWORK
-#  if !(defined(IP_RECVDSTADDR) && defined(IP_RECVIF) && defined(IP_SENDSRCADDR))
-  if (!option_bool(OPT_NOWILD))
-    {
-      bind_fallback = 1;
-      set_option_bool(OPT_NOWILD);
-    }
-#  endif
-  
+#if !(defined(IP_RECVDSTADDR) && defined(IP_RECVIF) && defined(IP_SENDSRCADDR))
+  if (!option_bool(OPT_NOWILD)) {
+    bind_fallback = 1;
+    set_option_bool(OPT_NOWILD);
+  }
+#endif
+
   /* -- bind-dynamic not supported on !Linux, fall back to --bind-interfaces */
-  if (option_bool(OPT_CLEVERBIND))
-    {
-      bind_fallback = 1;
-      set_option_bool(OPT_NOWILD);
-      reset_option_bool(OPT_CLEVERBIND);
-    }
+  if (option_bool(OPT_CLEVERBIND)) {
+    bind_fallback = 1;
+    set_option_bool(OPT_NOWILD);
+    reset_option_bool(OPT_CLEVERBIND);
+  }
 #endif
 
 #ifndef HAVE_INOTIFY
   if (daemon->dynamic_dirs)
-    die(_("dhcp-hostsdir, dhcp-optsdir and hostsdir are not supported on this platform"), NULL, EC_BADCONF);
+    die(_
+        ("dhcp-hostsdir, dhcp-optsdir and hostsdir are not supported on this platform"),
+        NULL, EC_BADCONF);
 #endif
-  
-  if (option_bool(OPT_DNSSEC_VALID))
-    {
+
+  if (option_bool(OPT_DNSSEC_VALID)) {
 #ifdef HAVE_DNSSEC
-      struct ds_config *ds;
+    struct ds_config *ds;
 
-      /* Must have at least a root trust anchor, or the DNSSEC code
-	 can loop forever. */
-      for (ds = daemon->ds; ds; ds = ds->next)
-	if (ds->name[0] == 0)
-	  break;
-
-      if (!ds)
-	die(_("no root trust anchor provided for DNSSEC"), NULL, EC_BADCONF);
-      
-      if (daemon->cachesize < CACHESIZ)
-	die(_("cannot reduce cache size from default when DNSSEC enabled"), NULL, EC_BADCONF);
-#else 
-      die(_("DNSSEC not available: set HAVE_DNSSEC in src/config.h"), NULL, EC_BADCONF);
+    /* Must have at least a root trust anchor, or the DNSSEC code
+       can loop forever. */
+    for (ds = daemon->ds; ds; ds = ds->next)
+      if (ds->name[0] == 0)
+        break;
+
+    if (!ds)
+      die(_("no root trust anchor provided for DNSSEC"), NULL, EC_BADCONF);
+
+    if (daemon->cachesize < CACHESIZ)
+      die(_("cannot reduce cache size from default when DNSSEC enabled"), NULL,
+          EC_BADCONF);
+#else
+    die(_("DNSSEC not available: set HAVE_DNSSEC in src/config.h"), NULL,
+        EC_BADCONF);
 #endif
-    }
-
+  }
 #ifndef HAVE_TFTP
   if (option_bool(OPT_TFTP))
-    die(_("TFTP server not available: set HAVE_TFTP in src/config.h"), NULL, EC_BADCONF);
+    die(_("TFTP server not available: set HAVE_TFTP in src/config.h"), NULL,
+        EC_BADCONF);
 #endif
 
 #ifdef HAVE_CONNTRACK
   if (option_bool(OPT_CONNTRACK) && (daemon->query_port != 0 || daemon->osport))
-    die (_("cannot use --conntrack AND --query-port"), NULL, EC_BADCONF); 
+    die(_("cannot use --conntrack AND --query-port"), NULL, EC_BADCONF);
 #else
   if (option_bool(OPT_CONNTRACK))
-    die(_("conntrack support not available: set HAVE_CONNTRACK in src/config.h"), NULL, EC_BADCONF);
+    die(_
+        ("conntrack support not available: set HAVE_CONNTRACK in src/config.h"),
+        NULL, EC_BADCONF);
 #endif
 
 #ifdef HAVE_SOLARIS_NETWORK
   if (daemon->max_logs != 0)
-    die(_("asynchronous logging is not available under Solaris"), NULL, EC_BADCONF);
+    die(_("asynchronous logging is not available under Solaris"), NULL,
+        EC_BADCONF);
 #endif
-  
+
 #ifdef __ANDROID__
   if (daemon->max_logs != 0)
-    die(_("asynchronous logging is not available under Android"), NULL, EC_BADCONF);
+    die(_("asynchronous logging is not available under Android"), NULL,
+        EC_BADCONF);
 #endif
 
 #ifndef HAVE_AUTH
   if (daemon->authserver)
-    die(_("authoritative DNS not available: set HAVE_AUTH in src/config.h"), NULL, EC_BADCONF);
+    die(_("authoritative DNS not available: set HAVE_AUTH in src/config.h"),
+        NULL, EC_BADCONF);
 #endif
 
 #ifndef HAVE_LOOP
   if (option_bool(OPT_LOOP_DETECT))
-    die(_("loop detection not available: set HAVE_LOOP in src/config.h"), NULL, EC_BADCONF);
+    die(_("loop detection not available: set HAVE_LOOP in src/config.h"), NULL,
+        EC_BADCONF);
 #endif
 
   if (daemon->max_port != MAX_PORT && daemon->min_port == 0)
@@ -233,53 +240,51 @@
 #ifdef HAVE_BROKEN_RTC
     die(_("zone serial must be configured in --auth-soa"), NULL, EC_BADCONF);
 #else
-  daemon->soa_sn = now;
+    daemon->soa_sn = now;
 #endif
-  
+
 #ifdef HAVE_DHCP6
-  if (daemon->dhcp6)
-    {
-      daemon->doing_ra = option_bool(OPT_RA);
-      
-      for (context = daemon->dhcp6; context; context = context->next)
-	{
-	  if (context->flags & CONTEXT_DHCP)
-	    daemon->doing_dhcp6 = 1;
-	  if (context->flags & CONTEXT_RA)
-	    daemon->doing_ra = 1;
+  if (daemon->dhcp6) {
+    daemon->doing_ra = option_bool(OPT_RA);
+
+    for (context = daemon->dhcp6; context; context = context->next) {
+      if (context->flags & CONTEXT_DHCP)
+        daemon->doing_dhcp6 = 1;
+      if (context->flags & CONTEXT_RA)
+        daemon->doing_ra = 1;
 #if !defined(HAVE_LINUX_NETWORK) && !defined(HAVE_BSD_NETWORK)
-	  if (context->flags & CONTEXT_TEMPLATE)
-	    die (_("dhcp-range constructor not available on this platform"), NULL, EC_BADCONF);
-#endif 
-	}
+      if (context->flags & CONTEXT_TEMPLATE)
+        die(_("dhcp-range constructor not available on this platform"), NULL,
+            EC_BADCONF);
+#endif
     }
+  }
 #endif
-  
+
 #ifdef HAVE_DHCP
   /* Note that order matters here, we must call lease_init before
      creating any file descriptors which shouldn't be leaked
      to the lease-script init process. We need to call common_init
      before lease_init to allocate buffers it uses.
      The script subsystem relies on DHCP buffers, hence the last two
-     conditions below. */  
-  if (daemon->dhcp || daemon->doing_dhcp6 || daemon->relay4 || 
-      daemon->relay6 || option_bool(OPT_TFTP) || option_bool(OPT_SCRIPT_ARP))
-    {
-      dhcp_common_init();
-      if (daemon->dhcp || daemon->doing_dhcp6)
-	lease_init(now);
-    }
-  
+     conditions below. */
+  if (daemon->dhcp || daemon->doing_dhcp6 || daemon->relay4 ||
+      daemon->relay6 || option_bool(OPT_TFTP) || option_bool(OPT_SCRIPT_ARP)) {
+    dhcp_common_init();
+    if (daemon->dhcp || daemon->doing_dhcp6)
+      lease_init(now);
+  }
+
   if (daemon->dhcp || daemon->relay4)
     dhcp_init();
-  
-#  ifdef HAVE_DHCP6
+
+#ifdef HAVE_DHCP6
   if (daemon->doing_ra || daemon->doing_dhcp6 || daemon->relay6)
     ra_init(now);
-  
+
   if (daemon->doing_dhcp6 || daemon->relay6)
     dhcp6_init();
-#  endif
+#endif
 
 #endif
 
@@ -296,49 +301,43 @@
 
   if (option_bool(OPT_NOWILD) && option_bool(OPT_CLEVERBIND))
     die(_("cannot set --bind-interfaces and --bind-dynamic"), NULL, EC_BADCONF);
-  
+
   if (!enumerate_interfaces(1) || !enumerate_interfaces(0))
     die(_("failed to find list of interfaces: %s"), NULL, EC_MISC);
-  
-  if (option_bool(OPT_NOWILD) || option_bool(OPT_CLEVERBIND)) 
-    {
-      create_bound_listeners(1);
-      
-      if (!option_bool(OPT_CLEVERBIND))
-	for (if_tmp = daemon->if_names; if_tmp; if_tmp = if_tmp->next)
-	  if (if_tmp->name && !if_tmp->used)
-	    die(_("unknown interface %s"), if_tmp->name, EC_BADNET);
+
+  if (option_bool(OPT_NOWILD) || option_bool(OPT_CLEVERBIND)) {
+    create_bound_listeners(1);
+
+    if (!option_bool(OPT_CLEVERBIND))
+      for (if_tmp = daemon->if_names; if_tmp; if_tmp = if_tmp->next)
+        if (if_tmp->name && !if_tmp->used)
+          die(_("unknown interface %s"), if_tmp->name, EC_BADNET);
 
 #if defined(HAVE_LINUX_NETWORK) && defined(HAVE_DHCP)
-      /* after enumerate_interfaces()  */
-      bound_device = whichdevice();
-      
-      if (daemon->dhcp)
-	{
-	  if (!daemon->relay4 && bound_device)
-	    {
-	      bindtodevice(bound_device, daemon->dhcpfd);
-	      did_bind = 1;
-	    }
-	  if (daemon->enable_pxe && bound_device)
-	    {
-	      bindtodevice(bound_device, daemon->pxefd);
-	      did_bind = 1;
-	    }
-	}
+    /* after enumerate_interfaces()  */
+    bound_device = whichdevice();
+
+    if (daemon->dhcp) {
+      if (!daemon->relay4 && bound_device) {
+        bindtodevice(bound_device, daemon->dhcpfd);
+        did_bind = 1;
+      }
+      if (daemon->enable_pxe && bound_device) {
+        bindtodevice(bound_device, daemon->pxefd);
+        did_bind = 1;
+      }
+    }
 #endif
 
 #if defined(HAVE_LINUX_NETWORK) && defined(HAVE_DHCP6)
-      if (daemon->doing_dhcp6 && !daemon->relay6 && bound_device)
-	{
-	  bindtodevice(bound_device, daemon->dhcp6fd);
-	  did_bind = 1;
-	}
-#endif
+    if (daemon->doing_dhcp6 && !daemon->relay6 && bound_device) {
+      bindtodevice(bound_device, daemon->dhcp6fd);
+      did_bind = 1;
     }
-  else 
+#endif
+  } else
     create_wildcard_listeners();
- 
+
 #ifdef HAVE_DHCP6
   /* after enumerate_interfaces() */
   if (daemon->doing_dhcp6 || daemon->relay6 || daemon->doing_ra)
@@ -347,34 +346,33 @@
   /* After netlink_init() and before create_helper() */
   lease_make_duid(now);
 #endif
-  
-  if (daemon->port != 0)
-    {
-      cache_init();
+
+  if (daemon->port != 0) {
+    cache_init();
 
 #ifdef HAVE_DNSSEC
-      blockdata_init();
+    blockdata_init();
 #endif
-    }
-
+  }
 #ifdef HAVE_INOTIFY
   if (daemon->port != 0 || daemon->dhcp || daemon->doing_dhcp6)
     inotify_dnsmasq_init();
   else
     daemon->inotifyfd = -1;
 #endif
-       
+
   if (option_bool(OPT_DBUS))
 #ifdef HAVE_DBUS
-    {
-      char *err;
-      daemon->dbus = NULL;
-      daemon->watches = NULL;
-      if ((err = dbus_init()))
-	die(_("DBus error: %s"), err, EC_MISC);
-    }
+  {
+    char *err;
+    daemon->dbus = NULL;
+    daemon->watches = NULL;
+    if ((err = dbus_init()))
+      die(_("DBus error: %s"), err, EC_MISC);
+  }
 #else
-  die(_("DBus not available: set HAVE_DBUS in src/config.h"), NULL, EC_BADCONF);
+    die(_("DBus not available: set HAVE_DBUS in src/config.h"), NULL,
+        EC_BADCONF);
 #endif
 
   if (daemon->port != 0)
@@ -382,20 +380,17 @@
 
 #if defined(HAVE_SCRIPT)
   /* Note getpwnam returns static storage */
-  if ((daemon->dhcp || daemon->dhcp6) && 
-      daemon->scriptuser && 
-      (daemon->lease_change_command || daemon->luascript))
-    {
-      if ((ent_pw = getpwnam(daemon->scriptuser)))
-	{
-	  script_uid = ent_pw->pw_uid;
-	  script_gid = ent_pw->pw_gid;
-	 }
-      else
-	baduser = daemon->scriptuser;
-    }
+  if ((daemon->dhcp || daemon->dhcp6) &&
+      daemon->scriptuser &&
+      (daemon->lease_change_command || daemon->luascript)) {
+    if ((ent_pw = getpwnam(daemon->scriptuser))) {
+      script_uid = ent_pw->pw_uid;
+      script_gid = ent_pw->pw_gid;
+    } else
+      baduser = daemon->scriptuser;
+  }
 #endif
-  
+
   if (daemon->username && !(ent_pw = getpwnam(daemon->username)))
     baduser = daemon->username;
   else if (daemon->groupname && !(gp = getgrnam(daemon->groupname)))
@@ -405,369 +400,343 @@
     die(_("unknown user or group: %s"), baduser, EC_BADCONF);
 
   /* implement group defaults, "dip" if available, or group associated with uid */
-  if (!daemon->group_set && !gp)
-    {
-      if (!(gp = getgrnam(CHGRP)) && ent_pw)
-	gp = getgrgid(ent_pw->pw_gid);
-      
-      /* for error message */
-      if (gp)
-	daemon->groupname = gp->gr_name; 
-    }
-
+  if (!daemon->group_set && !gp) {
+    if (!(gp = getgrnam(CHGRP)) && ent_pw)
+      gp = getgrgid(ent_pw->pw_gid);
+
+    /* for error message */
+    if (gp)
+      daemon->groupname = gp->gr_name;
+  }
 #if defined(HAVE_LINUX_NETWORK)
   /* determine capability API version here, while we can still
      call safe_malloc */
-  if (ent_pw && ent_pw->pw_uid != 0)
-    {
-      int capsize = 1; /* for header version 1 */
-      hdr = safe_malloc(sizeof(*hdr));
-
-      /* find version supported by kernel */
-      memset(hdr, 0, sizeof(*hdr));
-      capget(hdr, NULL);
-      
-      if (hdr->version != LINUX_CAPABILITY_VERSION_1)
-	{
-	  /* if unknown version, use largest supported version (3) */
-	  if (hdr->version != LINUX_CAPABILITY_VERSION_2)
-	    hdr->version = LINUX_CAPABILITY_VERSION_3;
-	  capsize = 2;
-	}
-      
-      data = safe_malloc(sizeof(*data) * capsize);
-      memset(data, 0, sizeof(*data) * capsize);
-    }
+  if (ent_pw && ent_pw->pw_uid != 0) {
+    int capsize = 1;            /* for header version 1 */
+    hdr = safe_malloc(sizeof(*hdr));
+
+    /* find version supported by kernel */
+    memset(hdr, 0, sizeof(*hdr));
+    capget(hdr, NULL);
+
+    if (hdr->version != LINUX_CAPABILITY_VERSION_1) {
+      /* if unknown version, use largest supported version (3) */
+      if (hdr->version != LINUX_CAPABILITY_VERSION_2)
+        hdr->version = LINUX_CAPABILITY_VERSION_3;
+      capsize = 2;
+    }
+
+    data = safe_malloc(sizeof(*data) * capsize);
+    memset(data, 0, sizeof(*data) * capsize);
+  }
 #endif
 
   /* Use a pipe to carry signals and other events back to the event loop 
      in a race-free manner and another to carry errors to daemon-invoking process */
   safe_pipe(pipefd, 1);
-  
+
   piperead = pipefd[0];
   pipewrite = pipefd[1];
   /* prime the pipe to load stuff first time. */
-  send_event(pipewrite, EVENT_INIT, 0, NULL); 
+  send_event(pipewrite, EVENT_INIT, 0, NULL);
 
   err_pipe[1] = -1;
-  
-  if (!option_bool(OPT_DEBUG))   
-    {
-      /* The following code "daemonizes" the process. 
-	 See Stevens section 12.4 */
-      
-      if (chdir("/") != 0)
-	die(_("cannot chdir to filesystem root: %s"), NULL, EC_MISC); 
-
-#ifndef NO_FORK      
-      if (!option_bool(OPT_NO_FORK))
-	{
-	  pid_t pid;
-	  
-	  /* pipe to carry errors back to original process.
-	     When startup is complete we close this and the process terminates. */
-	  safe_pipe(err_pipe, 0);
-	  
-	  if ((pid = fork()) == -1)
-	    /* fd == -1 since we've not forked, never returns. */
-	    send_event(-1, EVENT_FORK_ERR, errno, NULL);
-	   
-	  if (pid != 0)
-	    {
-	      struct event_desc ev;
-	      char *msg;
-
-	      /* close our copy of write-end */
-	      while (retry_send(close(err_pipe[1])));
-	      
-	      /* check for errors after the fork */
-	      if (read_event(err_pipe[0], &ev, &msg))
-		fatal_event(&ev, msg);
-	      
-	      _exit(EC_GOOD);
-	    } 
-	  
-	  while (retry_send(close(err_pipe[0])));
-
-	  /* NO calls to die() from here on. */
-	  
-	  setsid();
-	 
-	  if ((pid = fork()) == -1)
-	    send_event(err_pipe[1], EVENT_FORK_ERR, errno, NULL);
-	 
-	  if (pid != 0)
-	    _exit(0);
-	}
+
+  if (!option_bool(OPT_DEBUG)) {
+    /* The following code "daemonizes" the process.
+       See Stevens section 12.4 */
+
+    if (chdir("/") != 0)
+      die(_("cannot chdir to filesystem root: %s"), NULL, EC_MISC);
+
+#ifndef NO_FORK
+    if (!option_bool(OPT_NO_FORK)) {
+      pid_t pid;
+
+      /* pipe to carry errors back to original process.
+         When startup is complete we close this and the process terminates. */
+      safe_pipe(err_pipe, 0);
+
+      if ((pid = fork()) == -1)
+        /* fd == -1 since we've not forked, never returns. */
+        send_event(-1, EVENT_FORK_ERR, errno, NULL);
+
+      if (pid != 0) {
+        struct event_desc ev;
+        char *msg;
+
+        /* close our copy of write-end */
+        while (retry_send(close(err_pipe[1])));
+
+        /* check for errors after the fork */
+        if (read_event(err_pipe[0], &ev, &msg))
+          fatal_event(&ev, msg);
+
+        _exit(EC_GOOD);
+      }
+
+      while (retry_send(close(err_pipe[0])));
+
+      /* NO calls to die() from here on. */
+
+      setsid();
+
+      if ((pid = fork()) == -1)
+        send_event(err_pipe[1], EVENT_FORK_ERR, errno, NULL);
+
+      if (pid != 0)
+        _exit(0);
+    }
 #endif
-            
-      /* write pidfile _after_ forking ! */
-      if (daemon->runfile)
-	{
-	  int fd, err = 0;
 
-	  sprintf(daemon->namebuff, "%d\n", (int) getpid());
+    /* write pidfile _after_ forking ! */
+    if (daemon->runfile) {
+      int fd, err = 0;
+
+      sprintf(daemon->namebuff, "%d\n", (int) getpid());
+
+      /* Explanation: Some installations of dnsmasq (eg Debian/Ubuntu) locate the pid-file
+         in a directory which is writable by the non-privileged user that dnsmasq runs as. This
+         allows the daemon to delete the file as part of its shutdown. This is a security hole to the
+         extent that an attacker running as the unprivileged  user could replace the pidfile with a
+         symlink, and have the target of that symlink overwritten as root next time dnsmasq starts.
+
+         The following code first deletes any existing file, and then opens it with the O_EXCL flag,
+         ensuring that the open() fails should there be any existing file (because the unlink() failed,
+         or an attacker exploited the race between unlink() and open()). This ensures that no symlink
+         attack can succeed.
+
+         Any compromise of the non-privileged user still theoretically allows the pid-file to be
+         replaced whilst dnsmasq is running. The worst that could allow is that the usual
+         "shutdown dnsmasq" shell command could be tricked into stopping any other process.
+
+         Note that if dnsmasq is started as non-root (eg for testing) it silently ignores
+         failure to write the pid-file.
+       */
+
+      unlink(daemon->runfile);
+
+      if ((fd =
+           open(daemon->runfile, O_WRONLY | O_CREAT | O_TRUNC | O_EXCL,
+                S_IWUSR | S_IRUSR | S_IRGRP | S_IROTH)) == -1) {
+        /* only complain if started as root */
+        if (getuid() == 0)
+          err = 1;
+      } else {
+        if (!read_write
+            (fd, (unsigned char *) daemon->namebuff, strlen(daemon->namebuff),
+             0))
+          err = 1;
+        else {
+          while (retry_send(close(fd)));
+          if (errno != 0)
+            err = 1;
+        }
+      }
+
+      if (err) {
+        send_event(err_pipe[1], EVENT_PIDFILE, errno, daemon->runfile);
+        _exit(0);
+      }
+    }
+  }
+
+  log_err = log_start(ent_pw, err_pipe[1]);
+
+  if (!option_bool(OPT_DEBUG)) {
+    /* open  stdout etc to /dev/null */
+    int nullfd = open("/dev/null", O_RDWR);
+    if (nullfd != -1) {
+      dup2(nullfd, STDOUT_FILENO);
+      dup2(nullfd, STDERR_FILENO);
+      dup2(nullfd, STDIN_FILENO);
+      close(nullfd);
+    }
+  }
 
-	  /* Explanation: Some installations of dnsmasq (eg Debian/Ubuntu) locate the pid-file
-	     in a directory which is writable by the non-privileged user that dnsmasq runs as. This
-	     allows the daemon to delete the file as part of its shutdown. This is a security hole to the 
-	     extent that an attacker running as the unprivileged  user could replace the pidfile with a 
-	     symlink, and have the target of that symlink overwritten as root next time dnsmasq starts. 
-
-	     The following code first deletes any existing file, and then opens it with the O_EXCL flag,
-	     ensuring that the open() fails should there be any existing file (because the unlink() failed, 
-	     or an attacker exploited the race between unlink() and open()). This ensures that no symlink
-	     attack can succeed. 
-
-	     Any compromise of the non-privileged user still theoretically allows the pid-file to be
-	     replaced whilst dnsmasq is running. The worst that could allow is that the usual 
-	     "shutdown dnsmasq" shell command could be tricked into stopping any other process.
-
-	     Note that if dnsmasq is started as non-root (eg for testing) it silently ignores 
-	     failure to write the pid-file.
-	  */
-
-	  unlink(daemon->runfile); 
-	  
-	  if ((fd = open(daemon->runfile, O_WRONLY|O_CREAT|O_TRUNC|O_EXCL, S_IWUSR|S_IRUSR|S_IRGRP|S_IROTH)) == -1)
-	    {
-	      /* only complain if started as root */
-	      if (getuid() == 0)
-		err = 1;
-	    }
-	  else
-	    {
-	      if (!read_write(fd, (unsigned char *)daemon->namebuff, strlen(daemon->namebuff), 0))
-		err = 1;
-	      else 
-		{
-		  while (retry_send(close(fd)));
-		  if (errno != 0)
-		    err = 1;
-		}
-	    }
-
-	  if (err)
-	    {
-	      send_event(err_pipe[1], EVENT_PIDFILE, errno, daemon->runfile);
-	      _exit(0);
-	    }
-	}
-    }
-  
-   log_err = log_start(ent_pw, err_pipe[1]);
-
-   if (!option_bool(OPT_DEBUG)) 
-     {       
-       /* open  stdout etc to /dev/null */
-       int nullfd = open("/dev/null", O_RDWR);
-       if (nullfd != -1)
-	 {
-	   dup2(nullfd, STDOUT_FILENO);
-	   dup2(nullfd, STDERR_FILENO);
-	   dup2(nullfd, STDIN_FILENO);
-	   close(nullfd);
-	 }
-     }
-   
-   /* if we are to run scripts, we need to fork a helper before dropping root. */
+  /* if we are to run scripts, we need to fork a helper before dropping root. */
   daemon->helperfd = -1;
-#ifdef HAVE_SCRIPT 
-  if ((daemon->dhcp || daemon->dhcp6 || option_bool(OPT_TFTP) || option_bool(OPT_SCRIPT_ARP)) && 
-      (daemon->lease_change_command || daemon->luascript))
-      daemon->helperfd = create_helper(pipewrite, err_pipe[1], script_uid, script_gid, max_fd);
-#endif
-
-  if (!option_bool(OPT_DEBUG) && getuid() == 0)   
-    {
-      int bad_capabilities = 0;
-      gid_t dummy;
-      
-      /* remove all supplementary groups */
-      if (gp && 
-	  (setgroups(0, &dummy) == -1 ||
-	   setgid(gp->gr_gid) == -1))
-	{
-	  send_event(err_pipe[1], EVENT_GROUP_ERR, errno, daemon->groupname);
-	  _exit(0);
-	}
-  
-      if (ent_pw && ent_pw->pw_uid != 0)
-	{     
-#if defined(HAVE_LINUX_NETWORK)	  
-	  /* On linux, we keep CAP_NETADMIN (for ARP-injection) and
-	     CAP_NET_RAW (for icmp) if we're doing dhcp. If we have yet to bind 
-	     ports because of DAD, or we're doing it dynamically,
-	     we need CAP_NET_BIND_SERVICE too. */
-	  if (is_dad_listeners() || option_bool(OPT_CLEVERBIND))
-	    data->effective = data->permitted = data->inheritable =
-	      (1 << CAP_NET_ADMIN) | (1 << CAP_NET_RAW) | 
-	      (1 << CAP_SETUID) | (1 << CAP_NET_BIND_SERVICE);
-	  else
-	    data->effective = data->permitted = data->inheritable =
-	      (1 << CAP_NET_ADMIN) | (1 << CAP_NET_RAW) | (1 << CAP_SETUID);
-	  
-	  /* Tell kernel to not clear capabilities when dropping root */
-	  if (capset(hdr, data) == -1 || prctl(PR_SET_KEEPCAPS, 1, 0, 0, 0) == -1)
-	    bad_capabilities = errno;
-			  
+#ifdef HAVE_SCRIPT
+  if ((daemon->dhcp || daemon->dhcp6 || option_bool(OPT_TFTP)
+       || option_bool(OPT_SCRIPT_ARP)) && (daemon->lease_change_command
+                                           || daemon->luascript))
+    daemon->helperfd =
+        create_helper(pipewrite, err_pipe[1], script_uid, script_gid, max_fd);
+#endif
+
+  if (!option_bool(OPT_DEBUG) && getuid() == 0) {
+    int bad_capabilities = 0;
+    gid_t dummy;
+
+    /* remove all supplementary groups */
+    if (gp && (setgroups(0, &dummy) == -1 || setgid(gp->gr_gid) == -1)) {
+      send_event(err_pipe[1], EVENT_GROUP_ERR, errno, daemon->groupname);
+      _exit(0);
+    }
+
+    if (ent_pw && ent_pw->pw_uid != 0) {
+#if defined(HAVE_LINUX_NETWORK)
+      /* On linux, we keep CAP_NETADMIN (for ARP-injection) and
+         CAP_NET_RAW (for icmp) if we're doing dhcp. If we have yet to bind
+         ports because of DAD, or we're doing it dynamically,
+         we need CAP_NET_BIND_SERVICE too. */
+      if (is_dad_listeners() || option_bool(OPT_CLEVERBIND))
+        data->effective = data->permitted = data->inheritable =
+            (1 << CAP_NET_ADMIN) | (1 << CAP_NET_RAW) |
+            (1 << CAP_SETUID) | (1 << CAP_NET_BIND_SERVICE);
+      else
+        data->effective = data->permitted = data->inheritable =
+            (1 << CAP_NET_ADMIN) | (1 << CAP_NET_RAW) | (1 << CAP_SETUID);
+
+      /* Tell kernel to not clear capabilities when dropping root */
+      if (capset(hdr, data) == -1 || prctl(PR_SET_KEEPCAPS, 1, 0, 0, 0) == -1)
+        bad_capabilities = errno;
+
 #elif defined(HAVE_SOLARIS_NETWORK)
-	  /* http://developers.sun.com/solaris/articles/program_privileges.html */
-	  priv_set_t *priv_set;
-	  
-	  if (!(priv_set = priv_str_to_set("basic", ",", NULL)) ||
-	      priv_addset(priv_set, PRIV_NET_ICMPACCESS) == -1 ||
-	      priv_addset(priv_set, PRIV_SYS_NET_CONFIG) == -1)
-	    bad_capabilities = errno;
-
-	  if (priv_set && bad_capabilities == 0)
-	    {
-	      priv_inverse(priv_set);
-	  
-	      if (setppriv(PRIV_OFF, PRIV_LIMIT, priv_set) == -1)
-		bad_capabilities = errno;
-	    }
-
-	  if (priv_set)
-	    priv_freeset(priv_set);
-
-#endif    
-
-	  if (bad_capabilities != 0)
-	    {
-	      send_event(err_pipe[1], EVENT_CAP_ERR, bad_capabilities, NULL);
-	      _exit(0);
-	    }
-	  
-	  /* finally drop root */
-	  if (setuid(ent_pw->pw_uid) == -1)
-	    {
-	      send_event(err_pipe[1], EVENT_USER_ERR, errno, daemon->username);
-	      _exit(0);
-	    }     
+      /* http://developers.sun.com/solaris/articles/program_privileges.html */
+      priv_set_t *priv_set;
+
+      if (!(priv_set = priv_str_to_set("basic", ",", NULL)) ||
+          priv_addset(priv_set, PRIV_NET_ICMPACCESS) == -1 ||
+          priv_addset(priv_set, PRIV_SYS_NET_CONFIG) == -1)
+        bad_capabilities = errno;
+
+      if (priv_set && bad_capabilities == 0) {
+        priv_inverse(priv_set);
+
+        if (setppriv(PRIV_OFF, PRIV_LIMIT, priv_set) == -1)
+          bad_capabilities = errno;
+      }
+
+      if (priv_set)
+        priv_freeset(priv_set);
 
+#endif
+
+      if (bad_capabilities != 0) {
+        send_event(err_pipe[1], EVENT_CAP_ERR, bad_capabilities, NULL);
+        _exit(0);
+      }
+
+      /* finally drop root */
+      if (setuid(ent_pw->pw_uid) == -1) {
+        send_event(err_pipe[1], EVENT_USER_ERR, errno, daemon->username);
+        _exit(0);
+      }
 #ifdef HAVE_LINUX_NETWORK
-	  if (is_dad_listeners() || option_bool(OPT_CLEVERBIND))
-	   data->effective = data->permitted =
-	     (1 << CAP_NET_ADMIN) | (1 << CAP_NET_RAW) | (1 << CAP_NET_BIND_SERVICE);
-	 else
-	   data->effective = data->permitted = 
-	     (1 << CAP_NET_ADMIN) | (1 << CAP_NET_RAW);
-	  data->inheritable = 0;
-	  
-	  /* lose the setuid and setgid capabilities */
-	  if (capset(hdr, data) == -1)
-	    {
-	      send_event(err_pipe[1], EVENT_CAP_ERR, errno, NULL);
-	      _exit(0);
-	    }
+      if (is_dad_listeners() || option_bool(OPT_CLEVERBIND))
+        data->effective = data->permitted =
+            (1 << CAP_NET_ADMIN) | (1 << CAP_NET_RAW) | (1 <<
+                                                         CAP_NET_BIND_SERVICE);
+      else
+        data->effective = data->permitted =
+            (1 << CAP_NET_ADMIN) | (1 << CAP_NET_RAW);
+      data->inheritable = 0;
+
+      /* lose the setuid and setgid capabilities */
+      if (capset(hdr, data) == -1) {
+        send_event(err_pipe[1], EVENT_CAP_ERR, errno, NULL);
+        _exit(0);
+      }
 #endif
-	  
-	}
+
     }
-  
+  }
 #ifdef HAVE_LINUX_NETWORK
   free(hdr);
   free(data);
-  if (option_bool(OPT_DEBUG)) 
+  if (option_bool(OPT_DEBUG))
     prctl(PR_SET_DUMPABLE, 1, 0, 0, 0);
 #endif
 
 #ifdef HAVE_TFTP
-  if (option_bool(OPT_TFTP))
-    {
-      DIR *dir;
-      struct tftp_prefix *p;
-      
-      if (daemon->tftp_prefix)
-	{
-	  if (!((dir = opendir(daemon->tftp_prefix))))
-	    {
-	      tftp_prefix_missing = 1;
-	      if (!option_bool(OPT_TFTP_NO_FAIL))
-	        {
-	          send_event(err_pipe[1], EVENT_TFTP_ERR, errno, daemon->tftp_prefix);
-	          _exit(0);
-	        }
-	    }
-	  else
-	    closedir(dir);
-	}
-
-      for (p = daemon->if_prefix; p; p = p->next)
-	{
-	  p->missing = 0;
-	  if (!((dir = opendir(p->prefix))))
-	    {
-	      p->missing = 1;
-	      if (!option_bool(OPT_TFTP_NO_FAIL))
-		{
-		  send_event(err_pipe[1], EVENT_TFTP_ERR, errno, p->prefix);
-		  _exit(0);
-		}
-	    }
-	  else
-	    closedir(dir);
-	}
+  if (option_bool(OPT_TFTP)) {
+    DIR *dir;
+    struct tftp_prefix *p;
+
+    if (daemon->tftp_prefix) {
+      if (!((dir = opendir(daemon->tftp_prefix)))) {
+        tftp_prefix_missing = 1;
+        if (!option_bool(OPT_TFTP_NO_FAIL)) {
+          send_event(err_pipe[1], EVENT_TFTP_ERR, errno, daemon->tftp_prefix);
+          _exit(0);
+        }
+      } else
+        closedir(dir);
+    }
+
+    for (p = daemon->if_prefix; p; p = p->next) {
+      p->missing = 0;
+      if (!((dir = opendir(p->prefix)))) {
+        p->missing = 1;
+        if (!option_bool(OPT_TFTP_NO_FAIL)) {
+          send_event(err_pipe[1], EVENT_TFTP_ERR, errno, p->prefix);
+          _exit(0);
+        }
+      } else
+        closedir(dir);
     }
+  }
 #endif
 
   if (daemon->port == 0)
     my_syslog(LOG_INFO, _("started, version %s DNS disabled"), VERSION);
-  else 
-    {
-      if (daemon->cachesize != 0)
-	my_syslog(LOG_INFO, _("started, version %s cachesize %d"), VERSION, daemon->cachesize);
-      else
-	my_syslog(LOG_INFO, _("started, version %s cache disabled"), VERSION);
+  else {
+    if (daemon->cachesize != 0)
+      my_syslog(LOG_INFO, _("started, version %s cachesize %d"), VERSION,
+                daemon->cachesize);
+    else
+      my_syslog(LOG_INFO, _("started, version %s cache disabled"), VERSION);
+
+    if (option_bool(OPT_LOCAL_SERVICE))
+      my_syslog(LOG_INFO, _("DNS service limited to local subnets"));
+  }
 
-      if (option_bool(OPT_LOCAL_SERVICE))
-	my_syslog(LOG_INFO, _("DNS service limited to local subnets"));
-    }
-  
   my_syslog(LOG_INFO, _("compile time options: %s"), compile_opts);
-  
+
 #ifdef HAVE_DBUS
-  if (option_bool(OPT_DBUS))
-    {
-      if (daemon->dbus)
-	my_syslog(LOG_INFO, _("DBus support enabled: connected to system bus"));
-      else
-	my_syslog(LOG_INFO, _("DBus support enabled: bus connection pending"));
-    }
+  if (option_bool(OPT_DBUS)) {
+    if (daemon->dbus)
+      my_syslog(LOG_INFO, _("DBus support enabled: connected to system bus"));
+    else
+      my_syslog(LOG_INFO, _("DBus support enabled: bus connection pending"));
+  }
 #endif
 
 #ifdef HAVE_DNSSEC
-  if (option_bool(OPT_DNSSEC_VALID))
-    {
-      int rc;
-
-      /* Delay creating the timestamp file until here, after we've changed user, so that
-	 it has the correct owner to allow updating the mtime later. 
-	 This means we have to report fatal errors via the pipe. */
-      if ((rc = setup_timestamp()) == -1)
-	{
-	  send_event(err_pipe[1], EVENT_TIME_ERR, errno, daemon->timestamp_file);
-	  _exit(0);
-	}
-      
-      my_syslog(LOG_INFO, _("DNSSEC validation enabled"));
-      
-      daemon->dnssec_no_time_check = option_bool(OPT_DNSSEC_TIME);
-      if (option_bool(OPT_DNSSEC_TIME) && !daemon->back_to_the_future)
-	my_syslog(LOG_INFO, _("DNSSEC signature timestamps not checked until first cache reload"));
-      
-      if (rc == 1)
-	my_syslog(LOG_INFO, _("DNSSEC signature timestamps not checked until system time valid"));
-    }
+  if (option_bool(OPT_DNSSEC_VALID)) {
+    int rc;
+
+    /* Delay creating the timestamp file until here, after we've changed user, so that
+       it has the correct owner to allow updating the mtime later.
+       This means we have to report fatal errors via the pipe. */
+    if ((rc = setup_timestamp()) == -1) {
+      send_event(err_pipe[1], EVENT_TIME_ERR, errno, daemon->timestamp_file);
+      _exit(0);
+    }
+
+    my_syslog(LOG_INFO, _("DNSSEC validation enabled"));
+
+    daemon->dnssec_no_time_check = option_bool(OPT_DNSSEC_TIME);
+    if (option_bool(OPT_DNSSEC_TIME) && !daemon->back_to_the_future)
+      my_syslog(LOG_INFO,
+                _
+                ("DNSSEC signature timestamps not checked until first cache reload"));
+
+    if (rc == 1)
+      my_syslog(LOG_INFO,
+                _
+                ("DNSSEC signature timestamps not checked until system time valid"));
+  }
 #endif
 
   if (log_err != 0)
-    my_syslog(LOG_WARNING, _("warning: failed to change owner of %s: %s"), 
-	      daemon->log_file, strerror(log_err));
-  
+    my_syslog(LOG_WARNING, _("warning: failed to change owner of %s: %s"),
+              daemon->log_file, strerror(log_err));
+
   if (bind_fallback)
-    my_syslog(LOG_WARNING, _("setting --bind-interfaces option because of OS limitations"));
+    my_syslog(LOG_WARNING,
+              _("setting --bind-interfaces option because of OS limitations"));
 
   if (option_bool(OPT_NOWILD))
     warn_bound_listeners();
@@ -775,24 +744,29 @@
     warn_wild_labels();
 
   warn_int_names();
-  
-  if (!option_bool(OPT_NOWILD)) 
+
+  if (!option_bool(OPT_NOWILD))
     for (if_tmp = daemon->if_names; if_tmp; if_tmp = if_tmp->next)
       if (if_tmp->name && !if_tmp->used)
-	my_syslog(LOG_WARNING, _("warning: interface %s does not currently exist"), if_tmp->name);
-   
-  if (daemon->port != 0 && option_bool(OPT_NO_RESOLV))
-    {
-      if (daemon->resolv_files && !daemon->resolv_files->is_default)
-	my_syslog(LOG_WARNING, _("warning: ignoring resolv-file flag because no-resolv is set"));
-      daemon->resolv_files = NULL;
-      if (!daemon->servers)
-	my_syslog(LOG_WARNING, _("warning: no upstream servers configured"));
-    } 
+        my_syslog(LOG_WARNING,
+                  _("warning: interface %s does not currently exist"),
+                  if_tmp->name);
+
+  if (daemon->port != 0 && option_bool(OPT_NO_RESOLV)) {
+    if (daemon->resolv_files && !daemon->resolv_files->is_default)
+      my_syslog(LOG_WARNING,
+                _
+                ("warning: ignoring resolv-file flag because no-resolv is set"));
+    daemon->resolv_files = NULL;
+    if (!daemon->servers)
+      my_syslog(LOG_WARNING, _("warning: no upstream servers configured"));
+  }
 
   if (daemon->max_logs != 0)
-    my_syslog(LOG_INFO, _("asynchronous logging enabled, queue limit is %d messages"), daemon->max_logs);
-  
+    my_syslog(LOG_INFO,
+              _("asynchronous logging enabled, queue limit is %d messages"),
+              daemon->max_logs);
+
 
 #ifdef HAVE_DHCP
   for (context = daemon->dhcp; context; context = context->next)
@@ -801,24 +775,26 @@
   for (relay = daemon->relay4; relay; relay = relay->next)
     log_relay(AF_INET, relay);
 
-#  ifdef HAVE_DHCP6
+#ifdef HAVE_DHCP6
   for (context = daemon->dhcp6; context; context = context->next)
     log_context(AF_INET6, context);
 
   for (relay = daemon->relay6; relay; relay = relay->next)
     log_relay(AF_INET6, relay);
-  
+
   if (daemon->doing_dhcp6 || daemon->doing_ra)
     dhcp_construct_contexts(now);
-  
+
   if (option_bool(OPT_RA))
     my_syslog(MS_DHCP | LOG_INFO, _("IPv6 router advertisement enabled"));
-#  endif
+#endif
 
-#  ifdef HAVE_LINUX_NETWORK
+#ifdef HAVE_LINUX_NETWORK
   if (did_bind)
-    my_syslog(MS_DHCP | LOG_INFO, _("DHCP, sockets bound exclusively to interface %s"), bound_device);
-#  endif
+    my_syslog(MS_DHCP | LOG_INFO,
+              _("DHCP, sockets bound exclusively to interface %s"),
+              bound_device);
+#endif
 
   /* after dhcp_construct_contexts */
   if (daemon->dhcp || daemon->doing_dhcp6)
@@ -826,304 +802,290 @@
 #endif
 
 #ifdef HAVE_TFTP
-  if (option_bool(OPT_TFTP))
-    {
-      struct tftp_prefix *p;
+  if (option_bool(OPT_TFTP)) {
+    struct tftp_prefix *p;
 
-      my_syslog(MS_TFTP | LOG_INFO, "TFTP %s%s %s", 
-		daemon->tftp_prefix ? _("root is ") : _("enabled"),
-		daemon->tftp_prefix ? daemon->tftp_prefix: "",
-		option_bool(OPT_TFTP_SECURE) ? _("secure mode") : "");
-
-      if (tftp_prefix_missing)
-	my_syslog(MS_TFTP | LOG_WARNING, _("warning: %s inaccessible"), daemon->tftp_prefix);
-
-      for (p = daemon->if_prefix; p; p = p->next)
-	if (p->missing)
-	   my_syslog(MS_TFTP | LOG_WARNING, _("warning: TFTP directory %s inaccessible"), p->prefix);
-
-      /* This is a guess, it assumes that for small limits, 
-	 disjoint files might be served, but for large limits, 
-	 a single file will be sent to may clients (the file only needs
-	 one fd). */
-
-      max_fd -= 30; /* use other than TFTP */
-      
-      if (max_fd < 0)
-	max_fd = 5;
-      else if (max_fd < 100)
-	max_fd = max_fd/2;
-      else
-	max_fd = max_fd - 20;
-      
-      /* if we have to use a limited range of ports, 
-	 that will limit the number of transfers */
-      if (daemon->start_tftp_port != 0 &&
-	  daemon->end_tftp_port - daemon->start_tftp_port + 1 < max_fd)
-	max_fd = daemon->end_tftp_port - daemon->start_tftp_port + 1;
-
-      if (daemon->tftp_max > max_fd)
-	{
-	  daemon->tftp_max = max_fd;
-	  my_syslog(MS_TFTP | LOG_WARNING, 
-		    _("restricting maximum simultaneous TFTP transfers to %d"), 
-		    daemon->tftp_max);
-	}
+    my_syslog(MS_TFTP | LOG_INFO, "TFTP %s%s %s",
+              daemon->tftp_prefix ? _("root is ") : _("enabled"),
+              daemon->tftp_prefix ? daemon->tftp_prefix : "",
+              option_bool(OPT_TFTP_SECURE) ? _("secure mode") : "");
+
+    if (tftp_prefix_missing)
+      my_syslog(MS_TFTP | LOG_WARNING, _("warning: %s inaccessible"),
+                daemon->tftp_prefix);
+
+    for (p = daemon->if_prefix; p; p = p->next)
+      if (p->missing)
+        my_syslog(MS_TFTP | LOG_WARNING,
+                  _("warning: TFTP directory %s inaccessible"), p->prefix);
+
+    /* This is a guess, it assumes that for small limits,
+       disjoint files might be served, but for large limits,
+       a single file will be sent to may clients (the file only needs
+       one fd). */
+
+    max_fd -= 30;               /* use other than TFTP */
+
+    if (max_fd < 0)
+      max_fd = 5;
+    else if (max_fd < 100)
+      max_fd = max_fd / 2;
+    else
+      max_fd = max_fd - 20;
+
+    /* if we have to use a limited range of ports,
+       that will limit the number of transfers */
+    if (daemon->start_tftp_port != 0 &&
+        daemon->end_tftp_port - daemon->start_tftp_port + 1 < max_fd)
+      max_fd = daemon->end_tftp_port - daemon->start_tftp_port + 1;
+
+    if (daemon->tftp_max > max_fd) {
+      daemon->tftp_max = max_fd;
+      my_syslog(MS_TFTP | LOG_WARNING,
+                _("restricting maximum simultaneous TFTP transfers to %d"),
+                daemon->tftp_max);
     }
+  }
 #endif
 
   /* finished start-up - release original process */
   if (err_pipe[1] != -1)
     while (retry_send(close(err_pipe[1])));
-  
+
   if (daemon->port != 0)
     check_servers();
-  
+
   pid = getpid();
-  
+
 #ifdef HAVE_INOTIFY
   /* Using inotify, have to select a resolv file at startup */
   poll_resolv(1, 0, now);
 #endif
-  
-  while (1)
-    {
-      int t, timeout = -1;
-      
-      poll_reset();
-      
-      /* if we are out of resources, find how long we have to wait
-	 for some to come free, we'll loop around then and restart
-	 listening for queries */
-      if ((t = set_dns_listeners(now)) != 0)
-	timeout = t * 1000;
-
-      /* Whilst polling for the dbus, or doing a tftp transfer, wake every quarter second */
-      if (daemon->tftp_trans ||
-	  (option_bool(OPT_DBUS) && !daemon->dbus))
-	timeout = 250;
-
-      /* Wake every second whilst waiting for DAD to complete */
-      else if (is_dad_listeners())
-	timeout = 1000;
+
+  while (1) {
+    int t, timeout = -1;
+
+    poll_reset();
+
+    /* if we are out of resources, find how long we have to wait
+       for some to come free, we'll loop around then and restart
+       listening for queries */
+    if ((t = set_dns_listeners(now)) != 0)
+      timeout = t * 1000;
+
+    /* Whilst polling for the dbus, or doing a tftp transfer, wake every quarter second */
+    if (daemon->tftp_trans || (option_bool(OPT_DBUS) && !daemon->dbus))
+      timeout = 250;
+
+    /* Wake every second whilst waiting for DAD to complete */
+    else if (is_dad_listeners())
+      timeout = 1000;
 
 #ifdef HAVE_DBUS
-      set_dbus_listeners();
-#endif	
-  
+    set_dbus_listeners();
+#endif
+
 #ifdef HAVE_DHCP
-      if (daemon->dhcp || daemon->relay4)
-	{
-	  poll_listen(daemon->dhcpfd, POLLIN);
-	  if (daemon->pxefd != -1)
-	    poll_listen(daemon->pxefd, POLLIN);
-	}
+    if (daemon->dhcp || daemon->relay4) {
+      poll_listen(daemon->dhcpfd, POLLIN);
+      if (daemon->pxefd != -1)
+        poll_listen(daemon->pxefd, POLLIN);
+    }
 #endif
 
 #ifdef HAVE_DHCP6
-      if (daemon->doing_dhcp6 || daemon->relay6)
-	poll_listen(daemon->dhcp6fd, POLLIN);
-	
-      if (daemon->doing_ra)
-	poll_listen(daemon->icmp6fd, POLLIN); 
+    if (daemon->doing_dhcp6 || daemon->relay6)
+      poll_listen(daemon->dhcp6fd, POLLIN);
+
+    if (daemon->doing_ra)
+      poll_listen(daemon->icmp6fd, POLLIN);
 #endif
-    
+
 #ifdef HAVE_INOTIFY
-      if (daemon->inotifyfd != -1)
-	poll_listen(daemon->inotifyfd, POLLIN);
+    if (daemon->inotifyfd != -1)
+      poll_listen(daemon->inotifyfd, POLLIN);
 #endif
 
 #if defined(HAVE_LINUX_NETWORK)
-      poll_listen(daemon->netlinkfd, POLLIN);
+    poll_listen(daemon->netlinkfd, POLLIN);
 #elif defined(HAVE_BSD_NETWORK)
-      poll_listen(daemon->routefd, POLLIN);
+    poll_listen(daemon->routefd, POLLIN);
 #endif
-      
-      poll_listen(piperead, POLLIN);
+
+    poll_listen(piperead, POLLIN);
 
 #ifdef HAVE_SCRIPT
-#    ifdef HAVE_DHCP
-      while (helper_buf_empty() && do_script_run(now)); 
-#    endif
-
-      /* Refresh cache */
-      if (option_bool(OPT_SCRIPT_ARP))
-	find_mac(NULL, NULL, 0, now);
-      while (helper_buf_empty() && do_arp_script_run());
-
-#    ifdef HAVE_TFTP
-      while (helper_buf_empty() && do_tftp_script_run());
-#    endif
+#ifdef HAVE_DHCP
+    while (helper_buf_empty() && do_script_run(now));
+#endif
+
+    /* Refresh cache */
+    if (option_bool(OPT_SCRIPT_ARP))
+      find_mac(NULL, NULL, 0, now);
+    while (helper_buf_empty() && do_arp_script_run());
+
+#ifdef HAVE_TFTP
+    while (helper_buf_empty() && do_tftp_script_run());
+#endif
 
-      if (!helper_buf_empty())
-	poll_listen(daemon->helperfd, POLLOUT);
+    if (!helper_buf_empty())
+      poll_listen(daemon->helperfd, POLLOUT);
 #else
-      /* need this for other side-effects */
-#    ifdef HAVE_DHCP
-      while (do_script_run(now));
-#    endif
-
-      while (do_arp_script_run());
-
-#    ifdef HAVE_TFTP 
-      while (do_tftp_script_run());
-#    endif
+    /* need this for other side-effects */
+#ifdef HAVE_DHCP
+    while (do_script_run(now));
+#endif
 
+    while (do_arp_script_run());
+
+#ifdef HAVE_TFTP
+    while (do_tftp_script_run());
 #endif
 
-   
-      /* must do this just before select(), when we know no
-	 more calls to my_syslog() can occur */
-      set_log_writer();
-      
-      if (do_poll(timeout) < 0)
-	continue;
-      
-      now = dnsmasq_time();
-
-      check_log_writer(0);
-
-      /* prime. */
-      enumerate_interfaces(1);
-
-      /* Check the interfaces to see if any have exited DAD state
-	 and if so, bind the address. */
-      if (is_dad_listeners())
-	{
-	  enumerate_interfaces(0);
-	  /* NB, is_dad_listeners() == 1 --> we're binding interfaces */
-	  create_bound_listeners(0);
-	  warn_bound_listeners();
-	}
+#endif
+
+
+    /* must do this just before select(), when we know no
+       more calls to my_syslog() can occur */
+    set_log_writer();
+
+    if (do_poll(timeout) < 0)
+      continue;
 
+    now = dnsmasq_time();
+
+    check_log_writer(0);
+
+    /* prime. */
+    enumerate_interfaces(1);
+
+    /* Check the interfaces to see if any have exited DAD state
+       and if so, bind the address. */
+    if (is_dad_listeners()) {
+      enumerate_interfaces(0);
+      /* NB, is_dad_listeners() == 1 --> we're binding interfaces */
+      create_bound_listeners(0);
+      warn_bound_listeners();
+    }
 #if defined(HAVE_LINUX_NETWORK)
-      if (poll_check(daemon->netlinkfd, POLLIN))
-	netlink_multicast();
+    if (poll_check(daemon->netlinkfd, POLLIN))
+      netlink_multicast();
 #elif defined(HAVE_BSD_NETWORK)
-      if (poll_check(daemon->routefd, POLLIN))
-	route_sock();
+    if (poll_check(daemon->routefd, POLLIN))
+      route_sock();
 #endif
 
 #ifdef HAVE_INOTIFY
-      if  (daemon->inotifyfd != -1 && poll_check(daemon->inotifyfd, POLLIN) && inotify_check(now))
-	{
-	  if (daemon->port != 0 && !option_bool(OPT_NO_POLL))
-	    poll_resolv(1, 1, now);
-	} 	  
+    if (daemon->inotifyfd != -1 && poll_check(daemon->inotifyfd, POLLIN)
+        && inotify_check(now)) {
+      if (daemon->port != 0 && !option_bool(OPT_NO_POLL))
+        poll_resolv(1, 1, now);
+    }
 #else
-      /* Check for changes to resolv files once per second max. */
-      /* Don't go silent for long periods if the clock goes backwards. */
-      if (daemon->last_resolv == 0 || 
-	  difftime(now, daemon->last_resolv) > 1.0 || 
-	  difftime(now, daemon->last_resolv) < -1.0)
-	{
-	  /* poll_resolv doesn't need to reload first time through, since 
-	     that's queued anyway. */
-
-	  poll_resolv(0, daemon->last_resolv != 0, now); 	  
-	  daemon->last_resolv = now;
-	}
-#endif
-
-      if (poll_check(piperead, POLLIN))
-	async_event(piperead, now);
-      
+    /* Check for changes to resolv files once per second max. */
+    /* Don't go silent for long periods if the clock goes backwards. */
+    if (daemon->last_resolv == 0 ||
+        difftime(now, daemon->last_resolv) > 1.0 ||
+        difftime(now, daemon->last_resolv) < -1.0) {
+      /* poll_resolv doesn't need to reload first time through, since
+         that's queued anyway. */
+
+      poll_resolv(0, daemon->last_resolv != 0, now);
+      daemon->last_resolv = now;
+    }
+#endif
+
+    if (poll_check(piperead, POLLIN))
+      async_event(piperead, now);
+
 #ifdef HAVE_DBUS
-      /* if we didn't create a DBus connection, retry now. */ 
-     if (option_bool(OPT_DBUS) && !daemon->dbus)
-	{
-	  char *err;
-	  if ((err = dbus_init()))
-	    my_syslog(LOG_WARNING, _("DBus error: %s"), err);
-	  if (daemon->dbus)
-	    my_syslog(LOG_INFO, _("connected to system DBus"));
-	}
-      check_dbus_listeners();
+    /* if we didn't create a DBus connection, retry now. */
+    if (option_bool(OPT_DBUS) && !daemon->dbus) {
+      char *err;
+      if ((err = dbus_init()))
+        my_syslog(LOG_WARNING, _("DBus error: %s"), err);
+      if (daemon->dbus)
+        my_syslog(LOG_INFO, _("connected to system DBus"));
+    }
+    check_dbus_listeners();
 #endif
-      
-      check_dns_listeners(now);
+
+    check_dns_listeners(now);
 
 #ifdef HAVE_TFTP
-      check_tftp_listeners(now);
-#endif      
+    check_tftp_listeners(now);
+#endif
 
 #ifdef HAVE_DHCP
-      if (daemon->dhcp || daemon->relay4)
-	{
-	  if (poll_check(daemon->dhcpfd, POLLIN))
-	    dhcp_packet(now, 0);
-	  if (daemon->pxefd != -1 && poll_check(daemon->pxefd, POLLIN))
-	    dhcp_packet(now, 1);
-	}
-
+    if (daemon->dhcp || daemon->relay4) {
+      if (poll_check(daemon->dhcpfd, POLLIN))
+        dhcp_packet(now, 0);
+      if (daemon->pxefd != -1 && poll_check(daemon->pxefd, POLLIN))
+        dhcp_packet(now, 1);
+    }
 #ifdef HAVE_DHCP6
-      if ((daemon->doing_dhcp6 || daemon->relay6) && poll_check(daemon->dhcp6fd, POLLIN))
-	dhcp6_packet(now);
+    if ((daemon->doing_dhcp6 || daemon->relay6)
+        && poll_check(daemon->dhcp6fd, POLLIN))
+      dhcp6_packet(now);
 
-      if (daemon->doing_ra && poll_check(daemon->icmp6fd, POLLIN))
-	icmp6_packet(now);
+    if (daemon->doing_ra && poll_check(daemon->icmp6fd, POLLIN))
+      icmp6_packet(now);
 #endif
 
-#  ifdef HAVE_SCRIPT
-      if (daemon->helperfd != -1 && poll_check(daemon->helperfd, POLLOUT))
-	helper_write();
-#  endif
+#ifdef HAVE_SCRIPT
+    if (daemon->helperfd != -1 && poll_check(daemon->helperfd, POLLOUT))
+      helper_write();
+#endif
 #endif
 
-    }
+  }
 }
 
 static void sig_handler(int sig)
 {
-  if (pid == 0)
-    {
-      /* ignore anything other than TERM during startup
-	 and in helper proc. (helper ignore TERM too) */
-      if (sig == SIGTERM)
-	exit(EC_MISC);
-    }
-  else if (pid != getpid())
-    {
-      /* alarm is used to kill TCP children after a fixed time. */
-      if (sig == SIGALRM)
-	_exit(0);
-    }
-  else
-    {
-      /* master process */
-      int event, errsave = errno;
-      
-      if (sig == SIGHUP)
-	event = EVENT_RELOAD;
-      else if (sig == SIGCHLD)
-	event = EVENT_CHILD;
-      else if (sig == SIGALRM)
-	event = EVENT_ALARM;
-      else if (sig == SIGTERM)
-	event = EVENT_TERM;
-      else if (sig == SIGUSR1)
-	event = EVENT_DUMP;
-      else if (sig == SIGUSR2)
-	event = EVENT_REOPEN;
-      else
-	return;
+  if (pid == 0) {
+    /* ignore anything other than TERM during startup
+       and in helper proc. (helper ignore TERM too) */
+    if (sig == SIGTERM)
+      exit(EC_MISC);
+  } else if (pid != getpid()) {
+    /* alarm is used to kill TCP children after a fixed time. */
+    if (sig == SIGALRM)
+      _exit(0);
+  } else {
+    /* master process */
+    int event, errsave = errno;
+
+    if (sig == SIGHUP)
+      event = EVENT_RELOAD;
+    else if (sig == SIGCHLD)
+      event = EVENT_CHILD;
+    else if (sig == SIGALRM)
+      event = EVENT_ALARM;
+    else if (sig == SIGTERM)
+      event = EVENT_TERM;
+    else if (sig == SIGUSR1)
+      event = EVENT_DUMP;
+    else if (sig == SIGUSR2)
+      event = EVENT_REOPEN;
+    else
+      return;
 
-      send_event(pipewrite, event, 0, NULL); 
-      errno = errsave;
-    }
+    send_event(pipewrite, event, 0, NULL);
+    errno = errsave;
+  }
 }
 
 /* now == 0 -> queue immediate callback */
 void send_alarm(time_t event, time_t now)
 {
-  if (now == 0 || event != 0)
-    {
-      /* alarm(0) or alarm(-ve) doesn't do what we want.... */
-      if ((now == 0 || difftime(event, now) <= 0.0))
-	send_event(pipewrite, EVENT_ALARM, 0, NULL);
-      else 
-	alarm((unsigned)difftime(event, now)); 
-    }
+  if (now == 0 || event != 0) {
+    /* alarm(0) or alarm(-ve) doesn't do what we want.... */
+    if ((now == 0 || difftime(event, now) <= 0.0))
+      send_event(pipewrite, EVENT_ALARM, 0, NULL);
+    else
+      alarm((unsigned) difftime(event, now));
+  }
 }
 
 void queue_event(int event)
@@ -1139,12 +1101,12 @@
   ev.event = event;
   ev.data = data;
   ev.msg_sz = msg ? strlen(msg) : 0;
-  
+
   iov[0].iov_base = &ev;
   iov[0].iov_len = sizeof(ev);
   iov[1].iov_base = msg;
   iov[1].iov_len = ev.msg_sz;
-  
+
   /* error pipe, debug mode. */
   if (fd == -1)
     fatal_event(&ev, msg);
@@ -1160,233 +1122,223 @@
 {
   char *buf;
 
-  if (!read_write(fd, (unsigned char *)evp, sizeof(struct event_desc), 1))
+  if (!read_write(fd, (unsigned char *) evp, sizeof(struct event_desc), 1))
     return 0;
-  
+
   *msg = NULL;
-  
-  if (evp->msg_sz != 0 && 
+
+  if (evp->msg_sz != 0 &&
       (buf = malloc(evp->msg_sz + 1)) &&
-      read_write(fd, (unsigned char *)buf, evp->msg_sz, 1))
-    {
-      buf[evp->msg_sz] = 0;
-      *msg = buf;
-    }
+      read_write(fd, (unsigned char *) buf, evp->msg_sz, 1)) {
+    buf[evp->msg_sz] = 0;
+    *msg = buf;
+  }
 
   return 1;
 }
-    
+
 static void fatal_event(struct event_desc *ev, char *msg)
 {
   errno = ev->data;
-  
-  switch (ev->event)
-    {
-    case EVENT_DIE:
-      exit(0);
 
-    case EVENT_FORK_ERR:
-      die(_("cannot fork into background: %s"), NULL, EC_MISC);
-  
-    case EVENT_PIPE_ERR:
-      die(_("failed to create helper: %s"), NULL, EC_MISC);
-  
-    case EVENT_CAP_ERR:
-      die(_("setting capabilities failed: %s"), NULL, EC_MISC);
+  switch (ev->event) {
+  case EVENT_DIE:
+    exit(0);
 
-    case EVENT_USER_ERR:
-      die(_("failed to change user-id to %s: %s"), msg, EC_MISC);
+  case EVENT_FORK_ERR:
+    die(_("cannot fork into background: %s"), NULL, EC_MISC);
 
-    case EVENT_GROUP_ERR:
-      die(_("failed to change group-id to %s: %s"), msg, EC_MISC);
-      
-    case EVENT_PIDFILE:
-      die(_("failed to open pidfile %s: %s"), msg, EC_FILE);
-
-    case EVENT_LOG_ERR:
-      die(_("cannot open log %s: %s"), msg, EC_FILE);
-    
-    case EVENT_LUA_ERR:
-      die(_("failed to load Lua script: %s"), msg, EC_MISC);
+  case EVENT_PIPE_ERR:
+    die(_("failed to create helper: %s"), NULL, EC_MISC);
+
+  case EVENT_CAP_ERR:
+    die(_("setting capabilities failed: %s"), NULL, EC_MISC);
+
+  case EVENT_USER_ERR:
+    die(_("failed to change user-id to %s: %s"), msg, EC_MISC);
+
+  case EVENT_GROUP_ERR:
+    die(_("failed to change group-id to %s: %s"), msg, EC_MISC);
+
+  case EVENT_PIDFILE:
+    die(_("failed to open pidfile %s: %s"), msg, EC_FILE);
+
+  case EVENT_LOG_ERR:
+    die(_("cannot open log %s: %s"), msg, EC_FILE);
+
+  case EVENT_LUA_ERR:
+    die(_("failed to load Lua script: %s"), msg, EC_MISC);
+
+  case EVENT_TFTP_ERR:
+    die(_("TFTP directory %s inaccessible: %s"), msg, EC_FILE);
+
+  case EVENT_TIME_ERR:
+    die(_("cannot create timestamp file %s: %s"), msg, EC_BADCONF);
+  }
+}
 
-    case EVENT_TFTP_ERR:
-      die(_("TFTP directory %s inaccessible: %s"), msg, EC_FILE);
-    
-    case EVENT_TIME_ERR:
-      die(_("cannot create timestamp file %s: %s" ), msg, EC_BADCONF);
-    }
-}	
-      
 static void async_event(int pipe, time_t now)
 {
   pid_t p;
   struct event_desc ev;
   int i, check = 0;
   char *msg;
-  
+
   /* NOTE: the memory used to return msg is leaked: use msgs in events only
      to describe fatal errors. */
-  
+
   if (read_event(pipe, &ev, &msg))
-    switch (ev.event)
-      {
-      case EVENT_RELOAD:
-	daemon->soa_sn++; /* Bump zone serial, as it may have changed. */
+    switch (ev.event) {
+    case EVENT_RELOAD:
+      daemon->soa_sn++;         /* Bump zone serial, as it may have changed. */
 
 #ifdef HAVE_DNSSEC
-	if (daemon->dnssec_no_time_check && option_bool(OPT_DNSSEC_VALID) && option_bool(OPT_DNSSEC_TIME))
-	  {
-	    my_syslog(LOG_INFO, _("now checking DNSSEC signature timestamps"));
-	    daemon->dnssec_no_time_check = 0;
-	  } 
-#endif
-	/* fall through */
-	
-      case EVENT_INIT:
-	clear_cache_and_reload(now);
-	
-	if (daemon->port != 0)
-	  {
-	    if (daemon->resolv_files && option_bool(OPT_NO_POLL))
-	      {
-		reload_servers(daemon->resolv_files->name);
-		check = 1;
-	      }
-
-	    if (daemon->servers_file)
-	      {
-		read_servers_file();
-		check = 1;
-	      }
-
-	    if (check)
-	      check_servers();
-	  }
+      if (daemon->dnssec_no_time_check && option_bool(OPT_DNSSEC_VALID)
+          && option_bool(OPT_DNSSEC_TIME)) {
+        my_syslog(LOG_INFO, _("now checking DNSSEC signature timestamps"));
+        daemon->dnssec_no_time_check = 0;
+      }
+#endif
+      /* fall through */
+
+    case EVENT_INIT:
+      clear_cache_and_reload(now);
 
+      if (daemon->port != 0) {
+        if (daemon->resolv_files && option_bool(OPT_NO_POLL)) {
+          reload_servers(daemon->resolv_files->name);
+          check = 1;
+        }
+
+        if (daemon->servers_file) {
+          read_servers_file();
+          check = 1;
+        }
+
+        if (check)
+          check_servers();
+      }
 #ifdef HAVE_DHCP
-	rerun_scripts();
+      rerun_scripts();
 #endif
-	break;
-	
-      case EVENT_DUMP:
-	if (daemon->port != 0)
-	  dump_cache(now);
-	break;
-	
-      case EVENT_ALARM:
+      break;
+
+    case EVENT_DUMP:
+      if (daemon->port != 0)
+        dump_cache(now);
+      break;
+
+    case EVENT_ALARM:
 #ifdef HAVE_DHCP
-	if (daemon->dhcp || daemon->doing_dhcp6)
-	  {
-	    lease_prune(NULL, now);
-	    lease_update_file(now);
-	  }
+      if (daemon->dhcp || daemon->doing_dhcp6) {
+        lease_prune(NULL, now);
+        lease_update_file(now);
+      }
 #ifdef HAVE_DHCP6
-	else if (daemon->doing_ra)
-	  /* Not doing DHCP, so no lease system, manage alarms for ra only */
-	    send_alarm(periodic_ra(now), now);
-#endif
-#endif
-	break;
-		
-      case EVENT_CHILD:
-	/* See Stevens 5.10 */
-	while ((p = waitpid(-1, NULL, WNOHANG)) != 0)
-	  if (p == -1)
-	    {
-	      if (errno != EINTR)
-		break;
-	    }      
-	  else 
-	    for (i = 0 ; i < MAX_PROCS; i++)
-	      if (daemon->tcp_pids[i] == p)
-		daemon->tcp_pids[i] = 0;
-	break;
-	
-#if defined(HAVE_SCRIPT)	
-      case EVENT_KILLED:
-	my_syslog(LOG_WARNING, _("script process killed by signal %d"), ev.data);
-	break;
-
-      case EVENT_EXITED:
-	my_syslog(LOG_WARNING, _("script process exited with status %d"), ev.data);
-	break;
-
-      case EVENT_EXEC_ERR:
-	my_syslog(LOG_ERR, _("failed to execute %s: %s"), 
-		  daemon->lease_change_command, strerror(ev.data));
-	break;
-
-      case EVENT_SCRIPT_LOG:
-	my_syslog(MS_SCRIPT | LOG_DEBUG, "%s", msg ? msg : "");
-        free(msg);
-	msg = NULL;
-	break;
-
-	/* necessary for fatal errors in helper */
-      case EVENT_USER_ERR:
-      case EVENT_DIE:
-      case EVENT_LUA_ERR:
-	fatal_event(&ev, msg);
-	break;
-#endif
-
-      case EVENT_REOPEN:
-	/* Note: this may leave TCP-handling processes with the old file still open.
-	   Since any such process will die in CHILD_LIFETIME or probably much sooner,
-	   we leave them logging to the old file. */
-	if (daemon->log_file != NULL)
-	  log_reopen(daemon->log_file);
-	break;
-
-      case EVENT_NEWADDR:
-	newaddress(now);
-	break;
-
-      case EVENT_NEWROUTE:
-	resend_query();
-	/* Force re-reading resolv file right now, for luck. */
-	poll_resolv(0, 1, now);
-	break;
-
-      case EVENT_TERM:
-	/* Knock all our children on the head. */
-	for (i = 0; i < MAX_PROCS; i++)
-	  if (daemon->tcp_pids[i] != 0)
-	    kill(daemon->tcp_pids[i], SIGALRM);
-	
+      else if (daemon->doing_ra)
+        /* Not doing DHCP, so no lease system, manage alarms for ra only */
+        send_alarm(periodic_ra(now), now);
+#endif
+#endif
+      break;
+
+    case EVENT_CHILD:
+      /* See Stevens 5.10 */
+      while ((p = waitpid(-1, NULL, WNOHANG)) != 0)
+        if (p == -1) {
+          if (errno != EINTR)
+            break;
+        } else
+          for (i = 0; i < MAX_PROCS; i++)
+            if (daemon->tcp_pids[i] == p)
+              daemon->tcp_pids[i] = 0;
+      break;
+
+#if defined(HAVE_SCRIPT)
+    case EVENT_KILLED:
+      my_syslog(LOG_WARNING, _("script process killed by signal %d"), ev.data);
+      break;
+
+    case EVENT_EXITED:
+      my_syslog(LOG_WARNING, _("script process exited with status %d"),
+                ev.data);
+      break;
+
+    case EVENT_EXEC_ERR:
+      my_syslog(LOG_ERR, _("failed to execute %s: %s"),
+                daemon->lease_change_command, strerror(ev.data));
+      break;
+
+    case EVENT_SCRIPT_LOG:
+      my_syslog(MS_SCRIPT | LOG_DEBUG, "%s", msg ? msg : "");
+      free(msg);
+      msg = NULL;
+      break;
+
+      /* necessary for fatal errors in helper */
+    case EVENT_USER_ERR:
+    case EVENT_DIE:
+    case EVENT_LUA_ERR:
+      fatal_event(&ev, msg);
+      break;
+#endif
+
+    case EVENT_REOPEN:
+      /* Note: this may leave TCP-handling processes with the old file still open.
+         Since any such process will die in CHILD_LIFETIME or probably much sooner,
+         we leave them logging to the old file. */
+      if (daemon->log_file != NULL)
+        log_reopen(daemon->log_file);
+      break;
+
+    case EVENT_NEWADDR:
+      newaddress(now);
+      break;
+
+    case EVENT_NEWROUTE:
+      resend_query();
+      /* Force re-reading resolv file right now, for luck. */
+      poll_resolv(0, 1, now);
+      break;
+
+    case EVENT_TERM:
+      /* Knock all our children on the head. */
+      for (i = 0; i < MAX_PROCS; i++)
+        if (daemon->tcp_pids[i] != 0)
+          kill(daemon->tcp_pids[i], SIGALRM);
+
 #if defined(HAVE_SCRIPT) && defined(HAVE_DHCP)
-	/* handle pending lease transitions */
-	if (daemon->helperfd != -1)
-	  {
-	    /* block in writes until all done */
-	    if ((i = fcntl(daemon->helperfd, F_GETFL)) != -1)
-	      fcntl(daemon->helperfd, F_SETFL, i & ~O_NONBLOCK); 
-	    do {
-	      helper_write();
-	    } while (!helper_buf_empty() || do_script_run(now));
-	    while (retry_send(close(daemon->helperfd)));
-	  }
-#endif
-	
-	if (daemon->lease_stream)
-	  fclose(daemon->lease_stream);
+      /* handle pending lease transitions */
+      if (daemon->helperfd != -1) {
+        /* block in writes until all done */
+        if ((i = fcntl(daemon->helperfd, F_GETFL)) != -1)
+          fcntl(daemon->helperfd, F_SETFL, i & ~O_NONBLOCK);
+        do {
+          helper_write();
+        } while (!helper_buf_empty() || do_script_run(now));
+        while (retry_send(close(daemon->helperfd)));
+      }
+#endif
+
+      if (daemon->lease_stream)
+        fclose(daemon->lease_stream);
 
 #ifdef HAVE_DNSSEC
-	/* update timestamp file on TERM if time is considered valid */
-	if (daemon->back_to_the_future)
-	  {
-	     if (utimes(daemon->timestamp_file, NULL) == -1)
-		my_syslog(LOG_ERR, _("failed to update mtime on %s: %s"), daemon->timestamp_file, strerror(errno));
-	  }
+      /* update timestamp file on TERM if time is considered valid */
+      if (daemon->back_to_the_future) {
+        if (utimes(daemon->timestamp_file, NULL) == -1)
+          my_syslog(LOG_ERR, _("failed to update mtime on %s: %s"),
+                    daemon->timestamp_file, strerror(errno));
+      }
 #endif
 
-	if (daemon->runfile)
-	  unlink(daemon->runfile);
-	
-	my_syslog(LOG_INFO, _("exiting on receipt of SIGTERM"));
-	flush_log();
-	exit(EC_GOOD);
-      }
+      if (daemon->runfile)
+        unlink(daemon->runfile);
+
+      my_syslog(LOG_INFO, _("exiting on receipt of SIGTERM"));
+      flush_log();
+      exit(EC_GOOD);
+    }
 }
 
 static void poll_resolv(int force, int do_reload, time_t now)
@@ -1400,86 +1352,75 @@
 
   if (daemon->port == 0 || option_bool(OPT_NO_POLL))
     return;
-  
+
   for (latest = NULL, res = daemon->resolv_files; res; res = res->next)
-    if (stat(res->name, &statbuf) == -1)
-      {
-	if (force)
-	  {
-	    res->mtime = 0; 
-	    continue;
-	  }
-
-	if (!res->logged)
-	  my_syslog(LOG_WARNING, _("failed to access %s: %s"), res->name, strerror(errno));
-	res->logged = 1;
-	
-	if (res->mtime != 0)
-	  { 
-	    /* existing file evaporated, force selection of the latest
-	       file even if its mtime hasn't changed since we last looked */
-	    poll_resolv(1, do_reload, now);
-	    return;
-	  }
+    if (stat(res->name, &statbuf) == -1) {
+      if (force) {
+        res->mtime = 0;
+        continue;
+      }
+
+      if (!res->logged)
+        my_syslog(LOG_WARNING, _("failed to access %s: %s"), res->name,
+                  strerror(errno));
+      res->logged = 1;
+
+      if (res->mtime != 0) {
+        /* existing file evaporated, force selection of the latest
+           file even if its mtime hasn't changed since we last looked */
+        poll_resolv(1, do_reload, now);
+        return;
+      }
+    } else {
+      res->logged = 0;
+      if (force || (statbuf.st_mtime != res->mtime)) {
+        res->mtime = statbuf.st_mtime;
+        if (difftime(statbuf.st_mtime, last_change) > 0.0) {
+          last_change = statbuf.st_mtime;
+          latest = res;
+        }
       }
-    else
-      {
-	res->logged = 0;
-	if (force || (statbuf.st_mtime != res->mtime))
-          {
-            res->mtime = statbuf.st_mtime;
-	    if (difftime(statbuf.st_mtime, last_change) > 0.0)
-	      {
-		last_change = statbuf.st_mtime;
-		latest = res;
-	      }
-	  }
-      }
-  
-  if (latest)
-    {
-      static int warned = 0;
-      if (reload_servers(latest->name))
-	{
-	  my_syslog(LOG_INFO, _("reading %s"), latest->name);
-	  warned = 0;
-	  check_servers();
-	  if (option_bool(OPT_RELOAD) && do_reload)
-	    clear_cache_and_reload(now);
-	}
-      else 
-	{
-	  latest->mtime = 0;
-	  if (!warned)
-	    {
-	      my_syslog(LOG_WARNING, _("no servers found in %s, will retry"), latest->name);
-	      warned = 1;
-	    }
-	}
     }
-}       
+
+  if (latest) {
+    static int warned = 0;
+    if (reload_servers(latest->name)) {
+      my_syslog(LOG_INFO, _("reading %s"), latest->name);
+      warned = 0;
+      check_servers();
+      if (option_bool(OPT_RELOAD) && do_reload)
+        clear_cache_and_reload(now);
+    } else {
+      latest->mtime = 0;
+      if (!warned) {
+        my_syslog(LOG_WARNING, _("no servers found in %s, will retry"),
+                  latest->name);
+        warned = 1;
+      }
+    }
+  }
+}
 
 void clear_cache_and_reload(time_t now)
 {
-  (void)now;
+  (void) now;
 
   if (daemon->port != 0)
     cache_reload();
-  
+
 #ifdef HAVE_DHCP
-  if (daemon->dhcp || daemon->doing_dhcp6)
-    {
-      if (option_bool(OPT_ETHERS))
-	dhcp_read_ethers();
-      reread_dhcp();
+  if (daemon->dhcp || daemon->doing_dhcp6) {
+    if (option_bool(OPT_ETHERS))
+      dhcp_read_ethers();
+    reread_dhcp();
 #ifdef HAVE_INOTIFY
-      set_dynamic_inotify(AH_DHCP_HST | AH_DHCP_OPT, 0, NULL, 0);
+    set_dynamic_inotify(AH_DHCP_HST | AH_DHCP_OPT, 0, NULL, 0);
 #endif
-      dhcp_update_configs(daemon->dhcp_conf);
-      lease_update_from_configs(); 
-      lease_update_file(now); 
-      lease_update_dns(1);
-    }
+    dhcp_update_configs(daemon->dhcp_conf);
+    lease_update_from_configs();
+    lease_update_file(now);
+    lease_update_dns(1);
+  }
 #ifdef HAVE_DHCP6
   else if (daemon->doing_ra)
     /* Not doing DHCP, so no lease system, manage 
@@ -1494,52 +1435,48 @@
   struct serverfd *serverfdp;
   struct listener *listener;
   int wait = 0, i;
-  
+
 #ifdef HAVE_TFTP
-  int  tftp = 0;
+  int tftp = 0;
   struct tftp_transfer *transfer;
-  for (transfer = daemon->tftp_trans; transfer; transfer = transfer->next)
-    {
-      tftp++;
-      poll_listen(transfer->sockfd, POLLIN);
-    }
+  for (transfer = daemon->tftp_trans; transfer; transfer = transfer->next) {
+    tftp++;
+    poll_listen(transfer->sockfd, POLLIN);
+  }
 #endif
-  
+
   /* will we be able to get memory? */
   if (daemon->port != 0)
     get_new_frec(now, &wait, 0);
-  
+
   for (serverfdp = daemon->sfds; serverfdp; serverfdp = serverfdp->next)
     poll_listen(serverfdp->fd, POLLIN);
-    
+
   if (daemon->port != 0 && !daemon->osport)
     for (i = 0; i < RANDOM_SOCKS; i++)
       if (daemon->randomsocks[i].refcount != 0)
-	poll_listen(daemon->randomsocks[i].fd, POLLIN);
-	  
-  for (listener = daemon->listeners; listener; listener = listener->next)
-    {
-      /* only listen for queries if we have resources */
-      if (listener->fd != -1 && wait == 0)
-	poll_listen(listener->fd, POLLIN);
-	
-      /* death of a child goes through the select loop, so
-	 we don't need to explicitly arrange to wake up here */
-      if  (listener->tcpfd != -1)
-	for (i = 0; i < MAX_PROCS; i++)
-	  if (daemon->tcp_pids[i] == 0)
-	    {
-	      poll_listen(listener->tcpfd, POLLIN);
-	      break;
-	    }
+        poll_listen(daemon->randomsocks[i].fd, POLLIN);
 
+  for (listener = daemon->listeners; listener; listener = listener->next) {
+    /* only listen for queries if we have resources */
+    if (listener->fd != -1 && wait == 0)
+      poll_listen(listener->fd, POLLIN);
+
+    /* death of a child goes through the select loop, so
+       we don't need to explicitly arrange to wake up here */
+    if (listener->tcpfd != -1)
+      for (i = 0; i < MAX_PROCS; i++)
+        if (daemon->tcp_pids[i] == 0) {
+          poll_listen(listener->tcpfd, POLLIN);
+          break;
+        }
 #ifdef HAVE_TFTP
-      if (tftp <= daemon->tftp_max && listener->tftpfd != -1)
-	poll_listen(listener->tftpfd, POLLIN);
+    if (tftp <= daemon->tftp_max && listener->tftpfd != -1)
+      poll_listen(listener->tftpfd, POLLIN);
 #endif
 
-    }
-  
+  }
+
   return wait;
 }
 
@@ -1552,184 +1489,172 @@
   for (serverfdp = daemon->sfds; serverfdp; serverfdp = serverfdp->next)
     if (poll_check(serverfdp->fd, POLLIN))
       reply_query(serverfdp->fd, serverfdp->source_addr.sa.sa_family, now);
-  
+
   if (daemon->port != 0 && !daemon->osport)
     for (i = 0; i < RANDOM_SOCKS; i++)
-      if (daemon->randomsocks[i].refcount != 0 && 
-	  poll_check(daemon->randomsocks[i].fd, POLLIN))
-	reply_query(daemon->randomsocks[i].fd, daemon->randomsocks[i].family, now);
-  
-  for (listener = daemon->listeners; listener; listener = listener->next)
-    {
-      if (listener->fd != -1 && poll_check(listener->fd, POLLIN))
-	receive_query(listener, now); 
-      
-#ifdef HAVE_TFTP     
-      if (listener->tftpfd != -1 && poll_check(listener->tftpfd, POLLIN))
-	tftp_request(listener, now);
-#endif
-
-      if (listener->tcpfd != -1 && poll_check(listener->tcpfd, POLLIN))
-	{
-	  int confd, client_ok = 1;
-	  struct irec *iface = NULL;
-	  pid_t p;
-	  union mysockaddr tcp_addr;
-	  socklen_t tcp_len = sizeof(union mysockaddr);
-
-	  while ((confd = accept(listener->tcpfd, NULL, NULL)) == -1 && errno == EINTR);
-	  
-	  if (confd == -1)
-	    continue;
-	  
-	  if (getsockname(confd, (struct sockaddr *)&tcp_addr, &tcp_len) == -1)
-	    {
-	      while (retry_send(close(confd)));
-	      continue;
-	    }
-	  
-	  /* Make sure that the interface list is up-to-date.
-	     
-	     We do this here as we may need the results below, and
-	     the DNS code needs them for --interface-name stuff.
-
-	     Multiple calls to enumerate_interfaces() per select loop are
-	     inhibited, so calls to it in the child process (which doesn't select())
-	     have no effect. This avoids two processes reading from the same
-	     netlink fd and screwing the pooch entirely.
-	  */
- 
-	  enumerate_interfaces(0);
-	  
-	  if (option_bool(OPT_NOWILD))
-	    iface = listener->iface; /* May be NULL */
-	  else 
-	    {
-	      int if_index;
-	      char intr_name[IF_NAMESIZE];
-	      
-	      /* if we can find the arrival interface, check it's one that's allowed */
-	      if ((if_index = tcp_interface(confd, tcp_addr.sa.sa_family)) != 0 &&
-		  indextoname(listener->tcpfd, if_index, intr_name))
-		{
-		  struct all_addr addr;
-		  addr.addr.addr4 = tcp_addr.in.sin_addr;
+      if (daemon->randomsocks[i].refcount != 0 &&
+          poll_check(daemon->randomsocks[i].fd, POLLIN))
+        reply_query(daemon->randomsocks[i].fd, daemon->randomsocks[i].family,
+                    now);
+
+  for (listener = daemon->listeners; listener; listener = listener->next) {
+    if (listener->fd != -1 && poll_check(listener->fd, POLLIN))
+      receive_query(listener, now);
+
+#ifdef HAVE_TFTP
+    if (listener->tftpfd != -1 && poll_check(listener->tftpfd, POLLIN))
+      tftp_request(listener, now);
+#endif
+
+    if (listener->tcpfd != -1 && poll_check(listener->tcpfd, POLLIN)) {
+      int confd, client_ok = 1;
+      struct irec *iface = NULL;
+      pid_t p;
+      union mysockaddr tcp_addr;
+      socklen_t tcp_len = sizeof(union mysockaddr);
+
+      while ((confd = accept(listener->tcpfd, NULL, NULL)) == -1
+             && errno == EINTR);
+
+      if (confd == -1)
+        continue;
+
+      if (getsockname(confd, (struct sockaddr *) &tcp_addr, &tcp_len) == -1) {
+        while (retry_send(close(confd)));
+        continue;
+      }
+
+      /* Make sure that the interface list is up-to-date.
+
+         We do this here as we may need the results below, and
+         the DNS code needs them for --interface-name stuff.
+
+         Multiple calls to enumerate_interfaces() per select loop are
+         inhibited, so calls to it in the child process (which doesn't select())
+         have no effect. This avoids two processes reading from the same
+         netlink fd and screwing the pooch entirely.
+       */
+
+      enumerate_interfaces(0);
+
+      if (option_bool(OPT_NOWILD))
+        iface = listener->iface;        /* May be NULL */
+      else {
+        int if_index;
+        char intr_name[IF_NAMESIZE];
+
+        /* if we can find the arrival interface, check it's one that's allowed */
+        if ((if_index = tcp_interface(confd, tcp_addr.sa.sa_family)) != 0 &&
+            indextoname(listener->tcpfd, if_index, intr_name)) {
+          struct all_addr addr;
+          addr.addr.addr4 = tcp_addr.in.sin_addr;
 #ifdef HAVE_IPV6
-		  if (tcp_addr.sa.sa_family == AF_INET6)
-		    addr.addr.addr6 = tcp_addr.in6.sin6_addr;
+          if (tcp_addr.sa.sa_family == AF_INET6)
+            addr.addr.addr6 = tcp_addr.in6.sin6_addr;
 #endif
-		  
-		  for (iface = daemon->interfaces; iface; iface = iface->next)
-		    if (iface->index == if_index)
-		      break;
-		  
-		  if (!iface && !loopback_exception(listener->tcpfd, tcp_addr.sa.sa_family, &addr, intr_name))
-		    client_ok = 0;
-		}
-	      
-	      if (option_bool(OPT_CLEVERBIND))
-		iface = listener->iface; /* May be NULL */
-	      else
-		{
-		  /* Check for allowed interfaces when binding the wildcard address:
-		     we do this by looking for an interface with the same address as 
-		     the local address of the TCP connection, then looking to see if that's
-		     an allowed interface. As a side effect, we get the netmask of the
-		     interface too, for localisation. */
-		  
-		  for (iface = daemon->interfaces; iface; iface = iface->next)
-		    if (sockaddr_isequal(&iface->addr, &tcp_addr))
-		      break;
-		  
-		  if (!iface)
-		    client_ok = 0;
-		}
-	    }
-	  
-	  if (!client_ok)
-	    {
-	      shutdown(confd, SHUT_RDWR);
-	      while (retry_send(close(confd)));
-	    }
+
+          for (iface = daemon->interfaces; iface; iface = iface->next)
+            if (iface->index == if_index)
+              break;
+
+          if (!iface
+              && !loopback_exception(listener->tcpfd, tcp_addr.sa.sa_family,
+                                     &addr, intr_name))
+            client_ok = 0;
+        }
+
+        if (option_bool(OPT_CLEVERBIND))
+          iface = listener->iface;      /* May be NULL */
+        else {
+          /* Check for allowed interfaces when binding the wildcard address:
+             we do this by looking for an interface with the same address as
+             the local address of the TCP connection, then looking to see if that's
+             an allowed interface. As a side effect, we get the netmask of the
+             interface too, for localisation. */
+
+          for (iface = daemon->interfaces; iface; iface = iface->next)
+            if (sockaddr_isequal(&iface->addr, &tcp_addr))
+              break;
+
+          if (!iface)
+            client_ok = 0;
+        }
+      }
+
+      if (!client_ok) {
+        shutdown(confd, SHUT_RDWR);
+        while (retry_send(close(confd)));
+      }
 #ifndef NO_FORK
-	  else if (!option_bool(OPT_DEBUG) && (p = fork()) != 0)
-	    {
-	      if (p != -1)
-		{
-		  int i;
-		  for (i = 0; i < MAX_PROCS; i++)
-		    if (daemon->tcp_pids[i] == 0)
-		      {
-			daemon->tcp_pids[i] = p;
-			break;
-		      }
-		}
-	      while (retry_send(close(confd)));
-
-	      /* The child can use up to TCP_MAX_QUERIES ids, so skip that many. */
-	      daemon->log_id += TCP_MAX_QUERIES;
-	    }
-#endif
-	  else
-	    {
-	      unsigned char *buff;
-	      struct server *s; 
-	      int flags;
-	      struct in_addr netmask;
-	      int auth_dns;
-
-	      if (iface)
-		{
-		  netmask = iface->netmask;
-		  auth_dns = iface->dns_auth;
-		}
-	      else
-		{
-		  netmask.s_addr = 0;
-		  auth_dns = 0;
-		}
+      else if (!option_bool(OPT_DEBUG) && (p = fork()) != 0) {
+        if (p != -1) {
+          int i;
+          for (i = 0; i < MAX_PROCS; i++)
+            if (daemon->tcp_pids[i] == 0) {
+              daemon->tcp_pids[i] = p;
+              break;
+            }
+        }
+        while (retry_send(close(confd)));
 
+        /* The child can use up to TCP_MAX_QUERIES ids, so skip that many. */
+        daemon->log_id += TCP_MAX_QUERIES;
+      }
+#endif
+      else {
+        unsigned char *buff;
+        struct server *s;
+        int flags;
+        struct in_addr netmask;
+        int auth_dns;
+
+        if (iface) {
+          netmask = iface->netmask;
+          auth_dns = iface->dns_auth;
+        } else {
+          netmask.s_addr = 0;
+          auth_dns = 0;
+        }
+
+#ifndef NO_FORK
+        /* Arrange for SIGALRM after CHILD_LIFETIME seconds to
+           terminate the process. */
+        if (!option_bool(OPT_DEBUG))
+          alarm(CHILD_LIFETIME);
+#endif
+
+        /* start with no upstream connections. */
+        for (s = daemon->servers; s; s = s->next)
+          s->tcpfd = -1;
+
+        /* The connected socket inherits non-blocking
+           attribute from the listening socket.
+           Reset that here. */
+        if ((flags = fcntl(confd, F_GETFL, 0)) != -1)
+          fcntl(confd, F_SETFL, flags & ~O_NONBLOCK);
+
+        buff = tcp_request(confd, now, &tcp_addr, netmask, auth_dns);
+
+        shutdown(confd, SHUT_RDWR);
+        while (retry_send(close(confd)));
+
+        if (buff)
+          free(buff);
+
+        for (s = daemon->servers; s; s = s->next)
+          if (s->tcpfd != -1) {
+            shutdown(s->tcpfd, SHUT_RDWR);
+            while (retry_send(close(s->tcpfd)));
+          }
 #ifndef NO_FORK
-	      /* Arrange for SIGALRM after CHILD_LIFETIME seconds to
-		 terminate the process. */
-	      if (!option_bool(OPT_DEBUG))
-		alarm(CHILD_LIFETIME);
-#endif
-
-	      /* start with no upstream connections. */
-	      for (s = daemon->servers; s; s = s->next)
-		 s->tcpfd = -1; 
-	      
-	      /* The connected socket inherits non-blocking
-		 attribute from the listening socket. 
-		 Reset that here. */
-	      if ((flags = fcntl(confd, F_GETFL, 0)) != -1)
-		fcntl(confd, F_SETFL, flags & ~O_NONBLOCK);
-	      
-	      buff = tcp_request(confd, now, &tcp_addr, netmask, auth_dns);
-	       
-	      shutdown(confd, SHUT_RDWR);
-	      while (retry_send(close(confd)));
-	      
-	      if (buff)
-		free(buff);
-	      
-	      for (s = daemon->servers; s; s = s->next)
-		if (s->tcpfd != -1)
-		  {
-		    shutdown(s->tcpfd, SHUT_RDWR);
-		    while (retry_send(close(s->tcpfd)));
-		  }
-#ifndef NO_FORK		   
-	      if (!option_bool(OPT_DEBUG))
-		{
-		  flush_log();
-		  _exit(0);
-		}
+        if (!option_bool(OPT_DEBUG)) {
+          flush_log();
+          _exit(0);
+        }
 #endif
-	    }
-	}
+      }
     }
+  }
 }
 
 #ifdef HAVE_DHCP
@@ -1738,15 +1663,14 @@
   int fd;
   int zeroopt = 0;
 
-  if ((fd = socket (AF_INET, SOCK_RAW, IPPROTO_ICMP)) != -1)
-    {
-      if (!fix_fd(fd) ||
-	  setsockopt(fd, SOL_SOCKET, SO_DONTROUTE, &zeroopt, sizeof(zeroopt)) == -1)
-	{
-	  close(fd);
-	  fd = -1;
-	}
+  if ((fd = socket(AF_INET, SOCK_RAW, IPPROTO_ICMP)) != -1) {
+    if (!fix_fd(fd) ||
+        setsockopt(fd, SOL_SOCKET, SO_DONTROUTE, &zeroopt,
+                   sizeof(zeroopt)) == -1) {
+      close(fd);
+      fd = -1;
     }
+  }
 
   return fd;
 }
@@ -1757,7 +1681,7 @@
 
   int fd;
   struct sockaddr_in saddr;
-  struct { 
+  struct {
     struct ip ip;
     struct icmp icmp;
   } packet;
@@ -1780,19 +1704,19 @@
 #ifdef HAVE_SOCKADDR_SA_LEN
   saddr.sin_len = sizeof(struct sockaddr_in);
 #endif
-  
+
   memset(&packet.icmp, 0, sizeof(packet.icmp));
   packet.icmp.icmp_type = ICMP_ECHO;
   packet.icmp.icmp_id = id;
   for (j = 0, i = 0; i < sizeof(struct icmp) / 2; i++)
-    j += ((u16 *)&packet.icmp)[i];
-  while (j>>16)
-    j = (j & 0xffff) + (j >> 16);  
+    j += ((u16 *) & packet.icmp)[i];
+  while (j >> 16)
+    j = (j & 0xffff) + (j >> 16);
   packet.icmp.icmp_cksum = (j == 0xffff) ? j : ~j;
-  
-  while (retry_send(sendto(fd, (char *)&packet.icmp, sizeof(struct icmp), 0, 
-			   (struct sockaddr *)&saddr, sizeof(saddr))));
-  
+
+  while (retry_send(sendto(fd, (char *) &packet.icmp, sizeof(struct icmp), 0,
+                           (struct sockaddr *) &saddr, sizeof(saddr))));
+
   gotreply = delay_dhcp(dnsmasq_time(), PING_WAIT, fd, addr.s_addr, id);
 
 #if defined(HAVE_LINUX_NETWORK) || defined(HAVE_SOLARIS_NETWORK)
@@ -1828,61 +1752,56 @@
   time_t now;
 
   for (now = dnsmasq_time(), timeout_count = 0;
-       (difftime(now, start) <= (float)sec) && (timeout_count < sec * 4);)
-    {
-      poll_reset();
-      if (fd != -1)
-        poll_listen(fd, POLLIN);
-      set_dns_listeners(now);
-      set_log_writer();
-      
+       (difftime(now, start) <= (float) sec) && (timeout_count < sec * 4);) {
+    poll_reset();
+    if (fd != -1)
+      poll_listen(fd, POLLIN);
+    set_dns_listeners(now);
+    set_log_writer();
+
 #ifdef HAVE_DHCP6
-      if (daemon->doing_ra)
-	poll_listen(daemon->icmp6fd, POLLIN); 
+    if (daemon->doing_ra)
+      poll_listen(daemon->icmp6fd, POLLIN);
 #endif
-      
-      rc = do_poll(250);
-      
-      if (rc < 0)
-	continue;
-      else if (rc == 0)
-	timeout_count++;
-
-      now = dnsmasq_time();
-      
-      check_log_writer(0);
-      check_dns_listeners(now);
-      
+
+    rc = do_poll(250);
+
+    if (rc < 0)
+      continue;
+    else if (rc == 0)
+      timeout_count++;
+
+    now = dnsmasq_time();
+
+    check_log_writer(0);
+    check_dns_listeners(now);
+
 #ifdef HAVE_DHCP6
-      if (daemon->doing_ra && poll_check(daemon->icmp6fd, POLLIN))
-	icmp6_packet(now);
+    if (daemon->doing_ra && poll_check(daemon->icmp6fd, POLLIN))
+      icmp6_packet(now);
 #endif
-      
+
 #ifdef HAVE_TFTP
-      check_tftp_listeners(now);
+    check_tftp_listeners(now);
 #endif
 
-      if (fd != -1)
-        {
-          struct {
-            struct ip ip;
-            struct icmp icmp;
-          } packet;
-          struct sockaddr_in faddr;
-          socklen_t len = sizeof(faddr);
-	  
-          if (poll_check(fd, POLLIN) &&
-	      recvfrom(fd, &packet, sizeof(packet), 0, (struct sockaddr *)&faddr, &len) == sizeof(packet) &&
-	      addr == faddr.sin_addr.s_addr &&
-	      packet.icmp.icmp_type == ICMP_ECHOREPLY &&
-	      packet.icmp.icmp_seq == 0 &&
-	      packet.icmp.icmp_id == id)
-	    return 1;
-	}
+    if (fd != -1) {
+      struct {
+        struct ip ip;
+        struct icmp icmp;
+      } packet;
+      struct sockaddr_in faddr;
+      socklen_t len = sizeof(faddr);
+
+      if (poll_check(fd, POLLIN) &&
+          recvfrom(fd, &packet, sizeof(packet), 0, (struct sockaddr *) &faddr,
+                   &len) == sizeof(packet) && addr == faddr.sin_addr.s_addr
+          && packet.icmp.icmp_type == ICMP_ECHOREPLY
+          && packet.icmp.icmp_seq == 0 && packet.icmp.icmp_id == id)
+        return 1;
     }
+  }
 
   return 0;
 }
 #endif
-
- 
Index: dnsmasq-2.78/src/arp.c
===================================================================
--- dnsmasq-2.78.orig/src/arp.c	2017-10-02 21:13:51.000000000 +0800
+++ dnsmasq-2.78/src/arp.c	2018-10-29 16:14:19.345440022 +0800
@@ -20,14 +20,14 @@
 #define INTERVAL 90
 
 #define ARP_MARK  0
-#define ARP_FOUND 1  /* Confirmed */
-#define ARP_NEW   2  /* Newly created */
-#define ARP_EMPTY 3  /* No MAC addr */
+#define ARP_FOUND 1             /* Confirmed */
+#define ARP_NEW   2             /* Newly created */
+#define ARP_EMPTY 3             /* No MAC addr */
 
 struct arp_record {
   unsigned short hwlen, status;
   int family;
-  unsigned char hwaddr[DHCP_CHADDR_MAX]; 
+  unsigned char hwaddr[DHCP_CHADDR_MAX];
   struct all_addr addr;
   struct arp_record *next;
 };
@@ -35,11 +35,12 @@
 static struct arp_record *arps = NULL, *old = NULL, *freelist = NULL;
 static time_t last = 0;
 
-static int filter_mac(int family, char *addrp, char *mac, size_t maclen, void *parmv)
+static int filter_mac(int family, char *addrp, char *mac, size_t maclen,
+                      void *parmv)
 {
   struct arp_record *arp;
 
-  (void)parmv;
+  (void) parmv;
 
   if (maclen > DHCP_CHADDR_MAX)
     return 1;
@@ -50,65 +51,57 @@
 #endif
 
   /* Look for existing entry */
-  for (arp = arps; arp; arp = arp->next)
-    {
-      if (family != arp->family || arp->status == ARP_NEW)
-	continue;
-      
-      if (family == AF_INET)
-	{
-	  if (arp->addr.addr.addr4.s_addr != ((struct in_addr *)addrp)->s_addr)
-	    continue;
-	}
+  for (arp = arps; arp; arp = arp->next) {
+    if (family != arp->family || arp->status == ARP_NEW)
+      continue;
+
+    if (family == AF_INET) {
+      if (arp->addr.addr.addr4.s_addr != ((struct in_addr *) addrp)->s_addr)
+        continue;
+    }
 #ifdef HAVE_IPV6
-      else
-	{
-	  if (!IN6_ARE_ADDR_EQUAL(&arp->addr.addr.addr6, (struct in6_addr *)addrp))
-	    continue;
-	}
-#endif
-
-      if (arp->status == ARP_EMPTY)
-	{
-	  /* existing address, was negative. */
-	  arp->status = ARP_NEW;
-	  arp->hwlen = maclen;
-	  memcpy(arp->hwaddr, mac, maclen);
-	}
-      else if (arp->hwlen == maclen && memcmp(arp->hwaddr, mac, maclen) == 0)
-	/* Existing entry matches - confirm. */
-	arp->status = ARP_FOUND;
-      else
-	continue;
-      
-      break;
+    else {
+      if (!IN6_ARE_ADDR_EQUAL(&arp->addr.addr.addr6, (struct in6_addr *) addrp))
+        continue;
     }
+#endif
 
-  if (!arp)
-    {
-      /* New entry */
-      if (freelist)
-	{
-	  arp = freelist;
-	  freelist = freelist->next;
-	}
-      else if (!(arp = whine_malloc(sizeof(struct arp_record))))
-	return 1;
-      
-      arp->next = arps;
-      arps = arp;
+    if (arp->status == ARP_EMPTY) {
+      /* existing address, was negative. */
       arp->status = ARP_NEW;
       arp->hwlen = maclen;
-      arp->family = family;
       memcpy(arp->hwaddr, mac, maclen);
-      if (family == AF_INET)
-	arp->addr.addr.addr4.s_addr = ((struct in_addr *)addrp)->s_addr;
+    } else if (arp->hwlen == maclen && memcmp(arp->hwaddr, mac, maclen) == 0)
+      /* Existing entry matches - confirm. */
+      arp->status = ARP_FOUND;
+    else
+      continue;
+
+    break;
+  }
+
+  if (!arp) {
+    /* New entry */
+    if (freelist) {
+      arp = freelist;
+      freelist = freelist->next;
+    } else if (!(arp = whine_malloc(sizeof(struct arp_record))))
+      return 1;
+
+    arp->next = arps;
+    arps = arp;
+    arp->status = ARP_NEW;
+    arp->hwlen = maclen;
+    arp->family = family;
+    memcpy(arp->hwaddr, mac, maclen);
+    if (family == AF_INET)
+      arp->addr.addr.addr4.s_addr = ((struct in_addr *) addrp)->s_addr;
 #ifdef HAVE_IPV6
-      else
-	memcpy(&arp->addr.addr.addr6, addrp, IN6ADDRSZ);
+    else
+      memcpy(&arp->addr.addr.addr6, addrp, IN6ADDRSZ);
 #endif
-    }
-  
+  }
+
   return 1;
 }
 
@@ -118,130 +111,117 @@
   struct arp_record *arp, *tmp, **up;
   int updated = 0;
 
- again:
-  
+again:
+
   /* If the database is less then INTERVAL old, look in there */
-  if (difftime(now, last) < INTERVAL)
-    {
-      /* addr == NULL -> just make cache up-to-date */
-      if (!addr)
-	return 0;
-
-      for (arp = arps; arp; arp = arp->next)
-	{
-	  if (addr->sa.sa_family != arp->family)
-	    continue;
-	    
-	  if (arp->family == AF_INET &&
-	      arp->addr.addr.addr4.s_addr != addr->in.sin_addr.s_addr)
-	    continue;
-	    
+  if (difftime(now, last) < INTERVAL) {
+    /* addr == NULL -> just make cache up-to-date */
+    if (!addr)
+      return 0;
+
+    for (arp = arps; arp; arp = arp->next) {
+      if (addr->sa.sa_family != arp->family)
+        continue;
+
+      if (arp->family == AF_INET &&
+          arp->addr.addr.addr4.s_addr != addr->in.sin_addr.s_addr)
+        continue;
+
 #ifdef HAVE_IPV6
-	  if (arp->family == AF_INET6 && 
-	      !IN6_ARE_ADDR_EQUAL(&arp->addr.addr.addr6, &addr->in6.sin6_addr))
-	    continue;
-#endif
-	  
-	  /* Only accept positive entries unless in lazy mode. */
-	  if (arp->status != ARP_EMPTY || lazy || updated)
-	    {
-	      if (mac && arp->hwlen != 0)
-		memcpy(mac, arp->hwaddr, arp->hwlen);
-	      return arp->hwlen;
-	    }
-	}
+      if (arp->family == AF_INET6 &&
+          !IN6_ARE_ADDR_EQUAL(&arp->addr.addr.addr6, &addr->in6.sin6_addr))
+        continue;
+#endif
+
+      /* Only accept positive entries unless in lazy mode. */
+      if (arp->status != ARP_EMPTY || lazy || updated) {
+        if (mac && arp->hwlen != 0)
+          memcpy(mac, arp->hwaddr, arp->hwlen);
+        return arp->hwlen;
+      }
     }
+  }
 
   /* Not found, try the kernel */
-  if (!updated)
-     {
-       updated = 1;
-       last = now;
-
-       /* Mark all non-negative entries */
-       for (arp = arps; arp; arp = arp->next)
-	 if (arp->status != ARP_EMPTY)
-	   arp->status = ARP_MARK;
-       
-       iface_enumerate(AF_UNSPEC, NULL, filter_mac);
-       
-       /* Remove all unconfirmed entries to old list. */
-       for (arp = arps, up = &arps; arp; arp = tmp)
-	 {
-	   tmp = arp->next;
-	   
-	   if (arp->status == ARP_MARK)
-	     {
-	       *up = arp->next;
-	       arp->next = old;
-	       old = arp;
-	     }
-	   else
-	     up = &arp->next;
-	 }
+  if (!updated) {
+    updated = 1;
+    last = now;
+
+    /* Mark all non-negative entries */
+    for (arp = arps; arp; arp = arp->next)
+      if (arp->status != ARP_EMPTY)
+        arp->status = ARP_MARK;
+
+    iface_enumerate(AF_UNSPEC, NULL, filter_mac);
+
+    /* Remove all unconfirmed entries to old list. */
+    for (arp = arps, up = &arps; arp; arp = tmp) {
+      tmp = arp->next;
+
+      if (arp->status == ARP_MARK) {
+        *up = arp->next;
+        arp->next = old;
+        old = arp;
+      } else
+        up = &arp->next;
+    }
 
-       goto again;
-     }
+    goto again;
+  }
 
   /* record failure, so we don't consult the kernel each time
      we're asked for this address */
-  if (freelist)
-    {
-      arp = freelist;
-      freelist = freelist->next;
-    }
-  else
+  if (freelist) {
+    arp = freelist;
+    freelist = freelist->next;
+  } else
     arp = whine_malloc(sizeof(struct arp_record));
-  
-  if (arp)
-    {      
-      arp->next = arps;
-      arps = arp;
-      arp->status = ARP_EMPTY;
-      arp->family = addr->sa.sa_family;
-      arp->hwlen = 0;
 
-      if (addr->sa.sa_family == AF_INET)
-	arp->addr.addr.addr4.s_addr = addr->in.sin_addr.s_addr;
+  if (arp) {
+    arp->next = arps;
+    arps = arp;
+    arp->status = ARP_EMPTY;
+    arp->family = addr->sa.sa_family;
+    arp->hwlen = 0;
+
+    if (addr->sa.sa_family == AF_INET)
+      arp->addr.addr.addr4.s_addr = addr->in.sin_addr.s_addr;
 #ifdef HAVE_IPV6
-      else
-	memcpy(&arp->addr.addr.addr6, &addr->in6.sin6_addr, IN6ADDRSZ);
+    else
+      memcpy(&arp->addr.addr.addr6, &addr->in6.sin6_addr, IN6ADDRSZ);
 #endif
-    }
-	  
-   return 0;
+  }
+
+  return 0;
 }
 
 int do_arp_script_run(void)
 {
   struct arp_record *arp;
-  
+
   /* Notify any which went, then move to free list */
-  if (old)
-    {
+  if (old) {
 #ifdef HAVE_SCRIPT
-      if (option_bool(OPT_SCRIPT_ARP))
-	queue_arp(ACTION_ARP_DEL, old->hwaddr, old->hwlen, old->family, &old->addr);
-#endif
-      arp = old;
-      old = arp->next;
-      arp->next = freelist;
-      freelist = arp;
-      return 1;
-    }
+    if (option_bool(OPT_SCRIPT_ARP))
+      queue_arp(ACTION_ARP_DEL, old->hwaddr, old->hwlen, old->family,
+                &old->addr);
+#endif
+    arp = old;
+    old = arp->next;
+    arp->next = freelist;
+    freelist = arp;
+    return 1;
+  }
 
   for (arp = arps; arp; arp = arp->next)
-    if (arp->status == ARP_NEW)
-      {
+    if (arp->status == ARP_NEW) {
 #ifdef HAVE_SCRIPT
-	if (option_bool(OPT_SCRIPT_ARP))
-	  queue_arp(ACTION_ARP, arp->hwaddr, arp->hwlen, arp->family, &arp->addr);
+      if (option_bool(OPT_SCRIPT_ARP))
+        queue_arp(ACTION_ARP, arp->hwaddr, arp->hwlen, arp->family, &arp->addr);
 #endif
-	arp->status = ARP_FOUND;
-	return 1;
-      }
+      arp->status = ARP_FOUND;
+      return 1;
+    }
 
   return 0;
 }
-
-
Index: dnsmasq-2.78/src/auth.c
===================================================================
--- dnsmasq-2.78.orig/src/auth.c	2017-10-02 21:13:51.000000000 +0800
+++ dnsmasq-2.78/src/auth.c	2018-10-29 16:14:19.349440022 +0800
@@ -18,48 +18,52 @@
 
 #ifdef HAVE_AUTH
 
-static struct addrlist *find_addrlist(struct addrlist *list, int flag, struct all_addr *addr_u)
+static struct addrlist *find_addrlist(struct addrlist *list, int flag,
+                                      struct all_addr *addr_u)
 {
   do {
-    if (!(list->flags & ADDRLIST_IPV6))
-      {
-	struct in_addr netmask, addr = addr_u->addr.addr4;
-	
-	if (!(flag & F_IPV4))
-	  continue;
-	
-	netmask.s_addr = htonl(~(in_addr_t)0 << (32 - list->prefixlen));
-	
-	if  (is_same_net(addr, list->addr.addr.addr4, netmask))
-	  return list;
-      }
+    if (!(list->flags & ADDRLIST_IPV6)) {
+      struct in_addr netmask, addr = addr_u->addr.addr4;
+
+      if (!(flag & F_IPV4))
+        continue;
+
+      netmask.s_addr = htonl(~(in_addr_t) 0 << (32 - list->prefixlen));
+
+      if (is_same_net(addr, list->addr.addr.addr4, netmask))
+        return list;
+    }
 #ifdef HAVE_IPV6
-    else if (is_same_net6(&(addr_u->addr.addr6), &list->addr.addr.addr6, list->prefixlen))
+    else if (is_same_net6
+             (&(addr_u->addr.addr6), &list->addr.addr.addr6, list->prefixlen))
       return list;
 #endif
-    
+
   } while ((list = list->next));
-  
+
   return NULL;
 }
 
-static struct addrlist *find_subnet(struct auth_zone *zone, int flag, struct all_addr *addr_u)
+static struct addrlist *find_subnet(struct auth_zone *zone, int flag,
+                                    struct all_addr *addr_u)
 {
   if (!zone->subnet)
     return NULL;
-  
+
   return find_addrlist(zone->subnet, flag, addr_u);
 }
 
-static struct addrlist *find_exclude(struct auth_zone *zone, int flag, struct all_addr *addr_u)
+static struct addrlist *find_exclude(struct auth_zone *zone, int flag,
+                                     struct all_addr *addr_u)
 {
   if (!zone->exclude)
     return NULL;
-  
+
   return find_addrlist(zone->exclude, flag, addr_u);
 }
 
-static int filter_zone(struct auth_zone *zone, int flag, struct all_addr *addr_u)
+static int filter_zone(struct auth_zone *zone, int flag,
+                       struct all_addr *addr_u)
 {
   if (find_exclude(zone, flag, addr_u))
     return 0;
@@ -67,7 +71,7 @@
   /* No subnets specified, no filter */
   if (!zone->subnet)
     return 1;
-  
+
   return find_subnet(zone, flag, addr_u) != NULL;
 }
 
@@ -78,28 +82,27 @@
 
   if (cut)
     *cut = NULL;
-  
-  if (namelen >= domainlen && 
-      hostname_isequal(zone->domain, &name[namelen - domainlen]))
-    {
-      
-      if (namelen == domainlen)
-	return 1;
-      
-      if (name[namelen - domainlen - 1] == '.')
-	{
-	  if (cut)
-	    *cut = &name[namelen - domainlen - 1]; 
-	  return 1;
-	}
+
+  if (namelen >= domainlen &&
+      hostname_isequal(zone->domain, &name[namelen - domainlen])) {
+
+    if (namelen == domainlen)
+      return 1;
+
+    if (name[namelen - domainlen - 1] == '.') {
+      if (cut)
+        *cut = &name[namelen - domainlen - 1];
+      return 1;
     }
+  }
 
   return 0;
 }
 
 
-size_t answer_auth(struct dns_header *header, char *limit, size_t qlen, time_t now, union mysockaddr *peer_addr, 
-		   int local_query, int do_bit, int have_pseudoheader) 
+size_t answer_auth(struct dns_header * header, char *limit, size_t qlen,
+                   time_t now, union mysockaddr * peer_addr, int local_query,
+                   int do_bit, int have_pseudoheader)
 {
   char *name = daemon->namebuff;
   unsigned char *p, *ansp;
@@ -107,7 +110,7 @@
   int nameoffset, axfroffset = 0;
   int q, anscount = 0, authcount = 0;
   struct crec *crecp;
-  int  auth = !local_query, trunc = 0, nxdomain = 1, soa = 0, ns = 0, axfr = 0;
+  int auth = !local_query, trunc = 0, nxdomain = 1, soa = 0, ns = 0, axfr = 0;
   struct auth_zone *zone = NULL;
   struct addrlist *subnet = NULL;
   char *cut;
@@ -118,756 +121,718 @@
   struct all_addr addr;
   struct cname *a, *candidate;
   unsigned int wclen;
-  
-  if (ntohs(header->qdcount) == 0 || OPCODE(header) != QUERY )
+
+  if (ntohs(header->qdcount) == 0 || OPCODE(header) != QUERY)
     return 0;
 
   /* determine end of question section (we put answers there) */
   if (!(ansp = skip_questions(header, qlen)))
-    return 0; /* bad packet */
-  
+    return 0;                   /* bad packet */
+
   /* now process each question, answers go in RRs after the question */
-  p = (unsigned char *)(header+1);
+  p = (unsigned char *) (header + 1);
+
+  for (q = ntohs(header->qdcount); q != 0; q--) {
+    unsigned short flag = 0;
+    int found = 0;
+    int cname_wildcard = 0;
+
+    /* save pointer to name for copying into answers */
+    nameoffset = p - (unsigned char *) header;
+
+    /* now extract name as .-concatenated string into name */
+    if (!extract_name(header, qlen, &p, name, 1, 4))
+      return 0;                 /* bad packet */
+
+    GETSHORT(qtype, p);
+    GETSHORT(qclass, p);
+
+    if (qclass != C_IN) {
+      auth = 0;
+      continue;
+    }
+
+    if ((qtype == T_PTR || qtype == T_SOA || qtype == T_NS) &&
+        (flag = in_arpa_name_2_addr(name, &addr)) && !local_query) {
+      for (zone = daemon->auth_zones; zone; zone = zone->next)
+        if ((subnet = find_subnet(zone, flag, &addr)))
+          break;
+
+      if (!zone) {
+        auth = 0;
+        continue;
+      } else if (qtype == T_SOA)
+        soa = 1, found = 1;
+      else if (qtype == T_NS)
+        ns = 1, found = 1;
+    }
+
+    if (qtype == T_PTR && flag) {
+      intr = NULL;
 
-  for (q = ntohs(header->qdcount); q != 0; q--)
-    {
-      unsigned short flag = 0;
-      int found = 0;
-      int cname_wildcard = 0;
-  
-      /* save pointer to name for copying into answers */
-      nameoffset = p - (unsigned char *)header;
-
-      /* now extract name as .-concatenated string into name */
-      if (!extract_name(header, qlen, &p, name, 1, 4))
-	return 0; /* bad packet */
- 
-      GETSHORT(qtype, p); 
-      GETSHORT(qclass, p);
-      
-      if (qclass != C_IN)
-	{
-	  auth = 0;
-	  continue;
-	}
-
-      if ((qtype == T_PTR || qtype == T_SOA || qtype == T_NS) &&
-	  (flag = in_arpa_name_2_addr(name, &addr)) &&
-	  !local_query)
-	{
-	  for (zone = daemon->auth_zones; zone; zone = zone->next)
-	    if ((subnet = find_subnet(zone, flag, &addr)))
-	      break;
-	  
-	  if (!zone)
-	    {
-	      auth = 0;
-	      continue;
-	    }
-	  else if (qtype == T_SOA)
-	    soa = 1, found = 1;
-	  else if (qtype == T_NS)
-	    ns = 1, found = 1;
-	}
-
-      if (qtype == T_PTR && flag)
-	{
-	  intr = NULL;
-
-	  if (flag == F_IPV4)
-	    for (intr = daemon->int_names; intr; intr = intr->next)
-	      {
-		struct addrlist *addrlist;
-		
-		for (addrlist = intr->addr; addrlist; addrlist = addrlist->next)
-		  if (!(addrlist->flags & ADDRLIST_IPV6) && addr.addr.addr4.s_addr == addrlist->addr.addr.addr4.s_addr)
-		    break;
-		
-		if (addrlist)
-		  break;
-		else
-		  while (intr->next && strcmp(intr->intr, intr->next->intr) == 0)
-		    intr = intr->next;
-	      }
+      if (flag == F_IPV4)
+        for (intr = daemon->int_names; intr; intr = intr->next) {
+          struct addrlist *addrlist;
+
+          for (addrlist = intr->addr; addrlist; addrlist = addrlist->next)
+            if (!(addrlist->flags & ADDRLIST_IPV6)
+                && addr.addr.addr4.s_addr == addrlist->addr.addr.addr4.s_addr)
+              break;
+
+          if (addrlist)
+            break;
+          else
+            while (intr->next && strcmp(intr->intr, intr->next->intr) == 0)
+              intr = intr->next;
+        }
 #ifdef HAVE_IPV6
-	  else if (flag == F_IPV6)
-	    for (intr = daemon->int_names; intr; intr = intr->next)
-	      {
-		struct addrlist *addrlist;
-		
-		for (addrlist = intr->addr; addrlist; addrlist = addrlist->next)
-		  if ((addrlist->flags & ADDRLIST_IPV6) && IN6_ARE_ADDR_EQUAL(&addr.addr.addr6, &addrlist->addr.addr.addr6))
-		    break;
-		
-		if (addrlist)
-		  break;
-		else
-		  while (intr->next && strcmp(intr->intr, intr->next->intr) == 0)
-		    intr = intr->next;
-	      }
-#endif
-	  
-	  if (intr)
-	    {
-	      if (local_query || in_zone(zone, intr->name, NULL))
-		{	
-		  found = 1;
-		  log_query(flag | F_REVERSE | F_CONFIG, intr->name, &addr, NULL);
-		  if (add_resource_record(header, limit, &trunc, nameoffset, &ansp, 
-					  daemon->auth_ttl, NULL,
-					  T_PTR, C_IN, "d", intr->name))
-		    anscount++;
-		}
-	    }
-	  
-	  if ((crecp = cache_find_by_addr(NULL, &addr, now, flag)))
-	    do { 
-	      strcpy(name, cache_get_name(crecp));
-	      
-	      if (crecp->flags & F_DHCP && !option_bool(OPT_DHCP_FQDN))
-		{
-		  char *p = strchr(name, '.');
-		  if (p)
-		    *p = 0; /* must be bare name */
-		  
-		  /* add  external domain */
-		  if (zone)
-		    {
-		      strcat(name, ".");
-		      strcat(name, zone->domain);
-		    }
-		  log_query(flag | F_DHCP | F_REVERSE, name, &addr, record_source(crecp->uid));
-		  found = 1;
-		  if (add_resource_record(header, limit, &trunc, nameoffset, &ansp, 
-					  daemon->auth_ttl, NULL,
-					  T_PTR, C_IN, "d", name))
-		    anscount++;
-		}
-	      else if (crecp->flags & (F_DHCP | F_HOSTS) && (local_query || in_zone(zone, name, NULL)))
-		{
-		  log_query(crecp->flags & ~F_FORWARD, name, &addr, record_source(crecp->uid));
-		  found = 1;
-		  if (add_resource_record(header, limit, &trunc, nameoffset, &ansp, 
-					  daemon->auth_ttl, NULL,
-					  T_PTR, C_IN, "d", name))
-		    anscount++;
-		}
-	      else
-		continue;
-		    
-	    } while ((crecp = cache_find_by_addr(crecp, &addr, now, flag)));
-
-	  if (found)
-	    nxdomain = 0;
-	  else
-	    log_query(flag | F_NEG | F_NXDOMAIN | F_REVERSE | (auth ? F_AUTH : 0), NULL, &addr, NULL);
-
-	  continue;
-	}
-      
-    cname_restart:
+      else if (flag == F_IPV6)
+        for (intr = daemon->int_names; intr; intr = intr->next) {
+          struct addrlist *addrlist;
+
+          for (addrlist = intr->addr; addrlist; addrlist = addrlist->next)
+            if ((addrlist->flags & ADDRLIST_IPV6)
+                && IN6_ARE_ADDR_EQUAL(&addr.addr.addr6,
+                                      &addrlist->addr.addr.addr6))
+              break;
+
+          if (addrlist)
+            break;
+          else
+            while (intr->next && strcmp(intr->intr, intr->next->intr) == 0)
+              intr = intr->next;
+        }
+#endif
+
+      if (intr) {
+        if (local_query || in_zone(zone, intr->name, NULL)) {
+          found = 1;
+          log_query(flag | F_REVERSE | F_CONFIG, intr->name, &addr, NULL);
+          if (add_resource_record(header, limit, &trunc, nameoffset, &ansp,
+                                  daemon->auth_ttl, NULL,
+                                  T_PTR, C_IN, "d", intr->name))
+            anscount++;
+        }
+      }
+
+      if ((crecp = cache_find_by_addr(NULL, &addr, now, flag)))
+        do {
+          strcpy(name, cache_get_name(crecp));
+
+          if (crecp->flags & F_DHCP && !option_bool(OPT_DHCP_FQDN)) {
+            char *p = strchr(name, '.');
+            if (p)
+              *p = 0;           /* must be bare name */
+
+            /* add  external domain */
+            if (zone) {
+              strcat(name, ".");
+              strcat(name, zone->domain);
+            }
+            log_query(flag | F_DHCP | F_REVERSE, name, &addr,
+                      record_source(crecp->uid));
+            found = 1;
+            if (add_resource_record(header, limit, &trunc, nameoffset, &ansp,
+                                    daemon->auth_ttl, NULL,
+                                    T_PTR, C_IN, "d", name))
+              anscount++;
+          } else if (crecp->flags & (F_DHCP | F_HOSTS)
+                     && (local_query || in_zone(zone, name, NULL))) {
+            log_query(crecp->flags & ~F_FORWARD, name, &addr,
+                      record_source(crecp->uid));
+            found = 1;
+            if (add_resource_record(header, limit, &trunc, nameoffset, &ansp,
+                                    daemon->auth_ttl, NULL,
+                                    T_PTR, C_IN, "d", name))
+              anscount++;
+          } else
+            continue;
+
+        } while ((crecp = cache_find_by_addr(crecp, &addr, now, flag)));
+
       if (found)
-	/* NS and SOA .arpa requests have set found above. */
-	cut = NULL;
+        nxdomain = 0;
       else
-	{
-	  for (zone = daemon->auth_zones; zone; zone = zone->next)
-	    if (in_zone(zone, name, &cut))
-	      break;
-	  
-	  if (!zone)
-	    {
-	      auth = 0;
-	      continue;
-	    }
-	}
+        log_query(flag | F_NEG | F_NXDOMAIN | F_REVERSE | (auth ? F_AUTH : 0),
+                  NULL, &addr, NULL);
 
-      for (rec = daemon->mxnames; rec; rec = rec->next)
-	if (!rec->issrv && hostname_isequal(name, rec->name))
-	  {
-	    nxdomain = 0;
-	         
-	    if (qtype == T_MX)
-	      {
-		found = 1;
-		log_query(F_CONFIG | F_RRNAME, name, NULL, "<MX>"); 
-		if (add_resource_record(header, limit, &trunc, nameoffset, &ansp, daemon->auth_ttl,
-					NULL, T_MX, C_IN, "sd", rec->weight, rec->target))
-		  anscount++;
-	      }
-	  }
-      
-      for (move = NULL, up = &daemon->mxnames, rec = daemon->mxnames; rec; rec = rec->next)
-	if (rec->issrv && hostname_isequal(name, rec->name))
-	  {
-	    nxdomain = 0;
-	    
-	    if (qtype == T_SRV)
-	      {
-		found = 1;
-		log_query(F_CONFIG | F_RRNAME, name, NULL, "<SRV>"); 
-		if (add_resource_record(header, limit, &trunc, nameoffset, &ansp, daemon->auth_ttl,
-					NULL, T_SRV, C_IN, "sssd", 
-					rec->priority, rec->weight, rec->srvport, rec->target))
-
-		  anscount++;
-	      } 
-	    
-	    /* unlink first SRV record found */
-	    if (!move)
-	      {
-		move = rec;
-		*up = rec->next;
-	      }
-	    else
-	      up = &rec->next;      
-	  }
-	else
-	  up = &rec->next;
-	  
-      /* put first SRV record back at the end. */
-      if (move)
-	{
-	  *up = move;
-	  move->next = NULL;
-	}
+      continue;
+    }
+
+  cname_restart:
+    if (found)
+      /* NS and SOA .arpa requests have set found above. */
+      cut = NULL;
+    else {
+      for (zone = daemon->auth_zones; zone; zone = zone->next)
+        if (in_zone(zone, name, &cut))
+          break;
+
+      if (!zone) {
+        auth = 0;
+        continue;
+      }
+    }
+
+    for (rec = daemon->mxnames; rec; rec = rec->next)
+      if (!rec->issrv && hostname_isequal(name, rec->name)) {
+        nxdomain = 0;
+
+        if (qtype == T_MX) {
+          found = 1;
+          log_query(F_CONFIG | F_RRNAME, name, NULL, "<MX>");
+          if (add_resource_record
+              (header, limit, &trunc, nameoffset, &ansp, daemon->auth_ttl, NULL,
+               T_MX, C_IN, "sd", rec->weight, rec->target))
+            anscount++;
+        }
+      }
+
+    for (move = NULL, up = &daemon->mxnames, rec = daemon->mxnames; rec;
+         rec = rec->next)
+      if (rec->issrv && hostname_isequal(name, rec->name)) {
+        nxdomain = 0;
+
+        if (qtype == T_SRV) {
+          found = 1;
+          log_query(F_CONFIG | F_RRNAME, name, NULL, "<SRV>");
+          if (add_resource_record
+              (header, limit, &trunc, nameoffset, &ansp, daemon->auth_ttl, NULL,
+               T_SRV, C_IN, "sssd", rec->priority, rec->weight, rec->srvport,
+               rec->target))
+
+            anscount++;
+        }
+
+        /* unlink first SRV record found */
+        if (!move) {
+          move = rec;
+          *up = rec->next;
+        } else
+          up = &rec->next;
+      } else
+        up = &rec->next;
+
+    /* put first SRV record back at the end. */
+    if (move) {
+      *up = move;
+      move->next = NULL;
+    }
+
+    for (txt = daemon->rr; txt; txt = txt->next)
+      if (hostname_isequal(name, txt->name)) {
+        nxdomain = 0;
+        if (txt->class == qtype) {
+          found = 1;
+          log_query(F_CONFIG | F_RRNAME, name, NULL, "<RR>");
+          if (add_resource_record
+              (header, limit, &trunc, nameoffset, &ansp, daemon->auth_ttl, NULL,
+               txt->class, C_IN, "t", txt->len, txt->txt))
+            anscount++;
+        }
+      }
+
+    for (txt = daemon->txt; txt; txt = txt->next)
+      if (txt->class == C_IN && hostname_isequal(name, txt->name)) {
+        nxdomain = 0;
+        if (qtype == T_TXT) {
+          found = 1;
+          log_query(F_CONFIG | F_RRNAME, name, NULL, "<TXT>");
+          if (add_resource_record
+              (header, limit, &trunc, nameoffset, &ansp, daemon->auth_ttl, NULL,
+               T_TXT, C_IN, "t", txt->len, txt->txt))
+            anscount++;
+        }
+      }
+
+    for (na = daemon->naptr; na; na = na->next)
+      if (hostname_isequal(name, na->name)) {
+        nxdomain = 0;
+        if (qtype == T_NAPTR) {
+          found = 1;
+          log_query(F_CONFIG | F_RRNAME, name, NULL, "<NAPTR>");
+          if (add_resource_record
+              (header, limit, &trunc, nameoffset, &ansp, daemon->auth_ttl, NULL,
+               T_NAPTR, C_IN, "sszzzd", na->order, na->pref, na->flags,
+               na->services, na->regexp, na->replace))
+            anscount++;
+        }
+      }
+
+    if (qtype == T_A)
+      flag = F_IPV4;
 
-      for (txt = daemon->rr; txt; txt = txt->next)
-	if (hostname_isequal(name, txt->name))
-	  {
-	    nxdomain = 0;
-	    if (txt->class == qtype)
-	      {
-		found = 1;
-		log_query(F_CONFIG | F_RRNAME, name, NULL, "<RR>"); 
-		if (add_resource_record(header, limit, &trunc, nameoffset, &ansp, daemon->auth_ttl,
-					NULL, txt->class, C_IN, "t", txt->len, txt->txt))
-		  anscount++;
-	      }
-	  }
-      
-      for (txt = daemon->txt; txt; txt = txt->next)
-	if (txt->class == C_IN && hostname_isequal(name, txt->name))
-	  {
-	    nxdomain = 0;
-	    if (qtype == T_TXT)
-	      {
-		found = 1;
-		log_query(F_CONFIG | F_RRNAME, name, NULL, "<TXT>"); 
-		if (add_resource_record(header, limit, &trunc, nameoffset, &ansp, daemon->auth_ttl,
-					NULL, T_TXT, C_IN, "t", txt->len, txt->txt))
-		  anscount++;
-	      }
-	  }
-
-       for (na = daemon->naptr; na; na = na->next)
-	 if (hostname_isequal(name, na->name))
-	   {
-	     nxdomain = 0;
-	     if (qtype == T_NAPTR)
-	       {
-		 found = 1;
-		 log_query(F_CONFIG | F_RRNAME, name, NULL, "<NAPTR>");
-		 if (add_resource_record(header, limit, &trunc, nameoffset, &ansp, daemon->auth_ttl, 
-					 NULL, T_NAPTR, C_IN, "sszzzd", 
-					 na->order, na->pref, na->flags, na->services, na->regexp, na->replace))
-			  anscount++;
-	       }
-	   }
-    
-       if (qtype == T_A)
-	 flag = F_IPV4;
-       
 #ifdef HAVE_IPV6
-       if (qtype == T_AAAA)
-	 flag = F_IPV6;
+    if (qtype == T_AAAA)
+      flag = F_IPV6;
 #endif
-       
-       for (intr = daemon->int_names; intr; intr = intr->next)
-	 if (hostname_isequal(name, intr->name))
-	   {
-	     struct addrlist *addrlist;
-	     
-	     nxdomain = 0;
-	     
-	     if (flag)
-	       for (addrlist = intr->addr; addrlist; addrlist = addrlist->next)  
-		 if (((addrlist->flags & ADDRLIST_IPV6)  ? T_AAAA : T_A) == qtype &&
-		     (local_query || filter_zone(zone, flag, &addrlist->addr)))
-		   {
+
+    for (intr = daemon->int_names; intr; intr = intr->next)
+      if (hostname_isequal(name, intr->name)) {
+        struct addrlist *addrlist;
+
+        nxdomain = 0;
+
+        if (flag)
+          for (addrlist = intr->addr; addrlist; addrlist = addrlist->next)
+            if (((addrlist->flags & ADDRLIST_IPV6) ? T_AAAA : T_A) == qtype &&
+                (local_query || filter_zone(zone, flag, &addrlist->addr))) {
 #ifdef HAVE_IPV6
-		     if (addrlist->flags & ADDRLIST_REVONLY)
-		       continue;
+              if (addrlist->flags & ADDRLIST_REVONLY)
+                continue;
 #endif
-		     found = 1;
-		     log_query(F_FORWARD | F_CONFIG | flag, name, &addrlist->addr, NULL);
-		     if (add_resource_record(header, limit, &trunc, nameoffset, &ansp, 
-					     daemon->auth_ttl, NULL, qtype, C_IN, 
-					     qtype == T_A ? "4" : "6", &addrlist->addr))
-		       anscount++;
-		   }
-	     }
-       
-      if (!cut)
-	{
-	  nxdomain = 0;
-	  
-	  if (qtype == T_SOA)
-	    {
-	      auth = soa = 1; /* inhibits auth section */
-	      found = 1;
-	      log_query(F_RRNAME | F_AUTH, zone->domain, NULL, "<SOA>");
-	    }
-      	  else if (qtype == T_AXFR)
-	    {
-	      struct iname *peers;
-	      
-	      if (peer_addr->sa.sa_family == AF_INET)
-		peer_addr->in.sin_port = 0;
+              found = 1;
+              log_query(F_FORWARD | F_CONFIG | flag, name, &addrlist->addr,
+                        NULL);
+              if (add_resource_record
+                  (header, limit, &trunc, nameoffset, &ansp, daemon->auth_ttl,
+                   NULL, qtype, C_IN, qtype == T_A ? "4" : "6",
+                   &addrlist->addr))
+                anscount++;
+            }
+      }
+
+    if (!cut) {
+      nxdomain = 0;
+
+      if (qtype == T_SOA) {
+        auth = soa = 1;         /* inhibits auth section */
+        found = 1;
+        log_query(F_RRNAME | F_AUTH, zone->domain, NULL, "<SOA>");
+      } else if (qtype == T_AXFR) {
+        struct iname *peers;
+
+        if (peer_addr->sa.sa_family == AF_INET)
+          peer_addr->in.sin_port = 0;
 #ifdef HAVE_IPV6
-	      else
-		{
-		  peer_addr->in6.sin6_port = 0; 
-		  peer_addr->in6.sin6_scope_id = 0;
-		}
-#endif
-	      
-	      for (peers = daemon->auth_peers; peers; peers = peers->next)
-		if (sockaddr_isequal(peer_addr, &peers->addr))
-		  break;
-	      
-	      /* Refuse all AXFR unless --auth-sec-servers is set */
-	      if ((!peers && daemon->auth_peers) || !daemon->secondary_forward_server)
-		{
-		  if (peer_addr->sa.sa_family == AF_INET)
-		    inet_ntop(AF_INET, &peer_addr->in.sin_addr, daemon->addrbuff, ADDRSTRLEN);
+        else {
+          peer_addr->in6.sin6_port = 0;
+          peer_addr->in6.sin6_scope_id = 0;
+        }
+#endif
+
+        for (peers = daemon->auth_peers; peers; peers = peers->next)
+          if (sockaddr_isequal(peer_addr, &peers->addr))
+            break;
+
+        /* Refuse all AXFR unless --auth-sec-servers is set */
+        if ((!peers && daemon->auth_peers) || !daemon->secondary_forward_server) {
+          if (peer_addr->sa.sa_family == AF_INET)
+            inet_ntop(AF_INET, &peer_addr->in.sin_addr, daemon->addrbuff,
+                      ADDRSTRLEN);
 #ifdef HAVE_IPV6
-		  else
-		    inet_ntop(AF_INET6, &peer_addr->in6.sin6_addr, daemon->addrbuff, ADDRSTRLEN); 
+          else
+            inet_ntop(AF_INET6, &peer_addr->in6.sin6_addr, daemon->addrbuff,
+                      ADDRSTRLEN);
 #endif
-		  
-		  my_syslog(LOG_WARNING, _("ignoring zone transfer request from %s"), daemon->addrbuff);
-		  return 0;
-		}
-	       	      
-	      auth = 1;
-	      soa = 1; /* inhibits auth section */
-	      ns = 1; /* ensure we include NS records! */
-	      axfr = 1;
-	      found = 1;
-	      axfroffset = nameoffset;
-	      log_query(F_RRNAME | F_AUTH, zone->domain, NULL, "<AXFR>");
-	    }
-      	  else if (qtype == T_NS)
-	    {
-	      auth = 1;
-	      ns = 1; /* inhibits auth section */
-	      found = 1;
-	      log_query(F_RRNAME | F_AUTH, zone->domain, NULL, "<NS>"); 
-	    }
-	}
-      
-      if (!option_bool(OPT_DHCP_FQDN) && cut)
-	{	  
-	  *cut = 0; /* remove domain part */
-	  
-	  if (!strchr(name, '.') && (crecp = cache_find_by_name(NULL, name, now, F_IPV4 | F_IPV6)))
-	    {
-	      if (crecp->flags & F_DHCP)
-		do
-		  { 
-		    nxdomain = 0;
-		    if ((crecp->flags & flag) && 
-			(local_query || filter_zone(zone, flag, &(crecp->addr.addr))))
-		      {
-			*cut = '.'; /* restore domain part */
-			log_query(crecp->flags, name, &crecp->addr.addr, record_source(crecp->uid));
-			*cut  = 0; /* remove domain part */
-			found = 1;
-			if (add_resource_record(header, limit, &trunc, nameoffset, &ansp, 
-						daemon->auth_ttl, NULL, qtype, C_IN, 
-						qtype == T_A ? "4" : "6", &crecp->addr))
-			  anscount++;
-		      }
-		  } while ((crecp = cache_find_by_name(crecp, name, now,  F_IPV4 | F_IPV6)));
-	    }
-       	  
-	  *cut = '.'; /* restore domain part */	    
-	}
-      
-      if ((crecp = cache_find_by_name(NULL, name, now, F_IPV4 | F_IPV6)))
-	{
-	  if ((crecp->flags & F_HOSTS) || (((crecp->flags & F_DHCP) && option_bool(OPT_DHCP_FQDN))))
-	    do
-	      { 
-		 nxdomain = 0;
-		 if ((crecp->flags & flag) && (local_query || filter_zone(zone, flag, &(crecp->addr.addr))))
-		   {
-		     log_query(crecp->flags, name, &crecp->addr.addr, record_source(crecp->uid));
-		     found = 1;
-		     if (add_resource_record(header, limit, &trunc, nameoffset, &ansp, 
-					     daemon->auth_ttl, NULL, qtype, C_IN, 
-					     qtype == T_A ? "4" : "6", &crecp->addr))
-		       anscount++;
-		   }
-	      } while ((crecp = cache_find_by_name(crecp, name, now, F_IPV4 | F_IPV6)));
-	}
-      
-      /* Only supply CNAME if no record for any type is known. */
-      if (nxdomain)
-	{
-	  /* Check for possible wildcard match against *.domain 
-	     return length of match, to get longest.
-	     Note that if return length of wildcard section, so
-	     we match b.simon to _both_ *.simon and b.simon
-	     but return a longer (better) match to b.simon.
-	  */  
-	  for (wclen = 0, candidate = NULL, a = daemon->cnames; a; a = a->next)
-	    if (a->alias[0] == '*')
-	      {
-		char *test = name;
-		
-		while ((test = strchr(test+1, '.')))
-		  {
-		    if (hostname_isequal(test, &(a->alias[1])))
-		      {
-			if (strlen(test) > wclen && !cname_wildcard)
-			  {
-			    wclen = strlen(test);
-			    candidate = a;
-			    cname_wildcard = 1;
-			  }
-			break;
-		      }
-		  }
-		
-	      }
-	    else if (hostname_isequal(a->alias, name) && strlen(a->alias) > wclen)
-	      {
-		/* Simple case, no wildcard */
-		wclen = strlen(a->alias);
-		candidate = a;
-	      }
-	  
-	  if (candidate)
-	    {
-	      log_query(F_CONFIG | F_CNAME, name, NULL, NULL);
-	      strcpy(name, candidate->target);
-	      if (!strchr(name, '.'))
-		{
-		  strcat(name, ".");
-		  strcat(name, zone->domain);
-		}
-	      found = 1;
-	      if (add_resource_record(header, limit, &trunc, nameoffset, &ansp, 
-				      daemon->auth_ttl, &nameoffset,
-				      T_CNAME, C_IN, "d", name))
-		anscount++;
-	      
-	      goto cname_restart;
-	    }
-
-	  log_query(flag | F_NEG | (nxdomain ? F_NXDOMAIN : 0) | F_FORWARD | F_AUTH, name, NULL, NULL);
-	}
-      
+
+          my_syslog(LOG_WARNING, _("ignoring zone transfer request from %s"),
+                    daemon->addrbuff);
+          return 0;
+        }
+
+        auth = 1;
+        soa = 1;                /* inhibits auth section */
+        ns = 1;                 /* ensure we include NS records! */
+        axfr = 1;
+        found = 1;
+        axfroffset = nameoffset;
+        log_query(F_RRNAME | F_AUTH, zone->domain, NULL, "<AXFR>");
+      } else if (qtype == T_NS) {
+        auth = 1;
+        ns = 1;                 /* inhibits auth section */
+        found = 1;
+        log_query(F_RRNAME | F_AUTH, zone->domain, NULL, "<NS>");
+      }
+    }
+
+    if (!option_bool(OPT_DHCP_FQDN) && cut) {
+      *cut = 0;                 /* remove domain part */
+
+      if (!strchr(name, '.')
+          && (crecp = cache_find_by_name(NULL, name, now, F_IPV4 | F_IPV6))) {
+        if (crecp->flags & F_DHCP)
+          do {
+            nxdomain = 0;
+            if ((crecp->flags & flag) &&
+                (local_query || filter_zone(zone, flag, &(crecp->addr.addr)))) {
+              *cut = '.';       /* restore domain part */
+              log_query(crecp->flags, name, &crecp->addr.addr,
+                        record_source(crecp->uid));
+              *cut = 0;         /* remove domain part */
+              found = 1;
+              if (add_resource_record(header, limit, &trunc, nameoffset, &ansp,
+                                      daemon->auth_ttl, NULL, qtype, C_IN,
+                                      qtype == T_A ? "4" : "6", &crecp->addr))
+                anscount++;
+            }
+          } while ((crecp =
+                    cache_find_by_name(crecp, name, now, F_IPV4 | F_IPV6)));
+      }
+
+      *cut = '.';               /* restore domain part */
+    }
+
+    if ((crecp = cache_find_by_name(NULL, name, now, F_IPV4 | F_IPV6))) {
+      if ((crecp->flags & F_HOSTS)
+          || (((crecp->flags & F_DHCP) && option_bool(OPT_DHCP_FQDN))))
+        do {
+          nxdomain = 0;
+          if ((crecp->flags & flag)
+              && (local_query
+                  || filter_zone(zone, flag, &(crecp->addr.addr)))) {
+            log_query(crecp->flags, name, &crecp->addr.addr,
+                      record_source(crecp->uid));
+            found = 1;
+            if (add_resource_record(header, limit, &trunc, nameoffset, &ansp,
+                                    daemon->auth_ttl, NULL, qtype, C_IN,
+                                    qtype == T_A ? "4" : "6", &crecp->addr))
+              anscount++;
+          }
+        } while ((crecp =
+                  cache_find_by_name(crecp, name, now, F_IPV4 | F_IPV6)));
+    }
+
+    /* Only supply CNAME if no record for any type is known. */
+    if (nxdomain) {
+      /* Check for possible wildcard match against *.domain
+         return length of match, to get longest.
+         Note that if return length of wildcard section, so
+         we match b.simon to _both_ *.simon and b.simon
+         but return a longer (better) match to b.simon.
+       */
+      for (wclen = 0, candidate = NULL, a = daemon->cnames; a; a = a->next)
+        if (a->alias[0] == '*') {
+          char *test = name;
+
+          while ((test = strchr(test + 1, '.'))) {
+            if (hostname_isequal(test, &(a->alias[1]))) {
+              if (strlen(test) > wclen && !cname_wildcard) {
+                wclen = strlen(test);
+                candidate = a;
+                cname_wildcard = 1;
+              }
+              break;
+            }
+          }
+
+        } else if (hostname_isequal(a->alias, name) && strlen(a->alias) > wclen) {
+          /* Simple case, no wildcard */
+          wclen = strlen(a->alias);
+          candidate = a;
+        }
+
+      if (candidate) {
+        log_query(F_CONFIG | F_CNAME, name, NULL, NULL);
+        strcpy(name, candidate->target);
+        if (!strchr(name, '.')) {
+          strcat(name, ".");
+          strcat(name, zone->domain);
+        }
+        found = 1;
+        if (add_resource_record(header, limit, &trunc, nameoffset, &ansp,
+                                daemon->auth_ttl, &nameoffset,
+                                T_CNAME, C_IN, "d", name))
+          anscount++;
+
+        goto cname_restart;
+      }
+
+      log_query(flag | F_NEG | (nxdomain ? F_NXDOMAIN : 0) | F_FORWARD | F_AUTH,
+                name, NULL, NULL);
     }
-  
+
+  }
+
   /* Add auth section */
-  if (auth && zone)
-    {
-      char *authname;
-      int newoffset, offset = 0;
+  if (auth && zone) {
+    char *authname;
+    int newoffset, offset = 0;
+
+    if (!subnet)
+      authname = zone->domain;
+    else {
+      /* handle NS and SOA for PTR records */
+
+      authname = name;
+
+      if (!(subnet->flags & ADDRLIST_IPV6)) {
+        in_addr_t a = ntohl(subnet->addr.addr.addr4.s_addr) >> 8;
+        char *p = name;
+
+        if (subnet->prefixlen >= 24)
+          p += sprintf(p, "%u.", a & 0xff);
+        a = a >> 8;
+        if (subnet->prefixlen >= 16)
+          p += sprintf(p, "%u.", a & 0xff);
+        a = a >> 8;
+        p += sprintf(p, "%u.in-addr.arpa", a & 0xff);
 
-      if (!subnet)
-	authname = zone->domain;
-      else
-	{
-	  /* handle NS and SOA for PTR records */
-	  
-	  authname = name;
-
-	  if (!(subnet->flags & ADDRLIST_IPV6))
-	    {
-	      in_addr_t a = ntohl(subnet->addr.addr.addr4.s_addr) >> 8;
-	      char *p = name;
-	      
-	      if (subnet->prefixlen >= 24)
-		p += sprintf(p, "%u.", a & 0xff);
-	      a = a >> 8;
-	      if (subnet->prefixlen >= 16 )
-		p += sprintf(p, "%u.", a & 0xff);
-	      a = a >> 8;
-	      p += sprintf(p, "%u.in-addr.arpa", a & 0xff);
-	      
-	    }
+      }
 #ifdef HAVE_IPV6
-	  else
-	    {
-	      char *p = name;
-	      int i;
-	      
-	      for (i = subnet->prefixlen-1; i >= 0; i -= 4)
-		{ 
-		  int dig = ((unsigned char *)&subnet->addr.addr.addr6)[i>>3];
-		  p += sprintf(p, "%.1x.", (i>>2) & 1 ? dig & 15 : dig >> 4);
-		}
-	      p += sprintf(p, "ip6.arpa");
-	      
-	    }
-#endif
-	}
-      
-      /* handle NS and SOA in auth section or for explicit queries */
-       newoffset = ansp - (unsigned char *)header;
-       if (((anscount == 0 && !ns) || soa) &&
-	  add_resource_record(header, limit, &trunc, 0, &ansp, 
-			      daemon->auth_ttl, NULL, T_SOA, C_IN, "ddlllll",
-			      authname, daemon->authserver,  daemon->hostmaster,
-			      daemon->soa_sn, daemon->soa_refresh, 
-			      daemon->soa_retry, daemon->soa_expiry, 
-			      daemon->auth_ttl))
-	{
-	  offset = newoffset;
-	  if (soa)
-	    anscount++;
-	  else
-	    authcount++;
-	}
-      
-      if (anscount != 0 || ns)
-	{
-	  struct name_list *secondary;
-	  
-	  newoffset = ansp - (unsigned char *)header;
-	  if (add_resource_record(header, limit, &trunc, -offset, &ansp, 
-				  daemon->auth_ttl, NULL, T_NS, C_IN, "d", offset == 0 ? authname : NULL, daemon->authserver))
-	    {
-	      if (offset == 0) 
-		offset = newoffset;
-	      if (ns) 
-		anscount++;
-	      else
-		authcount++;
-	    }
-
-	  if (!subnet)
-	    for (secondary = daemon->secondary_forward_server; secondary; secondary = secondary->next)
-	      if (add_resource_record(header, limit, &trunc, offset, &ansp, 
-				      daemon->auth_ttl, NULL, T_NS, C_IN, "d", secondary->name))
-		{
-		  if (ns) 
-		    anscount++;
-		  else
-		    authcount++;
-		}
-	}
-      
-      if (axfr)
-	{
-	  for (rec = daemon->mxnames; rec; rec = rec->next)
-	    if (in_zone(zone, rec->name, &cut))
-	      {
-		if (cut)
-		   *cut = 0;
-
-		if (rec->issrv)
-		  {
-		    if (add_resource_record(header, limit, &trunc, -axfroffset, &ansp, daemon->auth_ttl,
-					    NULL, T_SRV, C_IN, "sssd", cut ? rec->name : NULL,
-					    rec->priority, rec->weight, rec->srvport, rec->target))
-		      
-		      anscount++;
-		  }
-		else
-		  {
-		    if (add_resource_record(header, limit, &trunc, -axfroffset, &ansp, daemon->auth_ttl,
-					    NULL, T_MX, C_IN, "sd", cut ? rec->name : NULL, rec->weight, rec->target))
-		      anscount++;
-		  }
-		
-		/* restore config data */
-		if (cut)
-		  *cut = '.';
-	      }
-	      
-	  for (txt = daemon->rr; txt; txt = txt->next)
-	    if (in_zone(zone, txt->name, &cut))
-	      {
-		if (cut)
-		  *cut = 0;
-		
-		if (add_resource_record(header, limit, &trunc, -axfroffset, &ansp, daemon->auth_ttl,
-					NULL, txt->class, C_IN, "t",  cut ? txt->name : NULL, txt->len, txt->txt))
-		  anscount++;
-		
-		/* restore config data */
-		if (cut)
-		  *cut = '.';
-	      }
-	  
-	  for (txt = daemon->txt; txt; txt = txt->next)
-	    if (txt->class == C_IN && in_zone(zone, txt->name, &cut))
-	      {
-		if (cut)
-		  *cut = 0;
-		
-		if (add_resource_record(header, limit, &trunc, -axfroffset, &ansp, daemon->auth_ttl,
-					NULL, T_TXT, C_IN, "t", cut ? txt->name : NULL, txt->len, txt->txt))
-		  anscount++;
-		
-		/* restore config data */
-		if (cut)
-		  *cut = '.';
-	      }
-	  
-	  for (na = daemon->naptr; na; na = na->next)
-	    if (in_zone(zone, na->name, &cut))
-	      {
-		if (cut)
-		  *cut = 0;
-		
-		if (add_resource_record(header, limit, &trunc, -axfroffset, &ansp, daemon->auth_ttl, 
-					NULL, T_NAPTR, C_IN, "sszzzd", cut ? na->name : NULL,
-					na->order, na->pref, na->flags, na->services, na->regexp, na->replace))
-		  anscount++;
-		
-		/* restore config data */
-		if (cut)
-		  *cut = '.'; 
-	      }
-	  
-	  for (intr = daemon->int_names; intr; intr = intr->next)
-	    if (in_zone(zone, intr->name, &cut))
-	      {
-		struct addrlist *addrlist;
-		
-		if (cut)
-		  *cut = 0;
-		
-		for (addrlist = intr->addr; addrlist; addrlist = addrlist->next) 
-		  if (!(addrlist->flags & ADDRLIST_IPV6) &&
-		      (local_query || filter_zone(zone, F_IPV4, &addrlist->addr)) && 
-		      add_resource_record(header, limit, &trunc, -axfroffset, &ansp, 
-					  daemon->auth_ttl, NULL, T_A, C_IN, "4", cut ? intr->name : NULL, &addrlist->addr))
-		    anscount++;
-		
+      else {
+        char *p = name;
+        int i;
+
+        for (i = subnet->prefixlen - 1; i >= 0; i -= 4) {
+          int dig = ((unsigned char *) &subnet->addr.addr.addr6)[i >> 3];
+          p += sprintf(p, "%.1x.", (i >> 2) & 1 ? dig & 15 : dig >> 4);
+        }
+        p += sprintf(p, "ip6.arpa");
+
+      }
+#endif
+    }
+
+    /* handle NS and SOA in auth section or for explicit queries */
+    newoffset = ansp - (unsigned char *) header;
+    if (((anscount == 0 && !ns) || soa) &&
+        add_resource_record(header, limit, &trunc, 0, &ansp,
+                            daemon->auth_ttl, NULL, T_SOA, C_IN, "ddlllll",
+                            authname, daemon->authserver, daemon->hostmaster,
+                            daemon->soa_sn, daemon->soa_refresh,
+                            daemon->soa_retry, daemon->soa_expiry,
+                            daemon->auth_ttl)) {
+      offset = newoffset;
+      if (soa)
+        anscount++;
+      else
+        authcount++;
+    }
+
+    if (anscount != 0 || ns) {
+      struct name_list *secondary;
+
+      newoffset = ansp - (unsigned char *) header;
+      if (add_resource_record(header, limit, &trunc, -offset, &ansp,
+                              daemon->auth_ttl, NULL, T_NS, C_IN, "d",
+                              offset == 0 ? authname : NULL,
+                              daemon->authserver)) {
+        if (offset == 0)
+          offset = newoffset;
+        if (ns)
+          anscount++;
+        else
+          authcount++;
+      }
+
+      if (!subnet)
+        for (secondary = daemon->secondary_forward_server; secondary;
+             secondary = secondary->next)
+          if (add_resource_record
+              (header, limit, &trunc, offset, &ansp, daemon->auth_ttl, NULL,
+               T_NS, C_IN, "d", secondary->name)) {
+            if (ns)
+              anscount++;
+            else
+              authcount++;
+          }
+    }
+
+    if (axfr) {
+      for (rec = daemon->mxnames; rec; rec = rec->next)
+        if (in_zone(zone, rec->name, &cut)) {
+          if (cut)
+            *cut = 0;
+
+          if (rec->issrv) {
+            if (add_resource_record
+                (header, limit, &trunc, -axfroffset, &ansp, daemon->auth_ttl,
+                 NULL, T_SRV, C_IN, "sssd", cut ? rec->name : NULL,
+                 rec->priority, rec->weight, rec->srvport, rec->target))
+
+              anscount++;
+          } else {
+            if (add_resource_record
+                (header, limit, &trunc, -axfroffset, &ansp, daemon->auth_ttl,
+                 NULL, T_MX, C_IN, "sd", cut ? rec->name : NULL, rec->weight,
+                 rec->target))
+              anscount++;
+          }
+
+          /* restore config data */
+          if (cut)
+            *cut = '.';
+        }
+
+      for (txt = daemon->rr; txt; txt = txt->next)
+        if (in_zone(zone, txt->name, &cut)) {
+          if (cut)
+            *cut = 0;
+
+          if (add_resource_record
+              (header, limit, &trunc, -axfroffset, &ansp, daemon->auth_ttl,
+               NULL, txt->class, C_IN, "t", cut ? txt->name : NULL, txt->len,
+               txt->txt))
+            anscount++;
+
+          /* restore config data */
+          if (cut)
+            *cut = '.';
+        }
+
+      for (txt = daemon->txt; txt; txt = txt->next)
+        if (txt->class == C_IN && in_zone(zone, txt->name, &cut)) {
+          if (cut)
+            *cut = 0;
+
+          if (add_resource_record
+              (header, limit, &trunc, -axfroffset, &ansp, daemon->auth_ttl,
+               NULL, T_TXT, C_IN, "t", cut ? txt->name : NULL, txt->len,
+               txt->txt))
+            anscount++;
+
+          /* restore config data */
+          if (cut)
+            *cut = '.';
+        }
+
+      for (na = daemon->naptr; na; na = na->next)
+        if (in_zone(zone, na->name, &cut)) {
+          if (cut)
+            *cut = 0;
+
+          if (add_resource_record
+              (header, limit, &trunc, -axfroffset, &ansp, daemon->auth_ttl,
+               NULL, T_NAPTR, C_IN, "sszzzd", cut ? na->name : NULL, na->order,
+               na->pref, na->flags, na->services, na->regexp, na->replace))
+            anscount++;
+
+          /* restore config data */
+          if (cut)
+            *cut = '.';
+        }
+
+      for (intr = daemon->int_names; intr; intr = intr->next)
+        if (in_zone(zone, intr->name, &cut)) {
+          struct addrlist *addrlist;
+
+          if (cut)
+            *cut = 0;
+
+          for (addrlist = intr->addr; addrlist; addrlist = addrlist->next)
+            if (!(addrlist->flags & ADDRLIST_IPV6) &&
+                (local_query || filter_zone(zone, F_IPV4, &addrlist->addr)) &&
+                add_resource_record(header, limit, &trunc, -axfroffset, &ansp,
+                                    daemon->auth_ttl, NULL, T_A, C_IN, "4",
+                                    cut ? intr->name : NULL, &addrlist->addr))
+              anscount++;
+
 #ifdef HAVE_IPV6
-		for (addrlist = intr->addr; addrlist; addrlist = addrlist->next) 
-		  if ((addrlist->flags & ADDRLIST_IPV6) && 
-		      (local_query || filter_zone(zone, F_IPV6, &addrlist->addr)) &&
-		      add_resource_record(header, limit, &trunc, -axfroffset, &ansp, 
-					  daemon->auth_ttl, NULL, T_AAAA, C_IN, "6", cut ? intr->name : NULL, &addrlist->addr))
-		    anscount++;
-#endif		    
-		
-		/* restore config data */
-		if (cut)
-		  *cut = '.'; 
-	      }
-             
-	  for (a = daemon->cnames; a; a = a->next)
-	    if (in_zone(zone, a->alias, &cut))
-	      {
-		strcpy(name, a->target);
-		if (!strchr(name, '.'))
-		  {
-		    strcat(name, ".");
-		    strcat(name, zone->domain);
-		  }
-		
-		if (cut)
-		  *cut = 0;
-		
-		if (add_resource_record(header, limit, &trunc, -axfroffset, &ansp, 
-					daemon->auth_ttl, NULL,
-					T_CNAME, C_IN, "d",  cut ? a->alias : NULL, name))
-		  anscount++;
-	      }
-	
-	  cache_enumerate(1);
-	  while ((crecp = cache_enumerate(0)))
-	    {
-	      if ((crecp->flags & (F_IPV4 | F_IPV6)) &&
-		  !(crecp->flags & (F_NEG | F_NXDOMAIN)) &&
-		  (crecp->flags & F_FORWARD))
-		{
-		  if ((crecp->flags & F_DHCP) && !option_bool(OPT_DHCP_FQDN))
-		    {
-		      char *cache_name = cache_get_name(crecp);
-		      if (!strchr(cache_name, '.') && 
-			  (local_query || filter_zone(zone, (crecp->flags & (F_IPV6 | F_IPV4)), &(crecp->addr.addr))))
-			{
-			  qtype = T_A;
+          for (addrlist = intr->addr; addrlist; addrlist = addrlist->next)
+            if ((addrlist->flags & ADDRLIST_IPV6) &&
+                (local_query || filter_zone(zone, F_IPV6, &addrlist->addr)) &&
+                add_resource_record(header, limit, &trunc, -axfroffset, &ansp,
+                                    daemon->auth_ttl, NULL, T_AAAA, C_IN, "6",
+                                    cut ? intr->name : NULL, &addrlist->addr))
+              anscount++;
+#endif
+
+          /* restore config data */
+          if (cut)
+            *cut = '.';
+        }
+
+      for (a = daemon->cnames; a; a = a->next)
+        if (in_zone(zone, a->alias, &cut)) {
+          strcpy(name, a->target);
+          if (!strchr(name, '.')) {
+            strcat(name, ".");
+            strcat(name, zone->domain);
+          }
+
+          if (cut)
+            *cut = 0;
+
+          if (add_resource_record(header, limit, &trunc, -axfroffset, &ansp,
+                                  daemon->auth_ttl, NULL,
+                                  T_CNAME, C_IN, "d", cut ? a->alias : NULL,
+                                  name))
+            anscount++;
+        }
+
+      cache_enumerate(1);
+      while ((crecp = cache_enumerate(0))) {
+        if ((crecp->flags & (F_IPV4 | F_IPV6)) &&
+            !(crecp->flags & (F_NEG | F_NXDOMAIN)) &&
+            (crecp->flags & F_FORWARD)) {
+          if ((crecp->flags & F_DHCP) && !option_bool(OPT_DHCP_FQDN)) {
+            char *cache_name = cache_get_name(crecp);
+            if (!strchr(cache_name, '.') &&
+                (local_query
+                 || filter_zone(zone, (crecp->flags & (F_IPV6 | F_IPV4)),
+                                &(crecp->addr.addr)))) {
+              qtype = T_A;
 #ifdef HAVE_IPV6
-			  if (crecp->flags & F_IPV6)
-			    qtype = T_AAAA;
+              if (crecp->flags & F_IPV6)
+                qtype = T_AAAA;
 #endif
-			  if (add_resource_record(header, limit, &trunc, -axfroffset, &ansp, 
-						  daemon->auth_ttl, NULL, qtype, C_IN, 
-						  (crecp->flags & F_IPV4) ? "4" : "6", cache_name, &crecp->addr))
-			    anscount++;
-			}
-		    }
-		  
-		  if ((crecp->flags & F_HOSTS) || (((crecp->flags & F_DHCP) && option_bool(OPT_DHCP_FQDN))))
-		    {
-		      strcpy(name, cache_get_name(crecp));
-		      if (in_zone(zone, name, &cut) && 
-			  (local_query || filter_zone(zone, (crecp->flags & (F_IPV6 | F_IPV4)), &(crecp->addr.addr))))
-			{
-			  qtype = T_A;
+              if (add_resource_record(header, limit, &trunc, -axfroffset, &ansp,
+                                      daemon->auth_ttl, NULL, qtype, C_IN,
+                                      (crecp->flags & F_IPV4) ? "4" : "6",
+                                      cache_name, &crecp->addr))
+                anscount++;
+            }
+          }
+
+          if ((crecp->flags & F_HOSTS)
+              || (((crecp->flags & F_DHCP) && option_bool(OPT_DHCP_FQDN)))) {
+            strcpy(name, cache_get_name(crecp));
+            if (in_zone(zone, name, &cut) &&
+                (local_query
+                 || filter_zone(zone, (crecp->flags & (F_IPV6 | F_IPV4)),
+                                &(crecp->addr.addr)))) {
+              qtype = T_A;
 #ifdef HAVE_IPV6
-			  if (crecp->flags & F_IPV6)
-			    qtype = T_AAAA;
+              if (crecp->flags & F_IPV6)
+                qtype = T_AAAA;
 #endif
-			   if (cut)
-			     *cut = 0;
+              if (cut)
+                *cut = 0;
+
+              if (add_resource_record(header, limit, &trunc, -axfroffset, &ansp,
+                                      daemon->auth_ttl, NULL, qtype, C_IN,
+                                      (crecp->flags & F_IPV4) ? "4" : "6",
+                                      cut ? name : NULL, &crecp->addr))
+                anscount++;
+            }
+          }
+        }
+      }
+
+      /* repeat SOA as last record */
+      if (add_resource_record(header, limit, &trunc, axfroffset, &ansp,
+                              daemon->auth_ttl, NULL, T_SOA, C_IN, "ddlllll",
+                              daemon->authserver, daemon->hostmaster,
+                              daemon->soa_sn, daemon->soa_refresh,
+                              daemon->soa_retry, daemon->soa_expiry,
+                              daemon->auth_ttl))
+        anscount++;
 
-			   if (add_resource_record(header, limit, &trunc, -axfroffset, &ansp, 
-						   daemon->auth_ttl, NULL, qtype, C_IN, 
-						   (crecp->flags & F_IPV4) ? "4" : "6", cut ? name : NULL, &crecp->addr))
-			     anscount++;
-			}
-		    }
-		}
-	    }
-	   
-	  /* repeat SOA as last record */
-	  if (add_resource_record(header, limit, &trunc, axfroffset, &ansp, 
-				  daemon->auth_ttl, NULL, T_SOA, C_IN, "ddlllll",
-				  daemon->authserver,  daemon->hostmaster,
-				  daemon->soa_sn, daemon->soa_refresh, 
-				  daemon->soa_retry, daemon->soa_expiry, 
-				  daemon->auth_ttl))
-	    anscount++;
-	  
-	}
-      
     }
-  
+
+  }
+
   /* done all questions, set up header and return length of result */
   /* clear authoritative and truncated flags, set QR flag */
   header->hb3 = (header->hb3 & ~(HB3_AA | HB3_TC)) | HB3_QR;
 
-  if (local_query)
-    {
-      /* set RA flag */
-      header->hb4 |= HB4_RA;
-    }
-  else
-    {
-      /* clear RA flag */
-      header->hb4 &= ~HB4_RA;
-    }
+  if (local_query) {
+    /* set RA flag */
+    header->hb4 |= HB4_RA;
+  } else {
+    /* clear RA flag */
+    header->hb4 &= ~HB4_RA;
+  }
 
   /* authoritative */
   if (auth)
     header->hb3 |= HB3_AA;
-  
+
   /* truncation */
   if (trunc)
     header->hb3 |= HB3_TC;
-  
+
   if ((auth || local_query) && nxdomain)
     SET_RCODE(header, NXDOMAIN);
   else
@@ -878,12 +843,11 @@
 
   /* Advertise our packet size limit in our reply */
   if (have_pseudoheader)
-    return add_pseudoheader(header,  ansp - (unsigned char *)header, (unsigned char *)limit, daemon->edns_pktsz, 0, NULL, 0, do_bit, 0);
+    return add_pseudoheader(header, ansp - (unsigned char *) header,
+                            (unsigned char *) limit, daemon->edns_pktsz, 0,
+                            NULL, 0, do_bit, 0);
 
-  return ansp - (unsigned char *)header;
+  return ansp - (unsigned char *) header;
 }
-  
-#endif  
-  
-
 
+#endif
Index: dnsmasq-2.78/src/blockdata.c
===================================================================
--- dnsmasq-2.78.orig/src/blockdata.c	2017-10-02 21:13:51.000000000 +0800
+++ dnsmasq-2.78/src/blockdata.c	2018-10-29 16:14:19.353440022 +0800
@@ -24,19 +24,18 @@
 static void blockdata_expand(int n)
 {
   struct blockdata *new = whine_malloc(n * sizeof(struct blockdata));
-  
-  if (n > 0 && new)
-    {
-      int i;
-      
-      new[n-1].next = keyblock_free;
-      keyblock_free = new;
 
-      for (i = 0; i < n - 1; i++)
-	new[i].next = &new[i+1];
+  if (n > 0 && new) {
+    int i;
 
-      blockdata_alloced += n;
-    }
+    new[n - 1].next = keyblock_free;
+    keyblock_free = new;
+
+    for (i = 0; i < n - 1; i++)
+      new[i].next = &new[i + 1];
+
+    blockdata_alloced += n;
+  }
 }
 
 /* Preallocate some blocks, proportional to cachesize, to reduce heap fragmentation. */
@@ -47,7 +46,7 @@
   blockdata_count = 0;
   blockdata_hwm = 0;
 
-  /* Note that daemon->cachesize is enforced to have non-zero size if OPT_DNSSEC_VALID is set */  
+  /* Note that daemon->cachesize is enforced to have non-zero size if OPT_DNSSEC_VALID is set */
   if (option_bool(OPT_DNSSEC_VALID))
     blockdata_expand((daemon->cachesize * 100) / sizeof(struct blockdata));
 }
@@ -55,11 +54,11 @@
 void blockdata_report(void)
 {
   if (option_bool(OPT_DNSSEC_VALID))
-    my_syslog(LOG_INFO, _("DNSSEC memory in use %u, max %u, allocated %u"), 
-	      blockdata_count * sizeof(struct blockdata),  
-	      blockdata_hwm * sizeof(struct blockdata),  
-	      blockdata_alloced * sizeof(struct blockdata));
-} 
+    my_syslog(LOG_INFO, _("DNSSEC memory in use %u, max %u, allocated %u"),
+              blockdata_count * sizeof(struct blockdata),
+              blockdata_hwm * sizeof(struct blockdata),
+              blockdata_alloced * sizeof(struct blockdata));
+}
 
 struct blockdata *blockdata_alloc(char *data, size_t len)
 {
@@ -67,85 +66,77 @@
   struct blockdata **prev = &ret;
   size_t blen;
 
-  while (len > 0)
-    {
-      if (!keyblock_free)
-	blockdata_expand(50);
-      
-      if (keyblock_free)
-	{
-	  block = keyblock_free;
-	  keyblock_free = block->next;
-	  blockdata_count++; 
-	}
-      else
-	{
-	  /* failed to alloc, free partial chain */
-	  blockdata_free(ret);
-	  return NULL;
-	}
-       
-      if (blockdata_hwm < blockdata_count)
-	blockdata_hwm = blockdata_count; 
-      
-      blen = len > KEYBLOCK_LEN ? KEYBLOCK_LEN : len;
-      memcpy(block->key, data, blen);
-      data += blen;
-      len -= blen;
-      *prev = block;
-      prev = &block->next;
-      block->next = NULL;
+  while (len > 0) {
+    if (!keyblock_free)
+      blockdata_expand(50);
+
+    if (keyblock_free) {
+      block = keyblock_free;
+      keyblock_free = block->next;
+      blockdata_count++;
+    } else {
+      /* failed to alloc, free partial chain */
+      blockdata_free(ret);
+      return NULL;
     }
-  
+
+    if (blockdata_hwm < blockdata_count)
+      blockdata_hwm = blockdata_count;
+
+    blen = len > KEYBLOCK_LEN ? KEYBLOCK_LEN : len;
+    memcpy(block->key, data, blen);
+    data += blen;
+    len -= blen;
+    *prev = block;
+    prev = &block->next;
+    block->next = NULL;
+  }
+
   return ret;
 }
 
 void blockdata_free(struct blockdata *blocks)
 {
   struct blockdata *tmp;
-  
-  if (blocks)
-    {
-      for (tmp = blocks; tmp->next; tmp = tmp->next)
-	blockdata_count--;
-      tmp->next = keyblock_free;
-      keyblock_free = blocks; 
+
+  if (blocks) {
+    for (tmp = blocks; tmp->next; tmp = tmp->next)
       blockdata_count--;
-    }
+    tmp->next = keyblock_free;
+    keyblock_free = blocks;
+    blockdata_count--;
+  }
 }
 
 /* if data == NULL, return pointer to static block of sufficient size */
 void *blockdata_retrieve(struct blockdata *block, size_t len, void *data)
 {
   size_t blen;
-  struct  blockdata *b;
+  struct blockdata *b;
   void *new, *d;
-  
+
   static unsigned int buff_len = 0;
   static unsigned char *buff = NULL;
-   
-  if (!data)
-    {
-      if (len > buff_len)
-	{
-	  if (!(new = whine_malloc(len)))
-	    return NULL;
-	  if (buff)
-	    free(buff);
-	  buff = new;
-	}
-      data = buff;
-    }
-  
-  for (d = data, b = block; len > 0 && b;  b = b->next)
-    {
-      blen = len > KEYBLOCK_LEN ? KEYBLOCK_LEN : len;
-      memcpy(d, b->key, blen);
-      d += blen;
-      len -= blen;
+
+  if (!data) {
+    if (len > buff_len) {
+      if (!(new = whine_malloc(len)))
+        return NULL;
+      if (buff)
+        free(buff);
+      buff = new;
     }
+    data = buff;
+  }
+
+  for (d = data, b = block; len > 0 && b; b = b->next) {
+    blen = len > KEYBLOCK_LEN ? KEYBLOCK_LEN : len;
+    memcpy(d, b->key, blen);
+    d += blen;
+    len -= blen;
+  }
 
   return data;
 }
- 
+
 #endif
Index: dnsmasq-2.78/src/bpf.c
===================================================================
--- dnsmasq-2.78.orig/src/bpf.c	2017-10-02 21:13:51.000000000 +0800
+++ dnsmasq-2.78/src/bpf.c	2018-10-29 16:14:19.353440022 +0800
@@ -28,11 +28,11 @@
 #include <net/if_dl.h>
 #include <netinet/if_ether.h>
 #if defined(__FreeBSD__)
-#  include <net/if_var.h> 
+#include <net/if_var.h>
 #endif
 #include <netinet/in_var.h>
 #ifdef HAVE_IPV6
-#  include <netinet6/in6_var.h>
+#include <netinet6/in6_var.h>
 #endif
 
 #ifndef SA_SIZE
@@ -49,7 +49,7 @@
 
 #if defined(HAVE_BSD_NETWORK) && !defined(__APPLE__)
 
-int arp_enumerate(void *parm, int (*callback)())
+int arp_enumerate(void *parm, int (*callback) ())
 {
   int mib[6];
   size_t needed;
@@ -72,46 +72,46 @@
   mib[5] = RTF_LLINFO;
 #else
   mib[5] = 0;
-#endif	
+#endif
   if (sysctl(mib, 6, NULL, &needed, NULL, 0) == -1 || needed == 0)
     return 0;
 
-  while (1) 
-    {
-      if (!expand_buf(&buff, needed))
-	return 0;
-      if ((rc = sysctl(mib, 6, buff.iov_base, &needed, NULL, 0)) == 0 ||
-	  errno != ENOMEM)
-	break;
-      needed += needed / 8;
-    }
+  while (1) {
+    if (!expand_buf(&buff, needed))
+      return 0;
+    if ((rc = sysctl(mib, 6, buff.iov_base, &needed, NULL, 0)) == 0 ||
+        errno != ENOMEM)
+      break;
+    needed += needed / 8;
+  }
   if (rc == -1)
     return 0;
-  
-  for (next = buff.iov_base ; next < (char *)buff.iov_base + needed; next += rtm->rtm_msglen)
-    {
-      rtm = (struct rt_msghdr *)next;
-      sin2 = (struct sockaddr_inarp *)(rtm + 1);
-      sdl = (struct sockaddr_dl *)((char *)sin2 + SA_SIZE(sin2));
-      if (!(*callback)(AF_INET, &sin2->sin_addr, LLADDR(sdl), sdl->sdl_alen, parm))
-	return 0;
-    }
+
+  for (next = buff.iov_base; next < (char *) buff.iov_base + needed;
+       next += rtm->rtm_msglen) {
+    rtm = (struct rt_msghdr *) next;
+    sin2 = (struct sockaddr_inarp *) (rtm + 1);
+    sdl = (struct sockaddr_dl *) ((char *) sin2 + SA_SIZE(sin2));
+    if (!(*callback)
+        (AF_INET, &sin2->sin_addr, LLADDR(sdl), sdl->sdl_alen, parm))
+      return 0;
+  }
 
   return 1;
 }
-#endif /* defined(HAVE_BSD_NETWORK) && !defined(__APPLE__) */
+#endif                          /* defined(HAVE_BSD_NETWORK) && !defined(__APPLE__) */
 
 
-int iface_enumerate(int family, void *parm, int (*callback)())
+int iface_enumerate(int family, void *parm, int (*callback) ())
 {
   struct ifaddrs *head, *addrs;
   int errsave, fd = -1, ret = 0;
 
   if (family == AF_UNSPEC)
 #if defined(HAVE_BSD_NETWORK) && !defined(__APPLE__)
-    return  arp_enumerate(parm, callback);
+    return arp_enumerate(parm, callback);
 #else
-  return 0; /* need code for Solaris and MacOS*/
+    return 0;                   /* need code for Solaris and MacOS */
 #endif
 
   /* AF_LINK doesn't exist in Linux, so we can't use it in our API */
@@ -125,127 +125,128 @@
   if (family == AF_INET6)
     fd = socket(PF_INET6, SOCK_DGRAM, 0);
 #endif
-  
-  for (addrs = head; addrs; addrs = addrs->ifa_next)
-    {
-      if (addrs->ifa_addr->sa_family == family)
-	{
-	  int iface_index = if_nametoindex(addrs->ifa_name);
-
-	  if (iface_index == 0 || !addrs->ifa_addr || 
-	      (!addrs->ifa_netmask && family != AF_LINK))
-	    continue;
-
-	  if (family == AF_INET)
-	    {
-	      struct in_addr addr, netmask, broadcast;
-	      addr = ((struct sockaddr_in *) addrs->ifa_addr)->sin_addr;
+
+  for (addrs = head; addrs; addrs = addrs->ifa_next) {
+    if (addrs->ifa_addr->sa_family == family) {
+      int iface_index = if_nametoindex(addrs->ifa_name);
+
+      if (iface_index == 0 || !addrs->ifa_addr ||
+          (!addrs->ifa_netmask && family != AF_LINK))
+        continue;
+
+      if (family == AF_INET) {
+        struct in_addr addr, netmask, broadcast;
+        addr = ((struct sockaddr_in *) addrs->ifa_addr)->sin_addr;
 #ifdef HAVE_BSD_NETWORK
-	      if (del_family == AF_INET && del_addr.addr.addr4.s_addr == addr.s_addr)
-		continue;
+        if (del_family == AF_INET && del_addr.addr.addr4.s_addr == addr.s_addr)
+          continue;
 #endif
-	      netmask = ((struct sockaddr_in *) addrs->ifa_netmask)->sin_addr;
-	      if (addrs->ifa_broadaddr)
-		broadcast = ((struct sockaddr_in *) addrs->ifa_broadaddr)->sin_addr; 
-	      else 
-		broadcast.s_addr = 0;	      
-	      if (!((*callback)(addr, iface_index, NULL, netmask, broadcast, parm)))
-		goto err;
-	    }
+        netmask = ((struct sockaddr_in *) addrs->ifa_netmask)->sin_addr;
+        if (addrs->ifa_broadaddr)
+          broadcast = ((struct sockaddr_in *) addrs->ifa_broadaddr)->sin_addr;
+        else
+          broadcast.s_addr = 0;
+        if (!((*callback) (addr, iface_index, NULL, netmask, broadcast, parm)))
+          goto err;
+      }
 #ifdef HAVE_IPV6
-	  else if (family == AF_INET6)
-	    {
-	      struct in6_addr *addr = &((struct sockaddr_in6 *) addrs->ifa_addr)->sin6_addr;
-	      unsigned char *netmask = (unsigned char *) &((struct sockaddr_in6 *) addrs->ifa_netmask)->sin6_addr;
-	      int scope_id = ((struct sockaddr_in6 *) addrs->ifa_addr)->sin6_scope_id;
-	      int i, j, prefix = 0;
-	      u32 valid = 0xffffffff, preferred = 0xffffffff;
-	      int flags = 0;
+      else if (family == AF_INET6) {
+        struct in6_addr *addr =
+            &((struct sockaddr_in6 *) addrs->ifa_addr)->sin6_addr;
+        unsigned char *netmask =
+            (unsigned char *) &((struct sockaddr_in6 *) addrs->ifa_netmask)->
+            sin6_addr;
+        int scope_id = ((struct sockaddr_in6 *) addrs->ifa_addr)->sin6_scope_id;
+        int i, j, prefix = 0;
+        u32 valid = 0xffffffff, preferred = 0xffffffff;
+        int flags = 0;
 #ifdef HAVE_BSD_NETWORK
-	      if (del_family == AF_INET6 && IN6_ARE_ADDR_EQUAL(&del_addr.addr.addr6, addr))
-		continue;
+        if (del_family == AF_INET6
+            && IN6_ARE_ADDR_EQUAL(&del_addr.addr.addr6, addr))
+          continue;
 #endif
 #if defined(HAVE_BSD_NETWORK) && !defined(__APPLE__)
-	      struct in6_ifreq ifr6;
+        struct in6_ifreq ifr6;
+
+        memset(&ifr6, 0, sizeof(ifr6));
+        strncpy(ifr6.ifr_name, addrs->ifa_name, sizeof(ifr6.ifr_name));
 
-	      memset(&ifr6, 0, sizeof(ifr6));
-	      strncpy(ifr6.ifr_name, addrs->ifa_name, sizeof(ifr6.ifr_name));
-	      
-	      ifr6.ifr_addr = *((struct sockaddr_in6 *) addrs->ifa_addr);
-	      if (fd != -1 && ioctl(fd, SIOCGIFAFLAG_IN6, &ifr6) != -1)
-		{
-		  if (ifr6.ifr_ifru.ifru_flags6 & IN6_IFF_TENTATIVE)
-		    flags |= IFACE_TENTATIVE;
-		  
-		  if (ifr6.ifr_ifru.ifru_flags6 & IN6_IFF_DEPRECATED)
-		    flags |= IFACE_DEPRECATED;
+        ifr6.ifr_addr = *((struct sockaddr_in6 *) addrs->ifa_addr);
+        if (fd != -1 && ioctl(fd, SIOCGIFAFLAG_IN6, &ifr6) != -1) {
+          if (ifr6.ifr_ifru.ifru_flags6 & IN6_IFF_TENTATIVE)
+            flags |= IFACE_TENTATIVE;
+
+          if (ifr6.ifr_ifru.ifru_flags6 & IN6_IFF_DEPRECATED)
+            flags |= IFACE_DEPRECATED;
 
 #ifdef IN6_IFF_TEMPORARY
-		  if (!(ifr6.ifr_ifru.ifru_flags6 & (IN6_IFF_AUTOCONF | IN6_IFF_TEMPORARY)))
-		    flags |= IFACE_PERMANENT;
+          if (!
+              (ifr6.ifr_ifru.
+               ifru_flags6 & (IN6_IFF_AUTOCONF | IN6_IFF_TEMPORARY)))
+            flags |= IFACE_PERMANENT;
 #endif
 
 #ifdef IN6_IFF_PRIVACY
-		  if (!(ifr6.ifr_ifru.ifru_flags6 & (IN6_IFF_AUTOCONF | IN6_IFF_PRIVACY)))
-		    flags |= IFACE_PERMANENT;
+          if (!
+              (ifr6.ifr_ifru.
+               ifru_flags6 & (IN6_IFF_AUTOCONF | IN6_IFF_PRIVACY)))
+            flags |= IFACE_PERMANENT;
+#endif
+        }
+
+        ifr6.ifr_addr = *((struct sockaddr_in6 *) addrs->ifa_addr);
+        if (fd != -1 && ioctl(fd, SIOCGIFALIFETIME_IN6, &ifr6) != -1) {
+          valid = ifr6.ifr_ifru.ifru_lifetime.ia6t_vltime;
+          preferred = ifr6.ifr_ifru.ifru_lifetime.ia6t_pltime;
+        }
+#endif
+
+        for (i = 0; i < IN6ADDRSZ; i++, prefix += 8)
+          if (netmask[i] != 0xff)
+            break;
+
+        if (i != IN6ADDRSZ && netmask[i])
+          for (j = 7; j > 0; j--, prefix++)
+            if ((netmask[i] & (1 << j)) == 0)
+              break;
+
+        /* voodoo to clear interface field in address */
+        if (!option_bool(OPT_NOWILD) && IN6_IS_ADDR_LINKLOCAL(addr)) {
+          addr->s6_addr[2] = 0;
+          addr->s6_addr[3] = 0;
+        }
+
+        if (!((*callback) (addr, prefix, scope_id, iface_index, flags,
+                           (int) preferred, (int) valid, parm)))
+          goto err;
+      }
+#endif                          /* HAVE_IPV6 */
+
+#ifdef HAVE_DHCP6
+      else if (family == AF_LINK) {
+        /* Assume ethernet again here */
+        struct sockaddr_dl *sdl = (struct sockaddr_dl *) addrs->ifa_addr;
+        if (sdl->sdl_alen != 0 &&
+            !((*callback)
+              (iface_index, ARPHRD_ETHER, LLADDR(sdl), sdl->sdl_alen, parm)))
+          goto err;
+      }
 #endif
-		}
-	      
-	      ifr6.ifr_addr = *((struct sockaddr_in6 *) addrs->ifa_addr);
-	      if (fd != -1 && ioctl(fd, SIOCGIFALIFETIME_IN6, &ifr6) != -1)
-		{
-		  valid = ifr6.ifr_ifru.ifru_lifetime.ia6t_vltime;
-		  preferred = ifr6.ifr_ifru.ifru_lifetime.ia6t_pltime;
-		}
-#endif
-	      	      
-	      for (i = 0; i < IN6ADDRSZ; i++, prefix += 8) 
-                if (netmask[i] != 0xff)
-		  break;
-	      
-	      if (i != IN6ADDRSZ && netmask[i]) 
-                for (j = 7; j > 0; j--, prefix++) 
-		  if ((netmask[i] & (1 << j)) == 0)
-		    break;
-	      
-	      /* voodoo to clear interface field in address */
-	      if (!option_bool(OPT_NOWILD) && IN6_IS_ADDR_LINKLOCAL(addr))
-		{
-		  addr->s6_addr[2] = 0;
-		  addr->s6_addr[3] = 0;
-		} 
-	     
-	      if (!((*callback)(addr, prefix, scope_id, iface_index, flags,
-				(int) preferred, (int)valid, parm)))
-		goto err;	      
-	    }
-#endif /* HAVE_IPV6 */
-
-#ifdef HAVE_DHCP6      
-	  else if (family == AF_LINK)
-	    { 
-	      /* Assume ethernet again here */
-	      struct sockaddr_dl *sdl = (struct sockaddr_dl *) addrs->ifa_addr;
-	      if (sdl->sdl_alen != 0 && 
-		  !((*callback)(iface_index, ARPHRD_ETHER, LLADDR(sdl), sdl->sdl_alen, parm)))
-		goto err;
-	    }
-#endif 
-	}
     }
-  
+  }
+
   ret = 1;
 
- err:
+err:
   errsave = errno;
-  freeifaddrs(head); 
+  freeifaddrs(head);
   if (fd != -1)
     close(fd);
   errno = errsave;
 
   return ret;
 }
-#endif /* defined(HAVE_BSD_NETWORK) || defined(HAVE_SOLARIS_NETWORK) */
+#endif                          /* defined(HAVE_BSD_NETWORK) || defined(HAVE_SOLARIS_NETWORK) */
 
 
 #if defined(HAVE_BSD_NETWORK) && defined(HAVE_DHCP)
@@ -255,27 +256,26 @@
 {
   int i = 0;
 
-  while (1) 
-    {
-      sprintf(daemon->dhcp_buff, "/dev/bpf%d", i++);
-      if ((daemon->dhcp_raw_fd = open(daemon->dhcp_buff, O_RDWR, 0)) != -1)
-	return;
-
-      if (errno != EBUSY)
-	die(_("cannot create DHCP BPF socket: %s"), NULL, EC_BADNET);
-    }	     
+  while (1) {
+    sprintf(daemon->dhcp_buff, "/dev/bpf%d", i++);
+    if ((daemon->dhcp_raw_fd = open(daemon->dhcp_buff, O_RDWR, 0)) != -1)
+      return;
+
+    if (errno != EBUSY)
+      die(_("cannot create DHCP BPF socket: %s"), NULL, EC_BADNET);
+  }
 }
 
 void send_via_bpf(struct dhcp_packet *mess, size_t len,
-		  struct in_addr iface_addr, struct ifreq *ifr)
+                  struct in_addr iface_addr, struct ifreq *ifr)
 {
-   /* Hairy stuff, packet either has to go to the
-      net broadcast or the destination can't reply to ARP yet,
-      but we do know the physical address. 
-      Build the packet by steam, and send directly, bypassing
-      the kernel IP stack */
-  
-  struct ether_header ether; 
+  /* Hairy stuff, packet either has to go to the
+     net broadcast or the destination can't reply to ARP yet,
+     but we do know the physical address.
+     Build the packet by steam, and send directly, bypassing
+     the kernel IP stack */
+
+  struct ether_header ether;
   struct ip ip;
   struct udphdr {
     u16 uh_sport;               /* source port */
@@ -283,58 +283,55 @@
     u16 uh_ulen;                /* udp length */
     u16 uh_sum;                 /* udp checksum */
   } udp;
-  
+
   u32 i, sum;
   struct iovec iov[4];
 
   /* Only know how to do ethernet on *BSD */
-  if (mess->htype != ARPHRD_ETHER || mess->hlen != ETHER_ADDR_LEN)
-    {
-      my_syslog(MS_DHCP | LOG_WARNING, _("DHCP request for unsupported hardware type (%d) received on %s"), 
-		mess->htype, ifr->ifr_name);
-      return;
-    }
-   
+  if (mess->htype != ARPHRD_ETHER || mess->hlen != ETHER_ADDR_LEN) {
+    my_syslog(MS_DHCP | LOG_WARNING,
+              _
+              ("DHCP request for unsupported hardware type (%d) received on %s"),
+              mess->htype, ifr->ifr_name);
+    return;
+  }
+
   ifr->ifr_addr.sa_family = AF_LINK;
   if (ioctl(daemon->dhcpfd, SIOCGIFADDR, ifr) < 0)
     return;
-  
-  memcpy(ether.ether_shost, LLADDR((struct sockaddr_dl *)&ifr->ifr_addr), ETHER_ADDR_LEN);
+
+  memcpy(ether.ether_shost, LLADDR((struct sockaddr_dl *) &ifr->ifr_addr),
+         ETHER_ADDR_LEN);
   ether.ether_type = htons(ETHERTYPE_IP);
-  
-  if (ntohs(mess->flags) & 0x8000)
-    {
-      memset(ether.ether_dhost, 255,  ETHER_ADDR_LEN);
-      ip.ip_dst.s_addr = INADDR_BROADCAST;
-    }
-  else
-    {
-      memcpy(ether.ether_dhost, mess->chaddr, ETHER_ADDR_LEN); 
-      ip.ip_dst.s_addr = mess->yiaddr.s_addr;
-    }
-  
+
+  if (ntohs(mess->flags) & 0x8000) {
+    memset(ether.ether_dhost, 255, ETHER_ADDR_LEN);
+    ip.ip_dst.s_addr = INADDR_BROADCAST;
+  } else {
+    memcpy(ether.ether_dhost, mess->chaddr, ETHER_ADDR_LEN);
+    ip.ip_dst.s_addr = mess->yiaddr.s_addr;
+  }
+
   ip.ip_p = IPPROTO_UDP;
   ip.ip_src.s_addr = iface_addr.s_addr;
-  ip.ip_len = htons(sizeof(struct ip) + 
-		    sizeof(struct udphdr) +
-		    len) ;
+  ip.ip_len = htons(sizeof(struct ip) + sizeof(struct udphdr) + len);
   ip.ip_hl = sizeof(struct ip) / 4;
   ip.ip_v = IPVERSION;
   ip.ip_tos = 0;
   ip.ip_id = htons(0);
-  ip.ip_off = htons(0x4000); /* don't fragment */
+  ip.ip_off = htons(0x4000);    /* don't fragment */
   ip.ip_ttl = IPDEFTTL;
   ip.ip_sum = 0;
   for (sum = 0, i = 0; i < sizeof(struct ip) / 2; i++)
-    sum += ((u16 *)&ip)[i];
-  while (sum>>16)
-    sum = (sum & 0xffff) + (sum >> 16);  
+    sum += ((u16 *) & ip)[i];
+  while (sum >> 16)
+    sum = (sum & 0xffff) + (sum >> 16);
   ip.ip_sum = (sum == 0xffff) ? sum : ~sum;
-  
+
   udp.uh_sport = htons(daemon->dhcp_server_port);
   udp.uh_dport = htons(daemon->dhcp_client_port);
   if (len & 1)
-    ((char *)mess)[len] = 0; /* for checksum, in case length is odd. */
+    ((char *) mess)[len] = 0;   /* for checksum, in case length is odd. */
   udp.uh_sum = 0;
   udp.uh_ulen = sum = htons(sizeof(struct udphdr) + len);
   sum += htons(IPPROTO_UDP);
@@ -342,16 +339,16 @@
   sum += (ip.ip_src.s_addr >> 16) & 0xffff;
   sum += ip.ip_dst.s_addr & 0xffff;
   sum += (ip.ip_dst.s_addr >> 16) & 0xffff;
-  for (i = 0; i < sizeof(struct udphdr)/2; i++)
-    sum += ((u16 *)&udp)[i];
+  for (i = 0; i < sizeof(struct udphdr) / 2; i++)
+    sum += ((u16 *) & udp)[i];
   for (i = 0; i < (len + 1) / 2; i++)
-    sum += ((u16 *)mess)[i];
-  while (sum>>16)
+    sum += ((u16 *) mess)[i];
+  while (sum >> 16)
     sum = (sum & 0xffff) + (sum >> 16);
   udp.uh_sum = (sum == 0xffff) ? sum : ~sum;
-  
+
   ioctl(daemon->dhcp_raw_fd, BIOCSETIF, ifr);
-  
+
   iov[0].iov_base = &ether;
   iov[0].iov_len = sizeof(ether);
   iov[1].iov_base = &ip;
@@ -364,8 +361,8 @@
   while (retry_send(writev(daemon->dhcp_raw_fd, iov, 4)));
 }
 
-#endif /* defined(HAVE_BSD_NETWORK) && defined(HAVE_DHCP) */
- 
+#endif                          /* defined(HAVE_BSD_NETWORK) && defined(HAVE_DHCP) */
+
 
 #ifdef HAVE_BSD_NETWORK
 
@@ -373,7 +370,7 @@
 {
   /* AF_UNSPEC: all addr families */
   daemon->routefd = socket(PF_ROUTE, SOCK_RAW, AF_UNSPEC);
-  
+
   if (daemon->routefd == -1 || !fix_fd(daemon->routefd))
     die(_("cannot create PF_ROUTE socket: %s"), NULL, EC_BADNET);
 }
@@ -386,65 +383,57 @@
   if (rc < 4)
     return;
 
-  msg = (struct if_msghdr *)daemon->packet;
-  
+  msg = (struct if_msghdr *) daemon->packet;
+
   if (rc < msg->ifm_msglen)
     return;
 
-   if (msg->ifm_version != RTM_VERSION)
-     {
-       static int warned = 0;
-       if (!warned)
-	 {
-	   my_syslog(LOG_WARNING, _("Unknown protocol version from route socket"));
-	   warned = 1;
-	 }
-     }
-   else if (msg->ifm_type == RTM_NEWADDR)
-     {
-       del_family = 0;
-       queue_event(EVENT_NEWADDR);
-     }
-   else if (msg->ifm_type == RTM_DELADDR)
-     {
-       /* There's a race in the kernel, such that if we run iface_enumerate() immediately
-	  we get a DELADDR event, the deleted address still appears. Here we store the deleted address
-	  in a static variable, and omit it from the set returned by iface_enumerate() */
-       int mask = ((struct ifa_msghdr *)msg)->ifam_addrs;
-       int maskvec[] = { RTA_DST, RTA_GATEWAY, RTA_NETMASK, RTA_GENMASK,
-			 RTA_IFP, RTA_IFA, RTA_AUTHOR, RTA_BRD };
-       int of;
-       unsigned int i;
-       
-       for (i = 0,  of = sizeof(struct ifa_msghdr); of < rc && i < sizeof(maskvec)/sizeof(maskvec[0]); i++) 
-	 if (mask & maskvec[i]) 
-	   {
-	     struct sockaddr *sa = (struct sockaddr *)((char *)msg + of);
-	     size_t diff = (sa->sa_len != 0) ? sa->sa_len : sizeof(long);
-	     
-	     if (maskvec[i] == RTA_IFA)
-	       {
-		 del_family = sa->sa_family;
-		 if (del_family == AF_INET)
-		   del_addr.addr.addr4 = ((struct sockaddr_in *)sa)->sin_addr;
+  if (msg->ifm_version != RTM_VERSION) {
+    static int warned = 0;
+    if (!warned) {
+      my_syslog(LOG_WARNING, _("Unknown protocol version from route socket"));
+      warned = 1;
+    }
+  } else if (msg->ifm_type == RTM_NEWADDR) {
+    del_family = 0;
+    queue_event(EVENT_NEWADDR);
+  } else if (msg->ifm_type == RTM_DELADDR) {
+    /* There's a race in the kernel, such that if we run iface_enumerate() immediately
+       we get a DELADDR event, the deleted address still appears. Here we store the deleted address
+       in a static variable, and omit it from the set returned by iface_enumerate() */
+    int mask = ((struct ifa_msghdr *) msg)->ifam_addrs;
+    int maskvec[] = { RTA_DST, RTA_GATEWAY, RTA_NETMASK, RTA_GENMASK,
+      RTA_IFP, RTA_IFA, RTA_AUTHOR, RTA_BRD
+    };
+    int of;
+    unsigned int i;
+
+    for (i = 0, of = sizeof(struct ifa_msghdr);
+         of < rc && i < sizeof(maskvec) / sizeof(maskvec[0]); i++)
+      if (mask & maskvec[i]) {
+        struct sockaddr *sa = (struct sockaddr *) ((char *) msg + of);
+        size_t diff = (sa->sa_len != 0) ? sa->sa_len : sizeof(long);
+
+        if (maskvec[i] == RTA_IFA) {
+          del_family = sa->sa_family;
+          if (del_family == AF_INET)
+            del_addr.addr.addr4 = ((struct sockaddr_in *) sa)->sin_addr;
 #ifdef HAVE_IPV6
-		 else if (del_family == AF_INET6)
-		   del_addr.addr.addr6 = ((struct sockaddr_in6 *)sa)->sin6_addr;
+          else if (del_family == AF_INET6)
+            del_addr.addr.addr6 = ((struct sockaddr_in6 *) sa)->sin6_addr;
 #endif
-		 else
-		   del_family = 0;
-	       }
-	     
-	     of += diff;
-	     /* round up as needed */
-	     if (diff & (sizeof(long) - 1)) 
-	       of += sizeof(long) - (diff & (sizeof(long) - 1));
-	   }
-       
-       queue_event(EVENT_NEWADDR);
-     }
-}
-
-#endif /* HAVE_BSD_NETWORK */
+          else
+            del_family = 0;
+        }
+
+        of += diff;
+        /* round up as needed */
+        if (diff & (sizeof(long) - 1))
+          of += sizeof(long) - (diff & (sizeof(long) - 1));
+      }
 
+    queue_event(EVENT_NEWADDR);
+  }
+}
 
+#endif                          /* HAVE_BSD_NETWORK */
Index: dnsmasq-2.78/src/cache.c
===================================================================
--- dnsmasq-2.78.orig/src/cache.c	2017-10-02 21:13:51.000000000 +0800
+++ dnsmasq-2.78/src/cache.c	2018-10-29 16:14:19.361440022 +0800
@@ -28,42 +28,43 @@
 /* type->string mapping: this is also used by the name-hash function as a mixing table. */
 static const struct {
   unsigned int type;
-  const char * const name;
+  const char *const name;
 } typestr[] = {
-  { 1,   "A" },
-  { 2,   "NS" },
-  { 5,   "CNAME" },
-  { 6,   "SOA" },
-  { 10,  "NULL" },
-  { 11,  "WKS" },
-  { 12,  "PTR" },
-  { 13,  "HINFO" },	
-  { 15,  "MX" },
-  { 16,  "TXT" },
-  { 22,  "NSAP" },
-  { 23,  "NSAP_PTR" },
-  { 24,  "SIG" },
-  { 25,  "KEY" },
-  { 28,  "AAAA" },
-  { 33,  "SRV" },
-  { 35,  "NAPTR" },
-  { 36,  "KX" },
-  { 37,  "CERT" },
-  { 38,  "A6" },
-  { 39,  "DNAME" },
-  { 41,  "OPT" },
-  { 43,  "DS" },
-  { 46,  "RRSIG" },
-  { 47,  "NSEC" },
-  { 48,  "DNSKEY" },
-  { 50,  "NSEC3" },
-  { 249, "TKEY" },
-  { 250, "TSIG" },
-  { 251, "IXFR" },
-  { 252, "AXFR" },
-  { 253, "MAILB" },
-  { 254, "MAILA" },
-  { 255, "ANY" }
+  {
+  1, "A"}, {
+  2, "NS"}, {
+  5, "CNAME"}, {
+  6, "SOA"}, {
+  10, "NULL"}, {
+  11, "WKS"}, {
+  12, "PTR"}, {
+  13, "HINFO"}, {
+  15, "MX"}, {
+  16, "TXT"}, {
+  22, "NSAP"}, {
+  23, "NSAP_PTR"}, {
+  24, "SIG"}, {
+  25, "KEY"}, {
+  28, "AAAA"}, {
+  33, "SRV"}, {
+  35, "NAPTR"}, {
+  36, "KX"}, {
+  37, "CERT"}, {
+  38, "A6"}, {
+  39, "DNAME"}, {
+  41, "OPT"}, {
+  43, "DS"}, {
+  46, "RRSIG"}, {
+  47, "NSEC"}, {
+  48, "DNSKEY"}, {
+  50, "NSEC3"}, {
+  249, "TKEY"}, {
+  250, "TSIG"}, {
+  251, "IXFR"}, {
+  252, "AXFR"}, {
+  253, "MAILB"}, {
+  254, "MAILA"}, {
+  255, "ANY"}
 };
 
 static void cache_free(struct crec *crecp);
@@ -77,11 +78,11 @@
   static unsigned int uid = 0;
 
   uid++;
-  
+
   /* uid == 0 used to indicate CNAME to interface name. */
   if (uid == SRC_INTERFACE)
     uid++;
-  
+
   return uid;
 }
 
@@ -89,22 +90,20 @@
 {
   struct crec *crecp;
   int i;
- 
-  bignames_left = daemon->cachesize/10;
-  
-  if (daemon->cachesize > 0)
-    {
-      crecp = safe_malloc(daemon->cachesize*sizeof(struct crec));
-      
-      for (i=0; i < daemon->cachesize; i++, crecp++)
-	{
-	  cache_link(crecp);
-	  crecp->flags = 0;
-	  crecp->uid = next_uid();
-	}
+
+  bignames_left = daemon->cachesize / 10;
+
+  if (daemon->cachesize > 0) {
+    crecp = safe_malloc(daemon->cachesize * sizeof(struct crec));
+
+    for (i = 0; i < daemon->cachesize; i++, crecp++) {
+      cache_link(crecp);
+      crecp->flags = 0;
+      crecp->uid = next_uid();
     }
-  
-  /* create initial hash table*/
+  }
+
+  /* create initial hash table */
   rehash(daemon->cachesize);
 }
 
@@ -118,47 +117,45 @@
   int i, new_size, old_size;
 
   /* hash_size is a power of two. */
-  for (new_size = 64; new_size < size/10; new_size = new_size << 1);
-  
+  for (new_size = 64; new_size < size / 10; new_size = new_size << 1);
+
   /* must succeed in getting first instance, failure later is non-fatal */
   if (!hash_table)
     new = safe_malloc(new_size * sizeof(struct crec *));
-  else if (new_size <= hash_size || !(new = whine_malloc(new_size * sizeof(struct crec *))))
+  else if (new_size <= hash_size
+           || !(new = whine_malloc(new_size * sizeof(struct crec *))))
     return;
 
-  for(i = 0; i < new_size; i++)
+  for (i = 0; i < new_size; i++)
     new[i] = NULL;
 
   old = hash_table;
   old_size = hash_size;
   hash_table = new;
   hash_size = new_size;
-  
-  if (old)
-    {
-      for (i = 0; i < old_size; i++)
-	for (p = old[i]; p ; p = tmp)
-	  {
-	    tmp = p->hash_next;
-	    cache_hash(p);
-	  }
-      free(old);
-    }
+
+  if (old) {
+    for (i = 0; i < old_size; i++)
+      for (p = old[i]; p; p = tmp) {
+        tmp = p->hash_next;
+        cache_hash(p);
+      }
+    free(old);
+  }
 }
-  
+
 static struct crec **hash_bucket(char *name)
 {
   unsigned int c, val = 017465; /* Barker code - minimum self-correlation in cyclic shift */
-  const unsigned char *mix_tab = (const unsigned char*)typestr; 
+  const unsigned char *mix_tab = (const unsigned char *) typestr;
+
+  while ((c = (unsigned char) *name++)) {
+    /* don't use tolower and friends here - they may be messed up by LOCALE */
+    if (c >= 'A' && c <= 'Z')
+      c += 'a' - 'A';
+    val = ((val << 7) | (val >> (32 - 7))) + (mix_tab[(val + c) & 0x3F] ^ c);
+  }
 
-  while((c = (unsigned char) *name++))
-    {
-      /* don't use tolower and friends here - they may be messed up by LOCALE */
-      if (c >= 'A' && c <= 'Z')
-	c += 'a' - 'A';
-      val = ((val << 7) | (val >> (32 - 7))) + (mix_tab[(val + c) & 0x3F] ^ c);
-    } 
-  
   /* hash_size is a power of two */
   return hash_table + ((val ^ (val >> 16)) & (hash_size - 1));
 }
@@ -172,15 +169,14 @@
 
   struct crec **up = hash_bucket(cache_get_name(crecp));
 
-  if (!(crecp->flags & F_REVERSE))
-    {
-      while (*up && ((*up)->flags & F_REVERSE))
-	up = &((*up)->hash_next); 
-      
-      if (crecp->flags & F_IMMORTAL)
-	while (*up && !((*up)->flags & F_IMMORTAL))
-	  up = &((*up)->hash_next);
-    }
+  if (!(crecp->flags & F_REVERSE)) {
+    while (*up && ((*up)->flags & F_REVERSE))
+      up = &((*up)->hash_next);
+
+    if (crecp->flags & F_IMMORTAL)
+      while (*up && !((*up)->flags & F_IMMORTAL))
+        up = &((*up)->hash_next);
+  }
   crecp->hash_next = *up;
   *up = crecp;
 }
@@ -199,7 +195,7 @@
 {
   crecp->flags &= ~F_FORWARD;
   crecp->flags &= ~F_REVERSE;
-  crecp->uid = next_uid(); /* invalidate CNAMES pointing to this. */
+  crecp->uid = next_uid();      /* invalidate CNAMES pointing to this. */
 
   if (cache_tail)
     cache_tail->next = crecp;
@@ -208,24 +204,22 @@
   crecp->prev = cache_tail;
   crecp->next = NULL;
   cache_tail = crecp;
-  
-  /* retrieve big name for further use. */
-  if (crecp->flags & F_BIGNAME)
-    {
-      crecp->name.bname->next = big_free;
-      big_free = crecp->name.bname;
-      crecp->flags &= ~F_BIGNAME;
-    }
 
+  /* retrieve big name for further use. */
+  if (crecp->flags & F_BIGNAME) {
+    crecp->name.bname->next = big_free;
+    big_free = crecp->name.bname;
+    crecp->flags &= ~F_BIGNAME;
+  }
 #ifdef HAVE_DNSSEC
   cache_blockdata_free(crecp);
 #endif
-}    
+}
 
 /* insert a new cache entry at the head of the list (youngest entry) */
 static void cache_link(struct crec *crecp)
 {
-  if (cache_head) /* check needed for init code */
+  if (cache_head)               /* check needed for init code */
     cache_head->prev = crecp;
   crecp->next = cache_head;
   crecp->prev = NULL;
@@ -234,8 +228,8 @@
     cache_tail = crecp;
 }
 
-/* remove an arbitrary cache entry for promotion */ 
-static void cache_unlink (struct crec *crecp)
+/* remove an arbitrary cache entry for promotion */
+static void cache_unlink(struct crec *crecp)
 {
   if (crecp->prev)
     crecp->prev->next = crecp->next;
@@ -252,9 +246,9 @@
 {
   if (crecp->flags & F_BIGNAME)
     return crecp->name.bname->name;
-  else if (crecp->flags & F_NAMEP) 
+  else if (crecp->flags & F_NAMEP)
     return crecp->name.namep;
-  
+
   return crecp->name.sname;
 }
 
@@ -273,21 +267,18 @@
   static int bucket;
   static struct crec *cache;
 
-  if (init)
-    {
-      bucket = 0;
-      cache = NULL;
-    }
-  else if (cache && cache->hash_next)
+  if (init) {
+    bucket = 0;
+    cache = NULL;
+  } else if (cache && cache->hash_next)
     cache = cache->hash_next;
-  else
-    {
-       cache = NULL; 
-       while (bucket < hash_size)
-	 if ((cache = hash_table[bucket++]))
-	   break;
-    }
-  
+  else {
+    cache = NULL;
+    while (bucket < hash_size)
+      if ((cache = hash_table[bucket++]))
+        break;
+  }
+
   return cache;
 }
 
@@ -295,14 +286,14 @@
 {
   if (!(crecp->flags & F_CNAME) || crecp->addr.cname.uid == SRC_INTERFACE)
     return 0;
-  
+
   /* NB. record may be reused as DS or DNSKEY, where uid is 
      overloaded for something completely different */
-  if (crecp->addr.cname.target.cache && 
+  if (crecp->addr.cname.target.cache &&
       (crecp->addr.cname.target.cache->flags & (F_IPV4 | F_IPV6 | F_CNAME)) &&
       crecp->addr.cname.uid == crecp->addr.cname.target.cache->uid)
     return 0;
-  
+
   return 1;
 }
 
@@ -313,11 +304,12 @@
 
   if (difftime(now, crecp->ttd) < 0)
     return 0;
-  
+
   return 1;
 }
 
-static struct crec *cache_scan_free(char *name, struct all_addr *addr, time_t now, unsigned short flags)
+static struct crec *cache_scan_free(char *name, struct all_addr *addr,
+                                    time_t now, unsigned short flags)
 {
   /* Scan and remove old entries.
      If (flags & F_FORWARD) then remove any forward entries for name and any expired
@@ -331,88 +323,76 @@
 
      We take advantage of the fact that hash chains have stuff in the order <reverse>,<other>,<immortal>
      so that when we hit an entry which isn't reverse and is immortal, we're done. */
- 
+
   struct crec *crecp, **up;
-  
-  if (flags & F_FORWARD)
-    {
-      for (up = hash_bucket(name), crecp = *up; crecp; crecp = crecp->hash_next)
-	{
-	  if (is_expired(now, crecp) || is_outdated_cname_pointer(crecp))
-	    { 
-	      *up = crecp->hash_next;
-	      if (!(crecp->flags & (F_HOSTS | F_DHCP | F_CONFIG)))
-		{
-		  cache_unlink(crecp);
-		  cache_free(crecp);
-		}
-	      continue;
-	    } 
-	
-	  if ((crecp->flags & F_FORWARD) && hostname_isequal(cache_get_name(crecp), name))
-	    {
-	      /* Don't delete DNSSEC in favour of a CNAME, they can co-exist */
-	      if ((flags & crecp->flags & (F_IPV4 | F_IPV6)) || 
-		  (((crecp->flags | flags) & F_CNAME) && !(crecp->flags & (F_DNSKEY | F_DS))))
-		{
-		  if (crecp->flags & (F_HOSTS | F_DHCP | F_CONFIG))
-		    return crecp;
-		  *up = crecp->hash_next;
-		  cache_unlink(crecp);
-		  cache_free(crecp);
-		  continue;
-		}
-	      
+
+  if (flags & F_FORWARD) {
+    for (up = hash_bucket(name), crecp = *up; crecp; crecp = crecp->hash_next) {
+      if (is_expired(now, crecp) || is_outdated_cname_pointer(crecp)) {
+        *up = crecp->hash_next;
+        if (!(crecp->flags & (F_HOSTS | F_DHCP | F_CONFIG))) {
+          cache_unlink(crecp);
+          cache_free(crecp);
+        }
+        continue;
+      }
+
+      if ((crecp->flags & F_FORWARD)
+          && hostname_isequal(cache_get_name(crecp), name)) {
+        /* Don't delete DNSSEC in favour of a CNAME, they can co-exist */
+        if ((flags & crecp->flags & (F_IPV4 | F_IPV6)) ||
+            (((crecp->flags | flags) & F_CNAME)
+             && !(crecp->flags & (F_DNSKEY | F_DS)))) {
+          if (crecp->flags & (F_HOSTS | F_DHCP | F_CONFIG))
+            return crecp;
+          *up = crecp->hash_next;
+          cache_unlink(crecp);
+          cache_free(crecp);
+          continue;
+        }
 #ifdef HAVE_DNSSEC
-	      /* Deletion has to be class-sensitive for DS and DNSKEY */
-	      if ((flags & crecp->flags & (F_DNSKEY | F_DS)) && crecp->uid == addr->addr.dnssec.class)
-		{
-		  if (crecp->flags & F_CONFIG)
-		    return crecp;
-		  *up = crecp->hash_next;
-		  cache_unlink(crecp);
-		  cache_free(crecp);
-		  continue;
-		}
-#endif
-	    }
-	  up = &crecp->hash_next;
-	}
+        /* Deletion has to be class-sensitive for DS and DNSKEY */
+        if ((flags & crecp->flags & (F_DNSKEY | F_DS))
+            && crecp->uid == addr->addr.dnssec.class) {
+          if (crecp->flags & F_CONFIG)
+            return crecp;
+          *up = crecp->hash_next;
+          cache_unlink(crecp);
+          cache_free(crecp);
+          continue;
+        }
+#endif
+      }
+      up = &crecp->hash_next;
     }
-  else
-    {
-      int i;
+  } else {
+    int i;
 #ifdef HAVE_IPV6
-      int addrlen = (flags & F_IPV6) ? IN6ADDRSZ : INADDRSZ;
+    int addrlen = (flags & F_IPV6) ? IN6ADDRSZ : INADDRSZ;
 #else
-      int addrlen = INADDRSZ;
-#endif 
-      for (i = 0; i < hash_size; i++)
-	for (crecp = hash_table[i], up = &hash_table[i]; 
-	     crecp && ((crecp->flags & F_REVERSE) || !(crecp->flags & F_IMMORTAL));
-	     crecp = crecp->hash_next)
-	  if (is_expired(now, crecp))
-	    {
-	      *up = crecp->hash_next;
-	      if (!(crecp->flags & (F_HOSTS | F_DHCP | F_CONFIG)))
-		{ 
-		  cache_unlink(crecp);
-		  cache_free(crecp);
-		}
-	    }
-	  else if (!(crecp->flags & (F_HOSTS | F_DHCP | F_CONFIG)) &&
-		   (flags & crecp->flags & F_REVERSE) && 
-		   (flags & crecp->flags & (F_IPV4 | F_IPV6)) &&
-		   memcmp(&crecp->addr.addr, addr, addrlen) == 0)
-	    {
-	      *up = crecp->hash_next;
-	      cache_unlink(crecp);
-	      cache_free(crecp);
-	    }
-	  else
-	    up = &crecp->hash_next;
-    }
-  
+    int addrlen = INADDRSZ;
+#endif
+    for (i = 0; i < hash_size; i++)
+      for (crecp = hash_table[i], up = &hash_table[i];
+           crecp && ((crecp->flags & F_REVERSE)
+                     || !(crecp->flags & F_IMMORTAL)); crecp = crecp->hash_next)
+        if (is_expired(now, crecp)) {
+          *up = crecp->hash_next;
+          if (!(crecp->flags & (F_HOSTS | F_DHCP | F_CONFIG))) {
+            cache_unlink(crecp);
+            cache_free(crecp);
+          }
+        } else if (!(crecp->flags & (F_HOSTS | F_DHCP | F_CONFIG)) &&
+                   (flags & crecp->flags & F_REVERSE) &&
+                   (flags & crecp->flags & (F_IPV4 | F_IPV6)) &&
+                   memcmp(&crecp->addr.addr, addr, addrlen) == 0) {
+          *up = crecp->hash_next;
+          cache_unlink(crecp);
+          cache_free(crecp);
+        } else
+          up = &crecp->hash_next;
+  }
+
   return NULL;
 }
 
@@ -428,19 +408,18 @@
 {
   /* Free any entries which didn't get committed during the last
      insert due to error.
-  */
-  while (new_chain)
-    {
-      struct crec *tmp = new_chain->next;
-      cache_free(new_chain);
-      new_chain = tmp;
-    }
+   */
+  while (new_chain) {
+    struct crec *tmp = new_chain->next;
+    cache_free(new_chain);
+    new_chain = tmp;
+  }
   new_chain = NULL;
   insert_error = 0;
 }
- 
-struct crec *cache_insert(char *name, struct all_addr *addr, 
-			  time_t now,  unsigned long ttl, unsigned short flags)
+
+struct crec *cache_insert(char *name, struct all_addr *addr,
+                          time_t now, unsigned long ttl, unsigned short flags)
 {
   struct crec *new;
   union bigname *big_name = NULL;
@@ -448,145 +427,130 @@
   int free_avail = 0;
 
   /* Don't log DNSSEC records here, done elsewhere */
-  if (flags & (F_IPV4 | F_IPV6 | F_CNAME))
-    {
-      log_query(flags | F_UPSTREAM, name, addr, NULL);
-      /* Don't mess with TTL for DNSSEC records. */
-      if (daemon->max_cache_ttl != 0 && daemon->max_cache_ttl < ttl)
-	ttl = daemon->max_cache_ttl;
-      if (daemon->min_cache_ttl != 0 && daemon->min_cache_ttl > ttl)
-	ttl = daemon->min_cache_ttl;
-    }
+  if (flags & (F_IPV4 | F_IPV6 | F_CNAME)) {
+    log_query(flags | F_UPSTREAM, name, addr, NULL);
+    /* Don't mess with TTL for DNSSEC records. */
+    if (daemon->max_cache_ttl != 0 && daemon->max_cache_ttl < ttl)
+      ttl = daemon->max_cache_ttl;
+    if (daemon->min_cache_ttl != 0 && daemon->min_cache_ttl > ttl)
+      ttl = daemon->min_cache_ttl;
+  }
 
   /* if previous insertion failed give up now. */
   if (insert_error)
     return NULL;
-  
+
   /* First remove any expired entries and entries for the name/address we
      are currently inserting. */
-  if ((new = cache_scan_free(name, addr, now, flags)))
-    {
-      /* We're trying to insert a record over one from 
-	 /etc/hosts or DHCP, or other config. If the 
-	 existing record is for an A or AAAA and
-	 the record we're trying to insert is the same, 
-	 just drop the insert, but don't error the whole process. */
-      if ((flags & (F_IPV4 | F_IPV6)) && (flags & F_FORWARD) && addr)
-	{
-	  if ((flags & F_IPV4) && (new->flags & F_IPV4) &&
-	      new->addr.addr.addr.addr4.s_addr == addr->addr.addr4.s_addr)
-	    return new;
+  if ((new = cache_scan_free(name, addr, now, flags))) {
+    /* We're trying to insert a record over one from
+       /etc/hosts or DHCP, or other config. If the
+       existing record is for an A or AAAA and
+       the record we're trying to insert is the same,
+       just drop the insert, but don't error the whole process. */
+    if ((flags & (F_IPV4 | F_IPV6)) && (flags & F_FORWARD) && addr) {
+      if ((flags & F_IPV4) && (new->flags & F_IPV4) &&
+          new->addr.addr.addr.addr4.s_addr == addr->addr.addr4.s_addr)
+        return new;
 #ifdef HAVE_IPV6
-	  else if ((flags & F_IPV6) && (new->flags & F_IPV6) &&
-		   IN6_ARE_ADDR_EQUAL(&new->addr.addr.addr.addr6, &addr->addr.addr6))
-	    return new;
+      else if ((flags & F_IPV6) && (new->flags & F_IPV6) &&
+               IN6_ARE_ADDR_EQUAL(&new->addr.addr.addr.addr6,
+                                  &addr->addr.addr6))
+        return new;
 #endif
-	}
-      
-      insert_error = 1;
-      return NULL;
     }
-  
+
+    insert_error = 1;
+    return NULL;
+  }
+
   /* Now get a cache entry from the end of the LRU list */
   while (1) {
-    if (!(new = cache_tail)) /* no entries left - cache is too small, bail */
-      {
-	insert_error = 1;
-	return NULL;
-      }
-    
+    if (!(new = cache_tail)) {  /* no entries left - cache is too small, bail */
+      insert_error = 1;
+      return NULL;
+    }
+
     /* End of LRU list is still in use: if we didn't scan all the hash
        chains for expired entries do that now. If we already tried that
        then it's time to start spilling things. */
-    
-    if (new->flags & (F_FORWARD | F_REVERSE))
-      { 
-	/* If free_avail set, we believe that an entry has been freed.
-	   Bugs have been known to make this not true, resulting in
-	   a tight loop here. If that happens, abandon the
-	   insert. Once in this state, all inserts will probably fail. */
-	if (free_avail)
-	  {
-	    static int warned = 0;
-	    if (!warned)
-	      {
-		my_syslog(LOG_ERR, _("Internal error in cache."));
-		warned = 1;
-	      }
-	    insert_error = 1;
-	    return NULL;
-	  }
-		
-	if (freed_all)
-	  {
-	    struct all_addr free_addr = new->addr.addr;;
+
+    if (new->flags & (F_FORWARD | F_REVERSE)) {
+      /* If free_avail set, we believe that an entry has been freed.
+         Bugs have been known to make this not true, resulting in
+         a tight loop here. If that happens, abandon the
+         insert. Once in this state, all inserts will probably fail. */
+      if (free_avail) {
+        static int warned = 0;
+        if (!warned) {
+          my_syslog(LOG_ERR, _("Internal error in cache."));
+          warned = 1;
+        }
+        insert_error = 1;
+        return NULL;
+      }
+
+      if (freed_all) {
+        struct all_addr free_addr = new->addr.addr;;
 
 #ifdef HAVE_DNSSEC
-	    /* For DNSSEC records, addr holds class. */
-	    if (new->flags & (F_DS | F_DNSKEY))
-	      free_addr.addr.dnssec.class = new->uid;
-#endif
-	    
-	    free_avail = 1; /* Must be free space now. */
-	    cache_scan_free(cache_get_name(new), &free_addr, now, new->flags);
-	    cache_live_freed++;
-	  }
-	else
-	  {
-	    cache_scan_free(NULL, NULL, now, 0);
-	    freed_all = 1;
-	  }
-	continue;
+        /* For DNSSEC records, addr holds class. */
+        if (new->flags & (F_DS | F_DNSKEY))
+          free_addr.addr.dnssec.class = new->uid;
+#endif
+
+        free_avail = 1;         /* Must be free space now. */
+        cache_scan_free(cache_get_name(new), &free_addr, now, new->flags);
+        cache_live_freed++;
+      } else {
+        cache_scan_free(NULL, NULL, now, 0);
+        freed_all = 1;
       }
- 
+      continue;
+    }
+
     /* Check if we need to and can allocate extra memory for a long name.
        If that fails, give up now, always succeed for DNSSEC records. */
-    if (name && (strlen(name) > SMALLDNAME-1))
-      {
-	if (big_free)
-	  { 
-	    big_name = big_free;
-	    big_free = big_free->next;
-	  }
-	else if ((bignames_left == 0 && !(flags & (F_DS | F_DNSKEY))) ||
-		 !(big_name = (union bigname *)whine_malloc(sizeof(union bigname))))
-	  {
-	    insert_error = 1;
-	    return NULL;
-	  }
-	else if (bignames_left != 0)
-	  bignames_left--;
-	
-      }
+    if (name && (strlen(name) > SMALLDNAME - 1)) {
+      if (big_free) {
+        big_name = big_free;
+        big_free = big_free->next;
+      } else if ((bignames_left == 0 && !(flags & (F_DS | F_DNSKEY))) ||
+                 !(big_name =
+                   (union bigname *) whine_malloc(sizeof(union bigname)))) {
+        insert_error = 1;
+        return NULL;
+      } else if (bignames_left != 0)
+        bignames_left--;
+
+    }
 
     /* Got the rest: finally grab entry. */
     cache_unlink(new);
     break;
   }
-  
+
   new->flags = flags;
-  if (big_name)
-    {
-      new->name.bname = big_name;
-      new->flags |= F_BIGNAME;
-    }
+  if (big_name) {
+    new->name.bname = big_name;
+    new->flags |= F_BIGNAME;
+  }
 
   if (name)
     strcpy(cache_get_name(new), name);
   else
     *cache_get_name(new) = 0;
 
-  if (addr)
-    {
+  if (addr) {
 #ifdef HAVE_DNSSEC
-      if (flags & (F_DS | F_DNSKEY))
-	new->uid = addr->addr.dnssec.class;
-      else
+    if (flags & (F_DS | F_DNSKEY))
+      new->uid = addr->addr.dnssec.class;
+    else
 #endif
-	new->addr.addr = *addr;	
-    }
+      new->addr.addr = *addr;
+  }
 
-  new->ttd = now + (time_t)ttl;
+  new->ttd = now + (time_t) ttl;
   new->next = new_chain;
   new_chain = new;
 
@@ -598,113 +562,96 @@
 {
   if (insert_error)
     return;
-  
-  while (new_chain)
-    { 
-      struct crec *tmp = new_chain->next;
-      /* drop CNAMEs which didn't find a target. */
-      if (is_outdated_cname_pointer(new_chain))
-	cache_free(new_chain);
-      else
-	{
-	  cache_hash(new_chain);
-	  cache_link(new_chain);
-	  cache_inserted++;
-	}
-      new_chain = tmp;
+
+  while (new_chain) {
+    struct crec *tmp = new_chain->next;
+    /* drop CNAMEs which didn't find a target. */
+    if (is_outdated_cname_pointer(new_chain))
+      cache_free(new_chain);
+    else {
+      cache_hash(new_chain);
+      cache_link(new_chain);
+      cache_inserted++;
     }
+    new_chain = tmp;
+  }
   new_chain = NULL;
 }
 
-struct crec *cache_find_by_name(struct crec *crecp, char *name, time_t now, unsigned int prot)
+struct crec *cache_find_by_name(struct crec *crecp, char *name, time_t now,
+                                unsigned int prot)
 {
   struct crec *ans;
   int no_rr = prot & F_NO_RR;
 
   prot &= ~F_NO_RR;
-  
-  if (crecp) /* iterating */
+
+  if (crecp)                    /* iterating */
     ans = crecp->next;
-  else
-    {
-      /* first search, look for relevant entries and push to top of list
-	 also free anything which has expired */
-      struct crec *next, **up, **insert = NULL, **chainp = &ans;
-      unsigned short ins_flags = 0;
-      
-      for (up = hash_bucket(name), crecp = *up; crecp; crecp = next)
-	{
-	  next = crecp->hash_next;
-	  
-	  if (!is_expired(now, crecp) && !is_outdated_cname_pointer(crecp))
-	    {
-	      if ((crecp->flags & F_FORWARD) && 
-		  (crecp->flags & prot) &&
-		  hostname_isequal(cache_get_name(crecp), name))
-		{
-		  if (crecp->flags & (F_HOSTS | F_DHCP | F_CONFIG))
-		    {
-		      *chainp = crecp;
-		      chainp = &crecp->next;
-		    }
-		  else
-		    {
-		      cache_unlink(crecp);
-		      cache_link(crecp);
-		    }
-	      	      
-		  /* Move all but the first entry up the hash chain
-		     this implements round-robin. 
-		     Make sure that re-ordering doesn't break the hash-chain
-		     order invariants. 
-		  */
-		  if (insert && (crecp->flags & (F_REVERSE | F_IMMORTAL)) == ins_flags)
-		    {
-		      *up = crecp->hash_next;
-		      crecp->hash_next = *insert;
-		      *insert = crecp;
-		      insert = &crecp->hash_next;
-		    }
-		  else
-		    {
-		      if (!insert && !no_rr)
-			{
-			  insert = up;
-			  ins_flags = crecp->flags & (F_REVERSE | F_IMMORTAL);
-			}
-		      up = &crecp->hash_next; 
-		    }
-		}
-	      else
-		/* case : not expired, incorrect entry. */
-		up = &crecp->hash_next; 
-	    }
-	  else
-	    {
-	      /* expired entry, free it */
-	      *up = crecp->hash_next;
-	      if (!(crecp->flags & (F_HOSTS | F_DHCP | F_CONFIG)))
-		{ 
-		  cache_unlink(crecp);
-		  cache_free(crecp);
-		}
-	    }
-	}
-	  
-      *chainp = cache_head;
+  else {
+    /* first search, look for relevant entries and push to top of list
+       also free anything which has expired */
+    struct crec *next, **up, **insert = NULL, **chainp = &ans;
+    unsigned short ins_flags = 0;
+
+    for (up = hash_bucket(name), crecp = *up; crecp; crecp = next) {
+      next = crecp->hash_next;
+
+      if (!is_expired(now, crecp) && !is_outdated_cname_pointer(crecp)) {
+        if ((crecp->flags & F_FORWARD) &&
+            (crecp->flags & prot) &&
+            hostname_isequal(cache_get_name(crecp), name)) {
+          if (crecp->flags & (F_HOSTS | F_DHCP | F_CONFIG)) {
+            *chainp = crecp;
+            chainp = &crecp->next;
+          } else {
+            cache_unlink(crecp);
+            cache_link(crecp);
+          }
+
+          /* Move all but the first entry up the hash chain
+             this implements round-robin.
+             Make sure that re-ordering doesn't break the hash-chain
+             order invariants.
+           */
+          if (insert && (crecp->flags & (F_REVERSE | F_IMMORTAL)) == ins_flags) {
+            *up = crecp->hash_next;
+            crecp->hash_next = *insert;
+            *insert = crecp;
+            insert = &crecp->hash_next;
+          } else {
+            if (!insert && !no_rr) {
+              insert = up;
+              ins_flags = crecp->flags & (F_REVERSE | F_IMMORTAL);
+            }
+            up = &crecp->hash_next;
+          }
+        } else
+          /* case : not expired, incorrect entry. */
+          up = &crecp->hash_next;
+      } else {
+        /* expired entry, free it */
+        *up = crecp->hash_next;
+        if (!(crecp->flags & (F_HOSTS | F_DHCP | F_CONFIG))) {
+          cache_unlink(crecp);
+          cache_free(crecp);
+        }
+      }
     }
 
-  if (ans && 
+    *chainp = cache_head;
+  }
+
+  if (ans &&
       (ans->flags & F_FORWARD) &&
-      (ans->flags & prot) &&     
-      hostname_isequal(cache_get_name(ans), name))
+      (ans->flags & prot) && hostname_isequal(cache_get_name(ans), name))
     return ans;
-  
+
   return NULL;
 }
 
-struct crec *cache_find_by_addr(struct crec *crecp, struct all_addr *addr, 
-				time_t now, unsigned int prot)
+struct crec *cache_find_by_addr(struct crec *crecp, struct all_addr *addr,
+                                time_t now, unsigned int prot)
 {
   struct crec *ans;
 #ifdef HAVE_IPV6
@@ -712,59 +659,48 @@
 #else
   int addrlen = INADDRSZ;
 #endif
-  
-  if (crecp) /* iterating */
+
+  if (crecp)                    /* iterating */
     ans = crecp->next;
-  else
-    {  
-      /* first search, look for relevant entries and push to top of list
-	 also free anything which has expired. All the reverse entries are at the
-	 start of the hash chain, so we can give up when we find the first 
-	 non-REVERSE one.  */
-       int i;
-       struct crec **up, **chainp = &ans;
-       
-       for (i=0; i<hash_size; i++)
-	 for (crecp = hash_table[i], up = &hash_table[i]; 
-	      crecp && (crecp->flags & F_REVERSE);
-	      crecp = crecp->hash_next)
-	   if (!is_expired(now, crecp))
-	     {      
-	       if ((crecp->flags & prot) &&
-		   memcmp(&crecp->addr.addr, addr, addrlen) == 0)
-		 {	    
-		   if (crecp->flags & (F_HOSTS | F_DHCP | F_CONFIG))
-		     {
-		       *chainp = crecp;
-		       chainp = &crecp->next;
-		     }
-		   else
-		     {
-		       cache_unlink(crecp);
-		       cache_link(crecp);
-		     }
-		 }
-	       up = &crecp->hash_next;
-	     }
-	   else
-	     {
-	       *up = crecp->hash_next;
-	       if (!(crecp->flags & (F_HOSTS | F_DHCP | F_CONFIG)))
-		 {
-		   cache_unlink(crecp);
-		   cache_free(crecp);
-		 }
-	     }
-       
-       *chainp = cache_head;
-    }
-  
-  if (ans && 
+  else {
+    /* first search, look for relevant entries and push to top of list
+       also free anything which has expired. All the reverse entries are at the
+       start of the hash chain, so we can give up when we find the first
+       non-REVERSE one.  */
+    int i;
+    struct crec **up, **chainp = &ans;
+
+    for (i = 0; i < hash_size; i++)
+      for (crecp = hash_table[i], up = &hash_table[i];
+           crecp && (crecp->flags & F_REVERSE); crecp = crecp->hash_next)
+        if (!is_expired(now, crecp)) {
+          if ((crecp->flags & prot) &&
+              memcmp(&crecp->addr.addr, addr, addrlen) == 0) {
+            if (crecp->flags & (F_HOSTS | F_DHCP | F_CONFIG)) {
+              *chainp = crecp;
+              chainp = &crecp->next;
+            } else {
+              cache_unlink(crecp);
+              cache_link(crecp);
+            }
+          }
+          up = &crecp->hash_next;
+        } else {
+          *up = crecp->hash_next;
+          if (!(crecp->flags & (F_HOSTS | F_DHCP | F_CONFIG))) {
+            cache_unlink(crecp);
+            cache_free(crecp);
+          }
+        }
+
+    *chainp = cache_head;
+  }
+
+  if (ans &&
       (ans->flags & F_REVERSE) &&
-      (ans->flags & prot) &&
-      memcmp(&ans->addr.addr, addr, addrlen) == 0)
+      (ans->flags & prot) && memcmp(&ans->addr.addr, addr, addrlen) == 0)
     return ans;
-  
+
   return NULL;
 }
 
@@ -772,41 +708,41 @@
 {
   struct crec *crec;
   struct cname *a;
-  
+
   for (a = daemon->cnames; a; a = a->next)
     if (a->alias[1] != '*' &&
-	hostname_isequal(cache_get_name(target), a->target) &&
-	(crec = whine_malloc(sizeof(struct crec))))
-      {
-	crec->flags = F_FORWARD | F_IMMORTAL | F_NAMEP | F_CONFIG | F_CNAME;
-	crec->ttd = a->ttl;
-	crec->name.namep = a->alias;
-	crec->addr.cname.target.cache = target;
-	crec->addr.cname.uid = target->uid;
-	crec->uid = next_uid();
-	cache_hash(crec);
-	add_hosts_cname(crec); /* handle chains */
-      }
+        hostname_isequal(cache_get_name(target), a->target) &&
+        (crec = whine_malloc(sizeof(struct crec)))) {
+      crec->flags = F_FORWARD | F_IMMORTAL | F_NAMEP | F_CONFIG | F_CNAME;
+      crec->ttd = a->ttl;
+      crec->name.namep = a->alias;
+      crec->addr.cname.target.cache = target;
+      crec->addr.cname.uid = target->uid;
+      crec->uid = next_uid();
+      cache_hash(crec);
+      add_hosts_cname(crec);    /* handle chains */
+    }
 }
-  
-static void add_hosts_entry(struct crec *cache, struct all_addr *addr, int addrlen, 
-			    unsigned int index, struct crec **rhash, int hashsz)
+
+static void add_hosts_entry(struct crec *cache, struct all_addr *addr,
+                            int addrlen, unsigned int index,
+                            struct crec **rhash, int hashsz)
 {
-  struct crec *lookup = cache_find_by_name(NULL, cache_get_name(cache), 0, cache->flags & (F_IPV4 | F_IPV6));
+  struct crec *lookup =
+      cache_find_by_name(NULL, cache_get_name(cache), 0,
+                         cache->flags & (F_IPV4 | F_IPV6));
   int i, nameexists = 0;
-  unsigned int j; 
+  unsigned int j;
 
   /* Remove duplicates in hosts files. */
-  if (lookup && (lookup->flags & F_HOSTS))
-    {
-      nameexists = 1;
-      if (memcmp(&lookup->addr.addr, addr, addrlen) == 0)
-	{
-	  free(cache);
-	  return;
-	}
+  if (lookup && (lookup->flags & F_HOSTS)) {
+    nameexists = 1;
+    if (memcmp(&lookup->addr.addr, addr, addrlen) == 0) {
+      free(cache);
+      return;
     }
-  
+  }
+
   /* Ensure there is only one address -> name mapping (first one trumps) 
      We do this by steam here, The entries are kept in hash chains, linked
      by ->next (which is unused at this point) held in hash buckets in
@@ -822,95 +758,87 @@
      Note that we only do this process when bulk-reading hosts files, 
      for incremental reads, rhash is NULL, and we use cache lookups
      instead.
-  */
-  
-  if (rhash)
-    {
-      /* hash address */
-      for (j = 0, i = 0; i < addrlen; i++)
-	j = (j*2 +((unsigned char *)addr)[i]) % hashsz;
-      
-      for (lookup = rhash[j]; lookup; lookup = lookup->next)
-	if ((lookup->flags & cache->flags & (F_IPV4 | F_IPV6)) &&
-	    memcmp(&lookup->addr.addr, addr, addrlen) == 0)
-	  {
-	    cache->flags &= ~F_REVERSE;
-	    break;
-	  }
-      
-      /* maintain address hash chain, insert new unique address */
-      if (!lookup)
-	{
-	  cache->next = rhash[j];
-	  rhash[j] = cache;
-	}
-    }
-  else
-    {
-      /* incremental read, lookup in cache */
-      lookup = cache_find_by_addr(NULL, addr, 0, cache->flags & (F_IPV4 | F_IPV6));
-      if (lookup && lookup->flags & F_HOSTS)
-	cache->flags &= ~F_REVERSE;
-    }
+   */
+
+  if (rhash) {
+    /* hash address */
+    for (j = 0, i = 0; i < addrlen; i++)
+      j = (j * 2 + ((unsigned char *) addr)[i]) % hashsz;
+
+    for (lookup = rhash[j]; lookup; lookup = lookup->next)
+      if ((lookup->flags & cache->flags & (F_IPV4 | F_IPV6)) &&
+          memcmp(&lookup->addr.addr, addr, addrlen) == 0) {
+        cache->flags &= ~F_REVERSE;
+        break;
+      }
+
+    /* maintain address hash chain, insert new unique address */
+    if (!lookup) {
+      cache->next = rhash[j];
+      rhash[j] = cache;
+    }
+  } else {
+    /* incremental read, lookup in cache */
+    lookup =
+        cache_find_by_addr(NULL, addr, 0, cache->flags & (F_IPV4 | F_IPV6));
+    if (lookup && lookup->flags & F_HOSTS)
+      cache->flags &= ~F_REVERSE;
+  }
 
   cache->uid = index;
-  memcpy(&cache->addr.addr, addr, addrlen);  
+  memcpy(&cache->addr.addr, addr, addrlen);
   cache_hash(cache);
-  
+
   /* don't need to do alias stuff for second and subsequent addresses. */
   if (!nameexists)
     add_hosts_cname(cache);
 }
 
-static int eatspace(FILE *f)
+static int eatspace(FILE * f)
 {
   int c, nl = 0;
 
-  while (1)
-    {
-      if ((c = getc(f)) == '#')
-	while (c != '\n' && c != EOF)
-	  c = getc(f);
-      
-      if (c == EOF)
-	return 1;
-
-      if (!isspace(c))
-	{
-	  ungetc(c, f);
-	  return nl;
-	}
+  while (1) {
+    if ((c = getc(f)) == '#')
+      while (c != '\n' && c != EOF)
+        c = getc(f);
+
+    if (c == EOF)
+      return 1;
 
-      if (c == '\n')
-	nl = 1;
+    if (!isspace(c)) {
+      ungetc(c, f);
+      return nl;
     }
+
+    if (c == '\n')
+      nl = 1;
+  }
 }
-	 
-static int gettok(FILE *f, char *token)
+
+static int gettok(FILE * f, char *token)
 {
   int c, count = 0;
- 
-  while (1)
-    {
-      if ((c = getc(f)) == EOF)
-	return (count == 0) ? EOF : 1;
-
-      if (isspace(c) || c == '#')
-	{
-	  ungetc(c, f);
-	  return eatspace(f);
-	}
-      
-      if (count < (MAXDNAME - 1))
-	{
-	  token[count++] = c;
-	  token[count] = 0;
-	}
+
+  while (1) {
+    if ((c = getc(f)) == EOF)
+      return (count == 0) ? EOF : 1;
+
+    if (isspace(c) || c == '#') {
+      ungetc(c, f);
+      return eatspace(f);
+    }
+
+    if (count < (MAXDNAME - 1)) {
+      token[count++] = c;
+      token[count] = 0;
     }
+  }
 }
 
-int read_hostsfile(char *filename, unsigned int index, int cache_size, struct crec **rhash, int hashsz)
-{  
+int read_hostsfile(char *filename, unsigned int index, int cache_size,
+                   struct crec **rhash, int hashsz)
+{
   FILE *f = fopen(filename, "r");
   char *token = daemon->namebuff, *domain_suffix = NULL;
   int addr_count = 0, name_count = cache_size, lineno = 0;
@@ -918,101 +846,94 @@
   struct all_addr addr;
   int atnl, addrlen = 0;
 
-  if (!f)
-    {
-      my_syslog(LOG_ERR, _("failed to load names from %s: %s"), filename, strerror(errno));
-      return cache_size;
-    }
-  
+  if (!f) {
+    my_syslog(LOG_ERR, _("failed to load names from %s: %s"), filename,
+              strerror(errno));
+    return cache_size;
+  }
+
   eatspace(f);
-  
-  while ((atnl = gettok(f, token)) != EOF)
-    {
-      lineno++;
-      
-      if (inet_pton(AF_INET, token, &addr) > 0)
-	{
-	  flags = F_HOSTS | F_IMMORTAL | F_FORWARD | F_REVERSE | F_IPV4;
-	  addrlen = INADDRSZ;
-	  domain_suffix = get_domain(addr.addr.addr4);
-	}
+
+  while ((atnl = gettok(f, token)) != EOF) {
+    lineno++;
+
+    if (inet_pton(AF_INET, token, &addr) > 0) {
+      flags = F_HOSTS | F_IMMORTAL | F_FORWARD | F_REVERSE | F_IPV4;
+      addrlen = INADDRSZ;
+      domain_suffix = get_domain(addr.addr.addr4);
+    }
 #ifdef HAVE_IPV6
-      else if (inet_pton(AF_INET6, token, &addr) > 0)
-	{
-	  flags = F_HOSTS | F_IMMORTAL | F_FORWARD | F_REVERSE | F_IPV6;
-	  addrlen = IN6ADDRSZ;
-	  domain_suffix = get_domain6(&addr.addr.addr6);
-	}
+    else if (inet_pton(AF_INET6, token, &addr) > 0) {
+      flags = F_HOSTS | F_IMMORTAL | F_FORWARD | F_REVERSE | F_IPV6;
+      addrlen = IN6ADDRSZ;
+      domain_suffix = get_domain6(&addr.addr.addr6);
+    }
 #endif
-      else
-	{
-	  my_syslog(LOG_ERR, _("bad address at %s line %d"), filename, lineno); 
-	  while (atnl == 0)
-	    atnl = gettok(f, token);
-	  continue;
-	}
-      
-      addr_count++;
-      
-      /* rehash every 1000 names. */
-      if (rhash && ((name_count - cache_size) > 1000))
-	{
-	  rehash(name_count);
-	  cache_size = name_count;
-	} 
-      
+    else {
+      my_syslog(LOG_ERR, _("bad address at %s line %d"), filename, lineno);
       while (atnl == 0)
-	{
-	  struct crec *cache;
-	  int fqdn, nomem;
-	  char *canon;
-	  
-	  if ((atnl = gettok(f, token)) == EOF)
-	    break;
-
-	  fqdn = !!strchr(token, '.');
-
-	  if ((canon = canonicalise(token, &nomem)))
-	    {
-	      /* If set, add a version of the name with a default domain appended */
-	      if (option_bool(OPT_EXPAND) && domain_suffix && !fqdn && 
-		  (cache = whine_malloc(sizeof(struct crec) + 
-					strlen(canon)+2+strlen(domain_suffix)-SMALLDNAME)))
-		{
-		  strcpy(cache->name.sname, canon);
-		  strcat(cache->name.sname, ".");
-		  strcat(cache->name.sname, domain_suffix);
-		  cache->flags = flags;
-		  cache->ttd = daemon->local_ttl;
-		  add_hosts_entry(cache, &addr, addrlen, index, rhash, hashsz);
-		  name_count++;
-		}
-	      if ((cache = whine_malloc(sizeof(struct crec) + strlen(canon)+1-SMALLDNAME)))
-		{
-		  strcpy(cache->name.sname, canon);
-		  cache->flags = flags;
-		  cache->ttd = daemon->local_ttl;
-		  add_hosts_entry(cache, &addr, addrlen, index, rhash, hashsz);
-		  name_count++;
-		}
-	      free(canon);
-	      
-	    }
-	  else if (!nomem)
-	    my_syslog(LOG_ERR, _("bad name at %s line %d"), filename, lineno); 
-	}
-    } 
+        atnl = gettok(f, token);
+      continue;
+    }
+
+    addr_count++;
+
+    /* rehash every 1000 names. */
+    if (rhash && ((name_count - cache_size) > 1000)) {
+      rehash(name_count);
+      cache_size = name_count;
+    }
+
+    while (atnl == 0) {
+      struct crec *cache;
+      int fqdn, nomem;
+      char *canon;
+
+      if ((atnl = gettok(f, token)) == EOF)
+        break;
+
+      fqdn = ! !strchr(token, '.');
+
+      if ((canon = canonicalise(token, &nomem))) {
+        /* If set, add a version of the name with a default domain appended */
+        if (option_bool(OPT_EXPAND) && domain_suffix && !fqdn &&
+            (cache = whine_malloc(sizeof(struct crec) +
+                                  strlen(canon) + 2 + strlen(domain_suffix) -
+                                  SMALLDNAME))) {
+          strcpy(cache->name.sname, canon);
+          strcat(cache->name.sname, ".");
+          strcat(cache->name.sname, domain_suffix);
+          cache->flags = flags;
+          cache->ttd = daemon->local_ttl;
+          add_hosts_entry(cache, &addr, addrlen, index, rhash, hashsz);
+          name_count++;
+        }
+        if ((cache =
+             whine_malloc(sizeof(struct crec) + strlen(canon) + 1 -
+                          SMALLDNAME))) {
+          strcpy(cache->name.sname, canon);
+          cache->flags = flags;
+          cache->ttd = daemon->local_ttl;
+          add_hosts_entry(cache, &addr, addrlen, index, rhash, hashsz);
+          name_count++;
+        }
+        free(canon);
+
+      } else if (!nomem)
+        my_syslog(LOG_ERR, _("bad name at %s line %d"), filename, lineno);
+    }
+  }
 
   fclose(f);
-  
+
   if (rhash)
-    rehash(name_count); 
-  
+    rehash(name_count);
+
   my_syslog(LOG_INFO, _("read %s - %d addresses"), filename, addr_count);
-  
+
   return name_count;
 }
-	    
+
 void cache_reload(void)
 {
   struct crec *cache, **up, *tmp;
@@ -1027,67 +948,58 @@
 #endif
 
   cache_inserted = cache_live_freed = 0;
-  
-  for (i=0; i<hash_size; i++)
-    for (cache = hash_table[i], up = &hash_table[i]; cache; cache = tmp)
-      {
+
+  for (i = 0; i < hash_size; i++)
+    for (cache = hash_table[i], up = &hash_table[i]; cache; cache = tmp) {
 #ifdef HAVE_DNSSEC
-	cache_blockdata_free(cache);
+      cache_blockdata_free(cache);
 #endif
-	tmp = cache->hash_next;
-	if (cache->flags & (F_HOSTS | F_CONFIG))
-	  {
-	    *up = cache->hash_next;
-	    free(cache);
-	  }
-	else if (!(cache->flags & F_DHCP))
-	  {
-	    *up = cache->hash_next;
-	    if (cache->flags & F_BIGNAME)
-	      {
-		cache->name.bname->next = big_free;
-		big_free = cache->name.bname;
-	      }
-	    cache->flags = 0;
-	  }
-	else
-	  up = &cache->hash_next;
-      }
-  
+      tmp = cache->hash_next;
+      if (cache->flags & (F_HOSTS | F_CONFIG)) {
+        *up = cache->hash_next;
+        free(cache);
+      } else if (!(cache->flags & F_DHCP)) {
+        *up = cache->hash_next;
+        if (cache->flags & F_BIGNAME) {
+          cache->name.bname->next = big_free;
+          big_free = cache->name.bname;
+        }
+        cache->flags = 0;
+      } else
+        up = &cache->hash_next;
+    }
+
   /* Add CNAMEs to interface_names to the cache */
   for (a = daemon->cnames; a; a = a->next)
     for (intr = daemon->int_names; intr; intr = intr->next)
       if (a->alias[1] != '*' &&
-	  hostname_isequal(a->target, intr->name) &&
-	  ((cache = whine_malloc(sizeof(struct crec)))))
-	{
-	  cache->flags = F_FORWARD | F_NAMEP | F_CNAME | F_IMMORTAL | F_CONFIG;
-	  cache->ttd = a->ttl;
-	  cache->name.namep = a->alias;
-	  cache->addr.cname.target.int_name = intr;
-	  cache->addr.cname.uid = SRC_INTERFACE;
-	  cache->uid = next_uid();
-	  cache_hash(cache);
-	  add_hosts_cname(cache); /* handle chains */
-	}
-
+          hostname_isequal(a->target, intr->name) &&
+          ((cache = whine_malloc(sizeof(struct crec))))) {
+        cache->flags = F_FORWARD | F_NAMEP | F_CNAME | F_IMMORTAL | F_CONFIG;
+        cache->ttd = a->ttl;
+        cache->name.namep = a->alias;
+        cache->addr.cname.target.int_name = intr;
+        cache->addr.cname.uid = SRC_INTERFACE;
+        cache->uid = next_uid();
+        cache_hash(cache);
+        add_hosts_cname(cache); /* handle chains */
+      }
 #ifdef HAVE_DNSSEC
   for (ds = daemon->ds; ds; ds = ds->next)
     if ((cache = whine_malloc(sizeof(struct crec))) &&
-	(cache->addr.ds.keydata = blockdata_alloc(ds->digest, ds->digestlen)))
-      {
-	cache->flags = F_FORWARD | F_IMMORTAL | F_DS | F_CONFIG | F_NAMEP;
-	cache->ttd = daemon->local_ttl;
-	cache->name.namep = ds->name;
-	cache->addr.ds.keylen = ds->digestlen;
-	cache->addr.ds.algo = ds->algo;
-	cache->addr.ds.keytag = ds->keytag;
-	cache->addr.ds.digest = ds->digest_type;
-	cache->uid = ds->class;
-	cache_hash(cache);
-      }
+        (cache->addr.ds.keydata = blockdata_alloc(ds->digest, ds->digestlen))) {
+      cache->flags = F_FORWARD | F_IMMORTAL | F_DS | F_CONFIG | F_NAMEP;
+      cache->ttd = daemon->local_ttl;
+      cache->name.namep = ds->name;
+      cache->addr.ds.keylen = ds->digestlen;
+      cache->addr.ds.algo = ds->algo;
+      cache->addr.ds.keytag = ds->keytag;
+      cache->addr.ds.digest = ds->digest_type;
+      cache->uid = ds->class;
+      cache_hash(cache);
+    }
 #endif
-  
+
   /* borrow the packet buffer for a temporary by-address hash */
   memset(daemon->packet, 0, daemon->packet_buff_sz);
   revhashsz = daemon->packet_buff_sz / sizeof(struct crec *);
@@ -1096,62 +1008,66 @@
 
   /* Do host_records in config. */
   for (hr = daemon->host_records; hr; hr = hr->next)
-    for (nl = hr->names; nl; nl = nl->next)
-      {
-	if (hr->addr.s_addr != 0 &&
-	    (cache = whine_malloc(sizeof(struct crec))))
-	  {
-	    cache->name.namep = nl->name;
-	    cache->ttd = hr->ttl;
-	    cache->flags = F_HOSTS | F_IMMORTAL | F_FORWARD | F_REVERSE | F_IPV4 | F_NAMEP | F_CONFIG;
-	    add_hosts_entry(cache, (struct all_addr *)&hr->addr, INADDRSZ, SRC_CONFIG, (struct crec **)daemon->packet, revhashsz);
-	  }
+    for (nl = hr->names; nl; nl = nl->next) {
+      if (hr->addr.s_addr != 0 && (cache = whine_malloc(sizeof(struct crec)))) {
+        cache->name.namep = nl->name;
+        cache->ttd = hr->ttl;
+        cache->flags =
+            F_HOSTS | F_IMMORTAL | F_FORWARD | F_REVERSE | F_IPV4 | F_NAMEP |
+            F_CONFIG;
+        add_hosts_entry(cache, (struct all_addr *) &hr->addr, INADDRSZ,
+                        SRC_CONFIG, (struct crec **) daemon->packet, revhashsz);
+      }
 #ifdef HAVE_IPV6
-	if (!IN6_IS_ADDR_UNSPECIFIED(&hr->addr6) &&
-	    (cache = whine_malloc(sizeof(struct crec))))
-	  {
-	    cache->name.namep = nl->name;
-	    cache->ttd = hr->ttl;
-	    cache->flags = F_HOSTS | F_IMMORTAL | F_FORWARD | F_REVERSE | F_IPV6 | F_NAMEP | F_CONFIG;
-	    add_hosts_entry(cache, (struct all_addr *)&hr->addr6, IN6ADDRSZ, SRC_CONFIG, (struct crec **)daemon->packet, revhashsz);
-	  }
-#endif
+      if (!IN6_IS_ADDR_UNSPECIFIED(&hr->addr6) &&
+          (cache = whine_malloc(sizeof(struct crec)))) {
+        cache->name.namep = nl->name;
+        cache->ttd = hr->ttl;
+        cache->flags =
+            F_HOSTS | F_IMMORTAL | F_FORWARD | F_REVERSE | F_IPV6 | F_NAMEP |
+            F_CONFIG;
+        add_hosts_entry(cache, (struct all_addr *) &hr->addr6, IN6ADDRSZ,
+                        SRC_CONFIG, (struct crec **) daemon->packet, revhashsz);
       }
-	
-  if (option_bool(OPT_NO_HOSTS) && !daemon->addn_hosts)
-    {
-      if (daemon->cachesize > 0)
-	my_syslog(LOG_INFO, _("cleared cache"));
-    }
-  else
-    {
-      if (!option_bool(OPT_NO_HOSTS))
-	total_size = read_hostsfile(HOSTSFILE, SRC_HOSTS, total_size, (struct crec **)daemon->packet, revhashsz);
-      
-      daemon->addn_hosts = expand_filelist(daemon->addn_hosts);
-      for (ah = daemon->addn_hosts; ah; ah = ah->next)
-	if (!(ah->flags & AH_INACTIVE))
-	  total_size = read_hostsfile(ah->fname, ah->index, total_size, (struct crec **)daemon->packet, revhashsz);
+#endif
     }
 
+  if (option_bool(OPT_NO_HOSTS) && !daemon->addn_hosts) {
+    if (daemon->cachesize > 0)
+      my_syslog(LOG_INFO, _("cleared cache"));
+  } else {
+    if (!option_bool(OPT_NO_HOSTS))
+      total_size =
+          read_hostsfile(HOSTSFILE, SRC_HOSTS, total_size,
+                         (struct crec **) daemon->packet, revhashsz);
+
+    daemon->addn_hosts = expand_filelist(daemon->addn_hosts);
+    for (ah = daemon->addn_hosts; ah; ah = ah->next)
+      if (!(ah->flags & AH_INACTIVE))
+        total_size =
+            read_hostsfile(ah->fname, ah->index, total_size,
+                           (struct crec **) daemon->packet, revhashsz);
+  }
+
 #ifdef HAVE_INOTIFY
-  set_dynamic_inotify(AH_HOSTS, total_size, (struct crec **)daemon->packet, revhashsz);
+  set_dynamic_inotify(AH_HOSTS, total_size, (struct crec **) daemon->packet,
+                      revhashsz);
 #endif
-  
-} 
+
+}
 
 #ifdef HAVE_DHCP
 struct in_addr a_record_from_hosts(char *name, time_t now)
 {
   struct crec *crecp = NULL;
   struct in_addr ret;
-  
+
   while ((crecp = cache_find_by_name(crecp, name, now, F_IPV4)))
     if (crecp->flags & F_HOSTS)
-      return *(struct in_addr *)&crecp->addr;
+      return *(struct in_addr *) &crecp->addr;
 
   my_syslog(MS_DHCP | LOG_WARNING, _("No IPv4 address found for %s"), name);
-  
+
   ret.s_addr = 0;
   return ret;
 }
@@ -1161,51 +1077,48 @@
   struct crec *cache, **up;
   int i;
 
-  for (i=0; i<hash_size; i++)
-    for (cache = hash_table[i], up = &hash_table[i]; cache; cache = cache->hash_next)
-      if (cache->flags & F_DHCP)
-	{
-	  *up = cache->hash_next;
-	  cache->next = dhcp_spare;
-	  dhcp_spare = cache;
-	}
-      else
-	up = &cache->hash_next;
+  for (i = 0; i < hash_size; i++)
+    for (cache = hash_table[i], up = &hash_table[i]; cache;
+         cache = cache->hash_next)
+      if (cache->flags & F_DHCP) {
+        *up = cache->hash_next;
+        cache->next = dhcp_spare;
+        dhcp_spare = cache;
+      } else
+        up = &cache->hash_next;
 }
 
 static void add_dhcp_cname(struct crec *target, time_t ttd)
 {
   struct crec *aliasc;
   struct cname *a;
-  
+
   for (a = daemon->cnames; a; a = a->next)
     if (a->alias[1] != '*' &&
-	hostname_isequal(cache_get_name(target), a->target))
-      {
-	if ((aliasc = dhcp_spare))
-	  dhcp_spare = dhcp_spare->next;
-	else /* need new one */
-	  aliasc = whine_malloc(sizeof(struct crec));
-	
-	if (aliasc)
-	  {
-	    aliasc->flags = F_FORWARD | F_NAMEP | F_DHCP | F_CNAME | F_CONFIG;
-	    if (ttd == 0)
-	      aliasc->flags |= F_IMMORTAL;
-	    else
-	      aliasc->ttd = ttd;
-	    aliasc->name.namep = a->alias;
-	    aliasc->addr.cname.target.cache = target;
-	    aliasc->addr.cname.uid = target->uid;
-	    aliasc->uid = next_uid();
-	    cache_hash(aliasc);
-	    add_dhcp_cname(aliasc, ttd);
-	  }
+        hostname_isequal(cache_get_name(target), a->target)) {
+      if ((aliasc = dhcp_spare))
+        dhcp_spare = dhcp_spare->next;
+      else                      /* need new one */
+        aliasc = whine_malloc(sizeof(struct crec));
+
+      if (aliasc) {
+        aliasc->flags = F_FORWARD | F_NAMEP | F_DHCP | F_CNAME | F_CONFIG;
+        if (ttd == 0)
+          aliasc->flags |= F_IMMORTAL;
+        else
+          aliasc->ttd = ttd;
+        aliasc->name.namep = a->alias;
+        aliasc->addr.cname.target.cache = target;
+        aliasc->addr.cname.uid = target->uid;
+        aliasc->uid = next_uid();
+        cache_hash(aliasc);
+        add_dhcp_cname(aliasc, ttd);
       }
+    }
 }
 
 void cache_add_dhcp_entry(char *host_name, int prot,
-			  struct all_addr *host_address, time_t ttd) 
+                          struct all_addr *host_address, time_t ttd)
 {
   struct crec *crec = NULL, *fail_crec = NULL;
   unsigned short flags = F_IPV4;
@@ -1213,89 +1126,81 @@
   size_t addrlen = sizeof(struct in_addr);
 
 #ifdef HAVE_IPV6
-  if (prot == AF_INET6)
-    {
-      flags = F_IPV6;
-      addrlen = sizeof(struct in6_addr);
-    }
+  if (prot == AF_INET6) {
+    flags = F_IPV6;
+    addrlen = sizeof(struct in6_addr);
+  }
 #endif
-  
+
   inet_ntop(prot, host_address, daemon->addrbuff, ADDRSTRLEN);
-  
-  while ((crec = cache_find_by_name(crec, host_name, 0, flags | F_CNAME)))
-    {
-      /* check all addresses associated with name */
-      if (crec->flags & (F_HOSTS | F_CONFIG))
-	{
-	  if (crec->flags & F_CNAME)
-	    my_syslog(MS_DHCP | LOG_WARNING, 
-		      _("%s is a CNAME, not giving it to the DHCP lease of %s"),
-		      host_name, daemon->addrbuff);
-	  else if (memcmp(&crec->addr.addr, host_address, addrlen) == 0)
-	    in_hosts = 1;
-	  else
-	    fail_crec = crec;
-	}
-      else if (!(crec->flags & F_DHCP))
-	{
-	  cache_scan_free(host_name, NULL, 0, crec->flags & (flags | F_CNAME | F_FORWARD));
-	  /* scan_free deletes all addresses associated with name */
-	  break;
-	}
+
+  while ((crec = cache_find_by_name(crec, host_name, 0, flags | F_CNAME))) {
+    /* check all addresses associated with name */
+    if (crec->flags & (F_HOSTS | F_CONFIG)) {
+      if (crec->flags & F_CNAME)
+        my_syslog(MS_DHCP | LOG_WARNING,
+                  _("%s is a CNAME, not giving it to the DHCP lease of %s"),
+                  host_name, daemon->addrbuff);
+      else if (memcmp(&crec->addr.addr, host_address, addrlen) == 0)
+        in_hosts = 1;
+      else
+        fail_crec = crec;
+    } else if (!(crec->flags & F_DHCP)) {
+      cache_scan_free(host_name, NULL, 0,
+                      crec->flags & (flags | F_CNAME | F_FORWARD));
+      /* scan_free deletes all addresses associated with name */
+      break;
     }
-  
+  }
+
   /* if in hosts, don't need DHCP record */
   if (in_hosts)
     return;
-  
+
   /* Name in hosts, address doesn't match */
-  if (fail_crec)
-    {
-      inet_ntop(prot, &fail_crec->addr.addr, daemon->namebuff, MAXDNAME);
-      my_syslog(MS_DHCP | LOG_WARNING, 
-		_("not giving name %s to the DHCP lease of %s because "
-		  "the name exists in %s with address %s"), 
-		host_name, daemon->addrbuff,
-		record_source(fail_crec->uid), daemon->namebuff);
-      return;
-    }	  
-  
-  if ((crec = cache_find_by_addr(NULL, (struct all_addr *)host_address, 0, flags)))
-    {
-      if (crec->flags & F_NEG)
-	{
-	  flags |= F_REVERSE;
-	  cache_scan_free(NULL, (struct all_addr *)host_address, 0, flags);
-	}
+  if (fail_crec) {
+    inet_ntop(prot, &fail_crec->addr.addr, daemon->namebuff, MAXDNAME);
+    my_syslog(MS_DHCP | LOG_WARNING,
+              _("not giving name %s to the DHCP lease of %s because "
+                "the name exists in %s with address %s"),
+              host_name, daemon->addrbuff,
+              record_source(fail_crec->uid), daemon->namebuff);
+    return;
+  }
+
+  if ((crec =
+       cache_find_by_addr(NULL, (struct all_addr *) host_address, 0, flags))) {
+    if (crec->flags & F_NEG) {
+      flags |= F_REVERSE;
+      cache_scan_free(NULL, (struct all_addr *) host_address, 0, flags);
     }
-  else
+  } else
     flags |= F_REVERSE;
-  
+
   if ((crec = dhcp_spare))
     dhcp_spare = dhcp_spare->next;
-  else /* need new one */
+  else                          /* need new one */
     crec = whine_malloc(sizeof(struct crec));
-  
-  if (crec) /* malloc may fail */
-    {
-      crec->flags = flags | F_NAMEP | F_DHCP | F_FORWARD;
-      if (ttd == 0)
-	crec->flags |= F_IMMORTAL;
-      else
-	crec->ttd = ttd;
-      crec->addr.addr = *host_address;
-      crec->name.namep = host_name;
-      crec->uid = next_uid();
-      cache_hash(crec);
 
-      add_dhcp_cname(crec, ttd);
-    }
+  if (crec) {                   /* malloc may fail */
+    crec->flags = flags | F_NAMEP | F_DHCP | F_FORWARD;
+    if (ttd == 0)
+      crec->flags |= F_IMMORTAL;
+    else
+      crec->ttd = ttd;
+    crec->addr.addr = *host_address;
+    crec->name.namep = host_name;
+    crec->uid = next_uid();
+    cache_hash(crec);
+
+    add_dhcp_cname(crec, ttd);
+  }
 }
 #endif
 
 #ifndef NO_ID
 int cache_make_stat(struct txt_record *t)
-{ 
+{
   static char *buff = NULL;
   static int bufflen = 60;
   int len;
@@ -1306,85 +1211,87 @@
     return 0;
 
   p = buff;
-  
-  switch (t->stat)
-    {
-    case TXT_STAT_CACHESIZE:
-      sprintf(buff+1, "%d", daemon->cachesize);
-      break;
 
-    case TXT_STAT_INSERTS:
-      sprintf(buff+1, "%d", cache_inserted);
-      break;
+  switch (t->stat) {
+  case TXT_STAT_CACHESIZE:
+    sprintf(buff + 1, "%d", daemon->cachesize);
+    break;
 
-    case TXT_STAT_EVICTIONS:
-      sprintf(buff+1, "%d", cache_live_freed);
-      break;
+  case TXT_STAT_INSERTS:
+    sprintf(buff + 1, "%d", cache_inserted);
+    break;
 
-    case TXT_STAT_MISSES:
-      sprintf(buff+1, "%u", daemon->queries_forwarded);
-      break;
+  case TXT_STAT_EVICTIONS:
+    sprintf(buff + 1, "%d", cache_live_freed);
+    break;
 
-    case TXT_STAT_HITS:
-      sprintf(buff+1, "%u", daemon->local_answer);
-      break;
+  case TXT_STAT_MISSES:
+    sprintf(buff + 1, "%u", daemon->queries_forwarded);
+    break;
+
+  case TXT_STAT_HITS:
+    sprintf(buff + 1, "%u", daemon->local_answer);
+    break;
 
 #ifdef HAVE_AUTH
-    case TXT_STAT_AUTH:
-      sprintf(buff+1, "%u", daemon->auth_answer);
-      break;
+  case TXT_STAT_AUTH:
+    sprintf(buff + 1, "%u", daemon->auth_answer);
+    break;
 #endif
 
-    case TXT_STAT_SERVERS:
-      /* sum counts from different records for same server */
-      for (serv = daemon->servers; serv; serv = serv->next)
-	serv->flags &= ~SERV_COUNTED;
-      
-      for (serv = daemon->servers; serv; serv = serv->next)
-	if (!(serv->flags & 
-	      (SERV_NO_ADDR | SERV_LITERAL_ADDRESS | SERV_COUNTED | SERV_USE_RESOLV | SERV_NO_REBIND)))
-	  {
-	    char *new, *lenp;
-	    int port, newlen, bytes_avail, bytes_needed;
-	    unsigned int queries = 0, failed_queries = 0;
-	    for (serv1 = serv; serv1; serv1 = serv1->next)
-	      if (!(serv1->flags & 
-		    (SERV_NO_ADDR | SERV_LITERAL_ADDRESS | SERV_COUNTED | SERV_USE_RESOLV | SERV_NO_REBIND)) && 
-		  sockaddr_isequal(&serv->addr, &serv1->addr))
-		{
-		  serv1->flags |= SERV_COUNTED;
-		  queries += serv1->queries;
-		  failed_queries += serv1->failed_queries;
-		}
-	    port = prettyprint_addr(&serv->addr, daemon->addrbuff);
-	    lenp = p++; /* length */
-	    bytes_avail = bufflen - (p - buff );
-	    bytes_needed = snprintf(p, bytes_avail, "%s#%d %u %u", daemon->addrbuff, port, queries, failed_queries);
-	    if (bytes_needed >= bytes_avail)
-	      {
-		/* expand buffer if necessary */
-		newlen = bytes_needed + 1 + bufflen - bytes_avail;
-		if (!(new = whine_malloc(newlen)))
-		  return 0;
-		memcpy(new, buff, bufflen);
-		free(buff);
-		p = new + (p - buff);
-		lenp = p - 1;
-		buff = new;
-		bufflen = newlen;
-		bytes_avail =  bufflen - (p - buff );
-		bytes_needed = snprintf(p, bytes_avail, "%s#%d %u %u", daemon->addrbuff, port, queries, failed_queries);
-	      }
-	    *lenp = bytes_needed;
-	    p += bytes_needed;
-	  }
-      t->txt = (unsigned char *)buff;
-      t->len = p - buff;
-      return 1;
-    }
-  
-  len = strlen(buff+1);
-  t->txt = (unsigned char *)buff;
+  case TXT_STAT_SERVERS:
+    /* sum counts from different records for same server */
+    for (serv = daemon->servers; serv; serv = serv->next)
+      serv->flags &= ~SERV_COUNTED;
+
+    for (serv = daemon->servers; serv; serv = serv->next)
+      if (!(serv->flags &
+            (SERV_NO_ADDR | SERV_LITERAL_ADDRESS | SERV_COUNTED |
+             SERV_USE_RESOLV | SERV_NO_REBIND))) {
+        char *new, *lenp;
+        int port, newlen, bytes_avail, bytes_needed;
+        unsigned int queries = 0, failed_queries = 0;
+        for (serv1 = serv; serv1; serv1 = serv1->next)
+          if (!(serv1->flags &
+                (SERV_NO_ADDR | SERV_LITERAL_ADDRESS | SERV_COUNTED |
+                 SERV_USE_RESOLV | SERV_NO_REBIND))
+              && sockaddr_isequal(&serv->addr, &serv1->addr)) {
+            serv1->flags |= SERV_COUNTED;
+            queries += serv1->queries;
+            failed_queries += serv1->failed_queries;
+          }
+        port = prettyprint_addr(&serv->addr, daemon->addrbuff);
+        lenp = p++;             /* length */
+        bytes_avail = bufflen - (p - buff);
+        bytes_needed =
+            snprintf(p, bytes_avail, "%s#%d %u %u", daemon->addrbuff, port,
+                     queries, failed_queries);
+        if (bytes_needed >= bytes_avail) {
+          /* expand buffer if necessary */
+          newlen = bytes_needed + 1 + bufflen - bytes_avail;
+          if (!(new = whine_malloc(newlen)))
+            return 0;
+          memcpy(new, buff, bufflen);
+          free(buff);
+          p = new + (p - buff);
+          lenp = p - 1;
+          buff = new;
+          bufflen = newlen;
+          bytes_avail = bufflen - (p - buff);
+          bytes_needed =
+              snprintf(p, bytes_avail, "%s#%d %u %u", daemon->addrbuff, port,
+                       queries, failed_queries);
+        }
+        *lenp = bytes_needed;
+        p += bytes_needed;
+      }
+    t->txt = (unsigned char *) buff;
+    t->len = p - buff;
+    return 1;
+  }
+
+  len = strlen(buff + 1);
+  t->txt = (unsigned char *) buff;
   t->len = len + 1;
   *buff = len;
   return 1;
@@ -1397,9 +1304,9 @@
 {
   unsigned char *r;
   if (name)
-    for (r = (unsigned char *)name; *r; r++)
-      if (!isprint((int)*r))
-	return "<name unprintable>";
+    for (r = (unsigned char *) name; *r; r++)
+      if (!isprint((int) *r))
+        return "<name unprintable>";
 
   return name;
 }
@@ -1410,13 +1317,16 @@
   struct server *serv, *serv1;
   char *t = "";
 
-  my_syslog(LOG_INFO, _("time %lu"), (unsigned long)now);
-  my_syslog(LOG_INFO, _("cache size %d, %d/%d cache insertions re-used unexpired cache entries."), 
-	    daemon->cachesize, cache_live_freed, cache_inserted);
-  my_syslog(LOG_INFO, _("queries forwarded %u, queries answered locally %u"), 
-	    daemon->queries_forwarded, daemon->local_answer);
+  my_syslog(LOG_INFO, _("time %lu"), (unsigned long) now);
+  my_syslog(LOG_INFO,
+            _
+            ("cache size %d, %d/%d cache insertions re-used unexpired cache entries."),
+            daemon->cachesize, cache_live_freed, cache_inserted);
+  my_syslog(LOG_INFO, _("queries forwarded %u, queries answered locally %u"),
+            daemon->queries_forwarded, daemon->local_answer);
 #ifdef HAVE_AUTH
-  my_syslog(LOG_INFO, _("queries for authoritative zones %u"), daemon->auth_answer);
+  my_syslog(LOG_INFO, _("queries for authoritative zones %u"),
+            daemon->auth_answer);
 #endif
 #ifdef HAVE_DNSSEC
   blockdata_report();
@@ -1425,95 +1335,98 @@
   /* sum counts from different records for same server */
   for (serv = daemon->servers; serv; serv = serv->next)
     serv->flags &= ~SERV_COUNTED;
-  
+
   for (serv = daemon->servers; serv; serv = serv->next)
-    if (!(serv->flags & 
-	  (SERV_NO_ADDR | SERV_LITERAL_ADDRESS | SERV_COUNTED | SERV_USE_RESOLV | SERV_NO_REBIND)))
-      {
-	int port;
-	unsigned int queries = 0, failed_queries = 0;
-	for (serv1 = serv; serv1; serv1 = serv1->next)
-	  if (!(serv1->flags & 
-		(SERV_NO_ADDR | SERV_LITERAL_ADDRESS | SERV_COUNTED | SERV_USE_RESOLV | SERV_NO_REBIND)) && 
-	      sockaddr_isequal(&serv->addr, &serv1->addr))
-	    {
-	      serv1->flags |= SERV_COUNTED;
-	      queries += serv1->queries;
-	      failed_queries += serv1->failed_queries;
-	    }
-	port = prettyprint_addr(&serv->addr, daemon->addrbuff);
-	my_syslog(LOG_INFO, _("server %s#%d: queries sent %u, retried or failed %u"), daemon->addrbuff, port, queries, failed_queries);
-      }
-  
-  if (option_bool(OPT_DEBUG) || option_bool(OPT_LOG))
-    {
-      struct crec *cache ;
-      int i;
-      my_syslog(LOG_INFO, "Host                                     Address                        Flags      Expires");
-    
-      for (i=0; i<hash_size; i++)
-	for (cache = hash_table[i]; cache; cache = cache->hash_next)
-	  {
-	    char *a = daemon->addrbuff, *p = daemon->namebuff, *n = cache_get_name(cache);
-	    *a = 0;
-	    if (strlen(n) == 0 && !(cache->flags & F_REVERSE))
-	      n = "<Root>";
-	    p += sprintf(p, "%-30.30s ", sanitise(n));
-	    if ((cache->flags & F_CNAME) && !is_outdated_cname_pointer(cache))
-	      a = sanitise(cache_get_cname_target(cache));
+    if (!(serv->flags &
+          (SERV_NO_ADDR | SERV_LITERAL_ADDRESS | SERV_COUNTED | SERV_USE_RESOLV
+           | SERV_NO_REBIND))) {
+      int port;
+      unsigned int queries = 0, failed_queries = 0;
+      for (serv1 = serv; serv1; serv1 = serv1->next)
+        if (!(serv1->flags &
+              (SERV_NO_ADDR | SERV_LITERAL_ADDRESS | SERV_COUNTED |
+               SERV_USE_RESOLV | SERV_NO_REBIND))
+            && sockaddr_isequal(&serv->addr, &serv1->addr)) {
+          serv1->flags |= SERV_COUNTED;
+          queries += serv1->queries;
+          failed_queries += serv1->failed_queries;
+        }
+      port = prettyprint_addr(&serv->addr, daemon->addrbuff);
+      my_syslog(LOG_INFO,
+                _("server %s#%d: queries sent %u, retried or failed %u"),
+                daemon->addrbuff, port, queries, failed_queries);
+    }
+
+  if (option_bool(OPT_DEBUG) || option_bool(OPT_LOG)) {
+    struct crec *cache;
+    int i;
+    my_syslog(LOG_INFO,
+              "Host                                     Address                        Flags      Expires");
+
+    for (i = 0; i < hash_size; i++)
+      for (cache = hash_table[i]; cache; cache = cache->hash_next) {
+        char *a = daemon->addrbuff, *p = daemon->namebuff, *n =
+            cache_get_name(cache);
+        *a = 0;
+        if (strlen(n) == 0 && !(cache->flags & F_REVERSE))
+          n = "<Root>";
+        p += sprintf(p, "%-30.30s ", sanitise(n));
+        if ((cache->flags & F_CNAME) && !is_outdated_cname_pointer(cache))
+          a = sanitise(cache_get_cname_target(cache));
 #ifdef HAVE_DNSSEC
-	    else if (cache->flags & F_DS)
-	      {
-		if (!(cache->flags & F_NEG))
-		  sprintf(a, "%5u %3u %3u", cache->addr.ds.keytag,
-			  cache->addr.ds.algo, cache->addr.ds.digest);
-	      }
-	    else if (cache->flags & F_DNSKEY)
-	      sprintf(a, "%5u %3u %3u", cache->addr.key.keytag,
-		      cache->addr.key.algo, cache->addr.key.flags);
-#endif
-	    else if (!(cache->flags & F_NEG) || !(cache->flags & F_FORWARD))
-	      { 
-		a = daemon->addrbuff;
-		if (cache->flags & F_IPV4)
-		  inet_ntop(AF_INET, &cache->addr.addr, a, ADDRSTRLEN);
+        else if (cache->flags & F_DS) {
+          if (!(cache->flags & F_NEG))
+            sprintf(a, "%5u %3u %3u", cache->addr.ds.keytag,
+                    cache->addr.ds.algo, cache->addr.ds.digest);
+        } else if (cache->flags & F_DNSKEY)
+          sprintf(a, "%5u %3u %3u", cache->addr.key.keytag,
+                  cache->addr.key.algo, cache->addr.key.flags);
+#endif
+        else if (!(cache->flags & F_NEG) || !(cache->flags & F_FORWARD)) {
+          a = daemon->addrbuff;
+          if (cache->flags & F_IPV4)
+            inet_ntop(AF_INET, &cache->addr.addr, a, ADDRSTRLEN);
 #ifdef HAVE_IPV6
-		else if (cache->flags & F_IPV6)
-		  inet_ntop(AF_INET6, &cache->addr.addr, a, ADDRSTRLEN);
+          else if (cache->flags & F_IPV6)
+            inet_ntop(AF_INET6, &cache->addr.addr, a, ADDRSTRLEN);
 #endif
-	      }
+        }
 
-	    if (cache->flags & F_IPV4)
-	      t = "4";
-	    else if (cache->flags & F_IPV6)
-	      t = "6";
-	    else if (cache->flags & F_CNAME)
-	      t = "C";
+        if (cache->flags & F_IPV4)
+          t = "4";
+        else if (cache->flags & F_IPV6)
+          t = "6";
+        else if (cache->flags & F_CNAME)
+          t = "C";
 #ifdef HAVE_DNSSEC
-	    else if (cache->flags & F_DS)
-	      t = "S";
-	    else if (cache->flags & F_DNSKEY)
-	      t = "K";
-#endif
-	    p += sprintf(p, "%-40.40s %s%s%s%s%s%s%s%s%s  ", a, t,
-			 cache->flags & F_FORWARD ? "F" : " ",
-			 cache->flags & F_REVERSE ? "R" : " ",
-			 cache->flags & F_IMMORTAL ? "I" : " ",
-			 cache->flags & F_DHCP ? "D" : " ",
-			 cache->flags & F_NEG ? "N" : " ",
-			 cache->flags & F_NXDOMAIN ? "X" : " ",
-			 cache->flags & F_HOSTS ? "H" : " ",
-			 cache->flags & F_DNSSECOK ? "V" : " ");
+        else if (cache->flags & F_DS)
+          t = "S";
+        else if (cache->flags & F_DNSKEY)
+          t = "K";
+#endif
+        p += sprintf(p, "%-40.40s %s%s%s%s%s%s%s%s%s  ", a, t,
+                     cache->flags & F_FORWARD ? "F" : " ",
+                     cache->flags & F_REVERSE ? "R" : " ",
+                     cache->flags & F_IMMORTAL ? "I" : " ",
+                     cache->flags & F_DHCP ? "D" : " ",
+                     cache->flags & F_NEG ? "N" : " ",
+                     cache->flags & F_NXDOMAIN ? "X" : " ",
+                     cache->flags & F_HOSTS ? "H" : " ",
+                     cache->flags & F_DNSSECOK ? "V" : " ");
 #ifdef HAVE_BROKEN_RTC
-	    p += sprintf(p, "%lu", cache->flags & F_IMMORTAL ? 0: (unsigned long)(cache->ttd - now));
+        p += sprintf(p, "%lu",
+                     cache->flags & F_IMMORTAL ? 0 : (unsigned long) (cache->
+                                                                      ttd -
+                                                                      now));
 #else
-	    p += sprintf(p, "%s", cache->flags & F_IMMORTAL ? "\n" : ctime(&(cache->ttd)));
-	    /* ctime includes trailing \n - eat it */
-	    *(p-1) = 0;
+        p += sprintf(p, "%s",
+                     cache->flags & F_IMMORTAL ? "\n" : ctime(&(cache->ttd)));
+        /* ctime includes trailing \n - eat it */
+        *(p - 1) = 0;
 #endif
-	    my_syslog(LOG_INFO, "%s", daemon->namebuff);
-	  }
-    }
+        my_syslog(LOG_INFO, "%s", daemon->namebuff);
+      }
+  }
 }
 
 char *record_source(unsigned int index)
@@ -1531,8 +1444,8 @@
 
 #ifdef HAVE_INOTIFY
   for (ah = daemon->dynamic_dirs; ah; ah = ah->next)
-     if (ah->index == index)
-       return ah->fname;
+    if (ah->index == index)
+      return ah->fname;
 #endif
 
   return "<unknown>";
@@ -1541,40 +1454,37 @@
 char *querystr(char *desc, unsigned short type)
 {
   unsigned int i;
-  int len = 10; /* strlen("type=xxxxx") */
+  int len = 10;                 /* strlen("type=xxxxx") */
   const char *types = NULL;
   static char *buff = NULL;
   static int bufflen = 0;
 
-  for (i = 0; i < (sizeof(typestr)/sizeof(typestr[0])); i++)
-    if (typestr[i].type == type)
-      {
-	types = typestr[i].name;
-	len = strlen(types);
-	break;
-      }
+  for (i = 0; i < (sizeof(typestr) / sizeof(typestr[0])); i++)
+    if (typestr[i].type == type) {
+      types = typestr[i].name;
+      len = strlen(types);
+      break;
+    }
 
-  len += 3; /* braces, terminator */
+  len += 3;                     /* braces, terminator */
   len += strlen(desc);
 
-  if (!buff || bufflen < len)
-    {
-      if (buff)
-	free(buff);
-      else if (len < 20)
-	len = 20;
-      
-      buff = whine_malloc(len);
-      bufflen = len;
-    }
+  if (!buff || bufflen < len) {
+    if (buff)
+      free(buff);
+    else if (len < 20)
+      len = 20;
 
-  if (buff)
-    {
-      if (types)
-	sprintf(buff, "%s[%s]", desc, types);
-      else
-	sprintf(buff, "%s[type=%d]", desc, type);
-    }
+    buff = whine_malloc(len);
+    bufflen = len;
+  }
+
+  if (buff) {
+    if (types)
+      sprintf(buff, "%s[%s]", desc, types);
+    else
+      sprintf(buff, "%s[type=%d]", desc, type);
+  }
 
   return buff ? buff : "";
 }
@@ -1583,54 +1493,48 @@
 {
   char *source, *dest = daemon->addrbuff;
   char *verb = "is";
-  
+
   if (!option_bool(OPT_LOG))
     return;
 
   name = sanitise(name);
 
-  if (addr)
-    {
-      if (flags & F_KEYTAG)
-	sprintf(daemon->addrbuff, arg, addr->addr.log.keytag, addr->addr.log.algo, addr->addr.log.digest);
-      else
-	{
+  if (addr) {
+    if (flags & F_KEYTAG)
+      sprintf(daemon->addrbuff, arg, addr->addr.log.keytag, addr->addr.log.algo,
+              addr->addr.log.digest);
+    else {
 #ifdef HAVE_IPV6
-	  inet_ntop(flags & F_IPV4 ? AF_INET : AF_INET6,
-		    addr, daemon->addrbuff, ADDRSTRLEN);
+      inet_ntop(flags & F_IPV4 ? AF_INET : AF_INET6,
+                addr, daemon->addrbuff, ADDRSTRLEN);
 #else
-	  strncpy(daemon->addrbuff, inet_ntoa(addr->addr.addr4), ADDRSTRLEN);  
+      strncpy(daemon->addrbuff, inet_ntoa(addr->addr.addr4), ADDRSTRLEN);
 #endif
-	}
     }
-  else
+  } else
     dest = arg;
 
-  if (flags & F_REVERSE)
-    {
-      dest = name;
-      name = daemon->addrbuff;
-    }
-  
-  if (flags & F_NEG)
-    {
-      if (flags & F_NXDOMAIN)
-	dest = "NXDOMAIN";
+  if (flags & F_REVERSE) {
+    dest = name;
+    name = daemon->addrbuff;
+  }
+
+  if (flags & F_NEG) {
+    if (flags & F_NXDOMAIN)
+      dest = "NXDOMAIN";
+    else {
+      if (flags & F_IPV4)
+        dest = "NODATA-IPv4";
+      else if (flags & F_IPV6)
+        dest = "NODATA-IPv6";
       else
-	{      
-	  if (flags & F_IPV4)
-	    dest = "NODATA-IPv4";
-	  else if (flags & F_IPV6)
-	    dest = "NODATA-IPv6";
-	  else
-	    dest = "NODATA";
-	}
+        dest = "NODATA";
     }
-  else if (flags & F_CNAME)
+  } else if (flags & F_CNAME)
     dest = "<CNAME>";
   else if (flags & F_RRNAME)
     dest = arg;
-    
+
   if (flags & F_CONFIG)
     source = "config";
   else if (flags & F_DHCP)
@@ -1643,44 +1547,34 @@
     source = "validation";
   else if (flags & F_AUTH)
     source = "auth";
-  else if (flags & F_SERVER)
-    {
-      source = "forwarded";
-      verb = "to";
-    }
-  else if (flags & F_QUERY)
-    {
-      source = arg;
-      verb = "from";
-    }
-  else if (flags & F_DNSSEC)
-    {
-      source = arg;
-      verb = "to";
-    }
-  else if (flags & F_IPSET)
-    {
-      source = "ipset add";
-      dest = name;
-      name = arg;
-      verb = daemon->addrbuff;
-    }
-  else
+  else if (flags & F_SERVER) {
+    source = "forwarded";
+    verb = "to";
+  } else if (flags & F_QUERY) {
+    source = arg;
+    verb = "from";
+  } else if (flags & F_DNSSEC) {
+    source = arg;
+    verb = "to";
+  } else if (flags & F_IPSET) {
+    source = "ipset add";
+    dest = name;
+    name = arg;
+    verb = daemon->addrbuff;
+  } else
     source = "cached";
-  
+
   if (strlen(name) == 0)
     name = ".";
 
-  if (option_bool(OPT_EXTRALOG))
-    {
-      int port = prettyprint_addr(daemon->log_source_addr, daemon->addrbuff2);
-      if (flags & F_NOEXTRA)
-	my_syslog(LOG_INFO, "* %s/%u %s %s %s %s", daemon->addrbuff2, port, source, name, verb, dest);
-      else
-	my_syslog(LOG_INFO, "%u %s/%u %s %s %s %s", daemon->log_display_id, daemon->addrbuff2, port, source, name, verb, dest);
-    }
-  else
+  if (option_bool(OPT_EXTRALOG)) {
+    int port = prettyprint_addr(daemon->log_source_addr, daemon->addrbuff2);
+    if (flags & F_NOEXTRA)
+      my_syslog(LOG_INFO, "* %s/%u %s %s %s %s", daemon->addrbuff2, port,
+                source, name, verb, dest);
+    else
+      my_syslog(LOG_INFO, "%u %s/%u %s %s %s %s", daemon->log_display_id,
+                daemon->addrbuff2, port, source, name, verb, dest);
+  } else
     my_syslog(LOG_INFO, "%s %s %s %s", source, name, verb, dest);
 }
-
- 
Index: dnsmasq-2.78/src/config.h
===================================================================
--- dnsmasq-2.78.orig/src/config.h	2017-10-02 21:13:51.000000000 +0800
+++ dnsmasq-2.78/src/config.h	2018-10-29 16:14:19.361440022 +0800
@@ -14,48 +14,48 @@
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
 
-#define FTABSIZ 150 /* max number of outstanding requests (default) */
-#define MAX_PROCS 20 /* max no children for TCP requests */
-#define CHILD_LIFETIME 150 /* secs 'till terminated (RFC1035 suggests > 120s) */
-#define TCP_MAX_QUERIES 100 /* Maximum number of queries per incoming TCP connection */
-#define TCP_BACKLOG 32  /* kernel backlog limit for TCP connections */
-#define EDNS_PKTSZ 4096 /* default max EDNS.0 UDP packet from RFC5625 */
-#define SAFE_PKTSZ 1280 /* "go anywhere" UDP packet size */
-#define KEYBLOCK_LEN 40 /* choose to minimise fragmentation when storing DNSSEC keys */
-#define DNSSEC_WORK 50 /* Max number of queries to validate one question */
-#define TIMEOUT 10 /* drop UDP queries after TIMEOUT seconds */
-#define FORWARD_TEST 50 /* try all servers every 50 queries */
-#define FORWARD_TIME 20 /* or 20 seconds */
-#define SERVERS_LOGGED 30 /* Only log this many servers when logging state */
-#define LOCALS_LOGGED 8 /* Only log this many local addresses when logging state */
-#define RANDOM_SOCKS 64 /* max simultaneous random ports */
-#define LEASE_RETRY 60 /* on error, retry writing leasefile after LEASE_RETRY seconds */
-#define CACHESIZ 150 /* default cache size */
-#define TTL_FLOOR_LIMIT 3600 /* don't allow --min-cache-ttl to raise TTL above this under any circumstances */
-#define MAXLEASES 1000 /* maximum number of DHCP leases */
-#define PING_WAIT 3 /* wait for ping address-in-use test */
-#define PING_CACHE_TIME 30 /* Ping test assumed to be valid this long. */
-#define DECLINE_BACKOFF 600 /* disable DECLINEd static addresses for this long */
-#define DHCP_PACKET_MAX 16384 /* hard limit on DHCP packet size */
-#define SMALLDNAME 50 /* most domain names are smaller than this */
-#define CNAME_CHAIN 10 /* chains longer than this atr dropped for loop protection */
+#define FTABSIZ 150             /* max number of outstanding requests (default) */
+#define MAX_PROCS 20            /* max no children for TCP requests */
+#define CHILD_LIFETIME 150      /* secs 'till terminated (RFC1035 suggests > 120s) */
+#define TCP_MAX_QUERIES 100     /* Maximum number of queries per incoming TCP connection */
+#define TCP_BACKLOG 32          /* kernel backlog limit for TCP connections */
+#define EDNS_PKTSZ 4096         /* default max EDNS.0 UDP packet from RFC5625 */
+#define SAFE_PKTSZ 1280         /* "go anywhere" UDP packet size */
+#define KEYBLOCK_LEN 40         /* choose to minimise fragmentation when storing DNSSEC keys */
+#define DNSSEC_WORK 50          /* Max number of queries to validate one question */
+#define TIMEOUT 10              /* drop UDP queries after TIMEOUT seconds */
+#define FORWARD_TEST 50         /* try all servers every 50 queries */
+#define FORWARD_TIME 20         /* or 20 seconds */
+#define SERVERS_LOGGED 30       /* Only log this many servers when logging state */
+#define LOCALS_LOGGED 8         /* Only log this many local addresses when logging state */
+#define RANDOM_SOCKS 64         /* max simultaneous random ports */
+#define LEASE_RETRY 60          /* on error, retry writing leasefile after LEASE_RETRY seconds */
+#define CACHESIZ 150            /* default cache size */
+#define TTL_FLOOR_LIMIT 3600    /* don't allow --min-cache-ttl to raise TTL above this under any circumstances */
+#define MAXLEASES 1000          /* maximum number of DHCP leases */
+#define PING_WAIT 3             /* wait for ping address-in-use test */
+#define PING_CACHE_TIME 30      /* Ping test assumed to be valid this long. */
+#define DECLINE_BACKOFF 600     /* disable DECLINEd static addresses for this long */
+#define DHCP_PACKET_MAX 16384   /* hard limit on DHCP packet size */
+#define SMALLDNAME 50           /* most domain names are smaller than this */
+#define CNAME_CHAIN 10          /* chains longer than this atr dropped for loop protection */
 #define HOSTSFILE "/etc/hosts"
 #define ETHERSFILE "/etc/ethers"
-#define DEFLEASE 3600 /* default lease time, 1 hour */
+#define DEFLEASE 3600           /* default lease time, 1 hour */
 #define CHUSER "nobody"
 #define CHGRP "dip"
 #define TFTP_MAX_CONNECTIONS 50 /* max simultaneous connections */
-#define LOG_MAX 5 /* log-queue length */
+#define LOG_MAX 5               /* log-queue length */
 #define RANDFILE "/dev/urandom"
-#define DNSMASQ_SERVICE "uk.org.thekelleys.dnsmasq" /* Default - may be overridden by config */
+#define DNSMASQ_SERVICE "uk.org.thekelleys.dnsmasq"     /* Default - may be overridden by config */
 #define DNSMASQ_PATH "/uk/org/thekelleys/dnsmasq"
-#define AUTH_TTL 600 /* default TTL for auth DNS */
-#define SOA_REFRESH 1200 /* SOA refresh default */
-#define SOA_RETRY 180 /* SOA retry default */
-#define SOA_EXPIRY 1209600 /* SOA expiry default */
+#define AUTH_TTL 600            /* default TTL for auth DNS */
+#define SOA_REFRESH 1200        /* SOA refresh default */
+#define SOA_RETRY 180           /* SOA retry default */
+#define SOA_EXPIRY 1209600      /* SOA expiry default */
 #define LOOP_TEST_DOMAIN "test" /* domain for loop testing, "test" is reserved by RFC 2606 and won't therefore clash */
 #define LOOP_TEST_TYPE T_TXT
- 
+
 /* compile-time options: uncomment below to enable or do eg.
    make COPTS=-DHAVE_BROKEN_RTC
 
@@ -160,11 +160,11 @@
    has no library dependencies other than libc */
 
 #define HAVE_DHCP
-#define HAVE_DHCP6 
+#define HAVE_DHCP6
 #define HAVE_TFTP
 #define HAVE_SCRIPT
 #define HAVE_AUTH
-#define HAVE_IPSET 
+#define HAVE_IPSET
 #define HAVE_LOOP
 
 /* Build options which require external libraries.
@@ -185,39 +185,39 @@
 /* Default locations for important system files. */
 
 #ifndef LEASEFILE
-#   if defined(__FreeBSD__) || defined (__OpenBSD__) || defined(__DragonFly__) || defined(__NetBSD__)
-#      define LEASEFILE "/var/db/dnsmasq.leases"
-#   elif defined(__sun__) || defined (__sun)
-#      define LEASEFILE "/var/cache/dnsmasq.leases"
-#   elif defined(__ANDROID__)
-#      define LEASEFILE "/data/misc/dhcp/dnsmasq.leases"
-#   else
-#      define LEASEFILE "/var/lib/misc/dnsmasq.leases"
-#   endif
+#if defined(__FreeBSD__) || defined (__OpenBSD__) || defined(__DragonFly__) || defined(__NetBSD__)
+#define LEASEFILE "/var/db/dnsmasq.leases"
+#elif defined(__sun__) || defined (__sun)
+#define LEASEFILE "/var/cache/dnsmasq.leases"
+#elif defined(__ANDROID__)
+#define LEASEFILE "/data/misc/dhcp/dnsmasq.leases"
+#else
+#define LEASEFILE "/var/lib/misc/dnsmasq.leases"
+#endif
 #endif
 
 #ifndef CONFFILE
-#   if defined(__FreeBSD__)
-#      define CONFFILE "/usr/local/etc/dnsmasq.conf"
-#   else
-#      define CONFFILE "/etc/dnsmasq.conf"
-#   endif
+#if defined(__FreeBSD__)
+#define CONFFILE "/usr/local/etc/dnsmasq.conf"
+#else
+#define CONFFILE "/etc/dnsmasq.conf"
+#endif
 #endif
 
 #ifndef RESOLVFILE
-#   if defined(__uClinux__)
-#      define RESOLVFILE "/etc/config/resolv.conf"
-#   else
-#      define RESOLVFILE "/etc/resolv.conf"
-#   endif
+#if defined(__uClinux__)
+#define RESOLVFILE "/etc/config/resolv.conf"
+#else
+#define RESOLVFILE "/etc/resolv.conf"
+#endif
 #endif
 
 #ifndef RUNFILE
-#   if defined(__ANDROID__)
-#      define RUNFILE "/data/dnsmasq.pid"
-#    else
-#      define RUNFILE "/var/run/dnsmasq.pid"
-#    endif
+#if defined(__ANDROID__)
+#define RUNFILE "/data/dnsmasq.pid"
+#else
+#define RUNFILE "/var/run/dnsmasq.pid"
+#endif
 #endif
 
 /* platform dependent options: these are determined automatically below
@@ -249,16 +249,16 @@
 #define HAVE_LINUX_NETWORK
 #if defined(__UCLIBC_HAS_GNU_GETOPT__) || \
    ((__UCLIBC_MAJOR__==0) && (__UCLIBC_MINOR__==9) && (__UCLIBC_SUBLEVEL__<21))
-#    define HAVE_GETOPT_LONG
+#define HAVE_GETOPT_LONG
 #endif
 #undef HAVE_SOCKADDR_SA_LEN
 #if !defined(__ARCH_HAS_MMU__) && !defined(__UCLIBC_HAS_MMU__)
-#  define NO_FORK
+#define NO_FORK
 #endif
 #if defined(__UCLIBC_HAS_IPV6__)
-#  ifndef IPV6_V6ONLY
-#    define IPV6_V6ONLY 26
-#  endif
+#ifndef IPV6_V6ONLY
+#define IPV6_V6ONLY 26
+#endif
 #endif
 
 /* This is for glibc 2.x */
@@ -274,7 +274,7 @@
 #define HAVE_BSD_NETWORK
 /* Later versions of FreeBSD have getopt_long() */
 #if defined(optional_argument) && defined(required_argument)
-#   define HAVE_GETOPT_LONG
+#define HAVE_GETOPT_LONG
 #endif
 #define HAVE_SOCKADDR_SA_LEN
 
@@ -286,7 +286,7 @@
 #define _BSD_SOCKLEN_T_
 /* Select the RFC_3542 version of the IPv6 socket API. 
    Define before netinet6/in6.h is included. */
-#define __APPLE_USE_RFC_3542 
+#define __APPLE_USE_RFC_3542
 #define NO_IPSET
 
 #elif defined(__NetBSD__)
@@ -298,8 +298,8 @@
 #define HAVE_SOLARIS_NETWORK
 #define HAVE_GETOPT_LONG
 #undef HAVE_SOCKADDR_SA_LEN
-#define ETHER_ADDR_LEN 6 
- 
+#define ETHER_ADDR_LEN 6
+
 #endif
 
 /* Decide if we're going to support IPv6 */
@@ -307,14 +307,14 @@
    headers don't have ntop and pton either */
 
 #if defined(INET6_ADDRSTRLEN) && defined(IPV6_V6ONLY)
-#  define HAVE_IPV6
-#  define ADDRSTRLEN INET6_ADDRSTRLEN
+#define HAVE_IPV6
+#define ADDRSTRLEN INET6_ADDRSTRLEN
 #else
-#  if !defined(INET_ADDRSTRLEN)
-#      define INET_ADDRSTRLEN 16 /* 4*3 + 3 dots + NULL */
-#  endif
-#  undef HAVE_IPV6
-#  define ADDRSTRLEN INET_ADDRSTRLEN
+#if !defined(INET_ADDRSTRLEN)
+#define INET_ADDRSTRLEN 16      /* 4*3 + 3 dots + NULL */
+#endif
+#undef HAVE_IPV6
+#define ADDRSTRLEN INET_ADDRSTRLEN
 #endif
 
 
@@ -374,89 +374,86 @@
 
 #ifdef DNSMASQ_COMPILE_OPTS
 
-static char *compile_opts = 
+static char *compile_opts =
 #ifndef HAVE_IPV6
-"no-"
+    "no-"
 #endif
-"IPv6 "
+    "IPv6 "
 #ifndef HAVE_GETOPT_LONG
-"no-"
+    "no-"
 #endif
-"GNU-getopt "
+    "GNU-getopt "
 #ifdef HAVE_BROKEN_RTC
-"no-RTC "
+    "no-RTC "
 #endif
 #ifdef NO_FORK
-"no-MMU "
+    "no-MMU "
 #endif
 #ifndef HAVE_DBUS
-"no-"
+    "no-"
 #endif
-"DBus "
+    "DBus "
 #ifndef LOCALEDIR
-"no-"
+    "no-"
 #endif
-"i18n "
+    "i18n "
 #if defined(HAVE_LIBIDN2)
-"IDN2 "
+    "IDN2 "
 #else
- #if !defined(HAVE_IDN)
-"no-"
- #endif 
-"IDN " 
+#if !defined(HAVE_IDN)
+    "no-"
+#endif
+    "IDN "
 #endif
 #ifndef HAVE_DHCP
-"no-"
+    "no-"
 #endif
-"DHCP "
+    "DHCP "
 #if defined(HAVE_DHCP)
-#  if !defined (HAVE_DHCP6)
-     "no-"
-#  endif  
-     "DHCPv6 "
+#if !defined (HAVE_DHCP6)
+    "no-"
+#endif
+    "DHCPv6 "
 #endif
 #if !defined(HAVE_SCRIPT)
-     "no-scripts "
+    "no-scripts "
 #else
-#  if !defined(HAVE_LUASCRIPT)
-     "no-"
-#  endif
-     "Lua "
+#if !defined(HAVE_LUASCRIPT)
+    "no-"
+#endif
+    "Lua "
 #endif
 #ifndef HAVE_TFTP
-"no-"
+    "no-"
 #endif
-"TFTP "
+    "TFTP "
 #ifndef HAVE_CONNTRACK
-"no-"
+    "no-"
 #endif
-"conntrack "
+    "conntrack "
 #ifndef HAVE_IPSET
-"no-"
+    "no-"
 #endif
-"ipset "
+    "ipset "
 #ifndef HAVE_AUTH
-"no-"
+    "no-"
 #endif
-"auth "
+    "auth "
 #ifndef HAVE_DNSSEC
-"no-"
+    "no-"
 #endif
-"DNSSEC "
+    "DNSSEC "
 #ifdef NO_ID
-"no-ID "
+    "no-ID "
 #endif
 #ifndef HAVE_LOOP
-"no-"
+    "no-"
 #endif
-"loop-detect "
+    "loop-detect "
 #ifndef HAVE_INOTIFY
-"no-"
+    "no-"
 #endif
-"inotify";
+    "inotify";
 
 
 #endif
-
-
-
Index: dnsmasq-2.78/src/conntrack.c
===================================================================
--- dnsmasq-2.78.orig/src/conntrack.c	2017-10-02 21:13:51.000000000 +0800
+++ dnsmasq-2.78/src/conntrack.c	2018-10-29 16:14:19.369440023 +0800
@@ -20,71 +20,67 @@
 
 #include <libnetfilter_conntrack/libnetfilter_conntrack.h>
 
-static int gotit = 0; /* yuck */
+static int gotit = 0;           /* yuck */
 
-static int callback(enum nf_conntrack_msg_type type, struct nf_conntrack *ct, void *data);
+static int callback(enum nf_conntrack_msg_type type, struct nf_conntrack *ct,
+                    void *data);
 
-int get_incoming_mark(union mysockaddr *peer_addr, struct all_addr *local_addr, int istcp, unsigned int *markp)
+int get_incoming_mark(union mysockaddr *peer_addr, struct all_addr *local_addr,
+                      int istcp, unsigned int *markp)
 {
   struct nf_conntrack *ct;
   struct nfct_handle *h;
-  
+
   gotit = 0;
-  
-  if ((ct = nfct_new())) 
-    {
-      nfct_set_attr_u8(ct, ATTR_L4PROTO, istcp ? IPPROTO_TCP : IPPROTO_UDP);
-      nfct_set_attr_u16(ct, ATTR_PORT_DST, htons(daemon->port));
-      
+
+  if ((ct = nfct_new())) {
+    nfct_set_attr_u8(ct, ATTR_L4PROTO, istcp ? IPPROTO_TCP : IPPROTO_UDP);
+    nfct_set_attr_u16(ct, ATTR_PORT_DST, htons(daemon->port));
+
 #ifdef HAVE_IPV6
-      if (peer_addr->sa.sa_family == AF_INET6)
-	{
-	  nfct_set_attr_u8(ct, ATTR_L3PROTO, AF_INET6);
-	  nfct_set_attr(ct, ATTR_IPV6_SRC, peer_addr->in6.sin6_addr.s6_addr);
-	  nfct_set_attr_u16(ct, ATTR_PORT_SRC, peer_addr->in6.sin6_port);
-	  nfct_set_attr(ct, ATTR_IPV6_DST, local_addr->addr.addr6.s6_addr);
-	}
-      else
+    if (peer_addr->sa.sa_family == AF_INET6) {
+      nfct_set_attr_u8(ct, ATTR_L3PROTO, AF_INET6);
+      nfct_set_attr(ct, ATTR_IPV6_SRC, peer_addr->in6.sin6_addr.s6_addr);
+      nfct_set_attr_u16(ct, ATTR_PORT_SRC, peer_addr->in6.sin6_port);
+      nfct_set_attr(ct, ATTR_IPV6_DST, local_addr->addr.addr6.s6_addr);
+    } else
 #endif
-	{
-	  nfct_set_attr_u8(ct, ATTR_L3PROTO, AF_INET);
-	  nfct_set_attr_u32(ct, ATTR_IPV4_SRC, peer_addr->in.sin_addr.s_addr);
-	  nfct_set_attr_u16(ct, ATTR_PORT_SRC, peer_addr->in.sin_port);
-	  nfct_set_attr_u32(ct, ATTR_IPV4_DST, local_addr->addr.addr4.s_addr);
-	}
-      
-      
-      if ((h = nfct_open(CONNTRACK, 0))) 
-	{
-	  nfct_callback_register(h, NFCT_T_ALL, callback, (void *)markp);  
-	  if (nfct_query(h, NFCT_Q_GET, ct) == -1)
-	    {
-	      static int warned = 0;
-	      if (!warned)
-		{
-		  my_syslog(LOG_ERR, _("Conntrack connection mark retrieval failed: %s"), strerror(errno));
-		  warned = 1;
-		}
-	    }
-	  nfct_close(h);  
-	}
-      nfct_destroy(ct);
+    {
+      nfct_set_attr_u8(ct, ATTR_L3PROTO, AF_INET);
+      nfct_set_attr_u32(ct, ATTR_IPV4_SRC, peer_addr->in.sin_addr.s_addr);
+      nfct_set_attr_u16(ct, ATTR_PORT_SRC, peer_addr->in.sin_port);
+      nfct_set_attr_u32(ct, ATTR_IPV4_DST, local_addr->addr.addr4.s_addr);
     }
 
+
+    if ((h = nfct_open(CONNTRACK, 0))) {
+      nfct_callback_register(h, NFCT_T_ALL, callback, (void *) markp);
+      if (nfct_query(h, NFCT_Q_GET, ct) == -1) {
+        static int warned = 0;
+        if (!warned) {
+          my_syslog(LOG_ERR,
+                    _("Conntrack connection mark retrieval failed: %s"),
+                    strerror(errno));
+          warned = 1;
+        }
+      }
+      nfct_close(h);
+    }
+    nfct_destroy(ct);
+  }
+
   return gotit;
 }
 
-static int callback(enum nf_conntrack_msg_type type, struct nf_conntrack *ct, void *data)
+static int callback(enum nf_conntrack_msg_type type, struct nf_conntrack *ct,
+                    void *data)
 {
-  unsigned int *ret = (unsigned int *)data;
+  unsigned int *ret = (unsigned int *) data;
   *ret = nfct_get_attr_u32(ct, ATTR_MARK);
-  (void)type; /* eliminate warning */
+  (void) type;                  /* eliminate warning */
   gotit = 1;
 
   return NFCT_CB_CONTINUE;
 }
 
 #endif
-  
-
-
Index: dnsmasq-2.78/src/dbus.c
===================================================================
--- dnsmasq-2.78.orig/src/dbus.c	2017-10-02 21:13:51.000000000 +0800
+++ dnsmasq-2.78/src/dbus.c	2018-10-29 16:14:19.369440023 +0800
@@ -20,83 +20,81 @@
 
 #include <dbus/dbus.h>
 
-const char* introspection_xml_template =
-"<!DOCTYPE node PUBLIC \"-//freedesktop//DTD D-BUS Object Introspection 1.0//EN\"\n"
-"\"http://www.freedesktop.org/standards/dbus/1.0/introspect.dtd\">\n"
-"<node name=\"" DNSMASQ_PATH "\">\n"
-"  <interface name=\"org.freedesktop.DBus.Introspectable\">\n"
-"    <method name=\"Introspect\">\n"
-"      <arg name=\"data\" direction=\"out\" type=\"s\"/>\n"
-"    </method>\n"
-"  </interface>\n"
-"  <interface name=\"%s\">\n"
-"    <method name=\"ClearCache\">\n"
-"    </method>\n"
-"    <method name=\"GetVersion\">\n"
-"      <arg name=\"version\" direction=\"out\" type=\"s\"/>\n"
-"    </method>\n"
+const char *introspection_xml_template =
+    "<!DOCTYPE node PUBLIC \"-//freedesktop//DTD D-BUS Object Introspection 1.0//EN\"\n"
+    "\"http://www.freedesktop.org/standards/dbus/1.0/introspect.dtd\">\n"
+    "<node name=\"" DNSMASQ_PATH "\">\n"
+    "  <interface name=\"org.freedesktop.DBus.Introspectable\">\n"
+    "    <method name=\"Introspect\">\n"
+    "      <arg name=\"data\" direction=\"out\" type=\"s\"/>\n"
+    "    </method>\n"
+    "  </interface>\n"
+    "  <interface name=\"%s\">\n"
+    "    <method name=\"ClearCache\">\n"
+    "    </method>\n"
+    "    <method name=\"GetVersion\">\n"
+    "      <arg name=\"version\" direction=\"out\" type=\"s\"/>\n"
+    "    </method>\n"
 #ifdef HAVE_LOOP
-"    <method name=\"GetLoopServers\">\n"
-"      <arg name=\"server\" direction=\"out\" type=\"as\"/>\n"
-"    </method>\n"
-#endif
-"    <method name=\"SetServers\">\n"
-"      <arg name=\"servers\" direction=\"in\" type=\"av\"/>\n"
-"    </method>\n"
-"    <method name=\"SetDomainServers\">\n"
-"      <arg name=\"servers\" direction=\"in\" type=\"as\"/>\n"
-"    </method>\n"
-"    <method name=\"SetServersEx\">\n"
-"      <arg name=\"servers\" direction=\"in\" type=\"aas\"/>\n"
-"    </method>\n"
-"    <method name=\"SetFilterWin2KOption\">\n"
-"      <arg name=\"filterwin2k\" direction=\"in\" type=\"b\"/>\n"
-"    </method>\n"
-"    <method name=\"SetBogusPrivOption\">\n"
-"      <arg name=\"boguspriv\" direction=\"in\" type=\"b\"/>\n"
-"    </method>\n"
-"    <signal name=\"DhcpLeaseAdded\">\n"
-"      <arg name=\"ipaddr\" type=\"s\"/>\n"
-"      <arg name=\"hwaddr\" type=\"s\"/>\n"
-"      <arg name=\"hostname\" type=\"s\"/>\n"
-"    </signal>\n"
-"    <signal name=\"DhcpLeaseDeleted\">\n"
-"      <arg name=\"ipaddr\" type=\"s\"/>\n"
-"      <arg name=\"hwaddr\" type=\"s\"/>\n"
-"      <arg name=\"hostname\" type=\"s\"/>\n"
-"    </signal>\n"
-"    <signal name=\"DhcpLeaseUpdated\">\n"
-"      <arg name=\"ipaddr\" type=\"s\"/>\n"
-"      <arg name=\"hwaddr\" type=\"s\"/>\n"
-"      <arg name=\"hostname\" type=\"s\"/>\n"
-"    </signal>\n"
+    "    <method name=\"GetLoopServers\">\n"
+    "      <arg name=\"server\" direction=\"out\" type=\"as\"/>\n"
+    "    </method>\n"
+#endif
+    "    <method name=\"SetServers\">\n"
+    "      <arg name=\"servers\" direction=\"in\" type=\"av\"/>\n"
+    "    </method>\n"
+    "    <method name=\"SetDomainServers\">\n"
+    "      <arg name=\"servers\" direction=\"in\" type=\"as\"/>\n"
+    "    </method>\n"
+    "    <method name=\"SetServersEx\">\n"
+    "      <arg name=\"servers\" direction=\"in\" type=\"aas\"/>\n"
+    "    </method>\n"
+    "    <method name=\"SetFilterWin2KOption\">\n"
+    "      <arg name=\"filterwin2k\" direction=\"in\" type=\"b\"/>\n"
+    "    </method>\n"
+    "    <method name=\"SetBogusPrivOption\">\n"
+    "      <arg name=\"boguspriv\" direction=\"in\" type=\"b\"/>\n"
+    "    </method>\n"
+    "    <signal name=\"DhcpLeaseAdded\">\n"
+    "      <arg name=\"ipaddr\" type=\"s\"/>\n"
+    "      <arg name=\"hwaddr\" type=\"s\"/>\n"
+    "      <arg name=\"hostname\" type=\"s\"/>\n"
+    "    </signal>\n"
+    "    <signal name=\"DhcpLeaseDeleted\">\n"
+    "      <arg name=\"ipaddr\" type=\"s\"/>\n"
+    "      <arg name=\"hwaddr\" type=\"s\"/>\n"
+    "      <arg name=\"hostname\" type=\"s\"/>\n"
+    "    </signal>\n"
+    "    <signal name=\"DhcpLeaseUpdated\">\n"
+    "      <arg name=\"ipaddr\" type=\"s\"/>\n"
+    "      <arg name=\"hwaddr\" type=\"s\"/>\n"
+    "      <arg name=\"hostname\" type=\"s\"/>\n" "    </signal>\n"
 #ifdef HAVE_DHCP
-"    <method name=\"AddDhcpLease\">\n"
-"       <arg name=\"ipaddr\" type=\"s\"/>\n"
-"       <arg name=\"hwaddr\" type=\"s\"/>\n"
-"       <arg name=\"hostname\" type=\"ay\"/>\n"
-"       <arg name=\"clid\" type=\"ay\"/>\n"
-"       <arg name=\"lease_duration\" type=\"u\"/>\n"
-"       <arg name=\"ia_id\" type=\"u\"/>\n"
-"       <arg name=\"is_temporary\" type=\"b\"/>\n"
-"    </method>\n"
-"    <method name=\"DeleteDhcpLease\">\n"
-"       <arg name=\"ipaddr\" type=\"s\"/>\n"
-"       <arg name=\"success\" type=\"b\" direction=\"out\"/>\n"
-"    </method>\n"
+    "    <method name=\"AddDhcpLease\">\n"
+    "       <arg name=\"ipaddr\" type=\"s\"/>\n"
+    "       <arg name=\"hwaddr\" type=\"s\"/>\n"
+    "       <arg name=\"hostname\" type=\"ay\"/>\n"
+    "       <arg name=\"clid\" type=\"ay\"/>\n"
+    "       <arg name=\"lease_duration\" type=\"u\"/>\n"
+    "       <arg name=\"ia_id\" type=\"u\"/>\n"
+    "       <arg name=\"is_temporary\" type=\"b\"/>\n"
+    "    </method>\n"
+    "    <method name=\"DeleteDhcpLease\">\n"
+    "       <arg name=\"ipaddr\" type=\"s\"/>\n"
+    "       <arg name=\"success\" type=\"b\" direction=\"out\"/>\n"
+    "    </method>\n"
 #endif
-"  </interface>\n"
-"</node>\n";
+    "  </interface>\n" "</node>\n";
 
 static char *introspection_xml = NULL;
 
 struct watch {
-  DBusWatch *watch;      
+  DBusWatch *watch;
   struct watch *next;
 };
 
 
-static dbus_bool_t add_watch(DBusWatch *watch, void *data)
+static dbus_bool_t add_watch(DBusWatch * watch, void *data)
 {
   struct watch *w;
 
@@ -111,311 +109,290 @@
   w->next = daemon->watches;
   daemon->watches = w;
 
-  w = data; /* no warning */
+  w = data;                     /* no warning */
   return TRUE;
 }
 
-static void remove_watch(DBusWatch *watch, void *data)
+static void remove_watch(DBusWatch * watch, void *data)
 {
-  struct watch **up, *w, *tmp;  
-  
-  for (up = &(daemon->watches), w = daemon->watches; w; w = tmp)
-    {
-      tmp = w->next;
-      if (w->watch == watch)
-	{
-	  *up = tmp;
-	  free(w);
-	}
-      else
-	up = &(w->next);
-    }
+  struct watch **up, *w, *tmp;
+
+  for (up = &(daemon->watches), w = daemon->watches; w; w = tmp) {
+    tmp = w->next;
+    if (w->watch == watch) {
+      *up = tmp;
+      free(w);
+    } else
+      up = &(w->next);
+  }
 
-  w = data; /* no warning */
+  w = data;                     /* no warning */
 }
 
-static void dbus_read_servers(DBusMessage *message)
+static void dbus_read_servers(DBusMessage * message)
 {
   DBusMessageIter iter;
-  union  mysockaddr addr, source_addr;
+  union mysockaddr addr, source_addr;
   char *domain;
-  
+
   dbus_message_iter_init(message, &iter);
 
   mark_servers(SERV_FROM_DBUS);
-  
-  while (1)
-    {
-      int skip = 0;
-
-      if (dbus_message_iter_get_arg_type(&iter) == DBUS_TYPE_UINT32)
-	{
-	  u32 a;
-	  
-	  dbus_message_iter_get_basic(&iter, &a);
-	  dbus_message_iter_next (&iter);
-	  
+
+  while (1) {
+    int skip = 0;
+
+    if (dbus_message_iter_get_arg_type(&iter) == DBUS_TYPE_UINT32) {
+      u32 a;
+
+      dbus_message_iter_get_basic(&iter, &a);
+      dbus_message_iter_next(&iter);
+
 #ifdef HAVE_SOCKADDR_SA_LEN
-	  source_addr.in.sin_len = addr.in.sin_len = sizeof(struct sockaddr_in);
+      source_addr.in.sin_len = addr.in.sin_len = sizeof(struct sockaddr_in);
 #endif
-	  addr.in.sin_addr.s_addr = ntohl(a);
-	  source_addr.in.sin_family = addr.in.sin_family = AF_INET;
-	  addr.in.sin_port = htons(NAMESERVER_PORT);
-	  source_addr.in.sin_addr.s_addr = INADDR_ANY;
-	  source_addr.in.sin_port = htons(daemon->query_port);
-	}
-      else if (dbus_message_iter_get_arg_type(&iter) == DBUS_TYPE_BYTE)
-	{
-	  unsigned char p[sizeof(struct in6_addr)];
-	  unsigned int i;
-
-	  skip = 1;
-
-	  for(i = 0; i < sizeof(struct in6_addr); i++)
-	    {
-	      dbus_message_iter_get_basic(&iter, &p[i]);
-	      dbus_message_iter_next (&iter);
-	      if (dbus_message_iter_get_arg_type(&iter) != DBUS_TYPE_BYTE)
-		{
-		  i++;
-		  break;
-		}
-	    }
+      addr.in.sin_addr.s_addr = ntohl(a);
+      source_addr.in.sin_family = addr.in.sin_family = AF_INET;
+      addr.in.sin_port = htons(NAMESERVER_PORT);
+      source_addr.in.sin_addr.s_addr = INADDR_ANY;
+      source_addr.in.sin_port = htons(daemon->query_port);
+    } else if (dbus_message_iter_get_arg_type(&iter) == DBUS_TYPE_BYTE) {
+      unsigned char p[sizeof(struct in6_addr)];
+      unsigned int i;
+
+      skip = 1;
+
+      for (i = 0; i < sizeof(struct in6_addr); i++) {
+        dbus_message_iter_get_basic(&iter, &p[i]);
+        dbus_message_iter_next(&iter);
+        if (dbus_message_iter_get_arg_type(&iter) != DBUS_TYPE_BYTE) {
+          i++;
+          break;
+        }
+      }
 
 #ifndef HAVE_IPV6
-	  my_syslog(LOG_WARNING, _("attempt to set an IPv6 server address via DBus - no IPv6 support"));
+      my_syslog(LOG_WARNING,
+                _
+                ("attempt to set an IPv6 server address via DBus - no IPv6 support"));
 #else
-	  if (i == sizeof(struct in6_addr))
-	    {
-	      memcpy(&addr.in6.sin6_addr, p, sizeof(struct in6_addr));
+      if (i == sizeof(struct in6_addr)) {
+        memcpy(&addr.in6.sin6_addr, p, sizeof(struct in6_addr));
 #ifdef HAVE_SOCKADDR_SA_LEN
-              source_addr.in6.sin6_len = addr.in6.sin6_len = sizeof(struct sockaddr_in6);
+        source_addr.in6.sin6_len = addr.in6.sin6_len =
+            sizeof(struct sockaddr_in6);
 #endif
-              source_addr.in6.sin6_family = addr.in6.sin6_family = AF_INET6;
-              addr.in6.sin6_port = htons(NAMESERVER_PORT);
-              source_addr.in6.sin6_flowinfo = addr.in6.sin6_flowinfo = 0;
-	      source_addr.in6.sin6_scope_id = addr.in6.sin6_scope_id = 0;
-              source_addr.in6.sin6_addr = in6addr_any;
-              source_addr.in6.sin6_port = htons(daemon->query_port);
-	      skip = 0;
-	    }
-#endif
-	}
-      else
-	/* At the end */
-	break;
-      
-      /* process each domain */
-      do {
-	if (dbus_message_iter_get_arg_type(&iter) == DBUS_TYPE_STRING)
-	  {
-	    dbus_message_iter_get_basic(&iter, &domain);
-	    dbus_message_iter_next (&iter);
-	  }
-	else
-	  domain = NULL;
-	
-	if (!skip)
-	  add_update_server(SERV_FROM_DBUS, &addr, &source_addr, NULL, domain);
-     
-      } while (dbus_message_iter_get_arg_type(&iter) == DBUS_TYPE_STRING); 
-    }
-   
+        source_addr.in6.sin6_family = addr.in6.sin6_family = AF_INET6;
+        addr.in6.sin6_port = htons(NAMESERVER_PORT);
+        source_addr.in6.sin6_flowinfo = addr.in6.sin6_flowinfo = 0;
+        source_addr.in6.sin6_scope_id = addr.in6.sin6_scope_id = 0;
+        source_addr.in6.sin6_addr = in6addr_any;
+        source_addr.in6.sin6_port = htons(daemon->query_port);
+        skip = 0;
+      }
+#endif
+    } else
+      /* At the end */
+      break;
+
+    /* process each domain */
+    do {
+      if (dbus_message_iter_get_arg_type(&iter) == DBUS_TYPE_STRING) {
+        dbus_message_iter_get_basic(&iter, &domain);
+        dbus_message_iter_next(&iter);
+      } else
+        domain = NULL;
+
+      if (!skip)
+        add_update_server(SERV_FROM_DBUS, &addr, &source_addr, NULL, domain);
+
+    } while (dbus_message_iter_get_arg_type(&iter) == DBUS_TYPE_STRING);
+  }
+
   /* unlink and free anything still marked. */
   cleanup_servers();
 }
 
 #ifdef HAVE_LOOP
-static DBusMessage *dbus_reply_server_loop(DBusMessage *message)
+static DBusMessage *dbus_reply_server_loop(DBusMessage * message)
 {
   DBusMessageIter args, args_iter;
   struct server *serv;
   DBusMessage *reply = dbus_message_new_method_return(message);
-   
-  dbus_message_iter_init_append (reply, &args);
-  dbus_message_iter_open_container (&args, DBUS_TYPE_ARRAY,DBUS_TYPE_STRING_AS_STRING, &args_iter);
+
+  dbus_message_iter_init_append(reply, &args);
+  dbus_message_iter_open_container(&args, DBUS_TYPE_ARRAY,
+                                   DBUS_TYPE_STRING_AS_STRING, &args_iter);
 
   for (serv = daemon->servers; serv; serv = serv->next)
-    if (serv->flags & SERV_LOOP)
-      {
-	prettyprint_addr(&serv->addr, daemon->addrbuff);
-	dbus_message_iter_append_basic (&args_iter, DBUS_TYPE_STRING, &daemon->addrbuff);
-      }
-  
-  dbus_message_iter_close_container (&args, &args_iter);
+    if (serv->flags & SERV_LOOP) {
+      prettyprint_addr(&serv->addr, daemon->addrbuff);
+      dbus_message_iter_append_basic(&args_iter, DBUS_TYPE_STRING,
+                                     &daemon->addrbuff);
+    }
+
+  dbus_message_iter_close_container(&args, &args_iter);
 
   return reply;
 }
 #endif
 
-static DBusMessage* dbus_read_servers_ex(DBusMessage *message, int strings)
+static DBusMessage *dbus_read_servers_ex(DBusMessage * message, int strings)
 {
   DBusMessageIter iter, array_iter, string_iter;
   DBusMessage *error = NULL;
   const char *addr_err;
   char *dup = NULL;
-  
-  if (!dbus_message_iter_init(message, &iter))
-    {
-      return dbus_message_new_error(message, DBUS_ERROR_INVALID_ARGS,
-                                    "Failed to initialize dbus message iter");
-    }
+
+  if (!dbus_message_iter_init(message, &iter)) {
+    return dbus_message_new_error(message, DBUS_ERROR_INVALID_ARGS,
+                                  "Failed to initialize dbus message iter");
+  }
 
   /* check that the message contains an array of arrays */
   if ((dbus_message_iter_get_arg_type(&iter) != DBUS_TYPE_ARRAY) ||
-      (dbus_message_iter_get_element_type(&iter) != (strings ? DBUS_TYPE_STRING : DBUS_TYPE_ARRAY)))
-    {
-      return dbus_message_new_error(message, DBUS_ERROR_INVALID_ARGS,
-                                    strings ? "Expected array of string" : "Expected array of string arrays");
-     }
- 
+      (dbus_message_iter_get_element_type(&iter) !=
+       (strings ? DBUS_TYPE_STRING : DBUS_TYPE_ARRAY))) {
+    return dbus_message_new_error(message, DBUS_ERROR_INVALID_ARGS,
+                                  strings ? "Expected array of string" :
+                                  "Expected array of string arrays");
+  }
+
   mark_servers(SERV_FROM_DBUS);
 
   /* array_iter points to each "as" element in the outer array */
   dbus_message_iter_recurse(&iter, &array_iter);
-  while (dbus_message_iter_get_arg_type(&array_iter) != DBUS_TYPE_INVALID)
-    {
-      const char *str = NULL;
-      union  mysockaddr addr, source_addr;
-      int flags = 0;
-      char interface[IF_NAMESIZE];
-      char *str_addr, *str_domain = NULL;
-
-      if (strings)
-	{
-	  dbus_message_iter_get_basic(&array_iter, &str);
-	  if (!str || !strlen (str))
-	    {
-	      error = dbus_message_new_error(message, DBUS_ERROR_INVALID_ARGS,
-					     "Empty string");
-	      break;
-	    }
-	  
-	  /* dup the string because it gets modified during parsing */
-	  if (dup)
-	    free(dup);
-	  if (!(dup = str_domain = whine_malloc(strlen(str)+1)))
-	    break;
-	  
-	  strcpy(str_domain, str);
-
-	  /* point to address part of old string for error message */
-	  if ((str_addr = strrchr(str, '/')))
-	    str = str_addr+1;
-	  
-	  if ((str_addr = strrchr(str_domain, '/')))
-	    {
-	      if (*str_domain != '/' || str_addr == str_domain)
-		{
-		  error = dbus_message_new_error_printf(message,
-							DBUS_ERROR_INVALID_ARGS,
-							"No domain terminator '%s'",
-							str);
-		  break;
-		}
-	      *str_addr++ = 0;
-	      str_domain++;
-	    }
-	  else
-	    {
-	      str_addr = str_domain;
-	      str_domain = NULL;
-	    }
-
-	  
-	}
-      else
-	{
-	  /* check the types of the struct and its elements */
-	  if ((dbus_message_iter_get_arg_type(&array_iter) != DBUS_TYPE_ARRAY) ||
-	      (dbus_message_iter_get_element_type(&array_iter) != DBUS_TYPE_STRING))
-	    {
-	      error = dbus_message_new_error(message, DBUS_ERROR_INVALID_ARGS,
-					     "Expected inner array of strings");
-	      break;
-	    }
-	  
-	  /* string_iter points to each "s" element in the inner array */
-	  dbus_message_iter_recurse(&array_iter, &string_iter);
-	  if (dbus_message_iter_get_arg_type(&string_iter) != DBUS_TYPE_STRING)
-	    {
-	      /* no IP address given */
-	      error = dbus_message_new_error(message, DBUS_ERROR_INVALID_ARGS,
-					     "Expected IP address");
-	      break;
-	    }
-	  
-	  dbus_message_iter_get_basic(&string_iter, &str);
-	  if (!str || !strlen (str))
-	    {
-	      error = dbus_message_new_error(message, DBUS_ERROR_INVALID_ARGS,
-					     "Empty IP address");
-	      break;
-	    }
-	  
-	  /* dup the string because it gets modified during parsing */
-	  if (dup)
-	    free(dup);
-	  if (!(dup = str_addr = whine_malloc(strlen(str)+1)))
-	    break;
-	  
-	  strcpy(str_addr, str);
-	}
-
-      memset(&addr, 0, sizeof(addr));
-      memset(&source_addr, 0, sizeof(source_addr));
-      memset(&interface, 0, sizeof(interface));
-
-      /* parse the IP address */
-      if ((addr_err = parse_server(str_addr, &addr, &source_addr, (char *) &interface, &flags)))
-	{
-          error = dbus_message_new_error_printf(message, DBUS_ERROR_INVALID_ARGS,
-                                                "Invalid IP address '%s': %s",
-                                                str, addr_err);
+  while (dbus_message_iter_get_arg_type(&array_iter) != DBUS_TYPE_INVALID) {
+    const char *str = NULL;
+    union mysockaddr addr, source_addr;
+    int flags = 0;
+    char interface[IF_NAMESIZE];
+    char *str_addr, *str_domain = NULL;
+
+    if (strings) {
+      dbus_message_iter_get_basic(&array_iter, &str);
+      if (!str || !strlen(str)) {
+        error = dbus_message_new_error(message, DBUS_ERROR_INVALID_ARGS,
+                                       "Empty string");
+        break;
+      }
+
+      /* dup the string because it gets modified during parsing */
+      if (dup)
+        free(dup);
+      if (!(dup = str_domain = whine_malloc(strlen(str) + 1)))
+        break;
+
+      strcpy(str_domain, str);
+
+      /* point to address part of old string for error message */
+      if ((str_addr = strrchr(str, '/')))
+        str = str_addr + 1;
+
+      if ((str_addr = strrchr(str_domain, '/'))) {
+        if (*str_domain != '/' || str_addr == str_domain) {
+          error = dbus_message_new_error_printf(message,
+                                                DBUS_ERROR_INVALID_ARGS,
+                                                "No domain terminator '%s'",
+                                                str);
           break;
         }
-      
-      /* 0.0.0.0 for server address == NULL, for Dbus */
-      if (addr.in.sin_family == AF_INET &&
-          addr.in.sin_addr.s_addr == 0)
-        flags |= SERV_NO_ADDR;
-      
-      if (strings)
-	{
-	  char *p;
-	  
-	  do {
-	    if (str_domain)
-	      {
-		if ((p = strchr(str_domain, '/')))
-		  *p++ = 0;
-	      }
-	    else 
-	      p = NULL;
-	    
-	    add_update_server(flags | SERV_FROM_DBUS, &addr, &source_addr, interface, str_domain);
-	  } while ((str_domain = p));
-	}
-      else
-	{
-	  /* jump past the address to the domain list (if any) */
-	  dbus_message_iter_next (&string_iter);
-	  
-	  /* parse domains and add each server/domain pair to the list */
-	  do {
-	    str = NULL;
-	    if (dbus_message_iter_get_arg_type(&string_iter) == DBUS_TYPE_STRING)
-	      dbus_message_iter_get_basic(&string_iter, &str);
-	    dbus_message_iter_next (&string_iter);
-	    
-	    add_update_server(flags | SERV_FROM_DBUS, &addr, &source_addr, interface, str);
-	  } while (dbus_message_iter_get_arg_type(&string_iter) == DBUS_TYPE_STRING);
-	}
-	 
-      /* jump to next element in outer array */
-      dbus_message_iter_next(&array_iter);
+        *str_addr++ = 0;
+        str_domain++;
+      } else {
+        str_addr = str_domain;
+        str_domain = NULL;
+      }
+
+
+    } else {
+      /* check the types of the struct and its elements */
+      if ((dbus_message_iter_get_arg_type(&array_iter) != DBUS_TYPE_ARRAY) ||
+          (dbus_message_iter_get_element_type(&array_iter) != DBUS_TYPE_STRING))
+      {
+        error = dbus_message_new_error(message, DBUS_ERROR_INVALID_ARGS,
+                                       "Expected inner array of strings");
+        break;
+      }
+
+      /* string_iter points to each "s" element in the inner array */
+      dbus_message_iter_recurse(&array_iter, &string_iter);
+      if (dbus_message_iter_get_arg_type(&string_iter) != DBUS_TYPE_STRING) {
+        /* no IP address given */
+        error = dbus_message_new_error(message, DBUS_ERROR_INVALID_ARGS,
+                                       "Expected IP address");
+        break;
+      }
+
+      dbus_message_iter_get_basic(&string_iter, &str);
+      if (!str || !strlen(str)) {
+        error = dbus_message_new_error(message, DBUS_ERROR_INVALID_ARGS,
+                                       "Empty IP address");
+        break;
+      }
+
+      /* dup the string because it gets modified during parsing */
+      if (dup)
+        free(dup);
+      if (!(dup = str_addr = whine_malloc(strlen(str) + 1)))
+        break;
+
+      strcpy(str_addr, str);
+    }
+
+    memset(&addr, 0, sizeof(addr));
+    memset(&source_addr, 0, sizeof(source_addr));
+    memset(&interface, 0, sizeof(interface));
+
+    /* parse the IP address */
+    if ((addr_err =
+         parse_server(str_addr, &addr, &source_addr, (char *) &interface,
+                      &flags))) {
+      error =
+          dbus_message_new_error_printf(message, DBUS_ERROR_INVALID_ARGS,
+                                        "Invalid IP address '%s': %s", str,
+                                        addr_err);
+      break;
+    }
+
+    /* 0.0.0.0 for server address == NULL, for Dbus */
+    if (addr.in.sin_family == AF_INET && addr.in.sin_addr.s_addr == 0)
+      flags |= SERV_NO_ADDR;
+
+    if (strings) {
+      char *p;
+
+      do {
+        if (str_domain) {
+          if ((p = strchr(str_domain, '/')))
+            *p++ = 0;
+        } else
+          p = NULL;
+
+        add_update_server(flags | SERV_FROM_DBUS, &addr, &source_addr,
+                          interface, str_domain);
+      } while ((str_domain = p));
+    } else {
+      /* jump past the address to the domain list (if any) */
+      dbus_message_iter_next(&string_iter);
+
+      /* parse domains and add each server/domain pair to the list */
+      do {
+        str = NULL;
+        if (dbus_message_iter_get_arg_type(&string_iter) == DBUS_TYPE_STRING)
+          dbus_message_iter_get_basic(&string_iter, &str);
+        dbus_message_iter_next(&string_iter);
+
+        add_update_server(flags | SERV_FROM_DBUS, &addr, &source_addr,
+                          interface, str);
+      } while (dbus_message_iter_get_arg_type(&string_iter) ==
+               DBUS_TYPE_STRING);
     }
 
+    /* jump to next element in outer array */
+    dbus_message_iter_next(&array_iter);
+  }
+
   cleanup_servers();
 
   if (dup)
@@ -424,36 +401,35 @@
   return error;
 }
 
-static DBusMessage *dbus_set_bool(DBusMessage *message, int flag, char *name)
+static DBusMessage *dbus_set_bool(DBusMessage * message, int flag, char *name)
 {
   DBusMessageIter iter;
   dbus_bool_t enabled;
 
-  if (!dbus_message_iter_init(message, &iter) || dbus_message_iter_get_arg_type(&iter) != DBUS_TYPE_BOOLEAN)
-    return dbus_message_new_error(message, DBUS_ERROR_INVALID_ARGS, "Expected boolean argument");
-  
+  if (!dbus_message_iter_init(message, &iter)
+      || dbus_message_iter_get_arg_type(&iter) != DBUS_TYPE_BOOLEAN)
+    return dbus_message_new_error(message, DBUS_ERROR_INVALID_ARGS,
+                                  "Expected boolean argument");
+
   dbus_message_iter_get_basic(&iter, &enabled);
 
-  if (enabled)
-    { 
-      my_syslog(LOG_INFO, _("Enabling --%s option from D-Bus"), name);
-      set_option_bool(flag);
-    }
-  else
-    {
-      my_syslog(LOG_INFO, _("Disabling --%s option from D-Bus"), name);
-      reset_option_bool(flag);
-    }
+  if (enabled) {
+    my_syslog(LOG_INFO, _("Enabling --%s option from D-Bus"), name);
+    set_option_bool(flag);
+  } else {
+    my_syslog(LOG_INFO, _("Disabling --%s option from D-Bus"), name);
+    reset_option_bool(flag);
+  }
 
   return NULL;
 }
 
 #ifdef HAVE_DHCP
-static DBusMessage *dbus_add_lease(DBusMessage* message)
+static DBusMessage *dbus_add_lease(DBusMessage * message)
 {
   struct dhcp_lease *lease;
   const char *ipaddr, *hwaddr, *hostname, *tmp;
-  const unsigned char* clid;
+  const unsigned char *clid;
   int clid_len, hostname_len, hw_len, hw_type;
   dbus_uint32_t expires, ia_id;
   dbus_bool_t is_temporary;
@@ -464,44 +440,43 @@
   DBusMessageIter iter, array_iter;
   if (!dbus_message_iter_init(message, &iter))
     return dbus_message_new_error(message, DBUS_ERROR_INVALID_ARGS,
-				  "Failed to initialize dbus message iter");
+                                  "Failed to initialize dbus message iter");
 
   if (dbus_message_iter_get_arg_type(&iter) != DBUS_TYPE_STRING)
     return dbus_message_new_error(message, DBUS_ERROR_INVALID_ARGS,
-				  "Expected string as first argument");
+                                  "Expected string as first argument");
 
   dbus_message_iter_get_basic(&iter, &ipaddr);
   dbus_message_iter_next(&iter);
 
   if (dbus_message_iter_get_arg_type(&iter) != DBUS_TYPE_STRING)
     return dbus_message_new_error(message, DBUS_ERROR_INVALID_ARGS,
-				  "Expected string as second argument");
-    
+                                  "Expected string as second argument");
+
   dbus_message_iter_get_basic(&iter, &hwaddr);
   dbus_message_iter_next(&iter);
 
   if ((dbus_message_iter_get_arg_type(&iter) != DBUS_TYPE_ARRAY) ||
       (dbus_message_iter_get_element_type(&iter) != DBUS_TYPE_BYTE))
     return dbus_message_new_error(message, DBUS_ERROR_INVALID_ARGS,
-				  "Expected byte array as third argument");
-    
+                                  "Expected byte array as third argument");
+
   dbus_message_iter_recurse(&iter, &array_iter);
   dbus_message_iter_get_fixed_array(&array_iter, &hostname, &hostname_len);
   tmp = memchr(hostname, '\0', hostname_len);
-  if (tmp)
-    {
-      if (tmp == &hostname[hostname_len - 1])
-	hostname_len--;
-      else
-	return dbus_message_new_error(message, DBUS_ERROR_INVALID_ARGS,
-				      "Hostname contains an embedded NUL character");
-    }
+  if (tmp) {
+    if (tmp == &hostname[hostname_len - 1])
+      hostname_len--;
+    else
+      return dbus_message_new_error(message, DBUS_ERROR_INVALID_ARGS,
+                                    "Hostname contains an embedded NUL character");
+  }
   dbus_message_iter_next(&iter);
 
   if ((dbus_message_iter_get_arg_type(&iter) != DBUS_TYPE_ARRAY) ||
       (dbus_message_iter_get_element_type(&iter) != DBUS_TYPE_BYTE))
     return dbus_message_new_error(message, DBUS_ERROR_INVALID_ARGS,
-				  "Expected byte array as fourth argument");
+                                  "Expected byte array as fourth argument");
 
   dbus_message_iter_recurse(&iter, &array_iter);
   dbus_message_iter_get_fixed_array(&array_iter, &clid, &clid_len);
@@ -509,63 +484,61 @@
 
   if (dbus_message_iter_get_arg_type(&iter) != DBUS_TYPE_UINT32)
     return dbus_message_new_error(message, DBUS_ERROR_INVALID_ARGS,
-				  "Expected uint32 as fifth argument");
-    
+                                  "Expected uint32 as fifth argument");
+
   dbus_message_iter_get_basic(&iter, &expires);
   dbus_message_iter_next(&iter);
 
   if (dbus_message_iter_get_arg_type(&iter) != DBUS_TYPE_UINT32)
     return dbus_message_new_error(message, DBUS_ERROR_INVALID_ARGS,
-                                    "Expected uint32 as sixth argument");
-  
+                                  "Expected uint32 as sixth argument");
+
   dbus_message_iter_get_basic(&iter, &ia_id);
   dbus_message_iter_next(&iter);
 
   if (dbus_message_iter_get_arg_type(&iter) != DBUS_TYPE_BOOLEAN)
     return dbus_message_new_error(message, DBUS_ERROR_INVALID_ARGS,
-				  "Expected uint32 as sixth argument");
+                                  "Expected uint32 as sixth argument");
 
   dbus_message_iter_get_basic(&iter, &is_temporary);
 
-  if (inet_pton(AF_INET, ipaddr, &addr.addr.addr4))
-    {
-      if (ia_id != 0 || is_temporary)
-	return dbus_message_new_error(message, DBUS_ERROR_INVALID_ARGS,
-				      "ia_id and is_temporary must be zero for IPv4 lease");
-      
-      if (!(lease = lease_find_by_addr(addr.addr.addr4)))
-    	lease = lease4_allocate(addr.addr.addr4);
-    }
+  if (inet_pton(AF_INET, ipaddr, &addr.addr.addr4)) {
+    if (ia_id != 0 || is_temporary)
+      return dbus_message_new_error(message, DBUS_ERROR_INVALID_ARGS,
+                                    "ia_id and is_temporary must be zero for IPv4 lease");
+
+    if (!(lease = lease_find_by_addr(addr.addr.addr4)))
+      lease = lease4_allocate(addr.addr.addr4);
+  }
 #ifdef HAVE_DHCP6
-  else if (inet_pton(AF_INET6, ipaddr, &addr.addr.addr6))
-    {
-      if (!(lease = lease6_find_by_addr(&addr.addr.addr6, 128, 0)))
-	lease = lease6_allocate(&addr.addr.addr6,
-				is_temporary ? LEASE_TA : LEASE_NA);
-      lease_set_iaid(lease, ia_id);
-    }
+  else if (inet_pton(AF_INET6, ipaddr, &addr.addr.addr6)) {
+    if (!(lease = lease6_find_by_addr(&addr.addr.addr6, 128, 0)))
+      lease = lease6_allocate(&addr.addr.addr6,
+                              is_temporary ? LEASE_TA : LEASE_NA);
+    lease_set_iaid(lease, ia_id);
+  }
 #endif
   else
     return dbus_message_new_error_printf(message, DBUS_ERROR_INVALID_ARGS,
-					 "Invalid IP address '%s'", ipaddr);
-   
-  hw_len = parse_hex((char*)hwaddr, dhcp_chaddr, DHCP_CHADDR_MAX, NULL, &hw_type);
+                                         "Invalid IP address '%s'", ipaddr);
+
+  hw_len =
+      parse_hex((char *) hwaddr, dhcp_chaddr, DHCP_CHADDR_MAX, NULL, &hw_type);
   if (hw_type == 0 && hw_len != 0)
     hw_type = ARPHRD_ETHER;
-  
-  lease_set_hwaddr(lease, dhcp_chaddr, clid, hw_len, hw_type,
-                   clid_len, now, 0);
+
+  lease_set_hwaddr(lease, dhcp_chaddr, clid, hw_len, hw_type, clid_len, now, 0);
   lease_set_expires(lease, expires, now);
   if (hostname_len != 0)
     lease_set_hostname(lease, hostname, 0, get_domain(lease->addr), NULL);
-  
+
   lease_update_file(now);
   lease_update_dns(0);
 
   return NULL;
 }
 
-static DBusMessage *dbus_del_lease(DBusMessage* message)
+static DBusMessage *dbus_del_lease(DBusMessage * message)
 {
   struct dhcp_lease *lease;
   DBusMessageIter iter;
@@ -577,12 +550,12 @@
 
   if (!dbus_message_iter_init(message, &iter))
     return dbus_message_new_error(message, DBUS_ERROR_INVALID_ARGS,
-				  "Failed to initialize dbus message iter");
-   
+                                  "Failed to initialize dbus message iter");
+
   if (dbus_message_iter_get_arg_type(&iter) != DBUS_TYPE_STRING)
     return dbus_message_new_error(message, DBUS_ERROR_INVALID_ARGS,
-				  "Expected string as first argument");
-   
+                                  "Expected string as first argument");
+
   dbus_message_iter_get_basic(&iter, &ipaddr);
 
   if (inet_pton(AF_INET, ipaddr, &addr.addr.addr4))
@@ -593,218 +566,197 @@
 #endif
   else
     return dbus_message_new_error_printf(message, DBUS_ERROR_INVALID_ARGS,
-					 "Invalid IP address '%s'", ipaddr);
-    
-  if (lease)
-    {
-      lease_prune(lease, now);
-      lease_update_file(now);
-      lease_update_dns(0);
-    }
-  else
+                                         "Invalid IP address '%s'", ipaddr);
+
+  if (lease) {
+    lease_prune(lease, now);
+    lease_update_file(now);
+    lease_update_dns(0);
+  } else
     ret = 0;
-  
+
   if ((reply = dbus_message_new_method_return(message)))
-    dbus_message_append_args(reply, DBUS_TYPE_BOOLEAN, &ret,
-			     DBUS_TYPE_INVALID);
-  
-    
+    dbus_message_append_args(reply, DBUS_TYPE_BOOLEAN, &ret, DBUS_TYPE_INVALID);
+
+
   return reply;
 }
 #endif
 
-DBusHandlerResult message_handler(DBusConnection *connection, 
-				  DBusMessage *message, 
-				  void *user_data)
+DBusHandlerResult message_handler(DBusConnection * connection,
+                                  DBusMessage * message, void *user_data)
 {
-  char *method = (char *)dbus_message_get_member(message);
+  char *method = (char *) dbus_message_get_member(message);
   DBusMessage *reply = NULL;
   int clear_cache = 0, new_servers = 0;
-    
-  if (dbus_message_is_method_call(message, DBUS_INTERFACE_INTROSPECTABLE, "Introspect"))
-    {
-      /* string length: "%s" provides space for termination zero */
-      if (!introspection_xml && 
-	  (introspection_xml = whine_malloc(strlen(introspection_xml_template) + strlen(daemon->dbus_name))))
-	sprintf(introspection_xml, introspection_xml_template, daemon->dbus_name);
-    
-      if (introspection_xml)
-	{
-	  reply = dbus_message_new_method_return(message);
-	  dbus_message_append_args(reply, DBUS_TYPE_STRING, &introspection_xml, DBUS_TYPE_INVALID);
-	}
-    }
-  else if (strcmp(method, "GetVersion") == 0)
-    {
-      char *v = VERSION;
+
+  if (dbus_message_is_method_call
+      (message, DBUS_INTERFACE_INTROSPECTABLE, "Introspect")) {
+    /* string length: "%s" provides space for termination zero */
+    if (!introspection_xml &&
+        (introspection_xml =
+         whine_malloc(strlen(introspection_xml_template) +
+                      strlen(daemon->dbus_name))))
+      sprintf(introspection_xml, introspection_xml_template, daemon->dbus_name);
+
+    if (introspection_xml) {
       reply = dbus_message_new_method_return(message);
-      
-      dbus_message_append_args(reply, DBUS_TYPE_STRING, &v, DBUS_TYPE_INVALID);
+      dbus_message_append_args(reply, DBUS_TYPE_STRING, &introspection_xml,
+                               DBUS_TYPE_INVALID);
     }
+  } else if (strcmp(method, "GetVersion") == 0) {
+    char *v = VERSION;
+    reply = dbus_message_new_method_return(message);
+
+    dbus_message_append_args(reply, DBUS_TYPE_STRING, &v, DBUS_TYPE_INVALID);
+  }
 #ifdef HAVE_LOOP
-  else if (strcmp(method, "GetLoopServers") == 0)
-    {
-      reply = dbus_reply_server_loop(message);
-    }
-#endif
-  else if (strcmp(method, "SetServers") == 0)
-    {
-      dbus_read_servers(message);
-      new_servers = 1;
-    }
-  else if (strcmp(method, "SetServersEx") == 0)
-    {
-      reply = dbus_read_servers_ex(message, 0);
-      new_servers = 1;
-    }
-  else if (strcmp(method, "SetDomainServers") == 0)
-    {
-      reply = dbus_read_servers_ex(message, 1);
-      new_servers = 1;
-    }
-  else if (strcmp(method, "SetFilterWin2KOption") == 0)
-    {
-      reply = dbus_set_bool(message, OPT_FILTER, "filterwin2k");
-    }
-  else if (strcmp(method, "SetBogusPrivOption") == 0)
-    {
-      reply = dbus_set_bool(message, OPT_BOGUSPRIV, "bogus-priv");
-    }
+  else if (strcmp(method, "GetLoopServers") == 0) {
+    reply = dbus_reply_server_loop(message);
+  }
+#endif
+  else if (strcmp(method, "SetServers") == 0) {
+    dbus_read_servers(message);
+    new_servers = 1;
+  } else if (strcmp(method, "SetServersEx") == 0) {
+    reply = dbus_read_servers_ex(message, 0);
+    new_servers = 1;
+  } else if (strcmp(method, "SetDomainServers") == 0) {
+    reply = dbus_read_servers_ex(message, 1);
+    new_servers = 1;
+  } else if (strcmp(method, "SetFilterWin2KOption") == 0) {
+    reply = dbus_set_bool(message, OPT_FILTER, "filterwin2k");
+  } else if (strcmp(method, "SetBogusPrivOption") == 0) {
+    reply = dbus_set_bool(message, OPT_BOGUSPRIV, "bogus-priv");
+  }
 #ifdef HAVE_DHCP
-  else if (strcmp(method, "AddDhcpLease") == 0)
-    {
-      reply = dbus_add_lease(message);
-    }
-  else if (strcmp(method, "DeleteDhcpLease") == 0)
-    {
-      reply = dbus_del_lease(message);
-    }
+  else if (strcmp(method, "AddDhcpLease") == 0) {
+    reply = dbus_add_lease(message);
+  } else if (strcmp(method, "DeleteDhcpLease") == 0) {
+    reply = dbus_del_lease(message);
+  }
 #endif
   else if (strcmp(method, "ClearCache") == 0)
     clear_cache = 1;
   else
     return (DBUS_HANDLER_RESULT_NOT_YET_HANDLED);
-   
-  if (new_servers)
-    {
-      my_syslog(LOG_INFO, _("setting upstream servers from DBus"));
-      check_servers();
-      if (option_bool(OPT_RELOAD))
-	clear_cache = 1;
-    }
+
+  if (new_servers) {
+    my_syslog(LOG_INFO, _("setting upstream servers from DBus"));
+    check_servers();
+    if (option_bool(OPT_RELOAD))
+      clear_cache = 1;
+  }
 
   if (clear_cache)
     clear_cache_and_reload(dnsmasq_time());
-  
-  method = user_data; /* no warning */
+
+  method = user_data;           /* no warning */
 
   /* If no reply or no error, return nothing */
   if (!reply)
     reply = dbus_message_new_method_return(message);
 
-  if (reply)
-    {
-      dbus_connection_send (connection, reply, NULL);
-      dbus_message_unref (reply);
-    }
+  if (reply) {
+    dbus_connection_send(connection, reply, NULL);
+    dbus_message_unref(reply);
+  }
 
   return (DBUS_HANDLER_RESULT_HANDLED);
 }
- 
+
 
 /* returns NULL or error message, may fail silently if dbus daemon not yet up. */
 char *dbus_init(void)
 {
   DBusConnection *connection = NULL;
-  DBusObjectPathVTable dnsmasq_vtable = {NULL, &message_handler, NULL, NULL, NULL, NULL };
+  DBusObjectPathVTable dnsmasq_vtable =
+      { NULL, &message_handler, NULL, NULL, NULL, NULL };
   DBusError dbus_error;
   DBusMessage *message;
 
-  dbus_error_init (&dbus_error);
-  if (!(connection = dbus_bus_get (DBUS_BUS_SYSTEM, &dbus_error)))
+  dbus_error_init(&dbus_error);
+  if (!(connection = dbus_bus_get(DBUS_BUS_SYSTEM, &dbus_error)))
     return NULL;
-    
+
   dbus_connection_set_exit_on_disconnect(connection, FALSE);
-  dbus_connection_set_watch_functions(connection, add_watch, remove_watch, 
-				      NULL, NULL, NULL);
-  dbus_error_init (&dbus_error);
-  dbus_bus_request_name (connection, daemon->dbus_name, 0, &dbus_error);
-  if (dbus_error_is_set (&dbus_error))
-    return (char *)dbus_error.message;
-  
-  if (!dbus_connection_register_object_path(connection,  DNSMASQ_PATH, 
-					    &dnsmasq_vtable, NULL))
+  dbus_connection_set_watch_functions(connection, add_watch, remove_watch,
+                                      NULL, NULL, NULL);
+  dbus_error_init(&dbus_error);
+  dbus_bus_request_name(connection, daemon->dbus_name, 0, &dbus_error);
+  if (dbus_error_is_set(&dbus_error))
+    return (char *) dbus_error.message;
+
+  if (!dbus_connection_register_object_path(connection, DNSMASQ_PATH,
+                                            &dnsmasq_vtable, NULL))
     return _("could not register a DBus message handler");
-  
-  daemon->dbus = connection; 
-  
-  if ((message = dbus_message_new_signal(DNSMASQ_PATH, daemon->dbus_name, "Up")))
-    {
-      dbus_connection_send(connection, message, NULL);
-      dbus_message_unref(message);
-    }
+
+  daemon->dbus = connection;
+
+  if ((message =
+       dbus_message_new_signal(DNSMASQ_PATH, daemon->dbus_name, "Up"))) {
+    dbus_connection_send(connection, message, NULL);
+    dbus_message_unref(message);
+  }
 
   return NULL;
 }
- 
+
 
 void set_dbus_listeners(void)
 {
   struct watch *w;
-  
+
   for (w = daemon->watches; w; w = w->next)
-    if (dbus_watch_get_enabled(w->watch))
-      {
-	unsigned int flags = dbus_watch_get_flags(w->watch);
-	int fd = dbus_watch_get_unix_fd(w->watch);
-	
-	if (flags & DBUS_WATCH_READABLE)
-	  poll_listen(fd, POLLIN);
-	
-	if (flags & DBUS_WATCH_WRITABLE)
-	  poll_listen(fd, POLLOUT);
-	
-	poll_listen(fd, POLLERR);
-      }
+    if (dbus_watch_get_enabled(w->watch)) {
+      unsigned int flags = dbus_watch_get_flags(w->watch);
+      int fd = dbus_watch_get_unix_fd(w->watch);
+
+      if (flags & DBUS_WATCH_READABLE)
+        poll_listen(fd, POLLIN);
+
+      if (flags & DBUS_WATCH_WRITABLE)
+        poll_listen(fd, POLLOUT);
+
+      poll_listen(fd, POLLERR);
+    }
 }
 
 void check_dbus_listeners()
 {
-  DBusConnection *connection = (DBusConnection *)daemon->dbus;
+  DBusConnection *connection = (DBusConnection *) daemon->dbus;
   struct watch *w;
 
   for (w = daemon->watches; w; w = w->next)
-    if (dbus_watch_get_enabled(w->watch))
-      {
-	unsigned int flags = 0;
-	int fd = dbus_watch_get_unix_fd(w->watch);
-	
-	if (poll_check(fd, POLLIN))
-	  flags |= DBUS_WATCH_READABLE;
-	
-	if (poll_check(fd, POLLOUT))
-	  flags |= DBUS_WATCH_WRITABLE;
-	
-	if (poll_check(fd, POLLERR))
-	  flags |= DBUS_WATCH_ERROR;
+    if (dbus_watch_get_enabled(w->watch)) {
+      unsigned int flags = 0;
+      int fd = dbus_watch_get_unix_fd(w->watch);
 
-	if (flags != 0)
-	  dbus_watch_handle(w->watch, flags);
-      }
+      if (poll_check(fd, POLLIN))
+        flags |= DBUS_WATCH_READABLE;
+
+      if (poll_check(fd, POLLOUT))
+        flags |= DBUS_WATCH_WRITABLE;
 
-  if (connection)
-    {
-      dbus_connection_ref (connection);
-      while (dbus_connection_dispatch (connection) == DBUS_DISPATCH_DATA_REMAINS);
-      dbus_connection_unref (connection);
+      if (poll_check(fd, POLLERR))
+        flags |= DBUS_WATCH_ERROR;
+
+      if (flags != 0)
+        dbus_watch_handle(w->watch, flags);
     }
+
+  if (connection) {
+    dbus_connection_ref(connection);
+    while (dbus_connection_dispatch(connection) == DBUS_DISPATCH_DATA_REMAINS);
+    dbus_connection_unref(connection);
+  }
 }
 
 #ifdef HAVE_DHCP
 void emit_dbus_signal(int action, struct dhcp_lease *lease, char *hostname)
 {
-  DBusConnection *connection = (DBusConnection *)daemon->dbus;
-  DBusMessage* message = NULL;
+  DBusConnection *connection = (DBusConnection *) daemon->dbus;
+  DBusMessage *message = NULL;
   DBusMessageIter args;
   char *action_str, *mac = daemon->namebuff;
   unsigned char *p;
@@ -812,24 +764,22 @@
 
   if (!connection)
     return;
-  
+
   if (!hostname)
     hostname = "";
-  
+
 #ifdef HAVE_DHCP6
-   if (lease->flags & (LEASE_TA | LEASE_NA))
-     {
-       print_mac(mac, lease->clid, lease->clid_len);
-       inet_ntop(AF_INET6, &lease->addr6, daemon->addrbuff, ADDRSTRLEN);
-     }
-   else
-#endif
-     {
-       p = extended_hwaddr(lease->hwaddr_type, lease->hwaddr_len,
-			   lease->hwaddr, lease->clid_len, lease->clid, &i);
-       print_mac(mac, p, i);
-       inet_ntop(AF_INET, &lease->addr, daemon->addrbuff, ADDRSTRLEN);
-     }
+  if (lease->flags & (LEASE_TA | LEASE_NA)) {
+    print_mac(mac, lease->clid, lease->clid_len);
+    inet_ntop(AF_INET6, &lease->addr6, daemon->addrbuff, ADDRSTRLEN);
+  } else
+#endif
+  {
+    p = extended_hwaddr(lease->hwaddr_type, lease->hwaddr_len,
+                        lease->hwaddr, lease->clid_len, lease->clid, &i);
+    print_mac(mac, p, i);
+    inet_ntop(AF_INET, &lease->addr, daemon->addrbuff, ADDRSTRLEN);
+  }
 
   if (action == ACTION_DEL)
     action_str = "DhcpLeaseDeleted";
@@ -840,16 +790,18 @@
   else
     return;
 
-  if (!(message = dbus_message_new_signal(DNSMASQ_PATH, daemon->dbus_name, action_str)))
+  if (!
+      (message =
+       dbus_message_new_signal(DNSMASQ_PATH, daemon->dbus_name, action_str)))
     return;
-  
+
   dbus_message_iter_init_append(message, &args);
-  
-  if (dbus_message_iter_append_basic(&args, DBUS_TYPE_STRING, &daemon->addrbuff) &&
-      dbus_message_iter_append_basic(&args, DBUS_TYPE_STRING, &mac) &&
-      dbus_message_iter_append_basic(&args, DBUS_TYPE_STRING, &hostname))
+
+  if (dbus_message_iter_append_basic(&args, DBUS_TYPE_STRING, &daemon->addrbuff)
+      && dbus_message_iter_append_basic(&args, DBUS_TYPE_STRING, &mac)
+      && dbus_message_iter_append_basic(&args, DBUS_TYPE_STRING, &hostname))
     dbus_connection_send(connection, message, NULL);
-  
+
   dbus_message_unref(message);
 }
 #endif
Index: dnsmasq-2.78/src/dhcp-common.c
===================================================================
--- dnsmasq-2.78.orig/src/dhcp-common.c	2017-10-02 21:13:51.000000000 +0800
+++ dnsmasq-2.78/src/dhcp-common.c	2018-10-29 16:14:19.373440023 +0800
@@ -23,9 +23,9 @@
   /* These each hold a DHCP option max size 255
      and get a terminating zero added */
   daemon->dhcp_buff = safe_malloc(DHCP_BUFF_SZ);
-  daemon->dhcp_buff2 = safe_malloc(DHCP_BUFF_SZ); 
+  daemon->dhcp_buff2 = safe_malloc(DHCP_BUFF_SZ);
   daemon->dhcp_buff3 = safe_malloc(DHCP_BUFF_SZ);
-  
+
   /* dhcp_packet is used by v4 and v6, outpacket only by v6 
      sizeof(struct dhcp_packet) is as good an initial size as any,
      even for v6 */
@@ -37,36 +37,33 @@
 }
 
 ssize_t recv_dhcp_packet(int fd, struct msghdr *msg)
-{  
+{
   ssize_t sz;
- 
-  while (1)
-    {
-      msg->msg_flags = 0;
-      while ((sz = recvmsg(fd, msg, MSG_PEEK | MSG_TRUNC)) == -1 && errno == EINTR);
-      
-      if (sz == -1)
-	return -1;
-      
-      if (!(msg->msg_flags & MSG_TRUNC))
-	break;
-
-      /* Very new Linux kernels return the actual size needed, 
-	 older ones always return truncated size */
-      if ((size_t)sz == msg->msg_iov->iov_len)
-	{
-	  if (!expand_buf(msg->msg_iov, sz + 100))
-	    return -1;
-	}
-      else
-	{
-	  expand_buf(msg->msg_iov, sz);
-	  break;
-	}
+
+  while (1) {
+    msg->msg_flags = 0;
+    while ((sz = recvmsg(fd, msg, MSG_PEEK | MSG_TRUNC)) == -1
+           && errno == EINTR);
+
+    if (sz == -1)
+      return -1;
+
+    if (!(msg->msg_flags & MSG_TRUNC))
+      break;
+
+    /* Very new Linux kernels return the actual size needed,
+       older ones always return truncated size */
+    if ((size_t) sz == msg->msg_iov->iov_len) {
+      if (!expand_buf(msg->msg_iov, sz + 100))
+        return -1;
+    } else {
+      expand_buf(msg->msg_iov, sz);
+      break;
     }
-  
+  }
+
   while ((sz = recvmsg(fd, msg, 0)) == -1 && errno == EINTR);
-  
+
   return (msg->msg_flags & MSG_TRUNC) ? -1 : sz;
 }
 
@@ -77,109 +74,109 @@
 
   for (exprs = daemon->tag_if; exprs; exprs = exprs->next)
     if (match_netid(exprs->tag, tags, 1))
-      for (list = exprs->set; list; list = list->next)
-	{
-	  list->list->next = tags;
-	  tags = list->list;
-	}
+      for (list = exprs->set; list; list = list->next) {
+        list->list->next = tags;
+        tags = list->list;
+      }
 
   return tags;
 }
 
 
-struct dhcp_netid *option_filter(struct dhcp_netid *tags, struct dhcp_netid *context_tags, struct dhcp_opt *opts)
+struct dhcp_netid *option_filter(struct dhcp_netid *tags,
+                                 struct dhcp_netid *context_tags,
+                                 struct dhcp_opt *opts)
 {
   struct dhcp_netid *tagif = run_tag_if(tags);
   struct dhcp_opt *opt;
-  struct dhcp_opt *tmp;  
+  struct dhcp_opt *tmp;
 
   /* flag options which are valid with the current tag set (sans context tags) */
-  for (opt = opts; opt; opt = opt->next)
-    {
-      opt->flags &= ~DHOPT_TAGOK;
-      if (!(opt->flags & (DHOPT_ENCAPSULATE | DHOPT_VENDOR | DHOPT_RFC3925)) &&
-	  match_netid(opt->netid, tagif, 0))
-	opt->flags |= DHOPT_TAGOK;
-    }
+  for (opt = opts; opt; opt = opt->next) {
+    opt->flags &= ~DHOPT_TAGOK;
+    if (!(opt->flags & (DHOPT_ENCAPSULATE | DHOPT_VENDOR | DHOPT_RFC3925)) &&
+        match_netid(opt->netid, tagif, 0))
+      opt->flags |= DHOPT_TAGOK;
+  }
 
   /* now flag options which are valid, including the context tags,
      otherwise valid options are inhibited if we found a higher priority one above */
-  if (context_tags)
-    {
-      struct dhcp_netid *last_tag;
-
-      for (last_tag = context_tags; last_tag->next; last_tag = last_tag->next);
-      last_tag->next = tags;
-      tagif = run_tag_if(context_tags);
-      
-      /* reset stuff with tag:!<tag> which now matches. */
-      for (opt = opts; opt; opt = opt->next)
-	if (!(opt->flags & (DHOPT_ENCAPSULATE | DHOPT_VENDOR | DHOPT_RFC3925)) &&
-	    (opt->flags & DHOPT_TAGOK) &&
-	    !match_netid(opt->netid, tagif, 0))
-	  opt->flags &= ~DHOPT_TAGOK;
-
-      for (opt = opts; opt; opt = opt->next)
-	if (!(opt->flags & (DHOPT_ENCAPSULATE | DHOPT_VENDOR | DHOPT_RFC3925 | DHOPT_TAGOK)) &&
-	    match_netid(opt->netid, tagif, 0))
-	  {
-	    struct dhcp_opt *tmp;  
-	    for (tmp = opts; tmp; tmp = tmp->next) 
-	      if (tmp->opt == opt->opt && opt->netid && (tmp->flags & DHOPT_TAGOK))
-		break;
-	    if (!tmp)
-	      opt->flags |= DHOPT_TAGOK;
-	  }      
-    }
-  
+  if (context_tags) {
+    struct dhcp_netid *last_tag;
+
+    for (last_tag = context_tags; last_tag->next; last_tag = last_tag->next);
+    last_tag->next = tags;
+    tagif = run_tag_if(context_tags);
+
+    /* reset stuff with tag:!<tag> which now matches. */
+    for (opt = opts; opt; opt = opt->next)
+      if (!(opt->flags & (DHOPT_ENCAPSULATE | DHOPT_VENDOR | DHOPT_RFC3925)) &&
+          (opt->flags & DHOPT_TAGOK) && !match_netid(opt->netid, tagif, 0))
+        opt->flags &= ~DHOPT_TAGOK;
+
+    for (opt = opts; opt; opt = opt->next)
+      if (!
+          (opt->
+           flags & (DHOPT_ENCAPSULATE | DHOPT_VENDOR | DHOPT_RFC3925 |
+                    DHOPT_TAGOK)) && match_netid(opt->netid, tagif, 0)) {
+        struct dhcp_opt *tmp;
+        for (tmp = opts; tmp; tmp = tmp->next)
+          if (tmp->opt == opt->opt && opt->netid && (tmp->flags & DHOPT_TAGOK))
+            break;
+        if (!tmp)
+          opt->flags |= DHOPT_TAGOK;
+      }
+  }
+
   /* now flag untagged options which are not overridden by tagged ones */
   for (opt = opts; opt; opt = opt->next)
-    if (!(opt->flags & (DHOPT_ENCAPSULATE | DHOPT_VENDOR | DHOPT_RFC3925 | DHOPT_TAGOK)) && !opt->netid)
-      {
-	for (tmp = opts; tmp; tmp = tmp->next) 
-	  if (tmp->opt == opt->opt && (tmp->flags & DHOPT_TAGOK))
-	    break;
-	if (!tmp)
-	  opt->flags |= DHOPT_TAGOK;
-	else if (!tmp->netid)
-	  my_syslog(MS_DHCP | LOG_WARNING, _("Ignoring duplicate dhcp-option %d"), tmp->opt); 
-      }
+    if (!
+        (opt->
+         flags & (DHOPT_ENCAPSULATE | DHOPT_VENDOR | DHOPT_RFC3925 |
+                  DHOPT_TAGOK)) && !opt->netid) {
+      for (tmp = opts; tmp; tmp = tmp->next)
+        if (tmp->opt == opt->opt && (tmp->flags & DHOPT_TAGOK))
+          break;
+      if (!tmp)
+        opt->flags |= DHOPT_TAGOK;
+      else if (!tmp->netid)
+        my_syslog(MS_DHCP | LOG_WARNING, _("Ignoring duplicate dhcp-option %d"),
+                  tmp->opt);
+    }
 
   /* Finally, eliminate duplicate options later in the chain, and therefore earlier in the config file. */
   for (opt = opts; opt; opt = opt->next)
     if (opt->flags & DHOPT_TAGOK)
-      for (tmp = opt->next; tmp; tmp = tmp->next) 
-	if (tmp->opt == opt->opt)
-	  tmp->flags &= ~DHOPT_TAGOK;
-  
+      for (tmp = opt->next; tmp; tmp = tmp->next)
+        if (tmp->opt == opt->opt)
+          tmp->flags &= ~DHOPT_TAGOK;
+
   return tagif;
 }
-	
+
 /* Is every member of check matched by a member of pool? 
    If tagnotneeded, untagged is OK */
-int match_netid(struct dhcp_netid *check, struct dhcp_netid *pool, int tagnotneeded)
+int match_netid(struct dhcp_netid *check, struct dhcp_netid *pool,
+                int tagnotneeded)
 {
   struct dhcp_netid *tmp1;
-  
+
   if (!check && !tagnotneeded)
     return 0;
 
-  for (; check; check = check->next)
-    {
-      /* '#' for not is for backwards compat. */
-      if (check->net[0] != '!' && check->net[0] != '#')
-	{
-	  for (tmp1 = pool; tmp1; tmp1 = tmp1->next)
-	    if (strcmp(check->net, tmp1->net) == 0)
-	      break;
-	  if (!tmp1)
-	    return 0;
-	}
-      else
-	for (tmp1 = pool; tmp1; tmp1 = tmp1->next)
-	  if (strcmp((check->net)+1, tmp1->net) == 0)
-	    return 0;
-    }
+  for (; check; check = check->next) {
+    /* '#' for not is for backwards compat. */
+    if (check->net[0] != '!' && check->net[0] != '#') {
+      for (tmp1 = pool; tmp1; tmp1 = tmp1->next)
+        if (strcmp(check->net, tmp1->net) == 0)
+          break;
+      if (!tmp1)
+        return 0;
+    } else
+      for (tmp1 = pool; tmp1; tmp1 = tmp1->next)
+        if (strcmp((check->net) + 1, tmp1->net) == 0)
+          return 0;
+  }
   return 1;
 }
 
@@ -187,94 +184,90 @@
 char *strip_hostname(char *hostname)
 {
   char *dot = strchr(hostname, '.');
- 
+
   if (!dot)
     return NULL;
-  
-  *dot = 0; /* truncate */
-  if (strlen(dot+1) != 0)
-    return dot+1;
-  
+
+  *dot = 0;                     /* truncate */
+  if (strlen(dot + 1) != 0)
+    return dot + 1;
+
   return NULL;
 }
 
 void log_tags(struct dhcp_netid *netid, u32 xid)
 {
-  if (netid && option_bool(OPT_LOG_OPTS))
-    {
-      char *s = daemon->namebuff;
-      for (*s = 0; netid; netid = netid->next)
-	{
-	  /* kill dupes. */
-	  struct dhcp_netid *n;
-	  
-	  for (n = netid->next; n; n = n->next)
-	    if (strcmp(netid->net, n->net) == 0)
-	      break;
-	  
-	  if (!n)
-	    {
-	      strncat (s, netid->net, (MAXDNAME-1) - strlen(s));
-	      if (netid->next)
-		strncat (s, ", ", (MAXDNAME-1) - strlen(s));
-	    }
-	}
-      my_syslog(MS_DHCP | LOG_INFO, _("%u tags: %s"), xid, s);
-    } 
-}   
-  
+  if (netid && option_bool(OPT_LOG_OPTS)) {
+    char *s = daemon->namebuff;
+    for (*s = 0; netid; netid = netid->next) {
+      /* kill dupes. */
+      struct dhcp_netid *n;
+
+      for (n = netid->next; n; n = n->next)
+        if (strcmp(netid->net, n->net) == 0)
+          break;
+
+      if (!n) {
+        strncat(s, netid->net, (MAXDNAME - 1) - strlen(s));
+        if (netid->next)
+          strncat(s, ", ", (MAXDNAME - 1) - strlen(s));
+      }
+    }
+    my_syslog(MS_DHCP | LOG_INFO, _("%u tags: %s"), xid, s);
+  }
+}
+
 int match_bytes(struct dhcp_opt *o, unsigned char *p, int len)
 {
   int i;
-  
+
   if (o->len > len)
     return 0;
-  
+
   if (o->len == 0)
     return 1;
-     
-  if (o->flags & DHOPT_HEX)
-    { 
-      if (memcmp_masked(o->val, p, o->len, o->u.wildcard_mask))
-	return 1;
+
+  if (o->flags & DHOPT_HEX) {
+    if (memcmp_masked(o->val, p, o->len, o->u.wildcard_mask))
+      return 1;
+  } else
+    for (i = 0; i <= (len - o->len);) {
+      if (memcmp(o->val, p + i, o->len) == 0)
+        return 1;
+
+      if (o->flags & DHOPT_STRING)
+        i++;
+      else
+        i += o->len;
     }
-  else 
-    for (i = 0; i <= (len - o->len); ) 
-      {
-	if (memcmp(o->val, p + i, o->len) == 0)
-	  return 1;
-	    
-	if (o->flags & DHOPT_STRING)
-	  i++;
-	else
-	  i += o->len;
-      }
-  
+
   return 0;
 }
 
-int config_has_mac(struct dhcp_config *config, unsigned char *hwaddr, int len, int type)
+int config_has_mac(struct dhcp_config *config, unsigned char *hwaddr, int len,
+                   int type)
 {
   struct hwaddr_config *conf_addr;
-  
+
   for (conf_addr = config->hwaddr; conf_addr; conf_addr = conf_addr->next)
     if (conf_addr->wildcard_mask == 0 &&
-	conf_addr->hwaddr_len == len &&
-	(conf_addr->hwaddr_type == type || conf_addr->hwaddr_type == 0) &&
-	memcmp(conf_addr->hwaddr, hwaddr, len) == 0)
+        conf_addr->hwaddr_len == len &&
+        (conf_addr->hwaddr_type == type || conf_addr->hwaddr_type == 0) &&
+        memcmp(conf_addr->hwaddr, hwaddr, len) == 0)
       return 1;
-  
+
   return 0;
 }
 
-static int is_config_in_context(struct dhcp_context *context, struct dhcp_config *config)
+static int is_config_in_context(struct dhcp_context *context,
+                                struct dhcp_config *config)
 {
-  if (!context) /* called via find_config() from lease_update_from_configs() */
-    return 1; 
+  if (!context)                 /* called via find_config() from lease_update_from_configs() */
+    return 1;
 
   if (!(config->flags & (CONFIG_ADDR | CONFIG_ADDR6)))
     return 1;
-  
+
 #ifdef HAVE_DHCP6
   if ((context->flags & CONTEXT_V6) && (config->flags & CONFIG_WILDCARD))
     return 1;
@@ -282,78 +275,80 @@
 
   for (; context; context = context->current)
 #ifdef HAVE_DHCP6
-    if (context->flags & CONTEXT_V6) 
-      {
-	if ((config->flags & CONFIG_ADDR6) && is_same_net6(&config->addr6, &context->start6, context->prefix))
-	  return 1;
-      }
-    else 
+    if (context->flags & CONTEXT_V6) {
+      if ((config->flags & CONFIG_ADDR6)
+          && is_same_net6(&config->addr6, &context->start6, context->prefix))
+        return 1;
+    } else
 #endif
-      if ((config->flags & CONFIG_ADDR) && is_same_net(config->addr, context->start, context->netmask))
-	return 1;
+    if ((config->flags & CONFIG_ADDR)
+          && is_same_net(config->addr, context->start, context->netmask))
+      return 1;
 
   return 0;
 }
 
 struct dhcp_config *find_config(struct dhcp_config *configs,
-				struct dhcp_context *context,
-				unsigned char *clid, int clid_len,
-				unsigned char *hwaddr, int hw_len, 
-				int hw_type, char *hostname)
+                                struct dhcp_context *context,
+                                unsigned char *clid, int clid_len,
+                                unsigned char *hwaddr, int hw_len,
+                                int hw_type, char *hostname)
 {
   int count, new;
-  struct dhcp_config *config, *candidate; 
+  struct dhcp_config *config, *candidate;
   struct hwaddr_config *conf_addr;
 
   if (clid)
     for (config = configs; config; config = config->next)
-      if (config->flags & CONFIG_CLID)
-	{
-	  if (config->clid_len == clid_len && 
-	      memcmp(config->clid, clid, clid_len) == 0 &&
-	      is_config_in_context(context, config))
-	    return config;
-	  
-	  /* dhcpcd prefixes ASCII client IDs by zero which is wrong, but we try and
-	     cope with that here. This is IPv4 only. context==NULL implies IPv4, 
-	     see lease_update_from_configs() */
-	  if ((!context || !(context->flags & CONTEXT_V6)) && *clid == 0 && config->clid_len == clid_len-1  &&
-	      memcmp(config->clid, clid+1, clid_len-1) == 0 &&
-	      is_config_in_context(context, config))
-	    return config;
-	}
-  
+      if (config->flags & CONFIG_CLID) {
+        if (config->clid_len == clid_len &&
+            memcmp(config->clid, clid, clid_len) == 0 &&
+            is_config_in_context(context, config))
+          return config;
+
+        /* dhcpcd prefixes ASCII client IDs by zero which is wrong, but we try and
+           cope with that here. This is IPv4 only. context==NULL implies IPv4,
+           see lease_update_from_configs() */
+        if ((!context || !(context->flags & CONTEXT_V6)) && *clid == 0
+            && config->clid_len == clid_len - 1
+            && memcmp(config->clid, clid + 1, clid_len - 1) == 0
+            && is_config_in_context(context, config))
+          return config;
+      }
+
 
   if (hwaddr)
     for (config = configs; config; config = config->next)
       if (config_has_mac(config, hwaddr, hw_len, hw_type) &&
-	  is_config_in_context(context, config))
-	return config;
-  
+          is_config_in_context(context, config))
+        return config;
+
   if (hostname && context)
     for (config = configs; config; config = config->next)
-      if ((config->flags & CONFIG_NAME) && 
-	  hostname_isequal(config->hostname, hostname) &&
-	  is_config_in_context(context, config))
-	return config;
+      if ((config->flags & CONFIG_NAME) &&
+          hostname_isequal(config->hostname, hostname) &&
+          is_config_in_context(context, config))
+        return config;
+
 
-  
   if (!hwaddr)
     return NULL;
 
   /* use match with fewest wildcard octets */
-  for (candidate = NULL, count = 0, config = configs; config; config = config->next)
+  for (candidate = NULL, count = 0, config = configs; config;
+       config = config->next)
     if (is_config_in_context(context, config))
       for (conf_addr = config->hwaddr; conf_addr; conf_addr = conf_addr->next)
-	if (conf_addr->wildcard_mask != 0 &&
-	    conf_addr->hwaddr_len == hw_len &&	
-	    (conf_addr->hwaddr_type == hw_type || conf_addr->hwaddr_type == 0) &&
-	    (new = memcmp_masked(conf_addr->hwaddr, hwaddr, hw_len, conf_addr->wildcard_mask)) > count)
-	  {
-	      count = new;
-	      candidate = config;
-	  }
-  
+        if (conf_addr->wildcard_mask != 0 &&
+            conf_addr->hwaddr_len == hw_len &&
+            (conf_addr->hwaddr_type == hw_type || conf_addr->hwaddr_type == 0)
+            && (new =
+                memcmp_masked(conf_addr->hwaddr, hwaddr, hw_len,
+                              conf_addr->wildcard_mask)) > count) {
+          count = new;
+          candidate = config;
+        }
+
   return candidate;
 }
 
@@ -365,7 +360,7 @@
      We take care to maintain the invariant that any IP address can appear
      in at most one dhcp-host. Since /etc/hosts can be re-read by SIGHUP, 
      restore the status-quo ante first. */
-  
+
   struct dhcp_config *config, *conf_tmp;
   struct crec *crec;
   int prot = AF_INET;
@@ -374,77 +369,75 @@
     if (config->flags & CONFIG_ADDR_HOSTS)
       config->flags &= ~(CONFIG_ADDR | CONFIG_ADDR6 | CONFIG_ADDR_HOSTS);
 
-#ifdef HAVE_DHCP6 
- again:  
+#ifdef HAVE_DHCP6
+again:
 #endif
 
   if (daemon->port != 0)
-    for (config = configs; config; config = config->next)
-      {
-	int conflags = CONFIG_ADDR;
-	int cacheflags = F_IPV4;
-
-#ifdef HAVE_DHCP6
-	if (prot == AF_INET6)
-	  {
-	    conflags = CONFIG_ADDR6;
-	    cacheflags = F_IPV6;
-	  }
-#endif
-	if (!(config->flags & conflags) &&
-	    (config->flags & CONFIG_NAME) && 
-	    (crec = cache_find_by_name(NULL, config->hostname, 0, cacheflags)) &&
-	    (crec->flags & F_HOSTS))
-	  {
-	    if (cache_find_by_name(crec, config->hostname, 0, cacheflags))
-	      {
-		/* use primary (first) address */
-		while (crec && !(crec->flags & F_REVERSE))
-		  crec = cache_find_by_name(crec, config->hostname, 0, cacheflags);
-		if (!crec)
-		  continue; /* should be never */
-		inet_ntop(prot, &crec->addr.addr, daemon->addrbuff, ADDRSTRLEN);
-		my_syslog(MS_DHCP | LOG_WARNING, _("%s has more than one address in hostsfile, using %s for DHCP"), 
-			  config->hostname, daemon->addrbuff);
-	      }
-	    
-	    if (prot == AF_INET && 
-		(!(conf_tmp = config_find_by_address(configs, crec->addr.addr.addr.addr4)) || conf_tmp == config))
-	      {
-		config->addr = crec->addr.addr.addr.addr4;
-		config->flags |= CONFIG_ADDR | CONFIG_ADDR_HOSTS;
-		continue;
-	      }
-
-#ifdef HAVE_DHCP6
-	    if (prot == AF_INET6 && 
-		(!(conf_tmp = config_find_by_address6(configs, &crec->addr.addr.addr.addr6, 128, 0)) || conf_tmp == config))
-	      {
-		memcpy(&config->addr6, &crec->addr.addr.addr.addr6, IN6ADDRSZ);
-		config->flags |= CONFIG_ADDR6 | CONFIG_ADDR_HOSTS;
-		continue;
-	      }
-#endif
-
-	    inet_ntop(prot, &crec->addr.addr, daemon->addrbuff, ADDRSTRLEN);
-	    my_syslog(MS_DHCP | LOG_WARNING, _("duplicate IP address %s (%s) in dhcp-config directive"), 
-		      daemon->addrbuff, config->hostname);
-	    
-	    
-	  }
-      }
+    for (config = configs; config; config = config->next) {
+      int conflags = CONFIG_ADDR;
+      int cacheflags = F_IPV4;
 
 #ifdef HAVE_DHCP6
-  if (prot == AF_INET)
-    {
-      prot = AF_INET6;
-      goto again;
+      if (prot == AF_INET6) {
+        conflags = CONFIG_ADDR6;
+        cacheflags = F_IPV6;
+      }
+#endif
+      if (!(config->flags & conflags) &&
+          (config->flags & CONFIG_NAME) &&
+          (crec = cache_find_by_name(NULL, config->hostname, 0, cacheflags)) &&
+          (crec->flags & F_HOSTS)) {
+        if (cache_find_by_name(crec, config->hostname, 0, cacheflags)) {
+          /* use primary (first) address */
+          while (crec && !(crec->flags & F_REVERSE))
+            crec = cache_find_by_name(crec, config->hostname, 0, cacheflags);
+          if (!crec)
+            continue;           /* should be never */
+          inet_ntop(prot, &crec->addr.addr, daemon->addrbuff, ADDRSTRLEN);
+          my_syslog(MS_DHCP | LOG_WARNING,
+                    _
+                    ("%s has more than one address in hostsfile, using %s for DHCP"),
+                    config->hostname, daemon->addrbuff);
+        }
+
+        if (prot == AF_INET &&
+            (!(conf_tmp =
+               config_find_by_address(configs, crec->addr.addr.addr.addr4))
+             || conf_tmp == config)) {
+          config->addr = crec->addr.addr.addr.addr4;
+          config->flags |= CONFIG_ADDR | CONFIG_ADDR_HOSTS;
+          continue;
+        }
+#ifdef HAVE_DHCP6
+        if (prot == AF_INET6 &&
+            (!(conf_tmp =
+               config_find_by_address6(configs, &crec->addr.addr.addr.addr6,
+                                       128, 0)) || conf_tmp == config)) {
+          memcpy(&config->addr6, &crec->addr.addr.addr.addr6, IN6ADDRSZ);
+          config->flags |= CONFIG_ADDR6 | CONFIG_ADDR_HOSTS;
+          continue;
+        }
+#endif
+
+        inet_ntop(prot, &crec->addr.addr, daemon->addrbuff, ADDRSTRLEN);
+        my_syslog(MS_DHCP | LOG_WARNING,
+                  _("duplicate IP address %s (%s) in dhcp-config directive"),
+                  daemon->addrbuff, config->hostname);
+
+
+      }
     }
+#ifdef HAVE_DHCP6
+  if (prot == AF_INET) {
+    prot = AF_INET6;
+    goto again;
+  }
 #endif
 
 }
 
-#ifdef HAVE_LINUX_NETWORK 
+#ifdef HAVE_LINUX_NETWORK
 char *whichdevice(void)
 {
   /* If we are doing DHCP on exactly one interface, and running linux, do SO_BINDTODEVICE
@@ -456,41 +449,40 @@
      Note that if wildcards are used in --interface, or --interface is not used at all,
      or a configured interface doesn't yet exist, then more interfaces may arrive later, 
      so we can't safely assert there is only one interface and proceed.
-*/
-  
+   */
+
   struct irec *iface, *found;
   struct iname *if_tmp;
-  
+
   if (!daemon->if_names)
     return NULL;
-  
+
   for (if_tmp = daemon->if_names; if_tmp; if_tmp = if_tmp->next)
     if (if_tmp->name && (!if_tmp->used || strchr(if_tmp->name, '*')))
       return NULL;
 
   for (found = NULL, iface = daemon->interfaces; iface; iface = iface->next)
-    if (iface->dhcp_ok)
-      {
-	if (!found)
-	  found = iface;
-	else if (strcmp(found->name, iface->name) != 0) 
-	  return NULL; /* more than one. */
-      }
+    if (iface->dhcp_ok) {
+      if (!found)
+        found = iface;
+      else if (strcmp(found->name, iface->name) != 0)
+        return NULL;            /* more than one. */
+    }
 
   if (found)
     return found->name;
 
   return NULL;
 }
- 
-void  bindtodevice(char *device, int fd)
+
+void bindtodevice(char *device, int fd)
 {
   struct ifreq ifr;
-  
+
   strcpy(ifr.ifr_name, device);
   /* only allowed by root. */
-  if (setsockopt(fd, SOL_SOCKET, SO_BINDTODEVICE, (void *)&ifr, sizeof(ifr)) == -1 &&
-      errno != EPERM)
+  if (setsockopt(fd, SOL_SOCKET, SO_BINDTODEVICE, (void *) &ifr, sizeof(ifr)) ==
+      -1 && errno != EPERM)
     die(_("failed to set SO_BINDTODEVICE on DHCP socket: %s"), NULL, EC_BADNET);
 }
 #endif
@@ -499,110 +491,112 @@
   char *name;
   u16 val, size;
 } opttab[] = {
-  { "netmask", 1, OT_ADDR_LIST },
-  { "time-offset", 2, 4 },
-  { "router", 3, OT_ADDR_LIST  },
-  { "dns-server", 6, OT_ADDR_LIST },
-  { "log-server", 7, OT_ADDR_LIST },
-  { "lpr-server", 9, OT_ADDR_LIST },
-  { "hostname", 12, OT_INTERNAL | OT_NAME },
-  { "boot-file-size", 13, 2 | OT_DEC },
-  { "domain-name", 15, OT_NAME },
-  { "swap-server", 16, OT_ADDR_LIST },
-  { "root-path", 17, OT_NAME },
-  { "extension-path", 18, OT_NAME },
-  { "ip-forward-enable", 19, 1 },
-  { "non-local-source-routing", 20, 1 },
-  { "policy-filter", 21, OT_ADDR_LIST },
-  { "max-datagram-reassembly", 22, 2 | OT_DEC },
-  { "default-ttl", 23, 1 | OT_DEC },
-  { "mtu", 26, 2 | OT_DEC },
-  { "all-subnets-local", 27, 1 },
-  { "broadcast", 28, OT_INTERNAL | OT_ADDR_LIST },
-  { "router-discovery", 31, 1 },
-  { "router-solicitation", 32, OT_ADDR_LIST },
-  { "static-route", 33, OT_ADDR_LIST },
-  { "trailer-encapsulation", 34, 1 },
-  { "arp-timeout", 35, 4 | OT_DEC },
-  { "ethernet-encap", 36, 1 },
-  { "tcp-ttl", 37, 1 },
-  { "tcp-keepalive", 38, 4 | OT_DEC },
-  { "nis-domain", 40, OT_NAME },
-  { "nis-server", 41, OT_ADDR_LIST },
-  { "ntp-server", 42, OT_ADDR_LIST },
-  { "vendor-encap", 43, OT_INTERNAL },
-  { "netbios-ns", 44, OT_ADDR_LIST },
-  { "netbios-dd", 45, OT_ADDR_LIST },
-  { "netbios-nodetype", 46, 1 },
-  { "netbios-scope", 47, 0 },
-  { "x-windows-fs", 48, OT_ADDR_LIST },
-  { "x-windows-dm", 49, OT_ADDR_LIST },
-  { "requested-address", 50, OT_INTERNAL | OT_ADDR_LIST },
-  { "lease-time", 51, OT_INTERNAL | OT_TIME },
-  { "option-overload", 52, OT_INTERNAL },
-  { "message-type", 53, OT_INTERNAL | OT_DEC },
-  { "server-identifier", 54, OT_INTERNAL | OT_ADDR_LIST },
-  { "parameter-request", 55, OT_INTERNAL },
-  { "message", 56, OT_INTERNAL },
-  { "max-message-size", 57, OT_INTERNAL },
-  { "T1", 58, OT_TIME},
-  { "T2", 59, OT_TIME},
-  { "vendor-class", 60, 0 },
-  { "client-id", 61, OT_INTERNAL },
-  { "nis+-domain", 64, OT_NAME },
-  { "nis+-server", 65, OT_ADDR_LIST },
-  { "tftp-server", 66, OT_NAME },
-  { "bootfile-name", 67, OT_NAME },
-  { "mobile-ip-home", 68, OT_ADDR_LIST }, 
-  { "smtp-server", 69, OT_ADDR_LIST }, 
-  { "pop3-server", 70, OT_ADDR_LIST }, 
-  { "nntp-server", 71, OT_ADDR_LIST }, 
-  { "irc-server", 74, OT_ADDR_LIST }, 
-  { "user-class", 77, 0 },
-  { "FQDN", 81, OT_INTERNAL },
-  { "agent-id", 82, OT_INTERNAL },
-  { "client-arch", 93, 2 | OT_DEC },
-  { "client-interface-id", 94, 0 },
-  { "client-machine-id", 97, 0 },
-  { "subnet-select", 118, OT_INTERNAL },
-  { "domain-search", 119, OT_RFC1035_NAME },
-  { "sip-server", 120, 0 },
-  { "classless-static-route", 121, 0 },
-  { "vendor-id-encap", 125, 0 },
-  { "server-ip-address", 255, OT_ADDR_LIST }, /* special, internal only, sets siaddr */
-  { NULL, 0, 0 }
+  {
+  "netmask", 1, OT_ADDR_LIST}, {
+  "time-offset", 2, 4}, {
+  "router", 3, OT_ADDR_LIST}, {
+  "dns-server", 6, OT_ADDR_LIST}, {
+  "log-server", 7, OT_ADDR_LIST}, {
+  "lpr-server", 9, OT_ADDR_LIST}, {
+  "hostname", 12, OT_INTERNAL | OT_NAME}, {
+  "boot-file-size", 13, 2 | OT_DEC}, {
+  "domain-name", 15, OT_NAME}, {
+  "swap-server", 16, OT_ADDR_LIST}, {
+  "root-path", 17, OT_NAME}, {
+  "extension-path", 18, OT_NAME}, {
+  "ip-forward-enable", 19, 1}, {
+  "non-local-source-routing", 20, 1}, {
+  "policy-filter", 21, OT_ADDR_LIST}, {
+  "max-datagram-reassembly", 22, 2 | OT_DEC}, {
+  "default-ttl", 23, 1 | OT_DEC}, {
+  "mtu", 26, 2 | OT_DEC}, {
+  "all-subnets-local", 27, 1}, {
+  "broadcast", 28, OT_INTERNAL | OT_ADDR_LIST}, {
+  "router-discovery", 31, 1}, {
+  "router-solicitation", 32, OT_ADDR_LIST}, {
+  "static-route", 33, OT_ADDR_LIST}, {
+  "trailer-encapsulation", 34, 1}, {
+  "arp-timeout", 35, 4 | OT_DEC}, {
+  "ethernet-encap", 36, 1}, {
+  "tcp-ttl", 37, 1}, {
+  "tcp-keepalive", 38, 4 | OT_DEC}, {
+  "nis-domain", 40, OT_NAME}, {
+  "nis-server", 41, OT_ADDR_LIST}, {
+  "ntp-server", 42, OT_ADDR_LIST}, {
+  "vendor-encap", 43, OT_INTERNAL}, {
+  "netbios-ns", 44, OT_ADDR_LIST}, {
+  "netbios-dd", 45, OT_ADDR_LIST}, {
+  "netbios-nodetype", 46, 1}, {
+  "netbios-scope", 47, 0}, {
+  "x-windows-fs", 48, OT_ADDR_LIST}, {
+  "x-windows-dm", 49, OT_ADDR_LIST}, {
+  "requested-address", 50, OT_INTERNAL | OT_ADDR_LIST}, {
+  "lease-time", 51, OT_INTERNAL | OT_TIME}, {
+  "option-overload", 52, OT_INTERNAL}, {
+  "message-type", 53, OT_INTERNAL | OT_DEC}, {
+  "server-identifier", 54, OT_INTERNAL | OT_ADDR_LIST}, {
+  "parameter-request", 55, OT_INTERNAL}, {
+  "message", 56, OT_INTERNAL}, {
+  "max-message-size", 57, OT_INTERNAL}, {
+  "T1", 58, OT_TIME}, {
+  "T2", 59, OT_TIME}, {
+  "vendor-class", 60, 0}, {
+  "client-id", 61, OT_INTERNAL}, {
+  "nis+-domain", 64, OT_NAME}, {
+  "nis+-server", 65, OT_ADDR_LIST}, {
+  "tftp-server", 66, OT_NAME}, {
+  "bootfile-name", 67, OT_NAME}, {
+  "mobile-ip-home", 68, OT_ADDR_LIST}, {
+  "smtp-server", 69, OT_ADDR_LIST}, {
+  "pop3-server", 70, OT_ADDR_LIST}, {
+  "nntp-server", 71, OT_ADDR_LIST}, {
+  "irc-server", 74, OT_ADDR_LIST}, {
+  "user-class", 77, 0}, {
+  "FQDN", 81, OT_INTERNAL}, {
+  "agent-id", 82, OT_INTERNAL}, {
+  "client-arch", 93, 2 | OT_DEC}, {
+  "client-interface-id", 94, 0}, {
+  "client-machine-id", 97, 0}, {
+  "subnet-select", 118, OT_INTERNAL}, {
+  "domain-search", 119, OT_RFC1035_NAME}, {
+  "sip-server", 120, 0}, {
+  "classless-static-route", 121, 0}, {
+  "vendor-id-encap", 125, 0}, {
+  "server-ip-address", 255, OT_ADDR_LIST},      /* special, internal only, sets siaddr */
+  {
+  NULL, 0, 0}
 };
 
 #ifdef HAVE_DHCP6
 static const struct opttab_t opttab6[] = {
-  { "client-id", 1, OT_INTERNAL },
-  { "server-id", 2, OT_INTERNAL },
-  { "ia-na", 3, OT_INTERNAL },
-  { "ia-ta", 4, OT_INTERNAL },
-  { "iaaddr", 5, OT_INTERNAL },
-  { "oro", 6, OT_INTERNAL },
-  { "preference", 7, OT_INTERNAL | OT_DEC },
-  { "unicast", 12, OT_INTERNAL },
-  { "status", 13, OT_INTERNAL },
-  { "rapid-commit", 14, OT_INTERNAL },
-  { "user-class", 15, OT_INTERNAL | OT_CSTRING },
-  { "vendor-class", 16, OT_INTERNAL | OT_CSTRING },
-  { "vendor-opts", 17, OT_INTERNAL },
-  { "sip-server-domain", 21,  OT_RFC1035_NAME },
-  { "sip-server", 22, OT_ADDR_LIST },
-  { "dns-server", 23, OT_ADDR_LIST },
-  { "domain-search", 24, OT_RFC1035_NAME },
-  { "nis-server", 27, OT_ADDR_LIST },
-  { "nis+-server", 28, OT_ADDR_LIST },
-  { "nis-domain", 29,  OT_RFC1035_NAME },
-  { "nis+-domain", 30, OT_RFC1035_NAME },
-  { "sntp-server", 31,  OT_ADDR_LIST },
-  { "information-refresh-time", 32, OT_TIME },
-  { "FQDN", 39, OT_INTERNAL | OT_RFC1035_NAME },
-  { "ntp-server", 56,  0 },
-  { "bootfile-url", 59, OT_NAME },
-  { "bootfile-param", 60, OT_CSTRING },
-  { NULL, 0, 0 }
+  {"client-id", 1, OT_INTERNAL},
+  {"server-id", 2, OT_INTERNAL},
+  {"ia-na", 3, OT_INTERNAL},
+  {"ia-ta", 4, OT_INTERNAL},
+  {"iaaddr", 5, OT_INTERNAL},
+  {"oro", 6, OT_INTERNAL},
+  {"preference", 7, OT_INTERNAL | OT_DEC},
+  {"unicast", 12, OT_INTERNAL},
+  {"status", 13, OT_INTERNAL},
+  {"rapid-commit", 14, OT_INTERNAL},
+  {"user-class", 15, OT_INTERNAL | OT_CSTRING},
+  {"vendor-class", 16, OT_INTERNAL | OT_CSTRING},
+  {"vendor-opts", 17, OT_INTERNAL},
+  {"sip-server-domain", 21, OT_RFC1035_NAME},
+  {"sip-server", 22, OT_ADDR_LIST},
+  {"dns-server", 23, OT_ADDR_LIST},
+  {"domain-search", 24, OT_RFC1035_NAME},
+  {"nis-server", 27, OT_ADDR_LIST},
+  {"nis+-server", 28, OT_ADDR_LIST},
+  {"nis-domain", 29, OT_RFC1035_NAME},
+  {"nis+-domain", 30, OT_RFC1035_NAME},
+  {"sntp-server", 31, OT_ADDR_LIST},
+  {"information-refresh-time", 32, OT_TIME},
+  {"FQDN", 39, OT_INTERNAL | OT_RFC1035_NAME},
+  {"ntp-server", 56, 0},
+  {"bootfile-url", 59, OT_NAME},
+  {"bootfile-param", 60, OT_CSTRING},
+  {NULL, 0, 0}
 };
 #endif
 
@@ -611,9 +605,9 @@
 void display_opts(void)
 {
   int i;
-  
+
   printf(_("Known DHCP options:\n"));
-  
+
   for (i = 0; opttab[i].name; i++)
     if (!(opttab[i].size & OT_INTERNAL))
       printf("%3d %s\n", opttab[i].val, opttab[i].name);
@@ -624,7 +618,7 @@
 {
   int i;
   printf(_("Known DHCPv6 options:\n"));
-  
+
   for (i = 0; opttab6[i].name; i++)
     if (!(opttab6[i].size & OT_INTERNAL))
       printf("%3d %s\n", opttab6[i].val, opttab6[i].name);
@@ -636,7 +630,7 @@
   const struct opttab_t *t;
   int i;
 
-  (void)prot;
+  (void) prot;
 
 #ifdef HAVE_DHCP6
   if (prot == AF_INET6)
@@ -648,7 +642,7 @@
   for (i = 0; t[i].name; i++)
     if (strcasecmp(t[i].name, name) == 0)
       return t[i].val;
-  
+
   return -1;
 }
 
@@ -657,7 +651,7 @@
   const struct opttab_t *t;
   int i;
 
-  (void)prot;
+  (void) prot;
 
 #ifdef HAVE_DHCP6
   if (prot == AF_INET6)
@@ -670,10 +664,11 @@
     if (val == t[i].val)
       return t[i].size & ~OT_DEC;
 
-   return 0;
+  return 0;
 }
 
-char *option_string(int prot, unsigned int opt, unsigned char *val, int opt_len, char *buf, int buf_len)
+char *option_string(int prot, unsigned int opt, unsigned char *val, int opt_len,
+                    char *buf, int buf_len)
 {
   int o, i, j, nodecode = 0;
   const struct opttab_t *ot = opttab;
@@ -684,114 +679,97 @@
 #endif
 
   for (o = 0; ot[o].name; o++)
-    if (ot[o].val == opt)
-      {
-	if (buf)
-	  {
-	    memset(buf, 0, buf_len);
-	    
-	    if (ot[o].size & OT_ADDR_LIST) 
-	      {
-		struct all_addr addr;
-		int addr_len = INADDRSZ;
-
-#ifdef HAVE_DHCP6
-		if (prot == AF_INET6)
-		  addr_len = IN6ADDRSZ;
-#endif
-		for (buf[0]= 0, i = 0; i <= opt_len - addr_len; i += addr_len) 
-		  {
-		    if (i != 0)
-		      strncat(buf, ", ", buf_len - strlen(buf));
-		    /* align */
-		    memcpy(&addr, &val[i], addr_len); 
-		    inet_ntop(prot, &val[i], daemon->addrbuff, ADDRSTRLEN);
-		    strncat(buf, daemon->addrbuff, buf_len - strlen(buf));
-		  }
-	      }
-	    else if (ot[o].size & OT_NAME)
-		for (i = 0, j = 0; i < opt_len && j < buf_len ; i++)
-		  {
-		    char c = val[i];
-		    if (isprint((int)c))
-		      buf[j++] = c;
-		  }
-#ifdef HAVE_DHCP6
-	    /* We don't handle compressed rfc1035 names, so no good in IPv4 land */
-	    else if ((ot[o].size & OT_RFC1035_NAME) && prot == AF_INET6)
-	      {
-		i = 0, j = 0;
-		while (i < opt_len && val[i] != 0)
-		  {
-		    int k, l = i + val[i] + 1;
-		    for (k = i + 1; k < opt_len && k < l && j < buf_len ; k++)
-		     {
-		       char c = val[k];
-		       if (isprint((int)c))
-			 buf[j++] = c;
-		     }
-		    i = l;
-		    if (val[i] != 0 && j < buf_len)
-		      buf[j++] = '.';
-		  }
-	      }
-	    else if ((ot[o].size & OT_CSTRING))
-	      {
-		int k, len;
-		unsigned char *p;
-
-		i = 0, j = 0;
-		while (1)
-		  {
-		    p = &val[i];
-		    GETSHORT(len, p);
-		    for (k = 0; k < len && j < buf_len; k++)
-		      {
-		       char c = *p++;
-		       if (isprint((int)c))
-			 buf[j++] = c;
-		     }
-		    i += len +2;
-		    if (i >= opt_len)
-		      break;
-
-		    if (j < buf_len)
-		      buf[j++] = ',';
-		  }
-	      }	      
-#endif
-	    else if ((ot[o].size & (OT_DEC | OT_TIME)) && opt_len != 0)
-	      {
-		unsigned int dec = 0;
-		
-		for (i = 0; i < opt_len; i++)
-		  dec = (dec << 8) | val[i]; 
-
-		if (ot[o].size & OT_TIME)
-		  prettyprint_time(buf, dec);
-		else
-		  sprintf(buf, "%u", dec);
-	      }
-	    else
-	      nodecode = 1;
-	  }
-	break;
+    if (ot[o].val == opt) {
+      if (buf) {
+        memset(buf, 0, buf_len);
+
+        if (ot[o].size & OT_ADDR_LIST) {
+          struct all_addr addr;
+          int addr_len = INADDRSZ;
+
+#ifdef HAVE_DHCP6
+          if (prot == AF_INET6)
+            addr_len = IN6ADDRSZ;
+#endif
+          for (buf[0] = 0, i = 0; i <= opt_len - addr_len; i += addr_len) {
+            if (i != 0)
+              strncat(buf, ", ", buf_len - strlen(buf));
+            /* align */
+            memcpy(&addr, &val[i], addr_len);
+            inet_ntop(prot, &val[i], daemon->addrbuff, ADDRSTRLEN);
+            strncat(buf, daemon->addrbuff, buf_len - strlen(buf));
+          }
+        } else if (ot[o].size & OT_NAME)
+          for (i = 0, j = 0; i < opt_len && j < buf_len; i++) {
+            char c = val[i];
+            if (isprint((int) c))
+              buf[j++] = c;
+          }
+#ifdef HAVE_DHCP6
+        /* We don't handle compressed rfc1035 names, so no good in IPv4 land */
+        else if ((ot[o].size & OT_RFC1035_NAME) && prot == AF_INET6) {
+          i = 0, j = 0;
+          while (i < opt_len && val[i] != 0) {
+            int k, l = i + val[i] + 1;
+            for (k = i + 1; k < opt_len && k < l && j < buf_len; k++) {
+              char c = val[k];
+              if (isprint((int) c))
+                buf[j++] = c;
+            }
+            i = l;
+            if (val[i] != 0 && j < buf_len)
+              buf[j++] = '.';
+          }
+        } else if ((ot[o].size & OT_CSTRING)) {
+          int k, len;
+          unsigned char *p;
+
+          i = 0, j = 0;
+          while (1) {
+            p = &val[i];
+            GETSHORT(len, p);
+            for (k = 0; k < len && j < buf_len; k++) {
+              char c = *p++;
+              if (isprint((int) c))
+                buf[j++] = c;
+            }
+            i += len + 2;
+            if (i >= opt_len)
+              break;
+
+            if (j < buf_len)
+              buf[j++] = ',';
+          }
+        }
+#endif
+        else if ((ot[o].size & (OT_DEC | OT_TIME)) && opt_len != 0) {
+          unsigned int dec = 0;
+
+          for (i = 0; i < opt_len; i++)
+            dec = (dec << 8) | val[i];
+
+          if (ot[o].size & OT_TIME)
+            prettyprint_time(buf, dec);
+          else
+            sprintf(buf, "%u", dec);
+        } else
+          nodecode = 1;
       }
+      break;
+    }
 
-  if (opt_len != 0 && buf && (!ot[o].name || nodecode))
-    {
-      int trunc  = 0;
-      if (opt_len > 14)
-	{
-	  trunc = 1;
-	  opt_len = 14;
-	}
-      print_mac(buf, val, opt_len);
-      if (trunc)
-	strncat(buf, "...", buf_len - strlen(buf));
-    
-
+  if (opt_len != 0 && buf && (!ot[o].name || nodecode)) {
+    int trunc = 0;
+    if (opt_len > 14) {
+      trunc = 1;
+      opt_len = 14;
     }
+    print_mac(buf, val, opt_len);
+    if (trunc)
+      strncat(buf, "...", buf_len - strlen(buf));
+
+
+  }
 
   return ot[o].name ? ot[o].name : "";
 
@@ -804,89 +782,87 @@
   void *start = &context->start;
   void *end = &context->end;
   char *template = "", *p = daemon->namebuff;
-  
+
   *p = 0;
-    
+
 #ifdef HAVE_DHCP6
-  if (family == AF_INET6)
-    {
-      struct in6_addr subnet = context->start6;
-      if (!(context->flags & CONTEXT_TEMPLATE))
-	setaddr6part(&subnet, 0);
-      inet_ntop(AF_INET6, &subnet, daemon->addrbuff, ADDRSTRLEN); 
-      start = &context->start6;
-      end = &context->end6;
-    }
+  if (family == AF_INET6) {
+    struct in6_addr subnet = context->start6;
+    if (!(context->flags & CONTEXT_TEMPLATE))
+      setaddr6part(&subnet, 0);
+    inet_ntop(AF_INET6, &subnet, daemon->addrbuff, ADDRSTRLEN);
+    start = &context->start6;
+    end = &context->end6;
+  }
 #endif
 
   if (family != AF_INET && (context->flags & CONTEXT_DEPRECATE))
     strcpy(daemon->namebuff, _(", prefix deprecated"));
-  else
-    {
-      p += sprintf(p, _(", lease time "));
-      prettyprint_time(p, context->lease_time);
-      p += strlen(p);
-    }	
-
-#ifdef HAVE_DHCP6
-  if (context->flags & CONTEXT_CONSTRUCTED)
-    {
-      char ifrn_name[IFNAMSIZ];
-      
-      template = p;
-      p += sprintf(p, ", ");
-      
-      if (indextoname(daemon->icmp6fd, context->if_index, ifrn_name))
-	sprintf(p, "%s for %s", (context->flags & CONTEXT_OLD) ? "old prefix" : "constructed", ifrn_name);
-    }
-  else if (context->flags & CONTEXT_TEMPLATE && !(context->flags & CONTEXT_RA_STATELESS))
-    {
-      template = p;
-      p += sprintf(p, ", ");
-      
-      sprintf(p, "template for %s", context->template_interface);  
-    }
+  else {
+    p += sprintf(p, _(", lease time "));
+    prettyprint_time(p, context->lease_time);
+    p += strlen(p);
+  }
+
+#ifdef HAVE_DHCP6
+  if (context->flags & CONTEXT_CONSTRUCTED) {
+    char ifrn_name[IFNAMSIZ];
+
+    template = p;
+    p += sprintf(p, ", ");
+
+    if (indextoname(daemon->icmp6fd, context->if_index, ifrn_name))
+      sprintf(p, "%s for %s",
+              (context->flags & CONTEXT_OLD) ? "old prefix" : "constructed",
+              ifrn_name);
+  } else if (context->flags & CONTEXT_TEMPLATE
+             && !(context->flags & CONTEXT_RA_STATELESS)) {
+    template = p;
+    p += sprintf(p, ", ");
+
+    sprintf(p, "template for %s", context->template_interface);
+  }
 #endif
-     
+
   if (!(context->flags & CONTEXT_OLD) &&
-      ((context->flags & CONTEXT_DHCP) || family == AF_INET)) 
-    {
-#ifdef HAVE_DHCP6
-      if (context->flags & CONTEXT_RA_STATELESS)
-	{
-	  if (context->flags & CONTEXT_TEMPLATE)
-	    strncpy(daemon->dhcp_buff, context->template_interface, DHCP_BUFF_SZ);
-	  else
-	    strcpy(daemon->dhcp_buff, daemon->addrbuff);
-	}
-      else 
-#endif
-	inet_ntop(family, start, daemon->dhcp_buff, DHCP_BUFF_SZ);
-      inet_ntop(family, end, daemon->dhcp_buff3, DHCP_BUFF_SZ);
-      my_syslog(MS_DHCP | LOG_INFO, 
-		(context->flags & CONTEXT_RA_STATELESS) ? 
-		_("%s stateless on %s%.0s%.0s%s") :
-		(context->flags & CONTEXT_STATIC) ? 
-		_("%s, static leases only on %.0s%s%s%.0s") :
-		(context->flags & CONTEXT_PROXY) ?
-		_("%s, proxy on subnet %.0s%s%.0s%.0s") :
-		_("%s, IP range %s -- %s%s%.0s"),
-		(family != AF_INET) ? "DHCPv6" : "DHCP",
-		daemon->dhcp_buff, daemon->dhcp_buff3, daemon->namebuff, template);
-    }
-  
+      ((context->flags & CONTEXT_DHCP) || family == AF_INET)) {
 #ifdef HAVE_DHCP6
-  if (context->flags & CONTEXT_TEMPLATE)
-    {
-      strcpy(daemon->addrbuff, context->template_interface);
-      template = "";
-    }
+    if (context->flags & CONTEXT_RA_STATELESS) {
+      if (context->flags & CONTEXT_TEMPLATE)
+        strncpy(daemon->dhcp_buff, context->template_interface, DHCP_BUFF_SZ);
+      else
+        strcpy(daemon->dhcp_buff, daemon->addrbuff);
+    } else
+#endif
+      inet_ntop(family, start, daemon->dhcp_buff, DHCP_BUFF_SZ);
+    inet_ntop(family, end, daemon->dhcp_buff3, DHCP_BUFF_SZ);
+    my_syslog(MS_DHCP | LOG_INFO,
+              (context->flags & CONTEXT_RA_STATELESS) ?
+              _("%s stateless on %s%.0s%.0s%s") :
+              (context->flags & CONTEXT_STATIC) ?
+              _("%s, static leases only on %.0s%s%s%.0s") :
+              (context->flags & CONTEXT_PROXY) ?
+              _("%s, proxy on subnet %.0s%s%.0s%.0s") :
+              _("%s, IP range %s -- %s%s%.0s"),
+              (family != AF_INET) ? "DHCPv6" : "DHCP",
+              daemon->dhcp_buff, daemon->dhcp_buff3, daemon->namebuff,
+              template);
+  }
+#ifdef HAVE_DHCP6
+  if (context->flags & CONTEXT_TEMPLATE) {
+    strcpy(daemon->addrbuff, context->template_interface);
+    template = "";
+  }
 
   if ((context->flags & CONTEXT_RA_NAME) && !(context->flags & CONTEXT_OLD))
-    my_syslog(MS_DHCP | LOG_INFO, _("DHCPv4-derived IPv6 names on %s%s"), daemon->addrbuff, template);
-  
-  if ((context->flags & CONTEXT_RA) || (option_bool(OPT_RA) && (context->flags & CONTEXT_DHCP) && family == AF_INET6)) 
-    my_syslog(MS_DHCP | LOG_INFO, _("router advertisement on %s%s"), daemon->addrbuff, template);
+    my_syslog(MS_DHCP | LOG_INFO, _("DHCPv4-derived IPv6 names on %s%s"),
+              daemon->addrbuff, template);
+
+  if ((context->flags & CONTEXT_RA)
+      || (option_bool(OPT_RA) && (context->flags & CONTEXT_DHCP)
+          && family == AF_INET6))
+    my_syslog(MS_DHCP | LOG_INFO, _("router advertisement on %s%s"),
+              daemon->addrbuff, template);
 #endif
 
 }
@@ -894,12 +870,14 @@
 void log_relay(int family, struct dhcp_relay *relay)
 {
   inet_ntop(family, &relay->local, daemon->addrbuff, ADDRSTRLEN);
-  inet_ntop(family, &relay->server, daemon->namebuff, ADDRSTRLEN); 
+  inet_ntop(family, &relay->server, daemon->namebuff, ADDRSTRLEN);
 
   if (relay->interface)
-    my_syslog(MS_DHCP | LOG_INFO, _("DHCP relay from %s to %s via %s"), daemon->addrbuff, daemon->namebuff, relay->interface);
+    my_syslog(MS_DHCP | LOG_INFO, _("DHCP relay from %s to %s via %s"),
+              daemon->addrbuff, daemon->namebuff, relay->interface);
   else
-    my_syslog(MS_DHCP | LOG_INFO, _("DHCP relay from %s to %s"), daemon->addrbuff, daemon->namebuff);
+    my_syslog(MS_DHCP | LOG_INFO, _("DHCP relay from %s to %s"),
+              daemon->addrbuff, daemon->namebuff);
 }
-   
+
 #endif
Index: dnsmasq-2.78/src/dhcp-protocol.h
===================================================================
--- dnsmasq-2.78.orig/src/dhcp-protocol.h	2017-10-02 21:13:51.000000000 +0800
+++ dnsmasq-2.78/src/dhcp-protocol.h	2018-10-29 16:14:19.373440023 +0800
@@ -39,7 +39,7 @@
 #define OPTION_DOMAINNAME        15
 #define OPTION_BROADCAST         28
 #define OPTION_VENDOR_CLASS_OPT  43
-#define OPTION_REQUESTED_IP      50 
+#define OPTION_REQUESTED_IP      50
 #define OPTION_LEASE_TIME        51
 #define OPTION_OVERLOAD          52
 #define OPTION_MESSAGE_TYPE      53
@@ -67,11 +67,11 @@
 
 #define SUBOPT_CIRCUIT_ID        1
 #define SUBOPT_REMOTE_ID         2
-#define SUBOPT_SUBNET_SELECT     5     /* RFC 3527 */
-#define SUBOPT_SUBSCR_ID         6     /* RFC 3393 */
-#define SUBOPT_SERVER_OR         11    /* RFC 5107 */
+#define SUBOPT_SUBNET_SELECT     5      /* RFC 3527 */
+#define SUBOPT_SUBSCR_ID         6      /* RFC 3393 */
+#define SUBOPT_SERVER_OR         11     /* RFC 5107 */
 
-#define SUBOPT_PXE_BOOT_ITEM     71    /* PXE standard */
+#define SUBOPT_PXE_BOOT_ITEM     71     /* PXE standard */
 #define SUBOPT_PXE_DISCOVERY     6
 #define SUBOPT_PXE_SERVERS       8
 #define SUBOPT_PXE_MENU          9
@@ -86,7 +86,7 @@
 #define DHCPRELEASE              7
 #define DHCPINFORM               8
 
-#define BRDBAND_FORUM_IANA       3561 /* Broadband forum IANA enterprise */
+#define BRDBAND_FORUM_IANA       3561   /* Broadband forum IANA enterprise */
 
 #define DHCP_CHADDR_MAX 16
 
Index: dnsmasq-2.78/src/dhcp.c
===================================================================
--- dnsmasq-2.78.orig/src/dhcp.c	2017-10-02 21:13:51.000000000 +0800
+++ dnsmasq-2.78/src/dhcp.c	2018-10-29 16:14:19.381440023 +0800
@@ -31,11 +31,15 @@
 };
 
 static int complete_context(struct in_addr local, int if_index, char *label,
-			    struct in_addr netmask, struct in_addr broadcast, void *vparam);
+                            struct in_addr netmask, struct in_addr broadcast,
+                            void *vparam);
 static int check_listen_addrs(struct in_addr local, int if_index, char *label,
-			      struct in_addr netmask, struct in_addr broadcast, void *vparam);
-static int relay_upstream4(struct dhcp_relay *relay, struct dhcp_packet *mess, size_t sz, int iface_index);
-static struct dhcp_relay *relay_reply4(struct dhcp_packet *mess, char *arrival_interface);
+                              struct in_addr netmask, struct in_addr broadcast,
+                              void *vparam);
+static int relay_upstream4(struct dhcp_relay *relay, struct dhcp_packet *mess,
+                           size_t sz, int iface_index);
+static struct dhcp_relay *relay_reply4(struct dhcp_packet *mess,
+                                       char *arrival_interface);
 
 static int make_fd(int port)
 {
@@ -50,8 +54,8 @@
 #endif
 
   if (fd == -1)
-    die (_("cannot create DHCP socket: %s"), NULL, EC_BADNET);
-  
+    die(_("cannot create DHCP socket: %s"), NULL, EC_BADNET);
+
   if (!fix_fd(fd) ||
 #if defined(IP_MTU_DISCOVER) && defined(IP_PMTUDISC_DONT)
       setsockopt(fd, IPPROTO_IP, IP_MTU_DISCOVER, &mtu, sizeof(mtu)) == -1 ||
@@ -64,31 +68,32 @@
 #else
       setsockopt(fd, IPPROTO_IP, IP_RECVIF, &oneopt, sizeof(oneopt)) == -1 ||
 #endif
-      setsockopt(fd, SOL_SOCKET, SO_BROADCAST, &oneopt, sizeof(oneopt)) == -1)  
+      setsockopt(fd, SOL_SOCKET, SO_BROADCAST, &oneopt, sizeof(oneopt)) == -1)
     die(_("failed to set options on DHCP socket: %s"), NULL, EC_BADNET);
-  
+
   /* When bind-interfaces is set, there might be more than one dnsmasq
      instance binding port 67. That's OK if they serve different networks.
      Need to set REUSEADDR|REUSEPORT to make this possible.
      Handle the case that REUSEPORT is defined, but the kernel doesn't 
      support it. This handles the introduction of REUSEPORT on Linux. */
-  if (option_bool(OPT_NOWILD) || option_bool(OPT_CLEVERBIND))
-    {
-      int rc = 0;
+  if (option_bool(OPT_NOWILD) || option_bool(OPT_CLEVERBIND)) {
+    int rc = 0;
 
 #ifdef SO_REUSEPORT
-      if ((rc = setsockopt(fd, SOL_SOCKET, SO_REUSEPORT, &oneopt, sizeof(oneopt))) == -1 && 
-	  errno == ENOPROTOOPT)
-	rc = 0;
+    if ((rc =
+         setsockopt(fd, SOL_SOCKET, SO_REUSEPORT, &oneopt,
+                    sizeof(oneopt))) == -1 && errno == ENOPROTOOPT)
+      rc = 0;
 #endif
-      
-      if (rc != -1)
-	rc = setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, &oneopt, sizeof(oneopt));
-      
-      if (rc == -1)
-	die(_("failed to set SO_REUSE{ADDR|PORT} on DHCP socket: %s"), NULL, EC_BADNET);
-    }
-  
+
+    if (rc != -1)
+      rc = setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, &oneopt, sizeof(oneopt));
+
+    if (rc == -1)
+      die(_("failed to set SO_REUSE{ADDR|PORT} on DHCP socket: %s"), NULL,
+          EC_BADNET);
+  }
+
   memset(&saddr, 0, sizeof(saddr));
   saddr.sin_family = AF_INET;
   saddr.sin_port = htons(port);
@@ -97,7 +102,7 @@
   saddr.sin_len = sizeof(struct sockaddr_in);
 #endif
 
-  if (bind(fd, (struct sockaddr *)&saddr, sizeof(struct sockaddr_in)))
+  if (bind(fd, (struct sockaddr *) &saddr, sizeof(struct sockaddr_in)))
     die(_("failed to bind DHCP server socket: %s"), NULL, EC_BADNET);
 
   return fd;
@@ -119,16 +124,17 @@
   /* When we're not using capabilities, we need to do this here before
      we drop root. Also, set buffer size small, to avoid wasting
      kernel buffers */
-  
+
   if (option_bool(OPT_NO_PING))
     daemon->dhcp_icmp_fd = -1;
   else if ((daemon->dhcp_icmp_fd = make_icmp_sock()) == -1 ||
-	   setsockopt(daemon->dhcp_icmp_fd, SOL_SOCKET, SO_RCVBUF, &oneopt, sizeof(oneopt)) == -1 )
+           setsockopt(daemon->dhcp_icmp_fd, SOL_SOCKET, SO_RCVBUF, &oneopt,
+                      sizeof(oneopt)) == -1)
     die(_("cannot create ICMP raw socket: %s."), NULL, EC_BADNET);
-  
+
   /* Make BPF raw send socket */
   init_bpf();
-#endif  
+#endif
 }
 
 void dhcp_packet(time_t now, int pxe_fd)
@@ -144,7 +150,7 @@
   struct sockaddr_in dest;
   struct cmsghdr *cmptr;
   struct iovec iov;
-  ssize_t sz; 
+  ssize_t sz;
   int iface_index = 0, unicast_dest = 0, is_inform = 0, loopback = 0;
   int rcvd_iface_index;
   struct in_addr iface_addr;
@@ -154,14 +160,14 @@
   struct arpreq arp_req;
   struct timeval tv;
 #endif
-  
+
   union {
-    struct cmsghdr align; /* this ensures alignment */
+    struct cmsghdr align;       /* this ensures alignment */
 #if defined(HAVE_LINUX_NETWORK)
     char control[CMSG_SPACE(sizeof(struct in_pktinfo))];
 #elif defined(HAVE_SOLARIS_NETWORK)
     char control[CMSG_SPACE(sizeof(unsigned int))];
-#elif defined(HAVE_BSD_NETWORK) 
+#elif defined(HAVE_BSD_NETWORK)
     char control[CMSG_SPACE(sizeof(struct sockaddr_dl))];
 #endif
   } control_u;
@@ -173,67 +179,62 @@
   msg.msg_namelen = sizeof(dest);
   msg.msg_iov = &daemon->dhcp_packet;
   msg.msg_iovlen = 1;
-  
-  if ((sz = recv_dhcp_packet(fd, &msg)) == -1 || 
-      (sz < (ssize_t)(sizeof(*mess) - sizeof(mess->options)))) 
+
+  if ((sz = recv_dhcp_packet(fd, &msg)) == -1 ||
+      (sz < (ssize_t) (sizeof(*mess) - sizeof(mess->options))))
     return;
-    
-  #if defined (HAVE_LINUX_NETWORK)
+
+#if defined (HAVE_LINUX_NETWORK)
   if (ioctl(fd, SIOCGSTAMP, &tv) == 0)
     recvtime = tv.tv_sec;
 
   if (msg.msg_controllen >= sizeof(struct cmsghdr))
     for (cmptr = CMSG_FIRSTHDR(&msg); cmptr; cmptr = CMSG_NXTHDR(&msg, cmptr))
-      if (cmptr->cmsg_level == IPPROTO_IP && cmptr->cmsg_type == IP_PKTINFO)
-	{
-	  union {
-	    unsigned char *c;
-	    struct in_pktinfo *p;
-	  } p;
-	  p.c = CMSG_DATA(cmptr);
-	  iface_index = p.p->ipi_ifindex;
-	  if (p.p->ipi_addr.s_addr != INADDR_BROADCAST)
-	    unicast_dest = 1;
-	}
-
-#elif defined(HAVE_BSD_NETWORK) 
+      if (cmptr->cmsg_level == IPPROTO_IP && cmptr->cmsg_type == IP_PKTINFO) {
+        union {
+          unsigned char *c;
+          struct in_pktinfo *p;
+        } p;
+        p.c = CMSG_DATA(cmptr);
+        iface_index = p.p->ipi_ifindex;
+        if (p.p->ipi_addr.s_addr != INADDR_BROADCAST)
+          unicast_dest = 1;
+      }
+#elif defined(HAVE_BSD_NETWORK)
   if (msg.msg_controllen >= sizeof(struct cmsghdr))
     for (cmptr = CMSG_FIRSTHDR(&msg); cmptr; cmptr = CMSG_NXTHDR(&msg, cmptr))
-      if (cmptr->cmsg_level == IPPROTO_IP && cmptr->cmsg_type == IP_RECVIF)
-        {
-	  union {
-            unsigned char *c;
-            struct sockaddr_dl *s;
-          } p;
-	  p.c = CMSG_DATA(cmptr);
-	  iface_index = p.s->sdl_index;
-	}
-  
-#elif defined(HAVE_SOLARIS_NETWORK) 
+      if (cmptr->cmsg_level == IPPROTO_IP && cmptr->cmsg_type == IP_RECVIF) {
+        union {
+          unsigned char *c;
+          struct sockaddr_dl *s;
+        } p;
+        p.c = CMSG_DATA(cmptr);
+        iface_index = p.s->sdl_index;
+      }
+#elif defined(HAVE_SOLARIS_NETWORK)
   if (msg.msg_controllen >= sizeof(struct cmsghdr))
     for (cmptr = CMSG_FIRSTHDR(&msg); cmptr; cmptr = CMSG_NXTHDR(&msg, cmptr))
-      if (cmptr->cmsg_level == IPPROTO_IP && cmptr->cmsg_type == IP_RECVIF)
-	{
-	  union {
-	    unsigned char *c;
-	    unsigned int *i;
-	  } p;
-	  p.c = CMSG_DATA(cmptr);
-	  iface_index = *(p.i);
-	}
+      if (cmptr->cmsg_level == IPPROTO_IP && cmptr->cmsg_type == IP_RECVIF) {
+        union {
+          unsigned char *c;
+          unsigned int *i;
+        } p;
+        p.c = CMSG_DATA(cmptr);
+        iface_index = *(p.i);
+      }
 #endif
-	
+
   if (!indextoname(daemon->dhcpfd, iface_index, ifr.ifr_name) ||
       ioctl(daemon->dhcpfd, SIOCGIFFLAGS, &ifr) != 0)
     return;
-  
-  mess = (struct dhcp_packet *)daemon->dhcp_packet.iov_base;
+
+  mess = (struct dhcp_packet *) daemon->dhcp_packet.iov_base;
   loopback = !mess->giaddr.s_addr && (ifr.ifr_flags & IFF_LOOPBACK);
-  
+
 #ifdef HAVE_LINUX_NETWORK
   /* ARP fiddling uses original interface even if we pretend to use a different one. */
   strncpy(arp_req.arp_dev, ifr.ifr_name, 16);
-#endif 
+#endif
 
   /* If the interface on which the DHCP request was received is an
      alias of some other interface (as specified by the
@@ -241,259 +242,244 @@
      for DHCP contexts associated with the aliased interface instead
      of with the aliasing one. */
   rcvd_iface_index = iface_index;
-  for (bridge = daemon->bridges; bridge; bridge = bridge->next)
-    {
-      for (alias = bridge->alias; alias; alias = alias->next)
-	if (wildcard_matchn(alias->iface, ifr.ifr_name, IF_NAMESIZE))
-	  {
-	    if (!(iface_index = if_nametoindex(bridge->iface)))
-	      {
-		my_syslog(MS_DHCP | LOG_WARNING,
-			  _("unknown interface %s in bridge-interface"),
-			  bridge->iface);
-		return;
-	      }
-	    else 
-	      {
-		strncpy(ifr.ifr_name,  bridge->iface, IF_NAMESIZE);
-		break;
-	      }
-	  }
-      
-      if (alias)
-	break;
-    }
+  for (bridge = daemon->bridges; bridge; bridge = bridge->next) {
+    for (alias = bridge->alias; alias; alias = alias->next)
+      if (wildcard_matchn(alias->iface, ifr.ifr_name, IF_NAMESIZE)) {
+        if (!(iface_index = if_nametoindex(bridge->iface))) {
+          my_syslog(MS_DHCP | LOG_WARNING,
+                    _("unknown interface %s in bridge-interface"),
+                    bridge->iface);
+          return;
+        } else {
+          strncpy(ifr.ifr_name, bridge->iface, IF_NAMESIZE);
+          break;
+        }
+      }
+
+    if (alias)
+      break;
+  }
 
 #ifdef MSG_BCAST
   /* OpenBSD tells us when a packet was broadcast */
   if (!(msg.msg_flags & MSG_BCAST))
     unicast_dest = 1;
 #endif
-  
-  if ((relay = relay_reply4((struct dhcp_packet *)daemon->dhcp_packet.iov_base, ifr.ifr_name)))
-    {
-      /* Reply from server, using us as relay. */
-      rcvd_iface_index = relay->iface_index;
-      if (!indextoname(daemon->dhcpfd, rcvd_iface_index, ifr.ifr_name))
-	return;
-      is_relay_reply = 1; 
-      iov.iov_len = sz;
+
+  if ((relay =
+       relay_reply4((struct dhcp_packet *) daemon->dhcp_packet.iov_base,
+                    ifr.ifr_name))) {
+    /* Reply from server, using us as relay. */
+    rcvd_iface_index = relay->iface_index;
+    if (!indextoname(daemon->dhcpfd, rcvd_iface_index, ifr.ifr_name))
+      return;
+    is_relay_reply = 1;
+    iov.iov_len = sz;
 #ifdef HAVE_LINUX_NETWORK
-      strncpy(arp_req.arp_dev, ifr.ifr_name, 16);
-#endif 
+    strncpy(arp_req.arp_dev, ifr.ifr_name, 16);
+#endif
+  } else {
+    ifr.ifr_addr.sa_family = AF_INET;
+    if (ioctl(daemon->dhcpfd, SIOCGIFADDR, &ifr) != -1)
+      iface_addr = ((struct sockaddr_in *) &ifr.ifr_addr)->sin_addr;
+    else {
+      if (iface_check(AF_INET, NULL, ifr.ifr_name, NULL))
+        my_syslog(MS_DHCP | LOG_WARNING,
+                  _("DHCP packet received on %s which has no address"),
+                  ifr.ifr_name);
+      return;
     }
-  else
-    {
-      ifr.ifr_addr.sa_family = AF_INET;
-      if (ioctl(daemon->dhcpfd, SIOCGIFADDR, &ifr) != -1 )
-	iface_addr = ((struct sockaddr_in *) &ifr.ifr_addr)->sin_addr;
-      else
-	{
-	  if (iface_check(AF_INET, NULL, ifr.ifr_name, NULL))
-	    my_syslog(MS_DHCP | LOG_WARNING, _("DHCP packet received on %s which has no address"), ifr.ifr_name);
-	  return;
-	}
-      
-      for (tmp = daemon->dhcp_except; tmp; tmp = tmp->next)
-	if (tmp->name && wildcard_match(tmp->name, ifr.ifr_name))
-	  return;
-      
-      /* unlinked contexts/relays are marked by context->current == context */
-      for (context = daemon->dhcp; context; context = context->next)
-	context->current = context;
-      
-      for (relay = daemon->relay4; relay; relay = relay->next)
-	relay->current = relay;
-      
-      parm.current = NULL;
-      parm.relay = NULL;
-      parm.relay_local.s_addr = 0;
-      parm.ind = iface_index;
-      
-      if (!iface_check(AF_INET, (struct all_addr *)&iface_addr, ifr.ifr_name, NULL))
-	{
-	  /* If we failed to match the primary address of the interface, see if we've got a --listen-address
-	     for a secondary */
-	  struct match_param match;
-	  
-	  match.matched = 0;
-	  match.ind = iface_index;
-	  
-	  if (!daemon->if_addrs ||
-	      !iface_enumerate(AF_INET, &match, check_listen_addrs) ||
-	      !match.matched)
-	    return;
-	  
-	  iface_addr = match.addr;
-	  /* make sure secondary address gets priority in case
-	     there is more than one address on the interface in the same subnet */
-	  complete_context(match.addr, iface_index, NULL, match.netmask, match.broadcast, &parm);
-	}    
-      
-      if (!iface_enumerate(AF_INET, &parm, complete_context))
-	return;
-
-      /* We're relaying this request */
-      if  (parm.relay_local.s_addr != 0 &&
-	   relay_upstream4(parm.relay, mess, (size_t)sz, iface_index))
-	return;
-
-      /* May have configured relay, but not DHCP server */
-      if (!daemon->dhcp)
-	return;
-
-      lease_prune(NULL, now); /* lose any expired leases */
-      iov.iov_len = dhcp_reply(parm.current, ifr.ifr_name, iface_index, (size_t)sz, 
-			       now, unicast_dest, loopback, &is_inform, pxe_fd, iface_addr, recvtime);
-      lease_update_file(now);
-      lease_update_dns(0);
-      
-      if (iov.iov_len == 0)
-	return;
+
+    for (tmp = daemon->dhcp_except; tmp; tmp = tmp->next)
+      if (tmp->name && wildcard_match(tmp->name, ifr.ifr_name))
+        return;
+
+    /* unlinked contexts/relays are marked by context->current == context */
+    for (context = daemon->dhcp; context; context = context->next)
+      context->current = context;
+
+    for (relay = daemon->relay4; relay; relay = relay->next)
+      relay->current = relay;
+
+    parm.current = NULL;
+    parm.relay = NULL;
+    parm.relay_local.s_addr = 0;
+    parm.ind = iface_index;
+
+    if (!iface_check
+        (AF_INET, (struct all_addr *) &iface_addr, ifr.ifr_name, NULL)) {
+      /* If we failed to match the primary address of the interface, see if we've got a --listen-address
+         for a secondary */
+      struct match_param match;
+
+      match.matched = 0;
+      match.ind = iface_index;
+
+      if (!daemon->if_addrs ||
+          !iface_enumerate(AF_INET, &match, check_listen_addrs) ||
+          !match.matched)
+        return;
+
+      iface_addr = match.addr;
+      /* make sure secondary address gets priority in case
+         there is more than one address on the interface in the same subnet */
+      complete_context(match.addr, iface_index, NULL, match.netmask,
+                       match.broadcast, &parm);
     }
 
+    if (!iface_enumerate(AF_INET, &parm, complete_context))
+      return;
+
+    /* We're relaying this request */
+    if (parm.relay_local.s_addr != 0 &&
+        relay_upstream4(parm.relay, mess, (size_t) sz, iface_index))
+      return;
+
+    /* May have configured relay, but not DHCP server */
+    if (!daemon->dhcp)
+      return;
+
+    lease_prune(NULL, now);     /* lose any expired leases */
+    iov.iov_len =
+        dhcp_reply(parm.current, ifr.ifr_name, iface_index, (size_t) sz, now,
+                   unicast_dest, loopback, &is_inform, pxe_fd, iface_addr,
+                   recvtime);
+    lease_update_file(now);
+    lease_update_dns(0);
+
+    if (iov.iov_len == 0)
+      return;
+  }
+
   msg.msg_name = &dest;
   msg.msg_namelen = sizeof(dest);
   msg.msg_control = NULL;
   msg.msg_controllen = 0;
   msg.msg_iov = &iov;
   iov.iov_base = daemon->dhcp_packet.iov_base;
-  
+
   /* packet buffer may have moved */
-  mess = (struct dhcp_packet *)daemon->dhcp_packet.iov_base;
-  
+  mess = (struct dhcp_packet *) daemon->dhcp_packet.iov_base;
+
 #ifdef HAVE_SOCKADDR_SA_LEN
   dest.sin_len = sizeof(struct sockaddr_in);
 #endif
-  
-  if (pxe_fd)
-    { 
-      if (mess->ciaddr.s_addr != 0)
-	dest.sin_addr = mess->ciaddr;
-    }
-  else if (mess->giaddr.s_addr && !is_relay_reply)
-    {
-      /* Send to BOOTP relay  */
-      dest.sin_port = htons(daemon->dhcp_server_port);
-      dest.sin_addr = mess->giaddr; 
+
+  if (pxe_fd) {
+    if (mess->ciaddr.s_addr != 0)
+      dest.sin_addr = mess->ciaddr;
+  } else if (mess->giaddr.s_addr && !is_relay_reply) {
+    /* Send to BOOTP relay  */
+    dest.sin_port = htons(daemon->dhcp_server_port);
+    dest.sin_addr = mess->giaddr;
+  } else if (mess->ciaddr.s_addr) {
+    /* If the client's idea of its own address tallys with
+       the source address in the request packet, we believe the
+       source port too, and send back to that.  If we're replying
+       to a DHCPINFORM, trust the source address always. */
+    if ((!is_inform && dest.sin_addr.s_addr != mess->ciaddr.s_addr) ||
+        dest.sin_port == 0 || dest.sin_addr.s_addr == 0 || is_relay_reply) {
+      dest.sin_port = htons(daemon->dhcp_client_port);
+      dest.sin_addr = mess->ciaddr;
     }
-  else if (mess->ciaddr.s_addr)
-    {
-      /* If the client's idea of its own address tallys with
-	 the source address in the request packet, we believe the
-	 source port too, and send back to that.  If we're replying 
-	 to a DHCPINFORM, trust the source address always. */
-      if ((!is_inform && dest.sin_addr.s_addr != mess->ciaddr.s_addr) ||
-	  dest.sin_port == 0 || dest.sin_addr.s_addr == 0 || is_relay_reply)
-	{
-	  dest.sin_port = htons(daemon->dhcp_client_port); 
-	  dest.sin_addr = mess->ciaddr;
-	}
-    } 
+  }
 #if defined(HAVE_LINUX_NETWORK)
-  else
-    {
-      /* fill cmsg for outbound interface (both broadcast & unicast) */
-      struct in_pktinfo *pkt;
-      msg.msg_control = control_u.control;
-      msg.msg_controllen = sizeof(control_u);
-      cmptr = CMSG_FIRSTHDR(&msg);
-      pkt = (struct in_pktinfo *)CMSG_DATA(cmptr);
-      pkt->ipi_ifindex = rcvd_iface_index;
-      pkt->ipi_spec_dst.s_addr = 0;
-      msg.msg_controllen = cmptr->cmsg_len = CMSG_LEN(sizeof(struct in_pktinfo));
-      cmptr->cmsg_level = IPPROTO_IP;
-      cmptr->cmsg_type = IP_PKTINFO;
-
-      if ((ntohs(mess->flags) & 0x8000) || mess->hlen == 0 ||
-         mess->hlen > sizeof(ifr.ifr_addr.sa_data) || mess->htype == 0)
-        {
-          /* broadcast to 255.255.255.255 (or mac address invalid) */
-          dest.sin_addr.s_addr = INADDR_BROADCAST;
-          dest.sin_port = htons(daemon->dhcp_client_port);
-        }
-      else
-        {
-          /* unicast to unconfigured client. Inject mac address direct into ARP cache.
-          struct sockaddr limits size to 14 bytes. */
-          dest.sin_addr = mess->yiaddr;
-          dest.sin_port = htons(daemon->dhcp_client_port);
-          memcpy(&arp_req.arp_pa, &dest, sizeof(struct sockaddr_in));
-          arp_req.arp_ha.sa_family = mess->htype;
-          memcpy(arp_req.arp_ha.sa_data, mess->chaddr, mess->hlen);
-          /* interface name already copied in */
-          arp_req.arp_flags = ATF_COM;
-          if (ioctl(daemon->dhcpfd, SIOCSARP, &arp_req) == -1)
-            my_syslog(MS_DHCP | LOG_ERR, _("ARP-cache injection failed: %s"), strerror(errno));
-        }
-    }
-#elif defined(HAVE_SOLARIS_NETWORK)
-  else if ((ntohs(mess->flags) & 0x8000) || mess->hlen != ETHER_ADDR_LEN || mess->htype != ARPHRD_ETHER)
-    {
+  else {
+    /* fill cmsg for outbound interface (both broadcast & unicast) */
+    struct in_pktinfo *pkt;
+    msg.msg_control = control_u.control;
+    msg.msg_controllen = sizeof(control_u);
+    cmptr = CMSG_FIRSTHDR(&msg);
+    pkt = (struct in_pktinfo *) CMSG_DATA(cmptr);
+    pkt->ipi_ifindex = rcvd_iface_index;
+    pkt->ipi_spec_dst.s_addr = 0;
+    msg.msg_controllen = cmptr->cmsg_len = CMSG_LEN(sizeof(struct in_pktinfo));
+    cmptr->cmsg_level = IPPROTO_IP;
+    cmptr->cmsg_type = IP_PKTINFO;
+
+    if ((ntohs(mess->flags) & 0x8000) || mess->hlen == 0 ||
+        mess->hlen > sizeof(ifr.ifr_addr.sa_data) || mess->htype == 0) {
       /* broadcast to 255.255.255.255 (or mac address invalid) */
       dest.sin_addr.s_addr = INADDR_BROADCAST;
       dest.sin_port = htons(daemon->dhcp_client_port);
-      /* note that we don't specify the interface here: that's done by the
-	 IP_BOUND_IF sockopt lower down. */
-    }
-  else
-    {
-      /* unicast to unconfigured client. Inject mac address direct into ARP cache. 
-	 Note that this only works for ethernet on solaris, because we use SIOCSARP
-	 and not SIOCSXARP, which would be perfect, except that it returns ENXIO 
-	 mysteriously. Bah. Fall back to broadcast for other net types. */
-      struct arpreq req;
+    } else {
+      /* unicast to unconfigured client. Inject mac address direct into ARP cache.
+         struct sockaddr limits size to 14 bytes. */
       dest.sin_addr = mess->yiaddr;
       dest.sin_port = htons(daemon->dhcp_client_port);
-      *((struct sockaddr_in *)&req.arp_pa) = dest;
-      req.arp_ha.sa_family = AF_UNSPEC;
-      memcpy(req.arp_ha.sa_data, mess->chaddr, mess->hlen);
-      req.arp_flags = ATF_COM;
-      ioctl(daemon->dhcpfd, SIOCSARP, &req);
+      memcpy(&arp_req.arp_pa, &dest, sizeof(struct sockaddr_in));
+      arp_req.arp_ha.sa_family = mess->htype;
+      memcpy(arp_req.arp_ha.sa_data, mess->chaddr, mess->hlen);
+      /* interface name already copied in */
+      arp_req.arp_flags = ATF_COM;
+      if (ioctl(daemon->dhcpfd, SIOCSARP, &arp_req) == -1)
+        my_syslog(MS_DHCP | LOG_ERR, _("ARP-cache injection failed: %s"),
+                  strerror(errno));
     }
+  }
+#elif defined(HAVE_SOLARIS_NETWORK)
+  else if ((ntohs(mess->flags) & 0x8000) || mess->hlen != ETHER_ADDR_LEN
+           || mess->htype != ARPHRD_ETHER) {
+    /* broadcast to 255.255.255.255 (or mac address invalid) */
+    dest.sin_addr.s_addr = INADDR_BROADCAST;
+    dest.sin_port = htons(daemon->dhcp_client_port);
+    /* note that we don't specify the interface here: that's done by the
+       IP_BOUND_IF sockopt lower down. */
+  } else {
+    /* unicast to unconfigured client. Inject mac address direct into ARP cache.
+       Note that this only works for ethernet on solaris, because we use SIOCSARP
+       and not SIOCSXARP, which would be perfect, except that it returns ENXIO
+       mysteriously. Bah. Fall back to broadcast for other net types. */
+    struct arpreq req;
+    dest.sin_addr = mess->yiaddr;
+    dest.sin_port = htons(daemon->dhcp_client_port);
+    *((struct sockaddr_in *) &req.arp_pa) = dest;
+    req.arp_ha.sa_family = AF_UNSPEC;
+    memcpy(req.arp_ha.sa_data, mess->chaddr, mess->hlen);
+    req.arp_flags = ATF_COM;
+    ioctl(daemon->dhcpfd, SIOCSARP, &req);
+  }
 #elif defined(HAVE_BSD_NETWORK)
-  else 
-    {
-      send_via_bpf(mess, iov.iov_len, iface_addr, &ifr);
-      return;
-    }
+  else {
+    send_via_bpf(mess, iov.iov_len, iface_addr, &ifr);
+    return;
+  }
 #endif
-   
+
 #ifdef HAVE_SOLARIS_NETWORK
   setsockopt(fd, IPPROTO_IP, IP_BOUND_IF, &iface_index, sizeof(iface_index));
 #endif
-  
-  while(retry_send(sendmsg(fd, &msg, 0)));
+
+  while (retry_send(sendmsg(fd, &msg, 0)));
 
   /* This can fail when, eg, iptables DROPS destination 255.255.255.255 */
   if (errno != 0)
     my_syslog(MS_DHCP | LOG_WARNING, _("Error sending DHCP packet to %s: %s"),
-	      inet_ntoa(dest.sin_addr), strerror(errno));
+              inet_ntoa(dest.sin_addr), strerror(errno));
 }
 
 /* check against secondary interface addresses */
 static int check_listen_addrs(struct in_addr local, int if_index, char *label,
-			      struct in_addr netmask, struct in_addr broadcast, void *vparam)
+                              struct in_addr netmask, struct in_addr broadcast,
+                              void *vparam)
 {
   struct match_param *param = vparam;
   struct iname *tmp;
 
   (void) label;
 
-  if (if_index == param->ind)
-    {
-      for (tmp = daemon->if_addrs; tmp; tmp = tmp->next)
-	if ( tmp->addr.sa.sa_family == AF_INET &&
-	     tmp->addr.in.sin_addr.s_addr == local.s_addr)
-	  {
-	    param->matched = 1;
-	    param->addr = local;
-	    param->netmask = netmask;
-	    param->broadcast = broadcast;
-	    break;
-	  }
-    }
-  
+  if (if_index == param->ind) {
+    for (tmp = daemon->if_addrs; tmp; tmp = tmp->next)
+      if (tmp->addr.sa.sa_family == AF_INET &&
+          tmp->addr.in.sin_addr.s_addr == local.s_addr) {
+        param->matched = 1;
+        param->addr = local;
+        param->netmask = netmask;
+        param->broadcast = broadcast;
+        break;
+      }
+  }
+
   return 1;
 }
 
@@ -508,100 +494,95 @@
    Note that the current chain may be superseded later for configured hosts or those coming via gateways. */
 
 static int complete_context(struct in_addr local, int if_index, char *label,
-			    struct in_addr netmask, struct in_addr broadcast, void *vparam)
+                            struct in_addr netmask, struct in_addr broadcast,
+                            void *vparam)
 {
   struct dhcp_context *context;
   struct dhcp_relay *relay;
   struct iface_param *param = vparam;
 
-  (void)label;
-  
-  for (context = daemon->dhcp; context; context = context->next)
-    {
-      if (!(context->flags & CONTEXT_NETMASK) &&
-	  (is_same_net(local, context->start, netmask) ||
-	   is_same_net(local, context->end, netmask)))
-      { 
-	if (context->netmask.s_addr != netmask.s_addr &&
-	    !(is_same_net(local, context->start, netmask) &&
-	      is_same_net(local, context->end, netmask)))
-	  {
-	    strcpy(daemon->dhcp_buff, inet_ntoa(context->start));
-	    strcpy(daemon->dhcp_buff2, inet_ntoa(context->end));
-	    my_syslog(MS_DHCP | LOG_WARNING, _("DHCP range %s -- %s is not consistent with netmask %s"),
-		      daemon->dhcp_buff, daemon->dhcp_buff2, inet_ntoa(netmask));
-	  }	
- 	context->netmask = netmask;
+  (void) label;
+
+  for (context = daemon->dhcp; context; context = context->next) {
+    if (!(context->flags & CONTEXT_NETMASK) &&
+        (is_same_net(local, context->start, netmask) ||
+         is_same_net(local, context->end, netmask))) {
+      if (context->netmask.s_addr != netmask.s_addr &&
+          !(is_same_net(local, context->start, netmask) &&
+            is_same_net(local, context->end, netmask))) {
+        strcpy(daemon->dhcp_buff, inet_ntoa(context->start));
+        strcpy(daemon->dhcp_buff2, inet_ntoa(context->end));
+        my_syslog(MS_DHCP | LOG_WARNING,
+                  _("DHCP range %s -- %s is not consistent with netmask %s"),
+                  daemon->dhcp_buff, daemon->dhcp_buff2, inet_ntoa(netmask));
       }
-      
-      if (context->netmask.s_addr != 0 &&
-	  is_same_net(local, context->start, context->netmask) &&
-	  is_same_net(local, context->end, context->netmask))
-	{
-	  /* link it onto the current chain if we've not seen it before */
-	  if (if_index == param->ind && context->current == context)
-	    {
-	      context->router = local;
-	      context->local = local;
-	      context->current = param->current;
-	      param->current = context;
-	    }
-	  
-	  if (!(context->flags & CONTEXT_BRDCAST))
-	    {
-	      if (is_same_net(broadcast, context->start, context->netmask))
-		context->broadcast = broadcast;
-	      else 
-		context->broadcast.s_addr  = context->start.s_addr | ~context->netmask.s_addr;
-	    }
-	}		
+      context->netmask = netmask;
     }
 
-  for (relay = daemon->relay4; relay; relay = relay->next)
-    if (if_index == param->ind && relay->local.addr.addr4.s_addr == local.s_addr && relay->current == relay &&
-	(param->relay_local.s_addr == 0 || param->relay_local.s_addr == local.s_addr))
-      {
-	relay->current = param->relay;
-	param->relay = relay;
-	param->relay_local = local;	
+    if (context->netmask.s_addr != 0 &&
+        is_same_net(local, context->start, context->netmask) &&
+        is_same_net(local, context->end, context->netmask)) {
+      /* link it onto the current chain if we've not seen it before */
+      if (if_index == param->ind && context->current == context) {
+        context->router = local;
+        context->local = local;
+        context->current = param->current;
+        param->current = context;
+      }
+
+      if (!(context->flags & CONTEXT_BRDCAST)) {
+        if (is_same_net(broadcast, context->start, context->netmask))
+          context->broadcast = broadcast;
+        else
+          context->broadcast.s_addr =
+              context->start.s_addr | ~context->netmask.s_addr;
       }
+    }
+  }
+
+  for (relay = daemon->relay4; relay; relay = relay->next)
+    if (if_index == param->ind && relay->local.addr.addr4.s_addr == local.s_addr
+        && relay->current == relay && (param->relay_local.s_addr == 0
+                                       || param->relay_local.s_addr ==
+                                       local.s_addr)) {
+      relay->current = param->relay;
+      param->relay = relay;
+      param->relay_local = local;
+    }
 
   return 1;
 }
-	  
-struct dhcp_context *address_available(struct dhcp_context *context, 
-				       struct in_addr taddr,
-				       struct dhcp_netid *netids)
+
+struct dhcp_context *address_available(struct dhcp_context *context,
+                                       struct in_addr taddr,
+                                       struct dhcp_netid *netids)
 {
   /* Check is an address is OK for this network, check all
      possible ranges. Make sure that the address isn't in use
      by the server itself. */
-  
+
   unsigned int start, end, addr = ntohl(taddr.s_addr);
   struct dhcp_context *tmp;
 
   for (tmp = context; tmp; tmp = tmp->current)
     if (taddr.s_addr == context->router.s_addr)
       return NULL;
-  
-  for (tmp = context; tmp; tmp = tmp->current)
-    {
-      start = ntohl(tmp->start.s_addr);
-      end = ntohl(tmp->end.s_addr);
-
-      if (!(tmp->flags & (CONTEXT_STATIC | CONTEXT_PROXY)) &&
-	  addr >= start &&
-	  addr <= end &&
-	  match_netid(tmp->filter, netids, 1))
-	return tmp;
-    }
+
+  for (tmp = context; tmp; tmp = tmp->current) {
+    start = ntohl(tmp->start.s_addr);
+    end = ntohl(tmp->end.s_addr);
+
+    if (!(tmp->flags & (CONTEXT_STATIC | CONTEXT_PROXY)) &&
+        addr >= start && addr <= end && match_netid(tmp->filter, netids, 1))
+      return tmp;
+  }
 
   return NULL;
 }
 
-struct dhcp_context *narrow_context(struct dhcp_context *context, 
-				    struct in_addr taddr,
-				    struct dhcp_netid *netids)
+struct dhcp_context *narrow_context(struct dhcp_context *context,
+                                    struct in_addr taddr,
+                                    struct dhcp_netid *netids)
 {
   /* We start of with a set of possible contexts, all on the current physical interface.
      These are chained on ->current.
@@ -610,36 +591,36 @@
      any dhcp-range. In that case we return a static range if possible, or failing that,
      any context on the correct subnet. (If there's more than one, this is a dodgy 
      configuration: maybe there should be a warning.) */
-  
+
   struct dhcp_context *tmp;
 
-  if (!(tmp = address_available(context, taddr, netids)))
-    {
+  if (!(tmp = address_available(context, taddr, netids))) {
+    for (tmp = context; tmp; tmp = tmp->current)
+      if (match_netid(tmp->filter, netids, 1) &&
+          is_same_net(taddr, tmp->start, tmp->netmask) &&
+          (tmp->flags & CONTEXT_STATIC))
+        break;
+
+    if (!tmp)
       for (tmp = context; tmp; tmp = tmp->current)
-	if (match_netid(tmp->filter, netids, 1) &&
-	    is_same_net(taddr, tmp->start, tmp->netmask) && 
-	    (tmp->flags & CONTEXT_STATIC))
-	  break;
-      
-      if (!tmp)
-	for (tmp = context; tmp; tmp = tmp->current)
-	  if (match_netid(tmp->filter, netids, 1) &&
-	      is_same_net(taddr, tmp->start, tmp->netmask) &&
-	      !(tmp->flags & CONTEXT_PROXY))
-	    break;
-    }
-  
+        if (match_netid(tmp->filter, netids, 1) &&
+            is_same_net(taddr, tmp->start, tmp->netmask) &&
+            !(tmp->flags & CONTEXT_PROXY))
+          break;
+  }
+
   /* Only one context allowed now */
   if (tmp)
     tmp->current = NULL;
-  
+
   return tmp;
 }
 
-struct dhcp_config *config_find_by_address(struct dhcp_config *configs, struct in_addr addr)
+struct dhcp_config *config_find_by_address(struct dhcp_config *configs,
+                                           struct in_addr addr)
 {
   struct dhcp_config *config;
-  
+
   for (config = configs; config; config = config->next)
     if ((config->flags & CONFIG_ADDR) && config->addr.s_addr == addr.s_addr)
       return config;
@@ -651,12 +632,13 @@
    This wrapper handles a cache and load-limiting.
    Return is NULL is address in use, or a pointer to a cache entry
    recording that it isn't. */
-struct ping_result *do_icmp_ping(time_t now, struct in_addr addr, unsigned int hash, int loopback)
+struct ping_result *do_icmp_ping(time_t now, struct in_addr addr,
+                                 unsigned int hash, int loopback)
 {
   static struct ping_result dummy;
   struct ping_result *r, *victim = NULL;
-  int count, max = (int)(0.6 * (((float)PING_CACHE_TIME)/
-				((float)PING_WAIT)));
+  int count, max = (int) (0.6 * (((float) PING_CACHE_TIME) /
+                                 ((float) PING_WAIT)));
 
   /* check if we failed to ping addr sometime in the last
      PING_CACHE_TIME seconds. If so, assume the same situation still exists.
@@ -665,51 +647,44 @@
      than 60% of the possible ping checks in the last 
      PING_CACHE_TIME, we are in high-load mode, so don't do any more. */
   for (count = 0, r = daemon->ping_results; r; r = r->next)
-    if (difftime(now, r->time) >  (float)PING_CACHE_TIME)
-      victim = r; /* old record */
-    else 
-      {
-	count++;
-	if (r->addr.s_addr == addr.s_addr)
-	  return r;
-      }
-  
+    if (difftime(now, r->time) > (float) PING_CACHE_TIME)
+      victim = r;               /* old record */
+    else {
+      count++;
+      if (r->addr.s_addr == addr.s_addr)
+        return r;
+    }
+
   /* didn't find cached entry */
-  if ((count >= max) || option_bool(OPT_NO_PING) || loopback)
-    {
-      /* overloaded, or configured not to check, loopback interface, return "not in use" */
-      dummy.hash = 0;
-      return &dummy;
+  if ((count >= max) || option_bool(OPT_NO_PING) || loopback) {
+    /* overloaded, or configured not to check, loopback interface, return "not in use" */
+    dummy.hash = 0;
+    return &dummy;
+  } else if (icmp_ping(addr))
+    return NULL;                /* address in use. */
+  else {
+    /* at this point victim may hold an expired record */
+    if (!victim) {
+      if ((victim = whine_malloc(sizeof(struct ping_result)))) {
+        victim->next = daemon->ping_results;
+        daemon->ping_results = victim;
+      }
     }
-  else if (icmp_ping(addr))
-    return NULL; /* address in use. */
-  else
-    {
-      /* at this point victim may hold an expired record */
-      if (!victim)
-	{
-	  if ((victim = whine_malloc(sizeof(struct ping_result))))
-	    {
-	      victim->next = daemon->ping_results;
-	      daemon->ping_results = victim;
-	    }
-	}
-      
-      /* record that this address is OK for 30s 
-	 without more ping checks */
-      if (victim)
-	{
-	  victim->addr = addr;
-	  victim->time = now;
-	  victim->hash = hash;
-	}
-      return victim;
+
+    /* record that this address is OK for 30s
+       without more ping checks */
+    if (victim) {
+      victim->addr = addr;
+      victim->time = now;
+      victim->hash = hash;
     }
+    return victim;
+  }
 }
 
 int address_allocate(struct dhcp_context *context,
-		     struct in_addr *addrp, unsigned char *hwaddr, int hw_len, 
-		     struct dhcp_netid *netids, time_t now, int loopback)   
+                     struct in_addr *addrp, unsigned char *hwaddr, int hw_len,
+                     struct dhcp_netid *netids, time_t now, int loopback)
 {
   /* Find a free address: exclude anything in use and anything allocated to
      a particular hwaddr/clientid/hostname in our configuration.
@@ -718,81 +693,79 @@
   struct in_addr start, addr;
   struct dhcp_context *c, *d;
   int i, pass;
-  unsigned int j; 
+  unsigned int j;
 
   /* hash hwaddr: use the SDBM hashing algorithm.  Seems to give good
-     dispersal even with similarly-valued "strings". */ 
+     dispersal even with similarly-valued "strings". */
   for (j = 0, i = 0; i < hw_len; i++)
     j = hwaddr[i] + (j << 6) + (j << 16) - j;
 
   /* j == 0 is marker */
   if (j == 0)
     j = 1;
-  
+
   for (pass = 0; pass <= 1; pass++)
     for (c = context; c; c = c->current)
       if (c->flags & (CONTEXT_STATIC | CONTEXT_PROXY))
-	continue;
+        continue;
       else if (!match_netid(c->filter, netids, pass))
-	continue;
-      else
-	{
-	  if (option_bool(OPT_CONSEC_ADDR))
-	    /* seed is largest extant lease addr in this context */
-	    start = lease_find_max_addr(c);
-	  else
-	    /* pick a seed based on hwaddr */
-	    start.s_addr = htonl(ntohl(c->start.s_addr) + 
-				 ((j + c->addr_epoch) % (1 + ntohl(c->end.s_addr) - ntohl(c->start.s_addr))));
-
-	  /* iterate until we find a free address. */
-	  addr = start;
-	  
-	  do {
-	    /* eliminate addresses in use by the server. */
-	    for (d = context; d; d = d->current)
-	      if (addr.s_addr == d->router.s_addr)
-		break;
-
-	    /* Addresses which end in .255 and .0 are broken in Windows even when using 
-	       supernetting. ie dhcp-range=192.168.0.1,192.168.1.254,255,255,254.0
-	       then 192.168.0.255 is a valid IP address, but not for Windows as it's
-	       in the class C range. See  KB281579. We therefore don't allocate these 
-	       addresses to avoid hard-to-diagnose problems. Thanks Bill. */	    
-	    if (!d &&
-		!lease_find_by_addr(addr) && 
-		!config_find_by_address(daemon->dhcp_conf, addr) &&
-		(!IN_CLASSC(ntohl(addr.s_addr)) || 
-		 ((ntohl(addr.s_addr) & 0xff) != 0xff && ((ntohl(addr.s_addr) & 0xff) != 0x0))))
-	      {
-		struct ping_result *r;
-		
-		if ((r = do_icmp_ping(now, addr, j, loopback)))
- 		  {
-		    /* consec-ip mode: we offered this address for another client
-		       (different hash) recently, don't offer it to this one. */
-		    if (!option_bool(OPT_CONSEC_ADDR) || r->hash == j)
-		      {
-			*addrp = addr;
-			return 1;
-		      }
-		  }
-		else
-		  {
-		    /* address in use: perturb address selection so that we are
-		       less likely to try this address again. */
-		    if (!option_bool(OPT_CONSEC_ADDR))
-		      c->addr_epoch++;
-		  }
-	      }
-	    
-	    addr.s_addr = htonl(ntohl(addr.s_addr) + 1);
-	    
-	    if (addr.s_addr == htonl(ntohl(c->end.s_addr) + 1))
-	      addr = c->start;
-	    
-	  } while (addr.s_addr != start.s_addr);
-	}
+        continue;
+      else {
+        if (option_bool(OPT_CONSEC_ADDR))
+          /* seed is largest extant lease addr in this context */
+          start = lease_find_max_addr(c);
+        else
+          /* pick a seed based on hwaddr */
+          start.s_addr = htonl(ntohl(c->start.s_addr) +
+                               ((j + c->addr_epoch) % (1 +
+                                                       ntohl(c->end.s_addr) -
+                                                       ntohl(c->start.
+                                                             s_addr))));
+
+        /* iterate until we find a free address. */
+        addr = start;
+
+        do {
+          /* eliminate addresses in use by the server. */
+          for (d = context; d; d = d->current)
+            if (addr.s_addr == d->router.s_addr)
+              break;
+
+          /* Addresses which end in .255 and .0 are broken in Windows even when using
+             supernetting. ie dhcp-range=192.168.0.1,192.168.1.254,255,255,254.0
+             then 192.168.0.255 is a valid IP address, but not for Windows as it's
+             in the class C range. See  KB281579. We therefore don't allocate these
+             addresses to avoid hard-to-diagnose problems. Thanks Bill. */
+          if (!d &&
+              !lease_find_by_addr(addr) &&
+              !config_find_by_address(daemon->dhcp_conf, addr) &&
+              (!IN_CLASSC(ntohl(addr.s_addr)) ||
+               ((ntohl(addr.s_addr) & 0xff) != 0xff
+                && ((ntohl(addr.s_addr) & 0xff) != 0x0)))) {
+            struct ping_result *r;
+
+            if ((r = do_icmp_ping(now, addr, j, loopback))) {
+              /* consec-ip mode: we offered this address for another client
+                 (different hash) recently, don't offer it to this one. */
+              if (!option_bool(OPT_CONSEC_ADDR) || r->hash == j) {
+                *addrp = addr;
+                return 1;
+              }
+            } else {
+              /* address in use: perturb address selection so that we are
+                 less likely to try this address again. */
+              if (!option_bool(OPT_CONSEC_ADDR))
+                c->addr_epoch++;
+            }
+          }
+
+          addr.s_addr = htonl(ntohl(addr.s_addr) + 1);
+
+          if (addr.s_addr == htonl(ntohl(c->end.s_addr) + 1))
+            addr = c->start;
+
+        } while (addr.s_addr != start.s_addr);
+      }
 
   return 0;
 }
@@ -809,150 +782,144 @@
   struct dhcp_config *config;
   int count = 0, lineno = 0;
 
-  addr.s_addr = 0; /* eliminate warning */
-  
-  if (!f)
-    {
-      my_syslog(MS_DHCP | LOG_ERR, _("failed to read %s: %s"), ETHERSFILE, strerror(errno));
-      return;
-    }
+  addr.s_addr = 0;              /* eliminate warning */
+
+  if (!f) {
+    my_syslog(MS_DHCP | LOG_ERR, _("failed to read %s: %s"), ETHERSFILE,
+              strerror(errno));
+    return;
+  }
 
   /* This can be called again on SIGHUP, so remove entries created last time round. */
-  for (up = &daemon->dhcp_conf, config = daemon->dhcp_conf; config; config = tmp)
-    {
-      tmp = config->next;
-      if (config->flags & CONFIG_FROM_ETHERS)
-	{
-	  *up = tmp;
-	  /* cannot have a clid */
-	  if (config->flags & CONFIG_NAME)
-	    free(config->hostname);
-	  free(config->hwaddr);
-	  free(config);
-	}
-      else
-	up = &config->next;
-    }
+  for (up = &daemon->dhcp_conf, config = daemon->dhcp_conf; config;
+       config = tmp) {
+    tmp = config->next;
+    if (config->flags & CONFIG_FROM_ETHERS) {
+      *up = tmp;
+      /* cannot have a clid */
+      if (config->flags & CONFIG_NAME)
+        free(config->hostname);
+      free(config->hwaddr);
+      free(config);
+    } else
+      up = &config->next;
+  }
+
+  while (fgets(buff, MAXDNAME, f)) {
+    char *host = NULL;
+
+    lineno++;
+
+    while (strlen(buff) > 0 && isspace((int) buff[strlen(buff) - 1]))
+      buff[strlen(buff) - 1] = 0;
+
+    if ((*buff == '#') || (*buff == '+') || (*buff == 0))
+      continue;
+
+    for (ip = buff; *ip && !isspace((int) *ip); ip++);
+    for (; *ip && isspace((int) *ip); ip++)
+      *ip = 0;
+    if (!*ip
+        || parse_hex(buff, hwaddr, ETHER_ADDR_LEN, NULL,
+                     NULL) != ETHER_ADDR_LEN) {
+      my_syslog(MS_DHCP | LOG_ERR, _("bad line at %s line %d"), ETHERSFILE,
+                lineno);
+      continue;
+    }
+
+    /* check for name or dotted-quad */
+    for (cp = ip; *cp; cp++)
+      if (!(*cp == '.' || (*cp >= '0' && *cp <= '9')))
+        break;
+
+    if (!*cp) {
+      if ((addr.s_addr = inet_addr(ip)) == (in_addr_t) - 1) {
+        my_syslog(MS_DHCP | LOG_ERR, _("bad address at %s line %d"), ETHERSFILE,
+                  lineno);
+        continue;
+      }
 
-  while (fgets(buff, MAXDNAME, f))
-    {
-      char *host = NULL;
-      
-      lineno++;
-      
-      while (strlen(buff) > 0 && isspace((int)buff[strlen(buff)-1]))
-	buff[strlen(buff)-1] = 0;
-      
-      if ((*buff == '#') || (*buff == '+') || (*buff == 0))
-	continue;
-      
-      for (ip = buff; *ip && !isspace((int)*ip); ip++);
-      for(; *ip && isspace((int)*ip); ip++)
-	*ip = 0;
-      if (!*ip || parse_hex(buff, hwaddr, ETHER_ADDR_LEN, NULL, NULL) != ETHER_ADDR_LEN)
-	{
-	  my_syslog(MS_DHCP | LOG_ERR, _("bad line at %s line %d"), ETHERSFILE, lineno); 
-	  continue;
-	}
-      
-      /* check for name or dotted-quad */
-      for (cp = ip; *cp; cp++)
-	if (!(*cp == '.' || (*cp >='0' && *cp <= '9')))
-	  break;
-      
-      if (!*cp)
-	{
-	  if ((addr.s_addr = inet_addr(ip)) == (in_addr_t)-1)
-	    {
-	      my_syslog(MS_DHCP | LOG_ERR, _("bad address at %s line %d"), ETHERSFILE, lineno); 
-	      continue;
-	    }
-
-	  flags = CONFIG_ADDR;
-	  
-	  for (config = daemon->dhcp_conf; config; config = config->next)
-	    if ((config->flags & CONFIG_ADDR) && config->addr.s_addr == addr.s_addr)
-	      break;
-	}
-      else 
-	{
-	  int nomem;
-	  if (!(host = canonicalise(ip, &nomem)) || !legal_hostname(host))
-	    {
-	      if (!nomem)
-		my_syslog(MS_DHCP | LOG_ERR, _("bad name at %s line %d"), ETHERSFILE, lineno); 
-	      free(host);
-	      continue;
-	    }
-	      
-	  flags = CONFIG_NAME;
-
-	  for (config = daemon->dhcp_conf; config; config = config->next)
-	    if ((config->flags & CONFIG_NAME) && hostname_isequal(config->hostname, host))
-	      break;
-	}
-
-      if (config && (config->flags & CONFIG_FROM_ETHERS))
-	{
-	  my_syslog(MS_DHCP | LOG_ERR, _("ignoring %s line %d, duplicate name or IP address"), ETHERSFILE, lineno); 
-	  continue;
-	}
-	
-      if (!config)
-	{ 
-	  for (config = daemon->dhcp_conf; config; config = config->next)
-	    {
-	      struct hwaddr_config *conf_addr = config->hwaddr;
-	      if (conf_addr && 
-		  conf_addr->next == NULL && 
-		  conf_addr->wildcard_mask == 0 &&
-		  conf_addr->hwaddr_len == ETHER_ADDR_LEN &&
-		  (conf_addr->hwaddr_type == ARPHRD_ETHER || conf_addr->hwaddr_type == 0) &&
-		  memcmp(conf_addr->hwaddr, hwaddr, ETHER_ADDR_LEN) == 0)
-		break;
-	    }
-	  
-	  if (!config)
-	    {
-	      if (!(config = whine_malloc(sizeof(struct dhcp_config))))
-		continue;
-	      config->flags = CONFIG_FROM_ETHERS;
-	      config->hwaddr = NULL;
-	      config->domain = NULL;
-	      config->netid = NULL;
-	      config->next = daemon->dhcp_conf;
-	      daemon->dhcp_conf = config;
-	    }
-	  
-	  config->flags |= flags;
-	  
-	  if (flags & CONFIG_NAME)
-	    {
-	      config->hostname = host;
-	      host = NULL;
-	    }
-	  
-	  if (flags & CONFIG_ADDR)
-	    config->addr = addr;
-	}
-      
-      config->flags |= CONFIG_NOCLID;
-      if (!config->hwaddr)
-	config->hwaddr = whine_malloc(sizeof(struct hwaddr_config));
-      if (config->hwaddr)
-	{
-	  memcpy(config->hwaddr->hwaddr, hwaddr, ETHER_ADDR_LEN);
-	  config->hwaddr->hwaddr_len = ETHER_ADDR_LEN;
-	  config->hwaddr->hwaddr_type = ARPHRD_ETHER;
-	  config->hwaddr->wildcard_mask = 0;
-	  config->hwaddr->next = NULL;
-	}
-      count++;
-      
-      free(host);
+      flags = CONFIG_ADDR;
+
+      for (config = daemon->dhcp_conf; config; config = config->next)
+        if ((config->flags & CONFIG_ADDR) && config->addr.s_addr == addr.s_addr)
+          break;
+    } else {
+      int nomem;
+      if (!(host = canonicalise(ip, &nomem)) || !legal_hostname(host)) {
+        if (!nomem)
+          my_syslog(MS_DHCP | LOG_ERR, _("bad name at %s line %d"), ETHERSFILE,
+                    lineno);
+        free(host);
+        continue;
+      }
 
+      flags = CONFIG_NAME;
+
+      for (config = daemon->dhcp_conf; config; config = config->next)
+        if ((config->flags & CONFIG_NAME)
+            && hostname_isequal(config->hostname, host))
+          break;
+    }
+
+    if (config && (config->flags & CONFIG_FROM_ETHERS)) {
+      my_syslog(MS_DHCP | LOG_ERR,
+                _("ignoring %s line %d, duplicate name or IP address"),
+                ETHERSFILE, lineno);
+      continue;
+    }
+
+    if (!config) {
+      for (config = daemon->dhcp_conf; config; config = config->next) {
+        struct hwaddr_config *conf_addr = config->hwaddr;
+        if (conf_addr &&
+            conf_addr->next == NULL &&
+            conf_addr->wildcard_mask == 0 &&
+            conf_addr->hwaddr_len == ETHER_ADDR_LEN &&
+            (conf_addr->hwaddr_type == ARPHRD_ETHER
+             || conf_addr->hwaddr_type == 0)
+            && memcmp(conf_addr->hwaddr, hwaddr, ETHER_ADDR_LEN) == 0)
+          break;
+      }
+
+      if (!config) {
+        if (!(config = whine_malloc(sizeof(struct dhcp_config))))
+          continue;
+        config->flags = CONFIG_FROM_ETHERS;
+        config->hwaddr = NULL;
+        config->domain = NULL;
+        config->netid = NULL;
+        config->next = daemon->dhcp_conf;
+        daemon->dhcp_conf = config;
+      }
+
+      config->flags |= flags;
+
+      if (flags & CONFIG_NAME) {
+        config->hostname = host;
+        host = NULL;
+      }
+
+      if (flags & CONFIG_ADDR)
+        config->addr = addr;
     }
-  
+
+    config->flags |= CONFIG_NOCLID;
+    if (!config->hwaddr)
+      config->hwaddr = whine_malloc(sizeof(struct hwaddr_config));
+    if (config->hwaddr) {
+      memcpy(config->hwaddr->hwaddr, hwaddr, ETHER_ADDR_LEN);
+      config->hwaddr->hwaddr_len = ETHER_ADDR_LEN;
+      config->hwaddr->hwaddr_type = ARPHRD_ETHER;
+      config->hwaddr->wildcard_mask = 0;
+      config->hwaddr->next = NULL;
+    }
+    count++;
+
+    free(host);
+
+  }
+
   fclose(f);
 
   my_syslog(MS_DHCP | LOG_INFO, _("read %s - %d addresses"), ETHERSFILE, count);
@@ -969,103 +936,98 @@
   struct crec *lookup;
 
   if (daemon->port == 0)
-    return NULL; /* DNS disabled. */
-  
-  lookup = cache_find_by_addr(NULL, (struct all_addr *)&addr, 0, F_IPV4);
-
-  if (lookup && (lookup->flags & F_HOSTS))
-    {
-      char *dot, *hostname = cache_get_name(lookup);
-      dot = strchr(hostname, '.');
-      
-      if (dot && strlen(dot+1) != 0)
-	{
-	  char *d2 = get_domain(addr);
-	  if (!d2 || !hostname_isequal(dot+1, d2))
-	    return NULL; /* wrong domain */
-	}
-
-      if (!legal_hostname(hostname))
-	return NULL;
-      
-      strncpy(daemon->dhcp_buff, hostname, 256);
-      daemon->dhcp_buff[255] = 0;
-      strip_hostname(daemon->dhcp_buff);
+    return NULL;                /* DNS disabled. */
 
-      return daemon->dhcp_buff;
+  lookup = cache_find_by_addr(NULL, (struct all_addr *) &addr, 0, F_IPV4);
+
+  if (lookup && (lookup->flags & F_HOSTS)) {
+    char *dot, *hostname = cache_get_name(lookup);
+    dot = strchr(hostname, '.');
+
+    if (dot && strlen(dot + 1) != 0) {
+      char *d2 = get_domain(addr);
+      if (!d2 || !hostname_isequal(dot + 1, d2))
+        return NULL;            /* wrong domain */
     }
-  
+
+    if (!legal_hostname(hostname))
+      return NULL;
+
+    strncpy(daemon->dhcp_buff, hostname, 256);
+    daemon->dhcp_buff[255] = 0;
+    strip_hostname(daemon->dhcp_buff);
+
+    return daemon->dhcp_buff;
+  }
+
   return NULL;
 }
 
-static int  relay_upstream4(struct dhcp_relay *relay, struct dhcp_packet *mess, size_t sz, int iface_index)
+static int relay_upstream4(struct dhcp_relay *relay, struct dhcp_packet *mess,
+                           size_t sz, int iface_index)
 {
   /* ->local is same value for all relays on ->current chain */
   struct all_addr from;
-  
+
   if (mess->op != BOOTREQUEST)
     return 0;
 
   /* source address == relay address */
   from.addr.addr4 = relay->local.addr.addr4;
-  
+
   /* already gatewayed ? */
-  if (mess->giaddr.s_addr)
-    {
-      /* if so check if by us, to stomp on loops. */
-      if (mess->giaddr.s_addr == relay->local.addr.addr4.s_addr)
-	return 1;
-    }
-  else
-    {
-      /* plug in our address */
-      mess->giaddr.s_addr = relay->local.addr.addr4.s_addr;
-    }
+  if (mess->giaddr.s_addr) {
+    /* if so check if by us, to stomp on loops. */
+    if (mess->giaddr.s_addr == relay->local.addr.addr4.s_addr)
+      return 1;
+  } else {
+    /* plug in our address */
+    mess->giaddr.s_addr = relay->local.addr.addr4.s_addr;
+  }
 
   if ((mess->hops++) > 20)
     return 1;
 
-  for (; relay; relay = relay->current)
-    {
-      union mysockaddr to;
-      
-      to.sa.sa_family = AF_INET;
-      to.in.sin_addr = relay->server.addr.addr4;
-      to.in.sin_port = htons(daemon->dhcp_server_port);
-      
-      send_from(daemon->dhcpfd, 0, (char *)mess, sz, &to, &from, 0);
-      
-      if (option_bool(OPT_LOG_OPTS))
-	{
-	  inet_ntop(AF_INET, &relay->local, daemon->addrbuff, ADDRSTRLEN);
-	  my_syslog(MS_DHCP | LOG_INFO, _("DHCP relay %s -> %s"), daemon->addrbuff, inet_ntoa(relay->server.addr.addr4));
-	}
-      
-      /* Save this for replies */
-      relay->iface_index = iface_index;
+  for (; relay; relay = relay->current) {
+    union mysockaddr to;
+
+    to.sa.sa_family = AF_INET;
+    to.in.sin_addr = relay->server.addr.addr4;
+    to.in.sin_port = htons(daemon->dhcp_server_port);
+
+    send_from(daemon->dhcpfd, 0, (char *) mess, sz, &to, &from, 0);
+
+    if (option_bool(OPT_LOG_OPTS)) {
+      inet_ntop(AF_INET, &relay->local, daemon->addrbuff, ADDRSTRLEN);
+      my_syslog(MS_DHCP | LOG_INFO, _("DHCP relay %s -> %s"), daemon->addrbuff,
+                inet_ntoa(relay->server.addr.addr4));
     }
-  
+
+    /* Save this for replies */
+    relay->iface_index = iface_index;
+  }
+
   return 1;
 }
 
 
-static struct dhcp_relay *relay_reply4(struct dhcp_packet *mess, char *arrival_interface)
+static struct dhcp_relay *relay_reply4(struct dhcp_packet *mess,
+                                       char *arrival_interface)
 {
   struct dhcp_relay *relay;
 
   if (mess->giaddr.s_addr == 0 || mess->op != BOOTREPLY)
     return NULL;
 
-  for (relay = daemon->relay4; relay; relay = relay->next)
-    {
-      if (mess->giaddr.s_addr == relay->local.addr.addr4.s_addr)
-	{
-	  if (!relay->interface || wildcard_match(relay->interface, arrival_interface))
-	    return relay->iface_index != 0 ? relay : NULL;
-	}
+  for (relay = daemon->relay4; relay; relay = relay->next) {
+    if (mess->giaddr.s_addr == relay->local.addr.addr4.s_addr) {
+      if (!relay->interface
+          || wildcard_match(relay->interface, arrival_interface))
+        return relay->iface_index != 0 ? relay : NULL;
     }
-  
-  return NULL;	 
-}     
+  }
+
+  return NULL;
+}
 
 #endif
Index: dnsmasq-2.78/src/dhcp6-protocol.h
===================================================================
--- dnsmasq-2.78.orig/src/dhcp6-protocol.h	2017-10-02 21:13:51.000000000 +0800
+++ dnsmasq-2.78/src/dhcp6-protocol.h	2018-10-29 16:14:19.381440023 +0800
@@ -62,7 +62,7 @@
 #define OPTION6_CLIENT_MAC      79
 
 /* replace this with the real number when allocated.
-   defining this also enables the relevant code. */ 
+   defining this also enables the relevant code. */
 /* #define OPTION6_PREFIX_CLASS    99 */
 
 
@@ -72,4 +72,3 @@
 #define DHCP6NOBINDING   3
 #define DHCP6NOTONLINK   4
 #define DHCP6USEMULTI    5
-
Index: dnsmasq-2.78/src/dhcp6.c
===================================================================
--- dnsmasq-2.78.orig/src/dhcp6.c	2017-10-02 21:13:51.000000000 +0800
+++ dnsmasq-2.78/src/dhcp6.c	2018-10-29 16:14:19.381440023 +0800
@@ -28,10 +28,12 @@
 };
 
 
-static int complete_context6(struct in6_addr *local,  int prefix,
-			     int scope, int if_index, int flags, 
-			     unsigned int preferred, unsigned int valid, void *vparam);
-static int make_duid1(int index, unsigned int type, char *mac, size_t maclen, void *parm); 
+static int complete_context6(struct in6_addr *local, int prefix,
+                             int scope, int if_index, int flags,
+                             unsigned int preferred, unsigned int valid,
+                             void *vparam);
+static int make_duid1(int index, unsigned int type, char *mac, size_t maclen,
+                      void *parm);
 
 void dhcp6_init(void)
 {
@@ -46,33 +48,33 @@
 #if defined(IPV6_TCLASS) && defined(IPTOS_CLASS_CS6)
       setsockopt(fd, IPPROTO_IPV6, IPV6_TCLASS, &class, sizeof(class)) == -1 ||
 #endif
-      setsockopt(fd, IPPROTO_IPV6, IPV6_V6ONLY, &oneopt, sizeof(oneopt)) == -1 ||
-      !fix_fd(fd) ||
-      !set_ipv6pktinfo(fd))
-    die (_("cannot create DHCPv6 socket: %s"), NULL, EC_BADNET);
-  
- /* When bind-interfaces is set, there might be more than one dnsmasq
+      setsockopt(fd, IPPROTO_IPV6, IPV6_V6ONLY, &oneopt, sizeof(oneopt)) == -1
+      || !fix_fd(fd) || !set_ipv6pktinfo(fd))
+    die(_("cannot create DHCPv6 socket: %s"), NULL, EC_BADNET);
+
+  /* When bind-interfaces is set, there might be more than one dnsmasq
      instance binding port 547. That's OK if they serve different networks.
      Need to set REUSEADDR|REUSEPORT to make this possible.
      Handle the case that REUSEPORT is defined, but the kernel doesn't 
      support it. This handles the introduction of REUSEPORT on Linux. */
-  if (option_bool(OPT_NOWILD) || option_bool(OPT_CLEVERBIND))
-    {
-      int rc = 0;
+  if (option_bool(OPT_NOWILD) || option_bool(OPT_CLEVERBIND)) {
+    int rc = 0;
 
 #ifdef SO_REUSEPORT
-      if ((rc = setsockopt(fd, SOL_SOCKET, SO_REUSEPORT, &oneopt, sizeof(oneopt))) == -1 &&
-	  errno == ENOPROTOOPT)
-	rc = 0;
+    if ((rc =
+         setsockopt(fd, SOL_SOCKET, SO_REUSEPORT, &oneopt,
+                    sizeof(oneopt))) == -1 && errno == ENOPROTOOPT)
+      rc = 0;
 #endif
-      
-      if (rc != -1)
-	rc = setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, &oneopt, sizeof(oneopt));
-      
-      if (rc == -1)
-	die(_("failed to set SO_REUSE{ADDR|PORT} on DHCPv6 socket: %s"), NULL, EC_BADNET);
-    }
-  
+
+    if (rc != -1)
+      rc = setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, &oneopt, sizeof(oneopt));
+
+    if (rc == -1)
+      die(_("failed to set SO_REUSE{ADDR|PORT} on DHCPv6 socket: %s"), NULL,
+          EC_BADNET);
+  }
+
   memset(&saddr, 0, sizeof(saddr));
 #ifdef HAVE_SOCKADDR_SA_LEN
   saddr.sin6_len = sizeof(struct sockaddr_in6);
@@ -80,10 +82,10 @@
   saddr.sin6_family = AF_INET6;
   saddr.sin6_addr = in6addr_any;
   saddr.sin6_port = htons(DHCPV6_SERVER_PORT);
-  
-  if (bind(fd, (struct sockaddr *)&saddr, sizeof(struct sockaddr_in6)))
+
+  if (bind(fd, (struct sockaddr *) &saddr, sizeof(struct sockaddr_in6)))
     die(_("failed to bind DHCPv6 server socket: %s"), NULL, EC_BADNET);
-  
+
   daemon->dhcp6fd = fd;
 }
 
@@ -96,11 +98,11 @@
   struct msghdr msg;
   int if_index = 0;
   union {
-    struct cmsghdr align; /* this ensures alignment */
+    struct cmsghdr align;       /* this ensures alignment */
     char control6[CMSG_SPACE(sizeof(struct in6_pktinfo))];
   } control_u;
   struct sockaddr_in6 from;
-  ssize_t sz; 
+  ssize_t sz;
   struct ifreq ifr;
   struct iname *tmp;
   unsigned short port;
@@ -113,149 +115,141 @@
   msg.msg_flags = 0;
   msg.msg_name = &from;
   msg.msg_namelen = sizeof(from);
-  msg.msg_iov =  &daemon->dhcp_packet;
+  msg.msg_iov = &daemon->dhcp_packet;
   msg.msg_iovlen = 1;
-  
+
   if ((sz = recv_dhcp_packet(daemon->dhcp6fd, &msg)) == -1)
     return;
-  
+
   for (cmptr = CMSG_FIRSTHDR(&msg); cmptr; cmptr = CMSG_NXTHDR(&msg, cmptr))
-    if (cmptr->cmsg_level == IPPROTO_IPV6 && cmptr->cmsg_type == daemon->v6pktinfo)
-      {
-	union {
-	  unsigned char *c;
-	  struct in6_pktinfo *p;
-	} p;
-	p.c = CMSG_DATA(cmptr);
-        
-	if_index = p.p->ipi6_ifindex;
-	dst_addr = p.p->ipi6_addr;
-      }
+    if (cmptr->cmsg_level == IPPROTO_IPV6
+        && cmptr->cmsg_type == daemon->v6pktinfo) {
+      union {
+        unsigned char *c;
+        struct in6_pktinfo *p;
+      } p;
+      p.c = CMSG_DATA(cmptr);
+
+      if_index = p.p->ipi6_ifindex;
+      dst_addr = p.p->ipi6_addr;
+    }
 
   if (!indextoname(daemon->dhcp6fd, if_index, ifr.ifr_name))
     return;
 
-  if ((port = relay_reply6(&from, sz, ifr.ifr_name)) == 0)
-    {
-      struct dhcp_bridge *bridge, *alias;
-
-      for (tmp = daemon->if_except; tmp; tmp = tmp->next)
-	if (tmp->name && wildcard_match(tmp->name, ifr.ifr_name))
-	  return;
-      
-      for (tmp = daemon->dhcp_except; tmp; tmp = tmp->next)
-	if (tmp->name && wildcard_match(tmp->name, ifr.ifr_name))
-	  return;
-      
-      parm.current = NULL;
-      parm.relay = NULL;
-      memset(&parm.relay_local, 0, IN6ADDRSZ);
-      parm.ind = if_index;
-      parm.addr_match = 0;
-      memset(&parm.fallback, 0, IN6ADDRSZ);
-      memset(&parm.ll_addr, 0, IN6ADDRSZ);
-      memset(&parm.ula_addr, 0, IN6ADDRSZ);
-
-      /* If the interface on which the DHCPv6 request was received is
-         an alias of some other interface (as specified by the
-         --bridge-interface option), change parm.ind so that we look
-         for DHCPv6 contexts associated with the aliased interface
-         instead of with the aliasing one. */
-      for (bridge = daemon->bridges; bridge; bridge = bridge->next)
-	{
-	  for (alias = bridge->alias; alias; alias = alias->next)
-	    if (wildcard_matchn(alias->iface, ifr.ifr_name, IF_NAMESIZE))
-	      {
-		parm.ind = if_nametoindex(bridge->iface);
-		if (!parm.ind)
-		  {
-		    my_syslog(MS_DHCP | LOG_WARNING,
-			      _("unknown interface %s in bridge-interface"),
-			      bridge->iface);
-		    return;
-		  }
-		break;
-	      }
-	  if (alias)
-	    break;
-	}
-      
-      for (context = daemon->dhcp6; context; context = context->next)
-	if (IN6_IS_ADDR_UNSPECIFIED(&context->start6) && context->prefix == 0)
-	  {
-	    /* wildcard context for DHCP-stateless only */
-	    parm.current = context;
-	    context->current = NULL;
-	  }
-	else
-	  {
-	    /* unlinked contexts are marked by context->current == context */
-	    context->current = context;
-	    memset(&context->local6, 0, IN6ADDRSZ);
-	  }
-
-      for (relay = daemon->relay6; relay; relay = relay->next)
-	relay->current = relay;
-      
-      if (!iface_enumerate(AF_INET6, &parm, complete_context6))
-	return;
-
-      if (daemon->if_names || daemon->if_addrs)
-	{
-	  
-	  for (tmp = daemon->if_names; tmp; tmp = tmp->next)
-	    if (tmp->name && wildcard_match(tmp->name, ifr.ifr_name))
-	      break;
-	  
-	  if (!tmp && !parm.addr_match)
-	    return;
-	}
-      
-      if (parm.relay)
-	{
-	  /* Ignore requests sent to the ALL_SERVERS multicast address for relay when
-	     we're listening there for DHCPv6 server reasons. */
-	  struct in6_addr all_servers;
-	  
-	  inet_pton(AF_INET6, ALL_SERVERS, &all_servers);
-	  
-	  if (!IN6_ARE_ADDR_EQUAL(&dst_addr, &all_servers))
-	    relay_upstream6(parm.relay, sz, &from.sin6_addr, from.sin6_scope_id, now);
-	  return;
-	}
-      
-      /* May have configured relay, but not DHCP server */
-      if (!daemon->doing_dhcp6)
-	return;
-
-      lease_prune(NULL, now); /* lose any expired leases */
-      
-      port = dhcp6_reply(parm.current, if_index, ifr.ifr_name, &parm.fallback, 
-			 &parm.ll_addr, &parm.ula_addr, sz, &from.sin6_addr, now);
-      
-      lease_update_file(now);
-      lease_update_dns(0);
+  if ((port = relay_reply6(&from, sz, ifr.ifr_name)) == 0) {
+    struct dhcp_bridge *bridge, *alias;
+
+    for (tmp = daemon->if_except; tmp; tmp = tmp->next)
+      if (tmp->name && wildcard_match(tmp->name, ifr.ifr_name))
+        return;
+
+    for (tmp = daemon->dhcp_except; tmp; tmp = tmp->next)
+      if (tmp->name && wildcard_match(tmp->name, ifr.ifr_name))
+        return;
+
+    parm.current = NULL;
+    parm.relay = NULL;
+    memset(&parm.relay_local, 0, IN6ADDRSZ);
+    parm.ind = if_index;
+    parm.addr_match = 0;
+    memset(&parm.fallback, 0, IN6ADDRSZ);
+    memset(&parm.ll_addr, 0, IN6ADDRSZ);
+    memset(&parm.ula_addr, 0, IN6ADDRSZ);
+
+    /* If the interface on which the DHCPv6 request was received is
+       an alias of some other interface (as specified by the
+       --bridge-interface option), change parm.ind so that we look
+       for DHCPv6 contexts associated with the aliased interface
+       instead of with the aliasing one. */
+    for (bridge = daemon->bridges; bridge; bridge = bridge->next) {
+      for (alias = bridge->alias; alias; alias = alias->next)
+        if (wildcard_matchn(alias->iface, ifr.ifr_name, IF_NAMESIZE)) {
+          parm.ind = if_nametoindex(bridge->iface);
+          if (!parm.ind) {
+            my_syslog(MS_DHCP | LOG_WARNING,
+                      _("unknown interface %s in bridge-interface"),
+                      bridge->iface);
+            return;
+          }
+          break;
+        }
+      if (alias)
+        break;
+    }
+
+    for (context = daemon->dhcp6; context; context = context->next)
+      if (IN6_IS_ADDR_UNSPECIFIED(&context->start6) && context->prefix == 0) {
+        /* wildcard context for DHCP-stateless only */
+        parm.current = context;
+        context->current = NULL;
+      } else {
+        /* unlinked contexts are marked by context->current == context */
+        context->current = context;
+        memset(&context->local6, 0, IN6ADDRSZ);
+      }
+
+    for (relay = daemon->relay6; relay; relay = relay->next)
+      relay->current = relay;
+
+    if (!iface_enumerate(AF_INET6, &parm, complete_context6))
+      return;
+
+    if (daemon->if_names || daemon->if_addrs) {
+
+      for (tmp = daemon->if_names; tmp; tmp = tmp->next)
+        if (tmp->name && wildcard_match(tmp->name, ifr.ifr_name))
+          break;
+
+      if (!tmp && !parm.addr_match)
+        return;
+    }
+
+    if (parm.relay) {
+      /* Ignore requests sent to the ALL_SERVERS multicast address for relay when
+         we're listening there for DHCPv6 server reasons. */
+      struct in6_addr all_servers;
+
+      inet_pton(AF_INET6, ALL_SERVERS, &all_servers);
+
+      if (!IN6_ARE_ADDR_EQUAL(&dst_addr, &all_servers))
+        relay_upstream6(parm.relay, sz, &from.sin6_addr, from.sin6_scope_id,
+                        now);
+      return;
     }
-			  
+
+    /* May have configured relay, but not DHCP server */
+    if (!daemon->doing_dhcp6)
+      return;
+
+    lease_prune(NULL, now);     /* lose any expired leases */
+
+    port = dhcp6_reply(parm.current, if_index, ifr.ifr_name, &parm.fallback,
+                       &parm.ll_addr, &parm.ula_addr, sz, &from.sin6_addr, now);
+
+    lease_update_file(now);
+    lease_update_dns(0);
+  }
+
   /* The port in the source address of the original request should
      be correct, but at least once client sends from the server port,
      so we explicitly send to the client port to a client, and the
      server port to a relay. */
-  if (port != 0)
-    {
-      from.sin6_port = htons(port);
-      while (retry_send(sendto(daemon->dhcp6fd, daemon->outpacket.iov_base, 
-			       save_counter(0), 0, (struct sockaddr *)&from, 
-			       sizeof(from))));
-    }
+  if (port != 0) {
+    from.sin6_port = htons(port);
+    while (retry_send(sendto(daemon->dhcp6fd, daemon->outpacket.iov_base,
+                             save_counter(0), 0, (struct sockaddr *) &from,
+                             sizeof(from))));
+  }
 }
 
-void get_client_mac(struct in6_addr *client, int iface, unsigned char *mac, unsigned int *maclenp, unsigned int *mactypep, time_t now)
+void get_client_mac(struct in6_addr *client, int iface, unsigned char *mac,
+                    unsigned int *maclenp, unsigned int *mactypep, time_t now)
 {
   /* Receiving a packet from a host does not populate the neighbour
      cache, so we send a neighbour discovery request if we can't 
      find the sender. Repeat a few times in case of packet loss. */
-  
+
   struct neigh_packet neigh;
   union mysockaddr addr;
   int i, maclen;
@@ -266,7 +260,7 @@
   neigh.target = *client;
   /* RFC4443 section-2.3: checksum has to be zero to be calculated */
   neigh.checksum = 0;
-   
+
   memset(&addr, 0, sizeof(addr));
 #ifdef HAVE_SOCKADDR_SA_LEN
   addr.in6.sin6_len = sizeof(struct sockaddr_in6);
@@ -275,143 +269,144 @@
   addr.in6.sin6_port = htons(IPPROTO_ICMPV6);
   addr.in6.sin6_addr = *client;
   addr.in6.sin6_scope_id = iface;
-  
-  for (i = 0; i < 5; i++)
-    {
-      struct timespec ts;
-      
-      if ((maclen = find_mac(&addr, mac, 0, now)) != 0)
-	break;
-	  
-      sendto(daemon->icmp6fd, &neigh, sizeof(neigh), 0, &addr.sa, sizeof(addr));
-      
-      ts.tv_sec = 0;
-      ts.tv_nsec = 100000000; /* 100ms */
-      nanosleep(&ts, NULL);
-    }
+
+  for (i = 0; i < 5; i++) {
+    struct timespec ts;
+
+    if ((maclen = find_mac(&addr, mac, 0, now)) != 0)
+      break;
+
+    sendto(daemon->icmp6fd, &neigh, sizeof(neigh), 0, &addr.sa, sizeof(addr));
+
+    ts.tv_sec = 0;
+    ts.tv_nsec = 100000000;     /* 100ms */
+    nanosleep(&ts, NULL);
+  }
 
   *maclenp = maclen;
   *mactypep = ARPHRD_ETHER;
 }
-    
-static int complete_context6(struct in6_addr *local,  int prefix,
-			     int scope, int if_index, int flags, unsigned int preferred, 
-			     unsigned int valid, void *vparam)
+
+static int complete_context6(struct in6_addr *local, int prefix,
+                             int scope, int if_index, int flags,
+                             unsigned int preferred, unsigned int valid,
+                             void *vparam)
 {
   struct dhcp_context *context;
   struct dhcp_relay *relay;
   struct iface_param *param = vparam;
   struct iname *tmp;
- 
-  (void)scope; /* warning */
-  
-  if (if_index == param->ind)
-    {
-      if (IN6_IS_ADDR_LINKLOCAL(local))
-	param->ll_addr = *local;
-      else if (IN6_IS_ADDR_ULA(local))
-	param->ula_addr = *local;
-
-      if (!IN6_IS_ADDR_LOOPBACK(local) &&
-	  !IN6_IS_ADDR_LINKLOCAL(local) &&
-	  !IN6_IS_ADDR_MULTICAST(local))
-	{
-	  /* if we have --listen-address config, see if the 
-	     arrival interface has a matching address. */
-	  for (tmp = daemon->if_addrs; tmp; tmp = tmp->next)
-	    if (tmp->addr.sa.sa_family == AF_INET6 &&
-		IN6_ARE_ADDR_EQUAL(&tmp->addr.in6.sin6_addr, local))
-	      param->addr_match = 1;
-	  
-	  /* Determine a globally address on the arrival interface, even
-	     if we have no matching dhcp-context, because we're only
-	     allocating on remote subnets via relays. This
-	     is used as a default for the DNS server option. */
-	  param->fallback = *local;
-	  
-	  for (context = daemon->dhcp6; context; context = context->next)
-	    {
-	      if ((context->flags & CONTEXT_DHCP) &&
-		  !(context->flags & (CONTEXT_TEMPLATE | CONTEXT_OLD)) &&
-		  prefix <= context->prefix &&
-		  is_same_net6(local, &context->start6, context->prefix) &&
-		  is_same_net6(local, &context->end6, context->prefix))
-		{
-		  
-		  
-		  /* link it onto the current chain if we've not seen it before */
-		  if (context->current == context)
-		    {
-		      struct dhcp_context *tmp, **up;
-		      
-		      /* use interface values only for constructed contexts */
-		      if (!(context->flags & CONTEXT_CONSTRUCTED))
-			preferred = valid = 0xffffffff;
-		      else if (flags & IFACE_DEPRECATED)
-			preferred = 0;
-		      
-		      if (context->flags & CONTEXT_DEPRECATE)
-			preferred = 0;
-		      
-		      /* order chain, longest preferred time first */
-		      for (up = &param->current, tmp = param->current; tmp; tmp = tmp->current)
-			if (tmp->preferred <= preferred)
-			  break;
-			else
-			  up = &tmp->current;
-		      
-		      context->current = *up;
-		      *up = context;
-		      context->local6 = *local;
-		      context->preferred = preferred;
-		      context->valid = valid;
-		    }
-		}
-	    }
-	}
-
-      for (relay = daemon->relay6; relay; relay = relay->next)
-	if (IN6_ARE_ADDR_EQUAL(local, &relay->local.addr.addr6) && relay->current == relay &&
-	    (IN6_IS_ADDR_UNSPECIFIED(&param->relay_local) || IN6_ARE_ADDR_EQUAL(local, &param->relay_local)))
-	  {
-	    relay->current = param->relay;
-	    param->relay = relay;
-	    param->relay_local = *local;
-	  }
-      
-    }          
- 
- return 1;
+
+  (void) scope;                 /* warning */
+
+  if (if_index == param->ind) {
+    if (IN6_IS_ADDR_LINKLOCAL(local))
+      param->ll_addr = *local;
+    else if (IN6_IS_ADDR_ULA(local))
+      param->ula_addr = *local;
+
+    if (!IN6_IS_ADDR_LOOPBACK(local) &&
+        !IN6_IS_ADDR_LINKLOCAL(local) && !IN6_IS_ADDR_MULTICAST(local)) {
+      /* if we have --listen-address config, see if the
+         arrival interface has a matching address. */
+      for (tmp = daemon->if_addrs; tmp; tmp = tmp->next)
+        if (tmp->addr.sa.sa_family == AF_INET6 &&
+            IN6_ARE_ADDR_EQUAL(&tmp->addr.in6.sin6_addr, local))
+          param->addr_match = 1;
+
+      /* Determine a globally address on the arrival interface, even
+         if we have no matching dhcp-context, because we're only
+         allocating on remote subnets via relays. This
+         is used as a default for the DNS server option. */
+      param->fallback = *local;
+
+      for (context = daemon->dhcp6; context; context = context->next) {
+        if ((context->flags & CONTEXT_DHCP) &&
+            !(context->flags & (CONTEXT_TEMPLATE | CONTEXT_OLD)) &&
+            prefix <= context->prefix &&
+            is_same_net6(local, &context->start6, context->prefix) &&
+            is_same_net6(local, &context->end6, context->prefix)) {
+
+
+          /* link it onto the current chain if we've not seen it before */
+          if (context->current == context) {
+            struct dhcp_context *tmp, **up;
+
+            /* use interface values only for constructed contexts */
+            if (!(context->flags & CONTEXT_CONSTRUCTED))
+              preferred = valid = 0xffffffff;
+            else if (flags & IFACE_DEPRECATED)
+              preferred = 0;
+
+            if (context->flags & CONTEXT_DEPRECATE)
+              preferred = 0;
+
+            /* order chain, longest preferred time first */
+            for (up = &param->current, tmp = param->current; tmp;
+                 tmp = tmp->current)
+              if (tmp->preferred <= preferred)
+                break;
+              else
+                up = &tmp->current;
+
+            context->current = *up;
+            *up = context;
+            context->local6 = *local;
+            context->preferred = preferred;
+            context->valid = valid;
+          }
+        }
+      }
+    }
+
+    for (relay = daemon->relay6; relay; relay = relay->next)
+      if (IN6_ARE_ADDR_EQUAL(local, &relay->local.addr.addr6)
+          && relay->current == relay
+          && (IN6_IS_ADDR_UNSPECIFIED(&param->relay_local)
+              || IN6_ARE_ADDR_EQUAL(local, &param->relay_local))) {
+        relay->current = param->relay;
+        param->relay = relay;
+        param->relay_local = *local;
+      }
+
+  }
+
+  return 1;
 }
 
-struct dhcp_config *config_find_by_address6(struct dhcp_config *configs, struct in6_addr *net, int prefix, u64 addr)
+struct dhcp_config *config_find_by_address6(struct dhcp_config *configs,
+                                            struct in6_addr *net, int prefix,
+                                            u64 addr)
 {
   struct dhcp_config *config;
-  
+
   for (config = configs; config; config = config->next)
     if ((config->flags & CONFIG_ADDR6) &&
-	is_same_net6(&config->addr6, net, prefix) &&
-	(prefix == 128 || addr6part(&config->addr6) == addr))
+        is_same_net6(&config->addr6, net, prefix) &&
+        (prefix == 128 || addr6part(&config->addr6) == addr))
       return config;
-  
+
   return NULL;
 }
 
-struct dhcp_context *address6_allocate(struct dhcp_context *context,  unsigned char *clid, int clid_len, int temp_addr,
-				       int iaid, int serial, struct dhcp_netid *netids, int plain_range, struct in6_addr *ans)   
+struct dhcp_context *address6_allocate(struct dhcp_context *context,
+                                       unsigned char *clid, int clid_len,
+                                       int temp_addr, int iaid, int serial,
+                                       struct dhcp_netid *netids,
+                                       int plain_range, struct in6_addr *ans)
 {
   /* Find a free address: exclude anything in use and anything allocated to
      a particular hwaddr/clientid/hostname in our configuration.
      Try to return from contexts which match netids first. 
-     
+
      Note that we assume the address prefix lengths are 64 or greater, so we can
      get by with 64 bit arithmetic.
-*/
+   */
 
   u64 start, addr;
   struct dhcp_context *c, *d;
   int i, pass;
-  u64 j; 
+  u64 j;
 
   /* hash hwaddr: use the SDBM hashing algorithm.  This works
      for MAC addresses, let's see how it manages with client-ids! 
@@ -421,185 +416,176 @@
   else
     for (j = iaid, i = 0; i < clid_len; i++)
       j = clid[i] + (j << 6) + (j << 16) - j;
-  
+
   for (pass = 0; pass <= plain_range ? 1 : 0; pass++)
     for (c = context; c; c = c->current)
-      if (c->flags & (CONTEXT_DEPRECATE | CONTEXT_STATIC | CONTEXT_RA_STATELESS | CONTEXT_USED))
-	continue;
+      if (c->
+          flags & (CONTEXT_DEPRECATE | CONTEXT_STATIC | CONTEXT_RA_STATELESS |
+                   CONTEXT_USED))
+        continue;
       else if (!match_netid(c->filter, netids, pass))
-	continue;
-      else
-	{ 
-	  if (!temp_addr && option_bool(OPT_CONSEC_ADDR))
-	    /* seed is largest extant lease addr in this context */
-	    start = lease_find_max_addr6(c) + serial;
-	  else
-	    {
-	      u64 range = 1 + addr6part(&c->end6) - addr6part(&c->start6);
-	      u64 offset = j + c->addr_epoch;
-
-	      /* don't divide by zero if range is whole 2^64 */
-	      if (range != 0)
-		offset = offset % range;
-
-	      start = addr6part(&c->start6) + offset;
-	    }
-
-	  /* iterate until we find a free address. */
-	  addr = start;
-	  
-	  do {
-	    /* eliminate addresses in use by the server. */
-	    for (d = context; d; d = d->current)
-	      if (addr == addr6part(&d->local6))
-		break;
-
-	    if (!d &&
-		!lease6_find_by_addr(&c->start6, c->prefix, addr) && 
-		!config_find_by_address6(daemon->dhcp_conf, &c->start6, c->prefix, addr))
-	      {
-		*ans = c->start6;
-		setaddr6part (ans, addr);
-		return c;
-	      }
-	
-	    addr++;
-	    
-	    if (addr  == addr6part(&c->end6) + 1)
-	      addr = addr6part(&c->start6);
-	    
-	  } while (addr != start);
-	}
-	   
+        continue;
+      else {
+        if (!temp_addr && option_bool(OPT_CONSEC_ADDR))
+          /* seed is largest extant lease addr in this context */
+          start = lease_find_max_addr6(c) + serial;
+        else {
+          u64 range = 1 + addr6part(&c->end6) - addr6part(&c->start6);
+          u64 offset = j + c->addr_epoch;
+
+          /* don't divide by zero if range is whole 2^64 */
+          if (range != 0)
+            offset = offset % range;
+
+          start = addr6part(&c->start6) + offset;
+        }
+
+        /* iterate until we find a free address. */
+        addr = start;
+
+        do {
+          /* eliminate addresses in use by the server. */
+          for (d = context; d; d = d->current)
+            if (addr == addr6part(&d->local6))
+              break;
+
+          if (!d &&
+              !lease6_find_by_addr(&c->start6, c->prefix, addr) &&
+              !config_find_by_address6(daemon->dhcp_conf, &c->start6, c->prefix,
+                                       addr)) {
+            *ans = c->start6;
+            setaddr6part(ans, addr);
+            return c;
+          }
+
+          addr++;
+
+          if (addr == addr6part(&c->end6) + 1)
+            addr = addr6part(&c->start6);
+
+        } while (addr != start);
+      }
+
   return NULL;
 }
 
 /* can dynamically allocate addr */
-struct dhcp_context *address6_available(struct dhcp_context *context, 
-					struct in6_addr *taddr,
-					struct dhcp_netid *netids,
-					int plain_range)
+struct dhcp_context *address6_available(struct dhcp_context *context,
+                                        struct in6_addr *taddr,
+                                        struct dhcp_netid *netids,
+                                        int plain_range)
 {
   u64 start, end, addr = addr6part(taddr);
   struct dhcp_context *tmp;
- 
-  for (tmp = context; tmp; tmp = tmp->current)
-    {
-      start = addr6part(&tmp->start6);
-      end = addr6part(&tmp->end6);
-
-      if (!(tmp->flags & (CONTEXT_STATIC | CONTEXT_RA_STATELESS)) &&
-          is_same_net6(&tmp->start6, taddr, tmp->prefix) &&
-	  is_same_net6(&tmp->end6, taddr, tmp->prefix) &&
-	  addr >= start &&
-          addr <= end &&
-          match_netid(tmp->filter, netids, plain_range))
-        return tmp;
-    }
+
+  for (tmp = context; tmp; tmp = tmp->current) {
+    start = addr6part(&tmp->start6);
+    end = addr6part(&tmp->end6);
+
+    if (!(tmp->flags & (CONTEXT_STATIC | CONTEXT_RA_STATELESS)) &&
+        is_same_net6(&tmp->start6, taddr, tmp->prefix) &&
+        is_same_net6(&tmp->end6, taddr, tmp->prefix) &&
+        addr >= start &&
+        addr <= end && match_netid(tmp->filter, netids, plain_range))
+      return tmp;
+  }
 
   return NULL;
 }
 
 /* address OK if configured */
-struct dhcp_context *address6_valid(struct dhcp_context *context, 
-				    struct in6_addr *taddr,
-				    struct dhcp_netid *netids,
-				    int plain_range)
+struct dhcp_context *address6_valid(struct dhcp_context *context,
+                                    struct in6_addr *taddr,
+                                    struct dhcp_netid *netids, int plain_range)
 {
   struct dhcp_context *tmp;
- 
+
   for (tmp = context; tmp; tmp = tmp->current)
     if (is_same_net6(&tmp->start6, taddr, tmp->prefix) &&
-	match_netid(tmp->filter, netids, plain_range))
+        match_netid(tmp->filter, netids, plain_range))
       return tmp;
 
   return NULL;
 }
 
-int config_valid(struct dhcp_config *config, struct dhcp_context *context, struct in6_addr *addr)
+int config_valid(struct dhcp_config *config, struct dhcp_context *context,
+                 struct in6_addr *addr)
 {
   if (!config || !(config->flags & CONFIG_ADDR6))
     return 0;
 
-  if ((config->flags & CONFIG_WILDCARD) && context->prefix == 64)
-    {
-      *addr = context->start6;
-      setaddr6part(addr, addr6part(&config->addr6));
-      return 1;
-    }
-  
-  if (is_same_net6(&context->start6, &config->addr6, context->prefix))
-    {
-      *addr = config->addr6;
-      return 1;
-    }
-  
+  if ((config->flags & CONFIG_WILDCARD) && context->prefix == 64) {
+    *addr = context->start6;
+    setaddr6part(addr, addr6part(&config->addr6));
+    return 1;
+  }
+
+  if (is_same_net6(&context->start6, &config->addr6, context->prefix)) {
+    *addr = config->addr6;
+    return 1;
+  }
+
   return 0;
 }
 
 void make_duid(time_t now)
 {
-  (void)now;
+  (void) now;
 
-  if (daemon->duid_config)
-    {
-      unsigned char *p;
-      
-      daemon->duid = p = safe_malloc(daemon->duid_config_len + 6);
-      daemon->duid_len = daemon->duid_config_len + 6;
-      PUTSHORT(2, p); /* DUID_EN */
-      PUTLONG(daemon->duid_enterprise, p);
-      memcpy(p, daemon->duid_config, daemon->duid_config_len);
-    }
-  else
-    {
-      time_t newnow = 0;
-      
-      /* If we have no persistent lease database, or a non-stable RTC, use DUID_LL (newnow == 0) */
+  if (daemon->duid_config) {
+    unsigned char *p;
+
+    daemon->duid = p = safe_malloc(daemon->duid_config_len + 6);
+    daemon->duid_len = daemon->duid_config_len + 6;
+    PUTSHORT(2, p);             /* DUID_EN */
+    PUTLONG(daemon->duid_enterprise, p);
+    memcpy(p, daemon->duid_config, daemon->duid_config_len);
+  } else {
+    time_t newnow = 0;
+
+    /* If we have no persistent lease database, or a non-stable RTC, use DUID_LL (newnow == 0) */
 #ifndef HAVE_BROKEN_RTC
-      /* rebase epoch to 1/1/2000 */
-      if (!option_bool(OPT_LEASE_RO) || daemon->lease_change_command)
-	newnow = now - 946684800;
-#endif      
-      
-      iface_enumerate(AF_LOCAL, &newnow, make_duid1);
-      
-      if(!daemon->duid)
-	die("Cannot create DHCPv6 server DUID: %s", NULL, EC_MISC);
-    }
+    /* rebase epoch to 1/1/2000 */
+    if (!option_bool(OPT_LEASE_RO) || daemon->lease_change_command)
+      newnow = now - 946684800;
+#endif
+
+    iface_enumerate(AF_LOCAL, &newnow, make_duid1);
+
+    if (!daemon->duid)
+      die("Cannot create DHCPv6 server DUID: %s", NULL, EC_MISC);
+  }
 }
 
-static int make_duid1(int index, unsigned int type, char *mac, size_t maclen, void *parm)
+static int make_duid1(int index, unsigned int type, char *mac, size_t maclen,
+                      void *parm)
 {
   /* create DUID as specified in RFC3315. We use the MAC of the
      first interface we find that isn't loopback or P-to-P and
      has address-type < 256. Address types above 256 are things like 
      tunnels which don't have usable MAC addresses. */
-  
+
   unsigned char *p;
-  (void)index;
-  (void)parm;
-  time_t newnow = *((time_t *)parm);
-  
+  (void) index;
+  (void) parm;
+  time_t newnow = *((time_t *) parm);
+
   if (type >= 256)
     return 1;
 
-  if (newnow == 0)
-    {
-      daemon->duid = p = safe_malloc(maclen + 4);
-      daemon->duid_len = maclen + 4;
-      PUTSHORT(3, p); /* DUID_LL */
-      PUTSHORT(type, p); /* address type */
-    }
-  else
-    {
-      daemon->duid = p = safe_malloc(maclen + 8);
-      daemon->duid_len = maclen + 8;
-      PUTSHORT(1, p); /* DUID_LLT */
-      PUTSHORT(type, p); /* address type */
-      PUTLONG(*((time_t *)parm), p); /* time */
-    }
-  
+  if (newnow == 0) {
+    daemon->duid = p = safe_malloc(maclen + 4);
+    daemon->duid_len = maclen + 4;
+    PUTSHORT(3, p);             /* DUID_LL */
+    PUTSHORT(type, p);          /* address type */
+  } else {
+    daemon->duid = p = safe_malloc(maclen + 8);
+    daemon->duid_len = maclen + 8;
+    PUTSHORT(1, p);             /* DUID_LLT */
+    PUTSHORT(type, p);          /* address type */
+    PUTLONG(*((time_t *) parm), p);     /* time */
+  }
+
   memcpy(p, mac, maclen);
 
   return 0;
@@ -610,24 +596,23 @@
   int newone, newname;
 };
 
-static int construct_worker(struct in6_addr *local, int prefix, 
-			    int scope, int if_index, int flags, 
-			    int preferred, int valid, void *vparam)
+static int construct_worker(struct in6_addr *local, int prefix,
+                            int scope, int if_index, int flags,
+                            int preferred, int valid, void *vparam)
 {
   char ifrn_name[IFNAMSIZ];
   struct in6_addr start6, end6;
   struct dhcp_context *template, *context;
 
-  (void)scope;
-  (void)flags;
-  (void)valid;
-  (void)preferred;
+  (void) scope;
+  (void) flags;
+  (void) valid;
+  (void) preferred;
 
   struct cparam *param = vparam;
 
   if (IN6_IS_ADDR_LOOPBACK(local) ||
-      IN6_IS_ADDR_LINKLOCAL(local) ||
-      IN6_IS_ADDR_MULTICAST(local))
+      IN6_IS_ADDR_LINKLOCAL(local) || IN6_IS_ADDR_MULTICAST(local))
     return 1;
 
   if (!(flags & IFACE_PERMANENT))
@@ -638,81 +623,74 @@
 
   if (!indextoname(daemon->icmp6fd, if_index, ifrn_name))
     return 0;
-  
+
   for (template = daemon->dhcp6; template; template = template->next)
-    if (!(template->flags & CONTEXT_TEMPLATE))
-      {
-	/* non-template entries, just fill in interface and local addresses */
-	if (prefix <= template->prefix &&
-	    is_same_net6(local, &template->start6, template->prefix) &&
-	    is_same_net6(local, &template->end6, template->prefix))
-	  {
-	    template->if_index = if_index;
-	    template->local6 = *local;
-	  }
-	
+    if (!(template->flags & CONTEXT_TEMPLATE)) {
+      /* non-template entries, just fill in interface and local addresses */
+      if (prefix <= template->prefix &&
+          is_same_net6(local, &template->start6, template->prefix) &&
+          is_same_net6(local, &template->end6, template->prefix)) {
+        template->if_index = if_index;
+        template->local6 = *local;
       }
-    else if (wildcard_match(template->template_interface, ifrn_name) &&
-	     template->prefix >= prefix)
-      {
-	start6 = *local;
-	setaddr6part(&start6, addr6part(&template->start6));
-	end6 = *local;
-	setaddr6part(&end6, addr6part(&template->end6));
-	
-	for (context = daemon->dhcp6; context; context = context->next)
-	  if ((context->flags & CONTEXT_CONSTRUCTED) &&
-	      IN6_ARE_ADDR_EQUAL(&start6, &context->start6) &&
-	      IN6_ARE_ADDR_EQUAL(&end6, &context->end6))
-	    {
-	      int flags = context->flags;
-	      context->flags &= ~(CONTEXT_GC | CONTEXT_OLD);
-	      if (flags & CONTEXT_OLD)
-		{
-		  /* address went, now it's back */
-		  log_context(AF_INET6, context); 
-		  /* fast RAs for a while */
-		  ra_start_unsolicited(param->now, context);
-		  param->newone = 1; 
-		  /* Add address to name again */
-		  if (context->flags & CONTEXT_RA_NAME)
-		    param->newname = 1;
-		}
-	      break;
-	    }
-	
-	if (!context && (context = whine_malloc(sizeof (struct dhcp_context))))
-	  {
-	    *context = *template;
-	    context->start6 = start6;
-	    context->end6 = end6;
-	    context->flags &= ~CONTEXT_TEMPLATE;
-	    context->flags |= CONTEXT_CONSTRUCTED;
-	    context->if_index = if_index;
-	    context->local6 = *local;
-	    context->saved_valid = 0;
-	    
-	    context->next = daemon->dhcp6;
-	    daemon->dhcp6 = context;
-
-	    ra_start_unsolicited(param->now, context);
-	    /* we created a new one, need to call
-	       lease_update_file to get periodic functions called */
-	    param->newone = 1; 
-
-	    /* Will need to add new putative SLAAC addresses to existing leases */
-	    if (context->flags & CONTEXT_RA_NAME)
-	      param->newname = 1;
-	    
-	    log_context(AF_INET6, context);
-	  } 
+
+    } else if (wildcard_match(template->template_interface, ifrn_name) &&
+               template->prefix >= prefix) {
+      start6 = *local;
+      setaddr6part(&start6, addr6part(&template->start6));
+      end6 = *local;
+      setaddr6part(&end6, addr6part(&template->end6));
+
+      for (context = daemon->dhcp6; context; context = context->next)
+        if ((context->flags & CONTEXT_CONSTRUCTED) &&
+            IN6_ARE_ADDR_EQUAL(&start6, &context->start6) &&
+            IN6_ARE_ADDR_EQUAL(&end6, &context->end6)) {
+          int flags = context->flags;
+          context->flags &= ~(CONTEXT_GC | CONTEXT_OLD);
+          if (flags & CONTEXT_OLD) {
+            /* address went, now it's back */
+            log_context(AF_INET6, context);
+            /* fast RAs for a while */
+            ra_start_unsolicited(param->now, context);
+            param->newone = 1;
+            /* Add address to name again */
+            if (context->flags & CONTEXT_RA_NAME)
+              param->newname = 1;
+          }
+          break;
+        }
+
+      if (!context && (context = whine_malloc(sizeof(struct dhcp_context)))) {
+        *context = *template;
+        context->start6 = start6;
+        context->end6 = end6;
+        context->flags &= ~CONTEXT_TEMPLATE;
+        context->flags |= CONTEXT_CONSTRUCTED;
+        context->if_index = if_index;
+        context->local6 = *local;
+        context->saved_valid = 0;
+
+        context->next = daemon->dhcp6;
+        daemon->dhcp6 = context;
+
+        ra_start_unsolicited(param->now, context);
+        /* we created a new one, need to call
+           lease_update_file to get periodic functions called */
+        param->newone = 1;
+
+        /* Will need to add new putative SLAAC addresses to existing leases */
+        if (context->flags & CONTEXT_RA_NAME)
+          param->newname = 1;
+
+        log_context(AF_INET6, context);
       }
-  
+    }
+
   return 1;
 }
 
 void dhcp_construct_contexts(time_t now)
-{ 
+{
   struct dhcp_context *context, *tmp, **up;
   struct cparam param;
   param.newone = 0;
@@ -722,62 +700,51 @@
   for (context = daemon->dhcp6; context; context = context->next)
     if (context->flags & CONTEXT_CONSTRUCTED)
       context->flags |= CONTEXT_GC;
-   
+
   iface_enumerate(AF_INET6, &param, construct_worker);
 
-  for (up = &daemon->dhcp6, context = daemon->dhcp6; context; context = tmp)
-    {
-      
-      tmp = context->next; 
-     
-      if (context->flags & CONTEXT_GC && !(context->flags & CONTEXT_OLD))
-	{
-	  if ((context->flags & CONTEXT_RA) || option_bool(OPT_RA))
-	    {
-	      /* previously constructed context has gone. advertise it's demise */
-	      context->flags |= CONTEXT_OLD;
-	      context->address_lost_time = now;
-	      /* Apply same ceiling of configured lease time as in radv.c */
-	      if (context->saved_valid > context->lease_time)
-		context->saved_valid = context->lease_time;
-	      /* maximum time is 2 hours, from RFC */
-	      if (context->saved_valid > 7200) /* 2 hours */
-		context->saved_valid = 7200;
-	      ra_start_unsolicited(now, context);
-	      param.newone = 1; /* include deletion */ 
-	      
-	      if (context->flags & CONTEXT_RA_NAME)
-		param.newname = 1; 
-			      
-	      log_context(AF_INET6, context);
-	      
-	      up = &context->next;
-	    }
-	  else
-	    {
-	      /* we were never doing RA for this, so free now */
-	      *up = context->next;
-	      free(context);
-	    }
-	}
-      else
-	 up = &context->next;
-    }
-  
-  if (param.newone)
-    {
-      if (daemon->dhcp || daemon->doing_dhcp6)
-	{
-	  if (param.newname)
-	    lease_update_slaac(now);
-	  lease_update_file(now);
-	}
-      else 
-	/* Not doing DHCP, so no lease system, manage alarms for ra only */
-	send_alarm(periodic_ra(now), now);
-    }
-}
+  for (up = &daemon->dhcp6, context = daemon->dhcp6; context; context = tmp) {
 
-#endif
+    tmp = context->next;
 
+    if (context->flags & CONTEXT_GC && !(context->flags & CONTEXT_OLD)) {
+      if ((context->flags & CONTEXT_RA) || option_bool(OPT_RA)) {
+        /* previously constructed context has gone. advertise it's demise */
+        context->flags |= CONTEXT_OLD;
+        context->address_lost_time = now;
+        /* Apply same ceiling of configured lease time as in radv.c */
+        if (context->saved_valid > context->lease_time)
+          context->saved_valid = context->lease_time;
+        /* maximum time is 2 hours, from RFC */
+        if (context->saved_valid > 7200)        /* 2 hours */
+          context->saved_valid = 7200;
+        ra_start_unsolicited(now, context);
+        param.newone = 1;       /* include deletion */
+
+        if (context->flags & CONTEXT_RA_NAME)
+          param.newname = 1;
+
+        log_context(AF_INET6, context);
+
+        up = &context->next;
+      } else {
+        /* we were never doing RA for this, so free now */
+        *up = context->next;
+        free(context);
+      }
+    } else
+      up = &context->next;
+  }
+
+  if (param.newone) {
+    if (daemon->dhcp || daemon->doing_dhcp6) {
+      if (param.newname)
+        lease_update_slaac(now);
+      lease_update_file(now);
+    } else
+      /* Not doing DHCP, so no lease system, manage alarms for ra only */
+      send_alarm(periodic_ra(now), now);
+  }
+}
 
+#endif
Index: dnsmasq-2.78/src/dns-protocol.h
===================================================================
--- dnsmasq-2.78.orig/src/dns-protocol.h	2017-10-02 21:13:51.000000000 +0800
+++ dnsmasq-2.78/src/dns-protocol.h	2018-10-29 16:14:19.385440023 +0800
@@ -21,29 +21,29 @@
 #define IN6ADDRSZ       16
 #define INADDRSZ        4
 
-#define PACKETSZ	512		/* maximum packet size */
-#define MAXDNAME	1025		/* maximum presentation domain name */
-#define RRFIXEDSZ	10		/* #/bytes of fixed data in r record */
-#define MAXLABEL        63              /* maximum length of domain label */
-
-#define NOERROR		0		/* no error */
-#define FORMERR		1		/* format error */
-#define SERVFAIL	2		/* server failure */
-#define NXDOMAIN	3		/* non existent domain */
-#define NOTIMP		4		/* not implemented */
-#define REFUSED		5		/* query refused */
-
-#define QUERY           0               /* opcode */
-
-#define C_IN            1               /* the arpa internet */
-#define C_CHAOS         3               /* for chaos net (MIT) */
-#define C_HESIOD        4               /* hesiod */
-#define C_ANY           255             /* wildcard match */
+#define PACKETSZ	512     /* maximum packet size */
+#define MAXDNAME	1025    /* maximum presentation domain name */
+#define RRFIXEDSZ	10      /* #/bytes of fixed data in r record */
+#define MAXLABEL        63      /* maximum length of domain label */
+
+#define NOERROR		0       /* no error */
+#define FORMERR		1       /* format error */
+#define SERVFAIL	2       /* server failure */
+#define NXDOMAIN	3       /* non existent domain */
+#define NOTIMP		4       /* not implemented */
+#define REFUSED		5       /* query refused */
+
+#define QUERY           0       /* opcode */
+
+#define C_IN            1       /* the arpa internet */
+#define C_CHAOS         3       /* for chaos net (MIT) */
+#define C_HESIOD        4       /* hesiod */
+#define C_ANY           255     /* wildcard match */
 
 #define T_A		1
 #define T_NS            2
 #define T_MD            3
-#define T_MF            4             
+#define T_MF            4
 #define T_CNAME		5
 #define T_SOA		6
 #define T_MB            7
@@ -70,32 +70,32 @@
 #define T_NSEC          47
 #define T_DNSKEY        48
 #define T_NSEC3         50
-#define	T_TKEY		249		
+#define	T_TKEY		249
 #define	T_TSIG		250
 #define T_AXFR          252
-#define T_MAILB		253	
+#define T_MAILB		253
 #define T_ANY		255
 
-#define EDNS0_OPTION_MAC            65001 /* dyndns.org temporary assignment */
-#define EDNS0_OPTION_CLIENT_SUBNET  8     /* IANA */
-#define EDNS0_OPTION_NOMDEVICEID    65073 /* Nominum temporary assignment */
-#define EDNS0_OPTION_NOMCPEID       65074 /* Nominum temporary assignment */
+#define EDNS0_OPTION_MAC            65001       /* dyndns.org temporary assignment */
+#define EDNS0_OPTION_CLIENT_SUBNET  8   /* IANA */
+#define EDNS0_OPTION_NOMDEVICEID    65073       /* Nominum temporary assignment */
+#define EDNS0_OPTION_NOMCPEID       65074       /* Nominum temporary assignment */
 
 struct dns_header {
   u16 id;
-  u8  hb3,hb4;
-  u16 qdcount,ancount,nscount,arcount;
+  u8 hb3, hb4;
+  u16 qdcount, ancount, nscount, arcount;
 };
 
-#define HB3_QR       0x80 /* Query */
+#define HB3_QR       0x80       /* Query */
 #define HB3_OPCODE   0x78
-#define HB3_AA       0x04 /* Authoritative Answer */
-#define HB3_TC       0x02 /* TrunCated */
-#define HB3_RD       0x01 /* Recursion Desired */
-
-#define HB4_RA       0x80 /* Recursion Available */
-#define HB4_AD       0x20 /* Authenticated Data */
-#define HB4_CD       0x10 /* Checking Disabled */
+#define HB3_AA       0x04       /* Authoritative Answer */
+#define HB3_TC       0x02       /* TrunCated */
+#define HB3_RD       0x01       /* Recursion Desired */
+
+#define HB4_RA       0x80       /* Recursion Available */
+#define HB4_AD       0x20       /* Authenticated Data */
+#define HB4_CD       0x10       /* Checking Disabled */
 #define HB4_RCODE    0x0f
 
 #define OPCODE(x)          (((x)->hb3 & HB3_OPCODE) >> 3)
@@ -103,7 +103,7 @@
 
 #define RCODE(x)           ((x)->hb4 & HB4_RCODE)
 #define SET_RCODE(x, code) (x)->hb4 = ((x)->hb4 & ~HB4_RCODE) | code
-  
+
 #define GETSHORT(s, cp) { \
 	unsigned char *t_cp = (unsigned char *)(cp); \
 	(s) = ((u16)t_cp[0] << 8) \
Index: dnsmasq-2.78/src/dnsmasq.h
===================================================================
--- dnsmasq-2.78.orig/src/dnsmasq.h	2017-10-02 21:13:51.000000000 +0800
+++ dnsmasq-2.78/src/dnsmasq.h	2018-10-29 16:14:19.389440023 +0800
@@ -19,36 +19,36 @@
 /* We do defines that influence behavior of stdio.h, so complain
    if included too early. */
 #ifdef _STDIO_H
-#  error "Header file stdio.h included too early!"
-#endif 
+#error "Header file stdio.h included too early!"
+#endif
 
 #ifndef NO_LARGEFILE
 /* Ensure we can use files >2GB (log files may grow this big) */
-#  define _LARGEFILE_SOURCE 1
-#  define _FILE_OFFSET_BITS 64
+#define _LARGEFILE_SOURCE 1
+#define _FILE_OFFSET_BITS 64
 #endif
 
 /* Get linux C library versions and define _GNU_SOURCE for kFreeBSD. */
 #if defined(__linux__) || defined(__GLIBC__)
-#  ifndef __ANDROID__
-#      define _GNU_SOURCE
-#  endif
-#  include <features.h> 
+#ifndef __ANDROID__
+#define _GNU_SOURCE
+#endif
+#include <features.h>
 #endif
 
 /* Need these defined early */
 #if defined(__sun) || defined(__sun__)
-#  define _XPG4_2
-#  define __EXTENSIONS__
+#define _XPG4_2
+#define __EXTENSIONS__
 #endif
 
 /* get these before config.h  for IPv6 stuff... */
-#include <sys/types.h> 
+#include <sys/types.h>
 #include <sys/socket.h>
 
 #ifdef __APPLE__
 /* Define before netinet/in.h to select API. OSX Lion onwards. */
-#  define __APPLE_USE_RFC_3542
+#define __APPLE_USE_RFC_3542
 #endif
 #include <netinet/in.h>
 
@@ -75,18 +75,18 @@
 
 #define gettext_noop(S) (S)
 #ifndef LOCALEDIR
-#  define _(S) (S)
+#define _(S) (S)
 #else
-#  include <libintl.h>
-#  include <locale.h>   
-#  define _(S) gettext(S)
+#include <libintl.h>
+#include <locale.h>
+#define _(S) gettext(S)
 #endif
 
 #include <arpa/inet.h>
 #include <sys/stat.h>
 #include <sys/ioctl.h>
 #if defined(HAVE_SOLARIS_NETWORK)
-#  include <sys/sockio.h>
+#include <sys/sockio.h>
 #endif
 #include <sys/poll.h>
 #include <sys/wait.h>
@@ -96,7 +96,7 @@
 #include <net/if.h>
 #if defined(HAVE_SOLARIS_NETWORK) && !defined(ifr_mtu)
 /* Some solaris net/if./h omit this. */
-#  define ifr_mtu  ifr_ifru.ifru_metric
+#define ifr_mtu  ifr_ifru.ifru_metric
 #endif
 #include <unistd.h>
 #include <stdio.h>
@@ -112,9 +112,9 @@
 #include <grp.h>
 #include <stdarg.h>
 #if defined(__OpenBSD__) || defined(__NetBSD__) || defined(__sun__) || defined (__sun) || defined (__ANDROID__)
-#  include <netinet/if_ether.h>
+#include <netinet/if_ether.h>
 #else
-#  include <net/ethernet.h>
+#include <net/ethernet.h>
 #endif
 #include <net/if_arp.h>
 #include <netinet/in_systm.h>
@@ -124,7 +124,7 @@
 #include <syslog.h>
 #include <dirent.h>
 #ifndef HAVE_LINUX_NETWORK
-#  include <net/if_dl.h>
+#include <net/if_dl.h>
 #endif
 
 #if defined(HAVE_LINUX_NETWORK)
@@ -213,7 +213,7 @@
 #define OPT_LEASE_RO       22
 #define OPT_ALL_SERVERS    23
 #define OPT_RELOAD         24
-#define OPT_LOCAL_REBIND   25  
+#define OPT_LOCAL_REBIND   25
 #define OPT_TFTP_SECURE    26
 #define OPT_TFTP_NOBLOCK   27
 #define OPT_LOG_OPTS       28
@@ -236,7 +236,7 @@
 #define OPT_DNSSEC_VALID   45
 #define OPT_DNSSEC_TIME    46
 #define OPT_DNSSEC_DEBUG   47
-#define OPT_DNSSEC_NO_SIGN 48 
+#define OPT_DNSSEC_NO_SIGN 48
 #define OPT_LOCAL_SERVICE  49
 #define OPT_LOOP_DETECT    50
 #define OPT_EXTRALOG       51
@@ -262,11 +262,11 @@
     /* for log_query */
     struct {
       unsigned short keytag, algo, digest;
-    } log; 
+    } log;
     /* for cache_insert of DNSKEY, DS */
     struct {
       unsigned short class, type;
-    } dnssec;      
+    } dnssec;
   } addr;
 };
 
@@ -321,7 +321,7 @@
   int ttl, flag;
   char *alias, *target;
   struct cname *next, *targetp;
-}; 
+};
 
 struct ds_config {
   char *name, *digest;
@@ -335,7 +335,7 @@
 
 struct addrlist {
   struct all_addr addr;
-  int flags, prefixlen; 
+  int flags, prefixlen;
   struct addrlist *next;
 };
 
@@ -369,16 +369,16 @@
 };
 
 struct interface_name {
-  char *name; /* domain name */
-  char *intr; /* interface name */
-  int family; /* AF_INET, AF_INET6 or zero for both */
+  char *name;                   /* domain name */
+  char *intr;                   /* interface name */
+  int family;                   /* AF_INET, AF_INET6 or zero for both */
   struct addrlist *addr;
   struct interface_name *next;
 };
 
 union bigname {
   char name[MAXDNAME];
-  union bigname *next; /* freelist */
+  union bigname *next;          /* freelist */
 };
 
 struct blockdata {
@@ -386,33 +386,33 @@
   unsigned char key[KEYBLOCK_LEN];
 };
 
-struct crec { 
+struct crec {
   struct crec *next, *prev, *hash_next;
   /* union is 16 bytes when doing IPv6, 8 bytes on 32 bit machines without IPv6 */
   union {
     struct all_addr addr;
     struct {
       union {
-	struct crec *cache;
-	struct interface_name *int_name;
+        struct crec *cache;
+        struct interface_name *int_name;
       } target;
-      unsigned int uid; /* 0 if union is interface-name */
+      unsigned int uid;         /* 0 if union is interface-name */
     } cname;
     struct {
       struct blockdata *keydata;
       unsigned short keylen, flags, keytag;
       unsigned char algo;
-    } key; 
+    } key;
     struct {
       struct blockdata *keydata;
       unsigned short keylen, keytag;
       unsigned char algo;
-      unsigned char digest; 
-    } ds; 
+      unsigned char digest;
+    } ds;
   } addr;
-  time_t ttd; /* time to die */
+  time_t ttd;                   /* time to die */
   /* used as class if DNSKEY/DS, index to source for F_HOSTS */
-  unsigned int uid; 
+  unsigned int uid;
   unsigned short flags;
   union {
     char sname[SMALLDNAME];
@@ -426,7 +426,7 @@
 #define F_REVERSE   (1u<<2)
 #define F_FORWARD   (1u<<3)
 #define F_DHCP      (1u<<4)
-#define F_NEG       (1u<<5)       
+#define F_NEG       (1u<<5)
 #define F_HOSTS     (1u<<6)
 #define F_IPV4      (1u<<7)
 #define F_IPV6      (1u<<8)
@@ -477,28 +477,28 @@
 #define IFACE_PERMANENT   4
 
 
-#define SERV_FROM_RESOLV       1  /* 1 for servers from resolv, 0 for command line. */
-#define SERV_NO_ADDR           2  /* no server, this domain is local only */
-#define SERV_LITERAL_ADDRESS   4  /* addr is the answer, not the server */ 
-#define SERV_HAS_DOMAIN        8  /* server for one domain only */
-#define SERV_HAS_SOURCE       16  /* source address defined */
-#define SERV_FOR_NODOTS       32  /* server for names with no domain part only */
-#define SERV_WARNED_RECURSIVE 64  /* avoid warning spam */
-#define SERV_FROM_DBUS       128  /* 1 if source is DBus */
-#define SERV_MARK            256  /* for mark-and-delete */
+#define SERV_FROM_RESOLV       1        /* 1 for servers from resolv, 0 for command line. */
+#define SERV_NO_ADDR           2        /* no server, this domain is local only */
+#define SERV_LITERAL_ADDRESS   4        /* addr is the answer, not the server */
+#define SERV_HAS_DOMAIN        8        /* server for one domain only */
+#define SERV_HAS_SOURCE       16        /* source address defined */
+#define SERV_FOR_NODOTS       32        /* server for names with no domain part only */
+#define SERV_WARNED_RECURSIVE 64        /* avoid warning spam */
+#define SERV_FROM_DBUS       128        /* 1 if source is DBus */
+#define SERV_MARK            256        /* for mark-and-delete */
 #define SERV_TYPE    (SERV_HAS_DOMAIN | SERV_FOR_NODOTS)
-#define SERV_COUNTED         512  /* workspace for log code */
-#define SERV_USE_RESOLV     1024  /* forward this domain in the normal way */
-#define SERV_NO_REBIND      2048  /* inhibit dns-rebind protection */
-#define SERV_FROM_FILE      4096  /* read from --servers-file */
-#define SERV_LOOP           8192  /* server causes forwarding loop */
-#define SERV_DO_DNSSEC     16384  /* Validate DNSSEC when using this server */
-#define SERV_GOT_TCP       32768  /* Got some data from the TCP connection */
+#define SERV_COUNTED         512        /* workspace for log code */
+#define SERV_USE_RESOLV     1024        /* forward this domain in the normal way */
+#define SERV_NO_REBIND      2048        /* inhibit dns-rebind protection */
+#define SERV_FROM_FILE      4096        /* read from --servers-file */
+#define SERV_LOOP           8192        /* server causes forwarding loop */
+#define SERV_DO_DNSSEC     16384        /* Validate DNSSEC when using this server */
+#define SERV_GOT_TCP       32768        /* Got some data from the TCP connection */
 
 struct serverfd {
   int fd;
   union mysockaddr source_addr;
-  char interface[IF_NAMESIZE+1];
+  char interface[IF_NAMESIZE + 1];
   unsigned int ifindex, used;
   struct serverfd *next;
 };
@@ -507,18 +507,18 @@
   int fd;
   unsigned short refcount, family;
 };
-  
+
 struct server {
   union mysockaddr addr, source_addr;
-  char interface[IF_NAMESIZE+1];
-  struct serverfd *sfd; 
-  char *domain; /* set if this server only handles a domain. */ 
+  char interface[IF_NAMESIZE + 1];
+  struct serverfd *sfd;
+  char *domain;                 /* set if this server only handles a domain. */
   int flags, tcpfd, edns_pktsz;
   unsigned int queries, failed_queries;
 #ifdef HAVE_LOOP
   u32 uid;
 #endif
-  struct server *next; 
+  struct server *next;
 };
 
 struct ipsets {
@@ -529,15 +529,16 @@
 
 struct irec {
   union mysockaddr addr;
-  struct in_addr netmask; /* only valid for IPv4 */
-  int tftp_ok, dhcp_ok, mtu, done, warned, dad, dns_auth, index, multicast_done, found, label;
-  char *name; 
+  struct in_addr netmask;       /* only valid for IPv4 */
+  int tftp_ok, dhcp_ok, mtu, done, warned, dad, dns_auth, index, multicast_done,
+      found, label;
+  char *name;
   struct irec *next;
 };
 
 struct listener {
   int fd, tcpfd, tftpfd, family;
-  struct irec *iface; /* only sometimes valid for non-wildcard */
+  struct irec *iface;           /* only sometimes valid for non-wildcard */
   struct listener *next;
 };
 
@@ -563,8 +564,8 @@
   time_t mtime;
   char *name;
 #ifdef HAVE_INOTIFY
-  int wd; /* inotify watch descriptor */
-  char *file; /* pointer to file part if path */
+  int wd;                       /* inotify watch descriptor */
+  char *file;                   /* pointer to file part if path */
 #endif
 };
 
@@ -580,9 +581,9 @@
   int flags;
   char *fname;
 #ifdef HAVE_INOTIFY
-  int wd; /* inotify watch descriptor */
+  int wd;                       /* inotify watch descriptor */
 #endif
-  unsigned int index; /* matches to cache entries for logging */
+  unsigned int index;           /* matches to cache entries for logging */
 };
 
 
@@ -606,10 +607,10 @@
 #define FREC_DO_QUESTION       64
 #define FREC_ADDED_PHEADER    128
 #define FREC_TEST_PKTSZ       256
-#define FREC_HAS_EXTRADATA    512        
+#define FREC_HAS_EXTRADATA    512
 
 #ifdef HAVE_DNSSEC
-#define HASH_SIZE 20 /* SHA-1 digest size */
+#define HASH_SIZE 20            /* SHA-1 digest size */
 #else
 #define HASH_SIZE sizeof(int)
 #endif
@@ -617,7 +618,7 @@
 struct frec {
   union mysockaddr source;
   struct all_addr dest;
-  struct server *sentto; /* NULL means free */
+  struct server *sentto;        /* NULL means free */
   struct randfd *rfd4;
 #ifdef HAVE_IPV6
   struct randfd *rfd6;
@@ -627,12 +628,12 @@
   int log_id, fd, forwardall, flags;
   time_t time;
   unsigned char *hash[HASH_SIZE];
-#ifdef HAVE_DNSSEC 
+#ifdef HAVE_DNSSEC
   int class, work_counter;
-  struct blockdata *stash; /* Saved reply, whilst we validate */
+  struct blockdata *stash;      /* Saved reply, whilst we validate */
   size_t stash_len;
-  struct frec *dependent; /* Query awaiting internally-generated DNSKEY or DS query */
-  struct frec *blocking_query; /* Query which is blocking us. */
+  struct frec *dependent;       /* Query awaiting internally-generated DNSKEY or DS query */
+  struct frec *blocking_query;  /* Query which is blocking us. */
 #endif
   struct frec *next;
 };
@@ -643,7 +644,7 @@
 #define OT_INTERNAL     0x2000
 #define OT_NAME         0x1000
 #define OT_CSTRING      0x0800
-#define OT_DEC          0x0400 
+#define OT_DEC          0x0400
 #define OT_TIME         0x0200
 
 /* actions in the daemon->helper RPC */
@@ -665,30 +666,30 @@
 #define LEASE_HAVE_HWADDR  128  /* Have set hwaddress */
 
 struct dhcp_lease {
-  int clid_len;          /* length of client identifier */
-  unsigned char *clid;   /* clientid */
-  char *hostname, *fqdn; /* name from client-hostname option or config */
-  char *old_hostname;    /* hostname before it moved to another lease */
+  int clid_len;                 /* length of client identifier */
+  unsigned char *clid;          /* clientid */
+  char *hostname, *fqdn;        /* name from client-hostname option or config */
+  char *old_hostname;           /* hostname before it moved to another lease */
   int flags;
-  time_t expires;        /* lease expiry */
+  time_t expires;               /* lease expiry */
 #ifdef HAVE_BROKEN_RTC
   unsigned int length;
 #endif
   int hwaddr_len, hwaddr_type;
-  unsigned char hwaddr[DHCP_CHADDR_MAX]; 
+  unsigned char hwaddr[DHCP_CHADDR_MAX];
   struct in_addr addr, override, giaddr;
   unsigned char *extradata;
   unsigned int extradata_len, extradata_size;
   int last_interface;
-  int new_interface;     /* save possible originated interface */
-  int new_prefixlen;     /* and its prefix length */
+  int new_interface;            /* save possible originated interface */
+  int new_prefixlen;            /* and its prefix length */
 #ifdef HAVE_DHCP6
   struct in6_addr addr6;
   int iaid;
   struct slaac_address {
     struct in6_addr addr;
     time_t ping_time;
-    int backoff; /* zero -> confirmed */
+    int backoff;                /* zero -> confirmed */
     struct slaac_address *next;
   } *slaac_address;
   int vendorclass_count;
@@ -727,8 +728,8 @@
 
 struct dhcp_config {
   unsigned int flags;
-  int clid_len;          /* length of client identifier */
-  unsigned char *clid;   /* clientid */
+  int clid_len;                 /* length of client identifier */
+  unsigned char *clid;          /* clientid */
   char *hostname, *domain;
   struct dhcp_netid_list *netid;
 #ifdef HAVE_DHCP6
@@ -741,7 +742,7 @@
   struct dhcp_config *next;
 };
 
-#define have_config(config, mask) ((config) && ((config)->flags & (mask))) 
+#define have_config(config, mask) ((config) && ((config)->flags & (mask)))
 
 #define CONFIG_DISABLE           1
 #define CONFIG_CLID              2
@@ -749,10 +750,10 @@
 #define CONFIG_NAME             16
 #define CONFIG_ADDR             32
 #define CONFIG_NOCLID          128
-#define CONFIG_FROM_ETHERS     256    /* entry created by /etc/ethers */
-#define CONFIG_ADDR_HOSTS      512    /* address added by from /etc/hosts */
-#define CONFIG_DECLINED       1024    /* address declined by client */
-#define CONFIG_BANK           2048    /* from dhcp hosts file */
+#define CONFIG_FROM_ETHERS     256      /* entry created by /etc/ethers */
+#define CONFIG_ADDR_HOSTS      512      /* address added by from /etc/hosts */
+#define CONFIG_DECLINED       1024      /* address declined by client */
+#define CONFIG_BANK           2048      /* from dhcp hosts file */
 #define CONFIG_ADDR6          4096
 #define CONFIG_WILDCARD       8192
 
@@ -791,7 +792,7 @@
 };
 
 struct pxe_service {
-  unsigned short CSA, type; 
+  unsigned short CSA, type;
   char *menu, *basename, *sname;
   struct in_addr server;
   struct dhcp_netid *netid;
@@ -834,9 +835,9 @@
 #endif
   int is6;
   struct cond_domain *next;
-}; 
+};
 
-#ifdef OPTION6_PREFIX_CLASS 
+#ifdef OPTION6_PREFIX_CLASS
 struct prefix_class {
   int class;
   struct dhcp_netid tag;
@@ -855,7 +856,7 @@
   unsigned int lease_time, addr_epoch;
   struct in_addr netmask, broadcast;
   struct in_addr local, router;
-  struct in_addr start, end; /* range of available addresses */
+  struct in_addr start, end;    /* range of available addresses */
 #ifdef HAVE_DHCP6
   struct in6_addr start6, end6; /* range of available addresses */
   struct in6_addr local6;
@@ -879,7 +880,7 @@
 #define CONTEXT_RA_STATELESS   (1u<<7)
 #define CONTEXT_DHCP           (1u<<8)
 #define CONTEXT_DEPRECATE      (1u<<9)
-#define CONTEXT_TEMPLATE       (1u<<10)    /* create contexts using addresses */
+#define CONTEXT_TEMPLATE       (1u<<10) /* create contexts using addresses */
 #define CONTEXT_CONSTRUCTED    (1u<<11)
 #define CONTEXT_GC             (1u<<12)
 #define CONTEXT_RA             (1u<<13)
@@ -930,8 +931,8 @@
 
 struct dhcp_relay {
   struct all_addr local, server;
-  char *interface; /* Allowable interface for replies from server, and dest for IPv6 multicast */
-  int iface_index; /* working - interface in which requests arrived, for return */
+  char *interface;              /* Allowable interface for replies from server, and dest for IPv6 multicast */
+  int iface_index;              /* working - interface in which requests arrived, for return */
   struct dhcp_relay *current, *next;
 };
 
@@ -964,18 +965,20 @@
   int group_set, osport;
   char *domain_suffix;
   struct cond_domain *cond_domain, *synth_domains;
-  char *runfile; 
+  char *runfile;
   char *lease_change_command;
-  struct iname *if_names, *if_addrs, *if_except, *dhcp_except, *auth_peers, *tftp_interfaces;
+  struct iname *if_names, *if_addrs, *if_except, *dhcp_except, *auth_peers,
+      *tftp_interfaces;
   struct bogus_addr *bogus_addr, *ignore_addr;
   struct server *servers;
   struct ipsets *ipsets;
-  int log_fac; /* log facility */
-  char *log_file; /* optional log file */
-  int max_logs;  /* queue limit */
+  int log_fac;                  /* log facility */
+  char *log_file;               /* optional log file */
+  int max_logs;                 /* queue limit */
   int cachesize, ftabsize;
   int port, query_port, min_port, max_port;
-  unsigned long local_ttl, neg_ttl, max_ttl, min_cache_ttl, max_cache_ttl, auth_ttl, dhcp_ttl, use_dhcp_ttl;
+  unsigned long local_ttl, neg_ttl, max_ttl, min_cache_ttl, max_cache_ttl,
+      auth_ttl, dhcp_ttl, use_dhcp_ttl;
   char *dns_client_id;
   struct hostsfile *addn_hosts;
   struct dhcp_context *dhcp, *dhcp6;
@@ -986,29 +989,29 @@
   struct dhcp_mac *dhcp_macs;
   struct dhcp_boot *boot_config;
   struct pxe_service *pxe_services;
-  struct tag_if *tag_if; 
+  struct tag_if *tag_if;
   struct addr_list *override_relays;
   struct dhcp_relay *relay4, *relay6;
   struct delay_config *delay_conf;
   int override;
   int enable_pxe;
   int doing_ra, doing_dhcp6;
-  struct dhcp_netid_list *dhcp_ignore, *dhcp_ignore_names, *dhcp_gen_names; 
+  struct dhcp_netid_list *dhcp_ignore, *dhcp_ignore_names, *dhcp_gen_names;
   struct dhcp_netid_list *force_broadcast, *bootp_dynamic;
   struct hostsfile *dhcp_hosts_file, *dhcp_opts_file, *dynamic_dirs;
   int dhcp_max, tftp_max, tftp_mtu;
   int dhcp_server_port, dhcp_client_port;
-  int start_tftp_port, end_tftp_port; 
+  int start_tftp_port, end_tftp_port;
   unsigned int min_leasetime;
   struct doctor *doctors;
   unsigned short edns_pktsz;
-  char *tftp_prefix; 
-  struct tftp_prefix *if_prefix; /* per-interface TFTP prefixes */
+  char *tftp_prefix;
+  struct tftp_prefix *if_prefix;        /* per-interface TFTP prefixes */
   unsigned int duid_enterprise, duid_config_len;
   unsigned char *duid_config;
   char *dbus_name;
   unsigned long soa_sn, soa_refresh, soa_retry, soa_expiry;
-#ifdef OPTION6_PREFIX_CLASS 
+#ifdef OPTION6_PREFIX_CLASS
   struct prefix_class *prefix_classes;
 #endif
 #ifdef HAVE_DNSSEC
@@ -1019,12 +1022,12 @@
 #endif
 
   /* globally used stuff for DNS */
-  char *packet; /* packet buffer */
-  int packet_buff_sz; /* size of above */
-  char *namebuff; /* MAXDNAME size buffer */
+  char *packet;                 /* packet buffer */
+  int packet_buff_sz;           /* size of above */
+  char *namebuff;               /* MAXDNAME size buffer */
 #ifdef HAVE_DNSSEC
-  char *keyname; /* MAXDNAME size buffer */
-  char *workspacename; /* ditto */
+  char *keyname;                /* MAXDNAME size buffer */
+  char *workspacename;          /* ditto */
 #endif
   unsigned int local_answer, queries_forwarded, auth_answer;
   struct frec *frec_list;
@@ -1034,18 +1037,18 @@
   struct server *last_server;
   time_t forwardtime;
   int forwardcount;
-  struct server *srv_save; /* Used for resend on DoD */
-  size_t packet_len;       /*      "        "        */
-  struct randfd *rfd_save; /*      "        "        */
+  struct server *srv_save;      /* Used for resend on DoD */
+  size_t packet_len;            /*      "        "        */
+  struct randfd *rfd_save;      /*      "        "        */
   pid_t tcp_pids[MAX_PROCS];
   struct randfd randomsocks[RANDOM_SOCKS];
-  int v6pktinfo; 
-  struct addrlist *interface_addrs; /* list of all addresses/prefix lengths associated with all local interfaces */
-  int log_id, log_display_id; /* ids of transactions for logging */
+  int v6pktinfo;
+  struct addrlist *interface_addrs;     /* list of all addresses/prefix lengths associated with all local interfaces */
+  int log_id, log_display_id;   /* ids of transactions for logging */
   union mysockaddr *log_source_addr;
 
   /* DHCP state */
-  int dhcpfd, helperfd, pxefd; 
+  int dhcpfd, helperfd, pxefd;
 #ifdef HAVE_INOTIFY
   int inotifyfd;
 #endif
@@ -1077,26 +1080,28 @@
 
   /* utility string buffer, hold max sized IP address as string */
   char *addrbuff;
-  char *addrbuff2; /* only allocated when OPT_EXTRALOG */
+  char *addrbuff2;              /* only allocated when OPT_EXTRALOG */
 
 } *daemon;
 
 /* cache.c */
 void cache_init(void);
-void log_query(unsigned int flags, char *name, struct all_addr *addr, char *arg); 
+void log_query(unsigned int flags, char *name, struct all_addr *addr,
+               char *arg);
 char *record_source(unsigned int index);
 char *querystr(char *desc, unsigned short type);
 struct crec *cache_find_by_addr(struct crec *crecp,
-				struct all_addr *addr, time_t now, 
-				unsigned int prot);
-struct crec *cache_find_by_name(struct crec *crecp, 
-				char *name, time_t now, unsigned int prot);
+                                struct all_addr *addr, time_t now,
+                                unsigned int prot);
+struct crec *cache_find_by_name(struct crec *crecp,
+                                char *name, time_t now, unsigned int prot);
 void cache_end_insert(void);
 void cache_start_insert(void);
 struct crec *cache_insert(char *name, struct all_addr *addr,
-			  time_t now, unsigned long ttl, unsigned short flags);
+                          time_t now, unsigned long ttl, unsigned short flags);
 void cache_reload(void);
-void cache_add_dhcp_entry(char *host_name, int prot, struct all_addr *host_address, time_t ttd);
+void cache_add_dhcp_entry(char *host_name, int prot,
+                          struct all_addr *host_address, time_t ttd);
 struct in_addr a_record_from_hosts(char *name, time_t now);
 void cache_unhash_dhcp(void);
 void dump_cache(time_t now);
@@ -1106,8 +1111,8 @@
 char *cache_get_name(struct crec *crecp);
 char *cache_get_cname_target(struct crec *crecp);
 struct crec *cache_enumerate(int init);
-int read_hostsfile(char *filename, unsigned int index, int cache_size, 
-		   struct crec **rhash, int hashsz);
+int read_hostsfile(char *filename, unsigned int index, int cache_size,
+                   struct crec **rhash, int hashsz);
 
 /* blockdata.c */
 #ifdef HAVE_DNSSEC
@@ -1127,55 +1132,66 @@
 int is_rev_synth(int flag, struct all_addr *addr, char *name);
 
 /* rfc1035.c */
-int extract_name(struct dns_header *header, size_t plen, unsigned char **pp, 
+int extract_name(struct dns_header *header, size_t plen, unsigned char **pp,
                  char *name, int isExtract, int extrabytes);
-unsigned char *skip_name(unsigned char *ansp, struct dns_header *header, size_t plen, int extrabytes);
+unsigned char *skip_name(unsigned char *ansp, struct dns_header *header,
+                         size_t plen, int extrabytes);
 unsigned char *skip_questions(struct dns_header *header, size_t plen);
-unsigned char *skip_section(unsigned char *ansp, int count, struct dns_header *header, size_t plen);
-unsigned int extract_request(struct dns_header *header, size_t qlen, 
-			       char *name, unsigned short *typep);
-size_t setup_reply(struct dns_header *header, size_t  qlen,
-		   struct all_addr *addrp, unsigned int flags,
-		   unsigned long ttl);
+unsigned char *skip_section(unsigned char *ansp, int count,
+                            struct dns_header *header, size_t plen);
+unsigned int extract_request(struct dns_header *header, size_t qlen, char *name,
+                             unsigned short *typep);
+size_t setup_reply(struct dns_header *header, size_t qlen,
+                   struct all_addr *addrp, unsigned int flags,
+                   unsigned long ttl);
 int extract_addresses(struct dns_header *header, size_t qlen, char *name,
-		      time_t now, char **ipsets, int is_sign, int check_rebind,
-		      int no_cache_dnssec, int secure, int *doctored);
-size_t answer_request(struct dns_header *header, char *limit, size_t qlen,  
-		      struct in_addr local_addr, struct in_addr local_netmask, 
-		      time_t now, int ad_reqd, int do_bit, int have_pseudoheader);
-int check_for_bogus_wildcard(struct dns_header *header, size_t qlen, char *name, 
-			     struct bogus_addr *baddr, time_t now);
-int check_for_ignored_address(struct dns_header *header, size_t qlen, struct bogus_addr *baddr);
+                      time_t now, char **ipsets, int is_sign, int check_rebind,
+                      int no_cache_dnssec, int secure, int *doctored);
+size_t answer_request(struct dns_header *header, char *limit, size_t qlen,
+                      struct in_addr local_addr, struct in_addr local_netmask,
+                      time_t now, int ad_reqd, int do_bit,
+                      int have_pseudoheader);
+int check_for_bogus_wildcard(struct dns_header *header, size_t qlen, char *name,
+                             struct bogus_addr *baddr, time_t now);
+int check_for_ignored_address(struct dns_header *header, size_t qlen,
+                              struct bogus_addr *baddr);
 int check_for_local_domain(char *name, time_t now);
 unsigned int questions_crc(struct dns_header *header, size_t plen, char *name);
-size_t resize_packet(struct dns_header *header, size_t plen, 
-		  unsigned char *pheader, size_t hlen);
+size_t resize_packet(struct dns_header *header, size_t plen,
+                     unsigned char *pheader, size_t hlen);
 int add_resource_record(struct dns_header *header, char *limit, int *truncp,
-			int nameoffset, unsigned char **pp, unsigned long ttl, 
-			int *offset, unsigned short type, unsigned short class, char *format, ...);
+                        int nameoffset, unsigned char **pp, unsigned long ttl,
+                        int *offset, unsigned short type, unsigned short class,
+                        char *format, ...);
 unsigned char *skip_questions(struct dns_header *header, size_t plen);
-int extract_name(struct dns_header *header, size_t plen, unsigned char **pp, 
-		 char *name, int isExtract, int extrabytes);
+int extract_name(struct dns_header *header, size_t plen, unsigned char **pp,
+                 char *name, int isExtract, int extrabytes);
 int in_arpa_name_2_addr(char *namein, struct all_addr *addrp);
 int private_net(struct in_addr addr, int ban_localhost);
 
 /* auth.c */
 #ifdef HAVE_AUTH
-size_t answer_auth(struct dns_header *header, char *limit, size_t qlen, 
-		   time_t now, union mysockaddr *peer_addr, int local_query,
-		   int do_bit, int have_pseudoheader);
+size_t answer_auth(struct dns_header *header, char *limit, size_t qlen,
+                   time_t now, union mysockaddr *peer_addr, int local_query,
+                   int do_bit, int have_pseudoheader);
 int in_zone(struct auth_zone *zone, char *name, char **cut);
 #endif
 
 /* dnssec.c */
-size_t dnssec_generate_query(struct dns_header *header, unsigned char *end, char *name, int class, int type, union mysockaddr *addr, int edns_pktsz);
-int dnssec_validate_by_ds(time_t now, struct dns_header *header, size_t plen, char *name, char *keyname, int class);
-int dnssec_validate_ds(time_t now, struct dns_header *header, size_t plen, char *name, char *keyname, int class);
-int dnssec_validate_reply(time_t now, struct dns_header *header, size_t plen, char *name, char *keyname, int *class,
-			  int check_unsigned, int *neganswer, int *nons);
+size_t dnssec_generate_query(struct dns_header *header, unsigned char *end,
+                             char *name, int class, int type,
+                             union mysockaddr *addr, int edns_pktsz);
+int dnssec_validate_by_ds(time_t now, struct dns_header *header, size_t plen,
+                          char *name, char *keyname, int class);
+int dnssec_validate_ds(time_t now, struct dns_header *header, size_t plen,
+                       char *name, char *keyname, int class);
+int dnssec_validate_reply(time_t now, struct dns_header *header, size_t plen,
+                          char *name, char *keyname, int *class,
+                          int check_unsigned, int *neganswer, int *nons);
 int dnskey_keytag(int alg, int flags, unsigned char *key, int keylen);
 size_t filter_rrsigs(struct dns_header *header, size_t plen);
-unsigned char* hash_questions(struct dns_header *header, size_t plen, char *name);
+unsigned char *hash_questions(struct dns_header *header, size_t plen,
+                              char *name);
 int setup_timestamp(void);
 
 /* util.c */
@@ -1203,16 +1219,16 @@
 int retry_send(ssize_t rc);
 void prettyprint_time(char *buf, unsigned int t);
 int prettyprint_addr(union mysockaddr *addr, char *buf);
-int parse_hex(char *in, unsigned char *out, int maxlen, 
-	      unsigned int *wildcard_mask, int *mac_type);
-int memcmp_masked(unsigned char *a, unsigned char *b, int len, 
-		  unsigned int mask);
+int parse_hex(char *in, unsigned char *out, int maxlen,
+              unsigned int *wildcard_mask, int *mac_type);
+int memcmp_masked(unsigned char *a, unsigned char *b, int len,
+                  unsigned int mask);
 int expand_buf(struct iovec *iov, size_t size);
 char *print_mac(char *buff, unsigned char *mac, int len);
 int read_write(int fd, unsigned char *packet, int size, int rw);
 
-int wildcard_match(const char* wildcard, const char* match);
-int wildcard_matchn(const char* wildcard, const char* match, int num);
+int wildcard_match(const char *wildcard, const char *match);
+int wildcard_matchn(const char *wildcard, const char *match, int num);
 
 /* log.c */
 void die(char *message, char *arg1, int exit_code);
@@ -1226,28 +1242,29 @@
 void flush_log(void);
 
 /* option.c */
-void read_opts (int argc, char **argv, char *compile_opts);
-char *option_string(int prot, unsigned int opt, unsigned char *val, 
-		    int opt_len, char *buf, int buf_len);
+void read_opts(int argc, char **argv, char *compile_opts);
+char *option_string(int prot, unsigned int opt, unsigned char *val,
+                    int opt_len, char *buf, int buf_len);
 void reread_dhcp(void);
 void read_servers_file(void);
 void set_option_bool(unsigned int opt);
 void reset_option_bool(unsigned int opt);
 struct hostsfile *expand_filelist(struct hostsfile *list);
-char *parse_server(char *arg, union mysockaddr *addr, 
-		   union mysockaddr *source_addr, char *interface, int *flags);
+char *parse_server(char *arg, union mysockaddr *addr,
+                   union mysockaddr *source_addr, char *interface, int *flags);
 int option_read_dynfile(char *file, int flags);
 
 /* forward.c */
 void reply_query(int fd, int family, time_t now);
 void receive_query(struct listener *listen, time_t now);
 unsigned char *tcp_request(int confd, time_t now,
-			   union mysockaddr *local_addr, struct in_addr netmask, int auth_dns);
+                           union mysockaddr *local_addr, struct in_addr netmask,
+                           int auth_dns);
 void server_gone(struct server *server);
 struct frec *get_new_frec(time_t now, int *wait, int force);
-int send_from(int fd, int nowild, char *packet, size_t len, 
-	       union mysockaddr *to, struct all_addr *source,
-	       unsigned int iface);
+int send_from(int fd, int nowild, char *packet, size_t len,
+              union mysockaddr *to, struct all_addr *source,
+              unsigned int iface);
 void resend_query(void);
 struct randfd *allocate_rfd(int family);
 void free_rfd(struct randfd *rfd);
@@ -1261,10 +1278,9 @@
 void mark_servers(int flag);
 void cleanup_servers(void);
 void add_update_server(int flags,
-		       union mysockaddr *addr,
-		       union mysockaddr *source_addr,
-		       const char *interface,
-		       const char *domain);
+                       union mysockaddr *addr,
+                       union mysockaddr *source_addr,
+                       const char *interface, const char *domain);
 void check_servers(void);
 int enumerate_interfaces(int reset);
 void create_wildcard_listeners(void);
@@ -1293,19 +1309,20 @@
 #ifdef HAVE_DHCP
 void dhcp_init(void);
 void dhcp_packet(time_t now, int pxe_fd);
-struct dhcp_context *address_available(struct dhcp_context *context, 
-				       struct in_addr taddr,
-				       struct dhcp_netid *netids);
-struct dhcp_context *narrow_context(struct dhcp_context *context, 
-				    struct in_addr taddr,
-				    struct dhcp_netid *netids);
+struct dhcp_context *address_available(struct dhcp_context *context,
+                                       struct in_addr taddr,
+                                       struct dhcp_netid *netids);
+struct dhcp_context *narrow_context(struct dhcp_context *context,
+                                    struct in_addr taddr,
+                                    struct dhcp_netid *netids);
 struct ping_result *do_icmp_ping(time_t now, struct in_addr addr,
-				 unsigned int hash, int loopback);
+                                 unsigned int hash, int loopback);
 int address_allocate(struct dhcp_context *context,
-		     struct in_addr *addrp, unsigned char *hwaddr, int hw_len,
-		     struct dhcp_netid *netids, time_t now, int loopback);
+                     struct in_addr *addrp, unsigned char *hwaddr, int hw_len,
+                     struct dhcp_netid *netids, time_t now, int loopback);
 void dhcp_read_ethers(void);
-struct dhcp_config *config_find_by_address(struct dhcp_config *configs, struct in_addr addr);
+struct dhcp_config *config_find_by_address(struct dhcp_config *configs,
+                                           struct in_addr addr);
 char *host_from_dns(struct in_addr addr);
 #endif
 
@@ -1317,25 +1334,31 @@
 struct dhcp_lease *lease4_allocate(struct in_addr addr);
 #ifdef HAVE_DHCP6
 struct dhcp_lease *lease6_allocate(struct in6_addr *addrp, int lease_type);
-struct dhcp_lease *lease6_find(unsigned char *clid, int clid_len, 
-			       int lease_type, int iaid, struct in6_addr *addr);
+struct dhcp_lease *lease6_find(unsigned char *clid, int clid_len,
+                               int lease_type, int iaid, struct in6_addr *addr);
 void lease6_reset(void);
-struct dhcp_lease *lease6_find_by_client(struct dhcp_lease *first, int lease_type, unsigned char *clid, int clid_len, int iaid);
-struct dhcp_lease *lease6_find_by_addr(struct in6_addr *net, int prefix, u64 addr);
+struct dhcp_lease *lease6_find_by_client(struct dhcp_lease *first,
+                                         int lease_type, unsigned char *clid,
+                                         int clid_len, int iaid);
+struct dhcp_lease *lease6_find_by_addr(struct in6_addr *net, int prefix,
+                                       u64 addr);
 u64 lease_find_max_addr6(struct dhcp_context *context);
-void lease_ping_reply(struct in6_addr *sender, unsigned char *packet, char *interface);
+void lease_ping_reply(struct in6_addr *sender, unsigned char *packet,
+                      char *interface);
 void lease_update_slaac(time_t now);
 void lease_set_iaid(struct dhcp_lease *lease, int iaid);
 void lease_make_duid(time_t now);
 #endif
 void lease_set_hwaddr(struct dhcp_lease *lease, const unsigned char *hwaddr,
-		      const unsigned char *clid, int hw_len, int hw_type,
-		      int clid_len, time_t now, int force);
-void lease_set_hostname(struct dhcp_lease *lease, const char *name, int auth, char *domain, char *config_domain);
+                      const unsigned char *clid, int hw_len, int hw_type,
+                      int clid_len, time_t now, int force);
+void lease_set_hostname(struct dhcp_lease *lease, const char *name, int auth,
+                        char *domain, char *config_domain);
 void lease_set_expires(struct dhcp_lease *lease, unsigned int len, time_t now);
 void lease_set_interface(struct dhcp_lease *lease, int interface, time_t now);
-struct dhcp_lease *lease_find_by_client(unsigned char *hwaddr, int hw_len, int hw_type,  
-					unsigned char *clid, int clid_len);
+struct dhcp_lease *lease_find_by_client(unsigned char *hwaddr, int hw_len,
+                                        int hw_type, unsigned char *clid,
+                                        int clid_len);
 struct dhcp_lease *lease_find_by_addr(struct in_addr addr);
 struct in_addr lease_find_max_addr(struct dhcp_context *context);
 void lease_prune(struct dhcp_lease *target, time_t now);
@@ -1344,18 +1367,19 @@
 void rerun_scripts(void);
 void lease_find_interfaces(time_t now);
 #ifdef HAVE_SCRIPT
-void lease_add_extradata(struct dhcp_lease *lease, unsigned char *data, 
-			 unsigned int len, int delim);
+void lease_add_extradata(struct dhcp_lease *lease, unsigned char *data,
+                         unsigned int len, int delim);
 #endif
 #endif
 
 /* rfc2131.c */
 #ifdef HAVE_DHCP
 size_t dhcp_reply(struct dhcp_context *context, char *iface_name, int int_index,
-		  size_t sz, time_t now, int unicast_dest, int loopback,
-		  int *is_inform, int pxe, struct in_addr fallback, time_t recvtime);
-unsigned char *extended_hwaddr(int hwtype, int hwlen, unsigned char *hwaddr, 
-			       int clid_len, unsigned char *clid, int *len_out);
+                  size_t sz, time_t now, int unicast_dest, int loopback,
+                  int *is_inform, int pxe, struct in_addr fallback,
+                  time_t recvtime);
+unsigned char *extended_hwaddr(int hwtype, int hwlen, unsigned char *hwaddr,
+                               int clid_len, unsigned char *clid, int *len_out);
 #endif
 
 /* dnsmasq.c */
@@ -1379,41 +1403,42 @@
 #ifdef HAVE_BSD_NETWORK
 void init_bpf(void);
 void send_via_bpf(struct dhcp_packet *mess, size_t len,
-		  struct in_addr iface_addr, struct ifreq *ifr);
+                  struct in_addr iface_addr, struct ifreq *ifr);
 void route_init(void);
 void route_sock(void);
 #endif
 
 /* bpf.c or netlink.c */
-int iface_enumerate(int family, void *parm, int (callback)());
+int iface_enumerate(int family, void *parm, int (callback) ());
 
 /* dbus.c */
 #ifdef HAVE_DBUS
 char *dbus_init(void);
 void check_dbus_listeners(void);
 void set_dbus_listeners(void);
-#  ifdef HAVE_DHCP
+#ifdef HAVE_DHCP
 void emit_dbus_signal(int action, struct dhcp_lease *lease, char *hostname);
-#  endif
+#endif
 #endif
 
 /* ipset.c */
 #ifdef HAVE_IPSET
 void ipset_init(void);
-int add_to_ipset(const char *setname, const struct all_addr *ipaddr, int flags, int remove);
+int add_to_ipset(const char *setname, const struct all_addr *ipaddr, int flags,
+                 int remove);
 #endif
 
 /* helper.c */
 #if defined(HAVE_SCRIPT)
 int create_helper(int event_fd, int err_fd, uid_t uid, gid_t gid, long max_fd);
 void helper_write(void);
-void queue_script(int action, struct dhcp_lease *lease, 
-		  char *hostname, time_t now);
+void queue_script(int action, struct dhcp_lease *lease,
+                  char *hostname, time_t now);
 #ifdef HAVE_TFTP
 void queue_tftp(off_t file_len, char *filename, union mysockaddr *peer);
 #endif
 void queue_arp(int action, unsigned char *mac, int maclen,
-	       int family, struct all_addr *addr);
+               int family, struct all_addr *addr);
 int helper_buf_empty(void);
 #endif
 
@@ -1427,41 +1452,47 @@
 /* conntrack.c */
 #ifdef HAVE_CONNTRACK
 int get_incoming_mark(union mysockaddr *peer_addr, struct all_addr *local_addr,
-		      int istcp, unsigned int *markp);
+                      int istcp, unsigned int *markp);
 #endif
 
 /* dhcp6.c */
 #ifdef HAVE_DHCP6
 void dhcp6_init(void);
 void dhcp6_packet(time_t now);
-struct dhcp_context *address6_allocate(struct dhcp_context *context,  unsigned char *clid, int clid_len, int temp_addr,
-				       int iaid, int serial, struct dhcp_netid *netids, int plain_range, struct in6_addr *ans);
-int config_valid(struct dhcp_config *config, struct dhcp_context *context, struct in6_addr *addr);
-struct dhcp_context *address6_available(struct dhcp_context *context, 
-					struct in6_addr *taddr,
-					struct dhcp_netid *netids,
-					int plain_range);
-struct dhcp_context *address6_valid(struct dhcp_context *context, 
-				    struct in6_addr *taddr,
-				    struct dhcp_netid *netids,
-				    int plain_range);
-struct dhcp_config *config_find_by_address6(struct dhcp_config *configs, struct in6_addr *net, 
-					    int prefix, u64 addr);
+struct dhcp_context *address6_allocate(struct dhcp_context *context,
+                                       unsigned char *clid, int clid_len,
+                                       int temp_addr, int iaid, int serial,
+                                       struct dhcp_netid *netids,
+                                       int plain_range, struct in6_addr *ans);
+int config_valid(struct dhcp_config *config, struct dhcp_context *context,
+                 struct in6_addr *addr);
+struct dhcp_context *address6_available(struct dhcp_context *context,
+                                        struct in6_addr *taddr,
+                                        struct dhcp_netid *netids,
+                                        int plain_range);
+struct dhcp_context *address6_valid(struct dhcp_context *context,
+                                    struct in6_addr *taddr,
+                                    struct dhcp_netid *netids, int plain_range);
+struct dhcp_config *config_find_by_address6(struct dhcp_config *configs,
+                                            struct in6_addr *net, int prefix,
+                                            u64 addr);
 void make_duid(time_t now);
 void dhcp_construct_contexts(time_t now);
-void get_client_mac(struct in6_addr *client, int iface, unsigned char *mac, 
-		    unsigned int *maclenp, unsigned int *mactypep, time_t now);
+void get_client_mac(struct in6_addr *client, int iface, unsigned char *mac,
+                    unsigned int *maclenp, unsigned int *mactypep, time_t now);
 #endif
-  
+
 /* rfc3315.c */
 #ifdef HAVE_DHCP6
-unsigned short dhcp6_reply(struct dhcp_context *context, int interface, char *iface_name,  
-			   struct in6_addr *fallback, struct in6_addr *ll_addr, struct in6_addr *ula_addr,
-			   size_t sz, struct in6_addr *client_addr, time_t now);
-void relay_upstream6(struct dhcp_relay *relay, ssize_t sz, struct in6_addr *peer_address, 
-		     u32 scope_id, time_t now);
+unsigned short dhcp6_reply(struct dhcp_context *context, int interface,
+                           char *iface_name, struct in6_addr *fallback,
+                           struct in6_addr *ll_addr, struct in6_addr *ula_addr,
+                           size_t sz, struct in6_addr *client_addr, time_t now);
+void relay_upstream6(struct dhcp_relay *relay, ssize_t sz,
+                     struct in6_addr *peer_address, u32 scope_id, time_t now);
 
-unsigned short relay_reply6( struct sockaddr_in6 *peer, ssize_t sz, char *arrival_interface);
+unsigned short relay_reply6(struct sockaddr_in6 *peer, ssize_t sz,
+                            char *arrival_interface);
 #endif
 
 /* dhcp-common.c */
@@ -1469,9 +1500,11 @@
 void dhcp_common_init(void);
 ssize_t recv_dhcp_packet(int fd, struct msghdr *msg);
 struct dhcp_netid *run_tag_if(struct dhcp_netid *tags);
-struct dhcp_netid *option_filter(struct dhcp_netid *tags, struct dhcp_netid *context_tags,
-				 struct dhcp_opt *opts);
-int match_netid(struct dhcp_netid *check, struct dhcp_netid *pool, int tagnotneeded);
+struct dhcp_netid *option_filter(struct dhcp_netid *tags,
+                                 struct dhcp_netid *context_tags,
+                                 struct dhcp_opt *opts);
+int match_netid(struct dhcp_netid *check, struct dhcp_netid *pool,
+                int tagnotneeded);
 char *strip_hostname(char *hostname);
 void log_tags(struct dhcp_netid *netid, u32 xid);
 int match_bytes(struct dhcp_opt *o, unsigned char *p, int len);
@@ -1479,21 +1512,22 @@
 void display_opts(void);
 int lookup_dhcp_opt(int prot, char *name);
 int lookup_dhcp_len(int prot, int val);
-char *option_string(int prot, unsigned int opt, unsigned char *val, 
-		    int opt_len, char *buf, int buf_len);
+char *option_string(int prot, unsigned int opt, unsigned char *val,
+                    int opt_len, char *buf, int buf_len);
 struct dhcp_config *find_config(struct dhcp_config *configs,
-				struct dhcp_context *context,
-				unsigned char *clid, int clid_len,
-				unsigned char *hwaddr, int hw_len, 
-				int hw_type, char *hostname);
-int config_has_mac(struct dhcp_config *config, unsigned char *hwaddr, int len, int type);
+                                struct dhcp_context *context,
+                                unsigned char *clid, int clid_len,
+                                unsigned char *hwaddr, int hw_len,
+                                int hw_type, char *hostname);
+int config_has_mac(struct dhcp_config *config, unsigned char *hwaddr, int len,
+                   int type);
 #ifdef HAVE_LINUX_NETWORK
 char *whichdevice(void);
 void bindtodevice(char *device, int fd);
 #endif
-#  ifdef HAVE_DHCP6
+#ifdef HAVE_DHCP6
 void display_opts6(void);
-#  endif
+#endif
 void log_context(int family, struct dhcp_context *context);
 void log_relay(int family, struct dhcp_relay *relay);
 #endif
@@ -1520,11 +1554,12 @@
 void ra_start_unsolicited(time_t now, struct dhcp_context *context);
 #endif
 
-/* slaac.c */ 
+/* slaac.c */
 #ifdef HAVE_DHCP6
 void slaac_add_addrs(struct dhcp_lease *lease, time_t now, int force);
 time_t periodic_slaac(time_t now, struct dhcp_lease *leases);
-void slaac_ping_reply(struct in6_addr *sender, unsigned char *packet, char *interface, struct dhcp_lease *leases);
+void slaac_ping_reply(struct in6_addr *sender, unsigned char *packet,
+                      char *interface, struct dhcp_lease *leases);
 #endif
 
 /* loop.c */
@@ -1537,7 +1572,8 @@
 #ifdef HAVE_INOTIFY
 void inotify_dnsmasq_init(void);
 int inotify_check(time_t now);
-void set_dynamic_inotify(int flag, int total_size, struct crec **rhash, int revhashsz);
+void set_dynamic_inotify(int flag, int total_size, struct crec **rhash,
+                         int revhashsz);
 #endif
 
 /* poll.c */
@@ -1553,13 +1589,18 @@
 
 /* edns0.c */
 unsigned char *find_pseudoheader(struct dns_header *header, size_t plen,
-				   size_t *len, unsigned char **p, int *is_sign, int *is_last);
-size_t add_pseudoheader(struct dns_header *header, size_t plen, unsigned char *limit, 
-			unsigned short udp_sz, int optno, unsigned char *opt, size_t optlen, int set_do, int replace);
+                                 size_t * len, unsigned char **p, int *is_sign,
+                                 int *is_last);
+size_t add_pseudoheader(struct dns_header *header, size_t plen,
+                        unsigned char *limit, unsigned short udp_sz, int optno,
+                        unsigned char *opt, size_t optlen, int set_do,
+                        int replace);
 size_t add_do_bit(struct dns_header *header, size_t plen, unsigned char *limit);
-size_t add_edns0_config(struct dns_header *header, size_t plen, unsigned char *limit, 
-			union mysockaddr *source, time_t now, int *check_subnet);
-int check_source(struct dns_header *header, size_t plen, unsigned char *pseudoheader, union mysockaddr *peer);
+size_t add_edns0_config(struct dns_header *header, size_t plen,
+                        unsigned char *limit, union mysockaddr *source,
+                        time_t now, int *check_subnet);
+int check_source(struct dns_header *header, size_t plen,
+                 unsigned char *pseudoheader, union mysockaddr *peer);
 
 /* arp.c */
 int find_mac(union mysockaddr *addr, unsigned char *mac, int lazy, time_t now);
Index: dnsmasq-2.78/src/dnssec.c
===================================================================
--- dnsmasq-2.78.orig/src/dnssec.c	2017-10-02 21:13:51.000000000 +0800
+++ dnsmasq-2.78/src/dnssec.c	2018-10-29 16:14:19.397440024 +0800
@@ -22,8 +22,8 @@
 #include <nettle/rsa.h>
 #include <nettle/dsa.h>
 #ifndef NO_NETTLE_ECC
-#  include <nettle/ecdsa.h>
-#  include <nettle/ecc-curve.h>
+#include <nettle/ecdsa.h>
+#include <nettle/ecc-curve.h>
 #endif
 #include <nettle/nettle-meta.h>
 #include <nettle/bignum.h>
@@ -42,64 +42,79 @@
 /* http://www.iana.org/assignments/ds-rr-types/ds-rr-types.xhtml */
 static char *ds_digest_name(int digest)
 {
-  switch (digest)
-    {
-    case 1: return "sha1";
-    case 2: return "sha256";
-    case 3: return "gosthash94";
-    case 4: return "sha384";
-    default: return NULL;
-    }
+  switch (digest) {
+  case 1:
+    return "sha1";
+  case 2:
+    return "sha256";
+  case 3:
+    return "gosthash94";
+  case 4:
+    return "sha384";
+  default:
+    return NULL;
+  }
 }
- 
+
 /* http://www.iana.org/assignments/dns-sec-alg-numbers/dns-sec-alg-numbers.xhtml */
 static char *algo_digest_name(int algo)
 {
-  switch (algo)
-    {
-    case 1: return "md5";
-    case 3: return "sha1";
-    case 5: return "sha1";
-    case 6: return "sha1";
-    case 7: return "sha1";
-    case 8: return "sha256";
-    case 10: return "sha512";
-    case 12: return "gosthash94";
-    case 13: return "sha256";
-    case 14: return "sha384";
-    default: return NULL;
-    }
+  switch (algo) {
+  case 1:
+    return "md5";
+  case 3:
+    return "sha1";
+  case 5:
+    return "sha1";
+  case 6:
+    return "sha1";
+  case 7:
+    return "sha1";
+  case 8:
+    return "sha256";
+  case 10:
+    return "sha512";
+  case 12:
+    return "gosthash94";
+  case 13:
+    return "sha256";
+  case 14:
+    return "sha384";
+  default:
+    return NULL;
+  }
 }
-  
+
 /* http://www.iana.org/assignments/dnssec-nsec3-parameters/dnssec-nsec3-parameters.xhtml */
 static char *nsec3_digest_name(int digest)
 {
-  switch (digest)
-    {
-    case 1: return "sha1";
-    default: return NULL;
-    }
+  switch (digest) {
+  case 1:
+    return "sha1";
+  default:
+    return NULL;
+  }
 }
- 
+
 /* Find pointer to correct hash function in nettle library */
 static const struct nettle_hash *hash_find(char *name)
 {
   int i;
-  
+
   if (!name)
     return NULL;
-  
-  for (i = 0; nettle_hashes[i]; i++)
-    {
-      if (strcmp(nettle_hashes[i]->name, name) == 0)
-	return nettle_hashes[i];
-    }
+
+  for (i = 0; nettle_hashes[i]; i++) {
+    if (strcmp(nettle_hashes[i]->name, name) == 0)
+      return nettle_hashes[i];
+  }
 
   return NULL;
 }
 
 /* expand ctx and digest memory allocations if necessary and init hash function */
-static int hash_init(const struct nettle_hash *hash, void **ctxp, unsigned char **digestp)
+static int hash_init(const struct nettle_hash *hash, void **ctxp,
+                     unsigned char **digestp)
 {
   static void *ctx = NULL;
   static unsigned char *digest = NULL;
@@ -108,25 +123,23 @@
 
   void *new;
 
-  if (ctx_sz < hash->context_size)
-    {
-      if (!(new = whine_malloc(hash->context_size)))
-	return 0;
-      if (ctx)
-	free(ctx);
-      ctx = new;
-      ctx_sz = hash->context_size;
-    }
-  
-  if (digest_sz < hash->digest_size)
-    {
-      if (!(new = whine_malloc(hash->digest_size)))
-	return 0;
-      if (digest)
-	free(digest);
-      digest = new;
-      digest_sz = hash->digest_size;
-    }
+  if (ctx_sz < hash->context_size) {
+    if (!(new = whine_malloc(hash->context_size)))
+      return 0;
+    if (ctx)
+      free(ctx);
+    ctx = new;
+    ctx_sz = hash->context_size;
+  }
+
+  if (digest_sz < hash->digest_size) {
+    if (!(new = whine_malloc(hash->digest_size)))
+      return 0;
+    if (digest)
+      free(digest);
+    digest = new;
+    digest_sz = hash->digest_size;
+  }
 
   *ctxp = ctx;
   *digestp = digest;
@@ -135,107 +148,113 @@
 
   return 1;
 }
-  
-static int dnsmasq_rsa_verify(struct blockdata *key_data, unsigned int key_len, unsigned char *sig, size_t sig_len,
-			      unsigned char *digest, size_t digest_len, int algo)
+
+static int dnsmasq_rsa_verify(struct blockdata *key_data, unsigned int key_len,
+                              unsigned char *sig, size_t sig_len,
+                              unsigned char *digest, size_t digest_len,
+                              int algo)
 {
   unsigned char *p;
   size_t exp_len;
-  
+
   static struct rsa_public_key *key = NULL;
   static mpz_t sig_mpz;
 
-  (void)digest_len;
-  
-  if (key == NULL)
-    {
-      if (!(key = whine_malloc(sizeof(struct rsa_public_key))))
-	return 0;
-      
-      nettle_rsa_public_key_init(key);
-      mpz_init(sig_mpz);
-    }
-  
+  (void) digest_len;
+
+  if (key == NULL) {
+    if (!(key = whine_malloc(sizeof(struct rsa_public_key))))
+      return 0;
+
+    nettle_rsa_public_key_init(key);
+    mpz_init(sig_mpz);
+  }
+
   if ((key_len < 3) || !(p = blockdata_retrieve(key_data, key_len, NULL)))
     return 0;
-  
+
   key_len--;
-  if ((exp_len = *p++) == 0)
-    {
-      GETSHORT(exp_len, p);
-      key_len -= 2;
-    }
-  
+  if ((exp_len = *p++) == 0) {
+    GETSHORT(exp_len, p);
+    key_len -= 2;
+  }
+
   if (exp_len >= key_len)
     return 0;
-  
-  key->size =  key_len - exp_len;
+
+  key->size = key_len - exp_len;
   mpz_import(key->e, exp_len, 1, 1, 0, 0, p);
   mpz_import(key->n, key->size, 1, 1, 0, 0, p + exp_len);
 
   mpz_import(sig_mpz, sig_len, 1, 1, 0, 0, sig);
-  
-  switch (algo)
-    {
-    case 1:
-      return nettle_rsa_md5_verify_digest(key, digest, sig_mpz);
-    case 5: case 7:
-      return nettle_rsa_sha1_verify_digest(key, digest, sig_mpz);
-    case 8:
-      return nettle_rsa_sha256_verify_digest(key, digest, sig_mpz);
-    case 10:
-      return nettle_rsa_sha512_verify_digest(key, digest, sig_mpz);
-    }
+
+  switch (algo) {
+  case 1:
+    return nettle_rsa_md5_verify_digest(key, digest, sig_mpz);
+  case 5:
+  case 7:
+    return nettle_rsa_sha1_verify_digest(key, digest, sig_mpz);
+  case 8:
+    return nettle_rsa_sha256_verify_digest(key, digest, sig_mpz);
+  case 10:
+    return nettle_rsa_sha512_verify_digest(key, digest, sig_mpz);
+  }
 
   return 0;
-}  
+}
 
-static int dnsmasq_dsa_verify(struct blockdata *key_data, unsigned int key_len, unsigned char *sig, size_t sig_len,
-			      unsigned char *digest, size_t digest_len, int algo)
+static int dnsmasq_dsa_verify(struct blockdata *key_data, unsigned int key_len,
+                              unsigned char *sig, size_t sig_len,
+                              unsigned char *digest, size_t digest_len,
+                              int algo)
 {
   unsigned char *p;
   unsigned int t;
-  
+
   static struct dsa_public_key *key = NULL;
   static struct dsa_signature *sig_struct;
-  
-  (void)digest_len;
 
-  if (key == NULL)
-    {
-      if (!(sig_struct = whine_malloc(sizeof(struct dsa_signature))) || 
-	  !(key = whine_malloc(sizeof(struct dsa_public_key)))) 
-	return 0;
-      
-      nettle_dsa_public_key_init(key);
-      nettle_dsa_signature_init(sig_struct);
-    }
-  
+  (void) digest_len;
+
+  if (key == NULL) {
+    if (!(sig_struct = whine_malloc(sizeof(struct dsa_signature))) ||
+        !(key = whine_malloc(sizeof(struct dsa_public_key))))
+      return 0;
+
+    nettle_dsa_public_key_init(key);
+    nettle_dsa_signature_init(sig_struct);
+  }
+
   if ((sig_len < 41) || !(p = blockdata_retrieve(key_data, key_len, NULL)))
     return 0;
-  
+
   t = *p++;
-  
+
   if (key_len < (213 + (t * 24)))
     return 0;
-  
-  mpz_import(key->q, 20, 1, 1, 0, 0, p); p += 20;
-  mpz_import(key->p, 64 + (t*8), 1, 1, 0, 0, p); p += 64 + (t*8);
-  mpz_import(key->g, 64 + (t*8), 1, 1, 0, 0, p); p += 64 + (t*8);
-  mpz_import(key->y, 64 + (t*8), 1, 1, 0, 0, p); p += 64 + (t*8);
-  
-  mpz_import(sig_struct->r, 20, 1, 1, 0, 0, sig+1);
-  mpz_import(sig_struct->s, 20, 1, 1, 0, 0, sig+21);
-  
-  (void)algo;
-  
+
+  mpz_import(key->q, 20, 1, 1, 0, 0, p);
+  p += 20;
+  mpz_import(key->p, 64 + (t * 8), 1, 1, 0, 0, p);
+  p += 64 + (t * 8);
+  mpz_import(key->g, 64 + (t * 8), 1, 1, 0, 0, p);
+  p += 64 + (t * 8);
+  mpz_import(key->y, 64 + (t * 8), 1, 1, 0, 0, p);
+  p += 64 + (t * 8);
+
+  mpz_import(sig_struct->r, 20, 1, 1, 0, 0, sig + 1);
+  mpz_import(sig_struct->s, 20, 1, 1, 0, 0, sig + 21);
+
+  (void) algo;
+
   return nettle_dsa_sha1_verify_digest(key, digest, sig_struct);
-} 
- 
+}
+
 #ifndef NO_NETTLE_ECC
-static int dnsmasq_ecdsa_verify(struct blockdata *key_data, unsigned int key_len, 
-				unsigned char *sig, size_t sig_len,
-				unsigned char *digest, size_t digest_len, int algo)
+static int dnsmasq_ecdsa_verify(struct blockdata *key_data,
+                                unsigned int key_len, unsigned char *sig,
+                                size_t sig_len, unsigned char *digest,
+                                size_t digest_len, int algo)
 {
   unsigned char *p;
   unsigned int t;
@@ -244,105 +263,109 @@
   static struct ecc_point *key_256 = NULL, *key_384 = NULL;
   static mpz_t x, y;
   static struct dsa_signature *sig_struct;
-  
-  if (!sig_struct)
-    {
-      if (!(sig_struct = whine_malloc(sizeof(struct dsa_signature))))
-	return 0;
-      
-      nettle_dsa_signature_init(sig_struct);
-      mpz_init(x);
-      mpz_init(y);
-    }
-  
-  switch (algo)
-    {
-    case 13:
-      if (!key_256)
-	{
-	  if (!(key_256 = whine_malloc(sizeof(struct ecc_point))))
-	    return 0;
-	  
-	  nettle_ecc_point_init(key_256, &nettle_secp_256r1);
-	}
-      
-      key = key_256;
-      t = 32;
-      break;
-      
-    case 14:
-      if (!key_384)
-	{
-	  if (!(key_384 = whine_malloc(sizeof(struct ecc_point))))
-	    return 0;
-	  
-	  nettle_ecc_point_init(key_384, &nettle_secp_384r1);
-	}
-      
-      key = key_384;
-      t = 48;
-      break;
-        
-    default:
+
+  if (!sig_struct) {
+    if (!(sig_struct = whine_malloc(sizeof(struct dsa_signature))))
       return 0;
+
+    nettle_dsa_signature_init(sig_struct);
+    mpz_init(x);
+    mpz_init(y);
+  }
+
+  switch (algo) {
+  case 13:
+    if (!key_256) {
+      if (!(key_256 = whine_malloc(sizeof(struct ecc_point))))
+        return 0;
+
+      nettle_ecc_point_init(key_256, &nettle_secp_256r1);
+    }
+
+    key = key_256;
+    t = 32;
+    break;
+
+  case 14:
+    if (!key_384) {
+      if (!(key_384 = whine_malloc(sizeof(struct ecc_point))))
+        return 0;
+
+      nettle_ecc_point_init(key_384, &nettle_secp_384r1);
     }
-  
-  if (sig_len != 2*t || key_len != 2*t ||
+
+    key = key_384;
+    t = 48;
+    break;
+
+  default:
+    return 0;
+  }
+
+  if (sig_len != 2 * t || key_len != 2 * t ||
       !(p = blockdata_retrieve(key_data, key_len, NULL)))
     return 0;
-  
-  mpz_import(x, t , 1, 1, 0, 0, p);
-  mpz_import(y, t , 1, 1, 0, 0, p + t);
+
+  mpz_import(x, t, 1, 1, 0, 0, p);
+  mpz_import(y, t, 1, 1, 0, 0, p + t);
 
   if (!ecc_point_set(key, x, y))
     return 0;
-  
+
   mpz_import(sig_struct->r, t, 1, 1, 0, 0, sig);
   mpz_import(sig_struct->s, t, 1, 1, 0, 0, sig + t);
-  
+
   return nettle_ecdsa_verify(key, digest_len, digest, sig_struct);
-} 
-#endif 
+}
+#endif
+
+static int (*verify_func(int algo)) (struct blockdata * key_data,
+                                     unsigned int key_len, unsigned char *sig,
+                                     size_t sig_len, unsigned char *digest,
+                                     size_t digest_len, int algo) {
 
-static int (*verify_func(int algo))(struct blockdata *key_data, unsigned int key_len, unsigned char *sig, size_t sig_len,
-				    unsigned char *digest, size_t digest_len, int algo)
-{
-    
   /* Enure at runtime that we have support for this digest */
   if (!hash_find(algo_digest_name(algo)))
     return NULL;
-  
+
   /* This switch defines which sig algorithms we support, can't introspect Nettle for that. */
-  switch (algo)
-    {
-    case 1: case 5: case 7: case 8: case 10:
-      return dnsmasq_rsa_verify;
-      
-    case 3: case 6: 
-      return dnsmasq_dsa_verify;
- 
-#ifndef NO_NETTLE_ECC   
-    case 13: case 14:
-      return dnsmasq_ecdsa_verify;
+  switch (algo) {
+  case 1:
+  case 5:
+  case 7:
+  case 8:
+  case 10:
+    return dnsmasq_rsa_verify;
+
+  case 3:
+  case 6:
+    return dnsmasq_dsa_verify;
+
+#ifndef NO_NETTLE_ECC
+  case 13:
+  case 14:
+    return dnsmasq_ecdsa_verify;
 #endif
-    }
-  
+  }
+
   return NULL;
 }
 
-static int verify(struct blockdata *key_data, unsigned int key_len, unsigned char *sig, size_t sig_len,
-		  unsigned char *digest, size_t digest_len, int algo)
+static int verify(struct blockdata *key_data, unsigned int key_len,
+                  unsigned char *sig, size_t sig_len, unsigned char *digest,
+                  size_t digest_len, int algo)
 {
 
-  int (*func)(struct blockdata *key_data, unsigned int key_len, unsigned char *sig, size_t sig_len,
-	      unsigned char *digest, size_t digest_len, int algo);
-  
+  int (*func) (struct blockdata * key_data, unsigned int key_len,
+               unsigned char *sig, size_t sig_len, unsigned char *digest,
+               size_t digest_len, int algo);
+
   func = verify_func(algo);
-  
+
   if (!func)
     return 0;
 
-  return (*func)(key_data, key_len, sig, sig_len, digest, digest_len, algo);
+  return (*func) (key_data, key_len, sig, sig_len, digest, digest_len, algo);
 }
 
 /* Convert from presentation format to wire format, in place.
@@ -366,30 +389,28 @@
   unsigned char *l, *p, *q, term;
   int len;
 
-  for (l = (unsigned char*)name; *l != 0; l = p)
-    {
-      for (p = l; *p != '.' && *p != 0; p++)
-	if (*p >= 'A' && *p <= 'Z')
-	  *p = *p - 'A' + 'a';
-	else if (*p == NAME_ESCAPE)
-	  {
-	    for (q = p; *q; q++)
-	      *q = *(q+1);
-	    (*p)--;
-	  }
-      term = *p;
-      
-      if ((len = p - l) != 0)
-	memmove(l+1, l, len);
-      *l = len;
-      
-      p++;
-      
-      if (term == 0)
-	*p = 0;
-    }
-  
-  return l + 1 - (unsigned char *)name;
+  for (l = (unsigned char *) name; *l != 0; l = p) {
+    for (p = l; *p != '.' && *p != 0; p++)
+      if (*p >= 'A' && *p <= 'Z')
+        *p = *p - 'A' + 'a';
+      else if (*p == NAME_ESCAPE) {
+        for (q = p; *q; q++)
+          *q = *(q + 1);
+        (*p)--;
+      }
+    term = *p;
+
+    if ((len = p - l) != 0)
+      memmove(l + 1, l, len);
+    *l = len;
+
+    p++;
+
+    if (term == 0)
+      *p = 0;
+  }
+
+  return l + 1 - (unsigned char *) name;
 }
 
 /* Note: no compression  allowed in input. */
@@ -397,27 +418,25 @@
 {
   unsigned char *l, *p, *last;
   int len;
-  
-  for (last = (unsigned char *)name; *last != 0; last += *last+1);
-  
-  for (l = (unsigned char *)name; *l != 0; l += len+1)
-    {
-      len = *l;
-      memmove(l, l+1, len);
-      for (p = l; p < l + len; p++)
-	if (*p == '.' || *p == 0 || *p == NAME_ESCAPE)
-	  {
-	    memmove(p+1, p, 1 + last - p);
-	    len++;
-	    *p++ = NAME_ESCAPE; 
-	    (*p)++;
-	  }
-	
-      l[len] = '.';
-    }
 
-  if ((char *)l != name)
-    *(l-1) = 0;
+  for (last = (unsigned char *) name; *last != 0; last += *last + 1);
+
+  for (l = (unsigned char *) name; *l != 0; l += len + 1) {
+    len = *l;
+    memmove(l, l + 1, len);
+    for (p = l; p < l + len; p++)
+      if (*p == '.' || *p == 0 || *p == NAME_ESCAPE) {
+        memmove(p + 1, p, 1 + last - p);
+        len++;
+        *p++ = NAME_ESCAPE;
+        (*p)++;
+      }
+
+    l[len] = '.';
+  }
+
+  if ((char *) l != name)
+    *(l - 1) = 0;
 }
 
 /* Input in presentation format */
@@ -432,7 +451,7 @@
     if (*name == '.')
       i++;
 
-  return i+1;
+  return i + 1;
 }
 
 /* Implement RFC1982 wrapped compare for 32-bit numbers */
@@ -441,11 +460,11 @@
   if (s1 == s2)
     return SERIAL_EQ;
 
-  if ((s1 < s2 && (s2 - s1) < (1UL<<31)) ||
-      (s1 > s2 && (s1 - s2) > (1UL<<31)))
+  if ((s1 < s2 && (s2 - s1) < (1UL << 31)) ||
+      (s1 > s2 && (s1 - s2) > (1UL << 31)))
     return SERIAL_LT;
-  if ((s1 < s2 && (s2 - s1) > (1UL<<31)) ||
-      (s1 > s2 && (s1 - s2) < (1UL<<31)))
+  if ((s1 < s2 && (s2 - s1) > (1UL << 31)) ||
+      (s1 > s2 && (s1 - s2) < (1UL << 31)))
     return SERIAL_GT;
   return SERIAL_UNDEF;
 }
@@ -462,44 +481,43 @@
 int setup_timestamp(void)
 {
   struct stat statbuf;
-  
+
   daemon->back_to_the_future = 0;
-  
+
   if (!daemon->timestamp_file)
     return 0;
-  
-  if (stat(daemon->timestamp_file, &statbuf) != -1)
-    {
-      timestamp_time = statbuf.st_mtime;
-    check_and_exit:
-      if (difftime(timestamp_time, time(0)) <=  0)
-	{
-	  /* time already OK, update timestamp, and do key checking from the start. */
-	  if (utimes(daemon->timestamp_file, NULL) == -1)
-	    my_syslog(LOG_ERR, _("failed to update mtime on %s: %s"), daemon->timestamp_file, strerror(errno));
-	  daemon->back_to_the_future = 1;
-	  return 0;
-	}
-      return 1;
+
+  if (stat(daemon->timestamp_file, &statbuf) != -1) {
+    timestamp_time = statbuf.st_mtime;
+  check_and_exit:
+    if (difftime(timestamp_time, time(0)) <= 0) {
+      /* time already OK, update timestamp, and do key checking from the start. */
+      if (utimes(daemon->timestamp_file, NULL) == -1)
+        my_syslog(LOG_ERR, _("failed to update mtime on %s: %s"),
+                  daemon->timestamp_file, strerror(errno));
+      daemon->back_to_the_future = 1;
+      return 0;
     }
-  
-  if (errno == ENOENT)
-    {
-      /* NB. for explanation of O_EXCL flag, see comment on pidfile in dnsmasq.c */ 
-      int fd = open(daemon->timestamp_file, O_WRONLY | O_CREAT | O_NONBLOCK | O_EXCL, 0666);
-      if (fd != -1)
-	{
-	  struct timeval tv[2];
-
-	  close(fd);
-	  
-	  timestamp_time = 1420070400; /* 1-1-2015 */
-	  tv[0].tv_sec = tv[1].tv_sec = timestamp_time;
-	  tv[0].tv_usec = tv[1].tv_usec = 0;
-	  if (utimes(daemon->timestamp_file, tv) == 0)
-	    goto check_and_exit;
-	}
+    return 1;
+  }
+
+  if (errno == ENOENT) {
+    /* NB. for explanation of O_EXCL flag, see comment on pidfile in dnsmasq.c */
+    int fd =
+        open(daemon->timestamp_file, O_WRONLY | O_CREAT | O_NONBLOCK | O_EXCL,
+             0666);
+    if (fd != -1) {
+      struct timeval tv[2];
+
+      close(fd);
+
+      timestamp_time = 1420070400;      /* 1-1-2015 */
+      tv[0].tv_sec = tv[1].tv_sec = timestamp_time;
+      tv[0].tv_usec = tv[1].tv_usec = 0;
+      if (utimes(daemon->timestamp_file, tv) == 0)
+        goto check_and_exit;
     }
+  }
 
   return -1;
 }
@@ -508,80 +526,77 @@
 static int check_date_range(u32 date_start, u32 date_end)
 {
   unsigned long curtime = time(0);
- 
+
   /* Checking timestamps may be temporarily disabled */
-    
+
   /* If the current time if _before_ the timestamp
      on our persistent timestamp file, then assume the
      time if not yet correct, and don't check the
      key timestamps. As soon as the current time is
      later then the timestamp, update the timestamp
      and start checking keys */
-  if (daemon->timestamp_file)
-    {
-      if (daemon->back_to_the_future == 0 && difftime(timestamp_time, curtime) <= 0)
-	{
-	  if (utimes(daemon->timestamp_file, NULL) != 0)
-	    my_syslog(LOG_ERR, _("failed to update mtime on %s: %s"), daemon->timestamp_file, strerror(errno));
-	  
-	  my_syslog(LOG_INFO, _("system time considered valid, now checking DNSSEC signature timestamps."));
-	  daemon->back_to_the_future = 1;
-	  daemon->dnssec_no_time_check = 0;
-	  queue_event(EVENT_RELOAD); /* purge cache */
-	} 
-
-      if (daemon->back_to_the_future == 0)
-	return 1;
+  if (daemon->timestamp_file) {
+    if (daemon->back_to_the_future == 0
+        && difftime(timestamp_time, curtime) <= 0) {
+      if (utimes(daemon->timestamp_file, NULL) != 0)
+        my_syslog(LOG_ERR, _("failed to update mtime on %s: %s"),
+                  daemon->timestamp_file, strerror(errno));
+
+      my_syslog(LOG_INFO,
+                _
+                ("system time considered valid, now checking DNSSEC signature timestamps."));
+      daemon->back_to_the_future = 1;
+      daemon->dnssec_no_time_check = 0;
+      queue_event(EVENT_RELOAD);        /* purge cache */
     }
-  else if (daemon->dnssec_no_time_check)
+
+    if (daemon->back_to_the_future == 0)
+      return 1;
+  } else if (daemon->dnssec_no_time_check)
     return 1;
-  
+
   /* We must explicitly check against wanted values, because of SERIAL_UNDEF */
   return serial_compare_32(curtime, date_start) == SERIAL_GT
-    && serial_compare_32(curtime, date_end) == SERIAL_LT;
+      && serial_compare_32(curtime, date_end) == SERIAL_LT;
 }
 
 /* Return bytes of canonicalised rdata, when the return value is zero, the remaining 
    data, pointed to by *p, should be used raw. */
-static int get_rdata(struct dns_header *header, size_t plen, unsigned char *end, char *buff, int bufflen,
-		     unsigned char **p, u16 **desc)
+static int get_rdata(struct dns_header *header, size_t plen, unsigned char *end,
+                     char *buff, int bufflen, unsigned char **p, u16 ** desc)
 {
   int d = **desc;
-  
+
   /* No more data needs mangling */
-  if (d == (u16)-1)
-    {
-      /* If there's more data than we have space for, just return what fits,
-	 we'll get called again for more chunks */
-      if (end - *p > bufflen)
-	{
-	  memcpy(buff, *p, bufflen);
-	  *p += bufflen;
-	  return bufflen;
-	}
-      
-      return 0;
+  if (d == (u16) - 1) {
+    /* If there's more data than we have space for, just return what fits,
+       we'll get called again for more chunks */
+    if (end - *p > bufflen) {
+      memcpy(buff, *p, bufflen);
+      *p += bufflen;
+      return bufflen;
     }
- 
+
+    return 0;
+  }
+
   (*desc)++;
-  
+
   if (d == 0 && extract_name(header, plen, p, buff, 1, 0))
     /* domain-name, canonicalise */
     return to_wire(buff);
-  else
-    { 
-      /* plain data preceding a domain-name, don't run off the end of the data */
-      if ((end - *p) < d)
-	d = end - *p;
-      
-      if (d != 0)
-	{
-	  memcpy(buff, *p, d);
-	  *p += d;
-	}
-      
-      return d;
+  else {
+    /* plain data preceding a domain-name, don't run off the end of the data */
+    if ((end - *p) < d)
+      d = end - *p;
+
+    if (d != 0) {
+      memcpy(buff, *p, d);
+      *p += d;
     }
+
+    return d;
+  }
 }
 
 /* Bubble sort the RRset into the canonical order. 
@@ -598,86 +613,85 @@
    leaving the following bytes as deciding the order. Hence the nasty left1 and left2 variables.
 */
 
-static void sort_rrset(struct dns_header *header, size_t plen, u16 *rr_desc, int rrsetidx, 
-		       unsigned char **rrset, char *buff1, char *buff2)
+static void sort_rrset(struct dns_header *header, size_t plen, u16 * rr_desc,
+                       int rrsetidx, unsigned char **rrset, char *buff1,
+                       char *buff2)
 {
   int swap, quit, i;
-  
-  do
-    {
-      for (swap = 0, i = 0; i < rrsetidx-1; i++)
-	{
-	  int rdlen1, rdlen2, left1, left2, len1, len2, len, rc;
-	  u16 *dp1, *dp2;
-	  unsigned char *end1, *end2;
-	  /* Note that these have been determined to be OK previously,
-	     so we don't need to check for NULL return here. */
-	  unsigned char *p1 = skip_name(rrset[i], header, plen, 10);
-	  unsigned char *p2 = skip_name(rrset[i+1], header, plen, 10);
-	  
-	  p1 += 8; /* skip class, type, ttl */
-	  GETSHORT(rdlen1, p1);
-	  end1 = p1 + rdlen1;
-	  
-	  p2 += 8; /* skip class, type, ttl */
-	  GETSHORT(rdlen2, p2);
-	  end2 = p2 + rdlen2; 
-	  
-	  dp1 = dp2 = rr_desc;
-	  
-	  for (quit = 0, left1 = 0, left2 = 0, len1 = 0, len2 = 0; !quit;)
-	    {
-	      if (left1 != 0)
-		memmove(buff1, buff1 + len1 - left1, left1);
-	      
-	      if ((len1 = get_rdata(header, plen, end1, buff1 + left1, (MAXDNAME * 2) - left1, &p1, &dp1)) == 0)
-		{
-		  quit = 1;
-		  len1 = end1 - p1;
-		  memcpy(buff1 + left1, p1, len1);
-		}
-	      len1 += left1;
-	      
-	      if (left2 != 0)
-		memmove(buff2, buff2 + len2 - left2, left2);
-	      
-	      if ((len2 = get_rdata(header, plen, end2, buff2 + left2, (MAXDNAME *2) - left2, &p2, &dp2)) == 0)
-		{
-		  quit = 1;
-		  len2 = end2 - p2;
-		  memcpy(buff2 + left2, p2, len2);
-		}
-	      len2 += left2;
-	       
-	      if (len1 > len2)
-		left1 = len1 - len2, left2 = 0, len = len2;
-	      else
-		left2 = len2 - len1, left1 = 0, len = len1;
-	      
-	      rc = (len == 0) ? 0 : memcmp(buff1, buff2, len);
-	      
-	      if (rc > 0 || (rc == 0 && quit && len1 > len2))
-		{
-		  unsigned char *tmp = rrset[i+1];
-		  rrset[i+1] = rrset[i];
-		  rrset[i] = tmp;
-		  swap = quit = 1;
-		}
-	      else if (rc < 0)
-		quit = 1;
-	    }
-	}
-    } while (swap);
+
+  do {
+    for (swap = 0, i = 0; i < rrsetidx - 1; i++) {
+      int rdlen1, rdlen2, left1, left2, len1, len2, len, rc;
+      u16 *dp1, *dp2;
+      unsigned char *end1, *end2;
+      /* Note that these have been determined to be OK previously,
+         so we don't need to check for NULL return here. */
+      unsigned char *p1 = skip_name(rrset[i], header, plen, 10);
+      unsigned char *p2 = skip_name(rrset[i + 1], header, plen, 10);
+
+      p1 += 8;                  /* skip class, type, ttl */
+      GETSHORT(rdlen1, p1);
+      end1 = p1 + rdlen1;
+
+      p2 += 8;                  /* skip class, type, ttl */
+      GETSHORT(rdlen2, p2);
+      end2 = p2 + rdlen2;
+
+      dp1 = dp2 = rr_desc;
+
+      for (quit = 0, left1 = 0, left2 = 0, len1 = 0, len2 = 0; !quit;) {
+        if (left1 != 0)
+          memmove(buff1, buff1 + len1 - left1, left1);
+
+        if ((len1 =
+             get_rdata(header, plen, end1, buff1 + left1,
+                       (MAXDNAME * 2) - left1, &p1, &dp1)) == 0) {
+          quit = 1;
+          len1 = end1 - p1;
+          memcpy(buff1 + left1, p1, len1);
+        }
+        len1 += left1;
+
+        if (left2 != 0)
+          memmove(buff2, buff2 + len2 - left2, left2);
+
+        if ((len2 =
+             get_rdata(header, plen, end2, buff2 + left2,
+                       (MAXDNAME * 2) - left2, &p2, &dp2)) == 0) {
+          quit = 1;
+          len2 = end2 - p2;
+          memcpy(buff2 + left2, p2, len2);
+        }
+        len2 += left2;
+
+        if (len1 > len2)
+          left1 = len1 - len2, left2 = 0, len = len2;
+        else
+          left2 = len2 - len1, left1 = 0, len = len1;
+
+        rc = (len == 0) ? 0 : memcmp(buff1, buff2, len);
+
+        if (rc > 0 || (rc == 0 && quit && len1 > len2)) {
+          unsigned char *tmp = rrset[i + 1];
+          rrset[i + 1] = rrset[i];
+          rrset[i] = tmp;
+          swap = quit = 1;
+        } else if (rc < 0)
+          quit = 1;
+      }
+    }
+  } while (swap);
 }
 
 static unsigned char **rrset = NULL, **sigs = NULL;
 
 /* Get pointers to RRset members and signature(s) for same.
    Check signatures, and return keyname associated in keyname. */
-static int explore_rrset(struct dns_header *header, size_t plen, int class, int type, 
-			 char *name, char *keyname, int *sigcnt, int *rrcnt)
+static int explore_rrset(struct dns_header *header, size_t plen, int class,
+                         int type, char *name, char *keyname, int *sigcnt,
+                         int *rrcnt)
 {
-  static int rrset_sz = 0, sig_sz = 0; 
+  static int rrset_sz = 0, sig_sz = 0;
   unsigned char *p;
   int rrsetidx, sigidx, j, rdlen, res;
   int gotkey = 0;
@@ -685,94 +699,85 @@
   if (!(p = skip_questions(header, plen)))
     return STAT_BOGUS;
 
-   /* look for RRSIGs for this RRset and get pointers to each RR in the set. */
-  for (rrsetidx = 0, sigidx = 0, j = ntohs(header->ancount) + ntohs(header->nscount); 
-       j != 0; j--) 
-    {
-      unsigned char *pstart, *pdata;
-      int stype, sclass, type_covered;
-
-      pstart = p;
-      
-      if (!(res = extract_name(header, plen, &p, name, 0, 10)))
-	return STAT_BOGUS; /* bad packet */
-      
-      GETSHORT(stype, p);
-      GETSHORT(sclass, p);
-      p += 4; /* TTL */
-      
-      pdata = p;
+  /* look for RRSIGs for this RRset and get pointers to each RR in the set. */
+  for (rrsetidx = 0, sigidx = 0, j =
+       ntohs(header->ancount) + ntohs(header->nscount); j != 0; j--) {
+    unsigned char *pstart, *pdata;
+    int stype, sclass, type_covered;
 
-      GETSHORT(rdlen, p);
-      
-      if (!CHECK_LEN(header, p, plen, rdlen))
-	return 0; 
-      
-      if (res == 1 && sclass == class)
-	{
-	  if (stype == type)
-	    {
-	      if (!expand_workspace(&rrset, &rrset_sz, rrsetidx))
-		return 0; 
-	      
-	      rrset[rrsetidx++] = pstart;
-	    }
-	  
-	  if (stype == T_RRSIG)
-	    {
-	      if (rdlen < 18)
-		return 0; /* bad packet */ 
-	      
-	      GETSHORT(type_covered, p);
-	      p += 16; /* algo, labels, orig_ttl, sig_expiration, sig_inception, key_tag */
-	      
-	      if (gotkey)
-		{
-		  /* If there's more than one SIG, ensure they all have same keyname */
-		  if (extract_name(header, plen, &p, keyname, 0, 0) != 1)
-		    return 0;
-		}
-	      else
-		{
-		  gotkey = 1;
-		  
-		  if (!extract_name(header, plen, &p, keyname, 1, 0))
-		    return 0;
-		  
-		  /* RFC 4035 5.3.1 says that the Signer's Name field MUST equal
-		     the name of the zone containing the RRset. We can't tell that
-		     for certain, but we can check that  the RRset name is equal to
-		     or encloses the signers name, which should be enough to stop 
-		     an attacker using signatures made with the key of an unrelated 
-		     zone he controls. Note that the root key is always allowed. */
-		  if (*keyname != 0)
-		    {
-		      char *name_start;
-		      for (name_start = name; !hostname_isequal(name_start, keyname); )
-			if ((name_start = strchr(name_start, '.')))
-			  name_start++; /* chop a label off and try again */
-			else
-			  return 0;
-		    }
-		}
-		  
-	      
-	      if (type_covered == type)
-		{
-		  if (!expand_workspace(&sigs, &sig_sz, sigidx))
-		    return 0; 
-		  
-		  sigs[sigidx++] = pdata;
-		} 
-	      
-	      p = pdata + 2; /* restore for ADD_RDLEN */
-	    }
-	}
-      
-      if (!ADD_RDLEN(header, p, plen, rdlen))
-	return 0;
+    pstart = p;
+
+    if (!(res = extract_name(header, plen, &p, name, 0, 10)))
+      return STAT_BOGUS;        /* bad packet */
+
+    GETSHORT(stype, p);
+    GETSHORT(sclass, p);
+    p += 4;                     /* TTL */
+
+    pdata = p;
+
+    GETSHORT(rdlen, p);
+
+    if (!CHECK_LEN(header, p, plen, rdlen))
+      return 0;
+
+    if (res == 1 && sclass == class) {
+      if (stype == type) {
+        if (!expand_workspace(&rrset, &rrset_sz, rrsetidx))
+          return 0;
+
+        rrset[rrsetidx++] = pstart;
+      }
+
+      if (stype == T_RRSIG) {
+        if (rdlen < 18)
+          return 0;             /* bad packet */
+
+        GETSHORT(type_covered, p);
+        p += 16;                /* algo, labels, orig_ttl, sig_expiration, sig_inception, key_tag */
+
+        if (gotkey) {
+          /* If there's more than one SIG, ensure they all have same keyname */
+          if (extract_name(header, plen, &p, keyname, 0, 0) != 1)
+            return 0;
+        } else {
+          gotkey = 1;
+
+          if (!extract_name(header, plen, &p, keyname, 1, 0))
+            return 0;
+
+          /* RFC 4035 5.3.1 says that the Signer's Name field MUST equal
+             the name of the zone containing the RRset. We can't tell that
+             for certain, but we can check that  the RRset name is equal to
+             or encloses the signers name, which should be enough to stop
+             an attacker using signatures made with the key of an unrelated
+             zone he controls. Note that the root key is always allowed. */
+          if (*keyname != 0) {
+            char *name_start;
+            for (name_start = name; !hostname_isequal(name_start, keyname);)
+              if ((name_start = strchr(name_start, '.')))
+                name_start++;   /* chop a label off and try again */
+              else
+                return 0;
+          }
+        }
+
+
+        if (type_covered == type) {
+          if (!expand_workspace(&sigs, &sig_sz, sigidx))
+            return 0;
+
+          sigs[sigidx++] = pdata;
+        }
+
+        p = pdata + 2;          /* restore for ADD_RDLEN */
+      }
     }
-  
+
+    if (!ADD_RDLEN(header, p, plen, rdlen))
+      return 0;
+  }
+
   *sigcnt = sigidx;
   *rrcnt = rrsetidx;
 
@@ -795,158 +800,158 @@
 
    Call explore_rrset first to find and count RRs and sigs.
 */
-static int validate_rrset(time_t now, struct dns_header *header, size_t plen, int class, int type, int sigidx, int rrsetidx, 
-			  char *name, char *keyname, char **wildcard_out, struct blockdata *key, int keylen, int algo_in, int keytag_in)
+static int validate_rrset(time_t now, struct dns_header *header, size_t plen,
+                          int class, int type, int sigidx, int rrsetidx,
+                          char *name, char *keyname, char **wildcard_out,
+                          struct blockdata *key, int keylen, int algo_in,
+                          int keytag_in)
 {
   unsigned char *p;
   int rdlen, j, name_labels, algo, labels, orig_ttl, key_tag;
   struct crec *crecp = NULL;
   u16 *rr_desc = rrfilter_desc(type);
-  u32 sig_expiration, sig_inception
-;
+  u32 sig_expiration, sig_inception;
   if (wildcard_out)
     *wildcard_out = NULL;
-  
-  name_labels = count_labels(name); /* For 4035 5.3.2 check */
+
+  name_labels = count_labels(name);     /* For 4035 5.3.2 check */
 
   /* Sort RRset records into canonical order. 
      Note that at this point keyname and daemon->workspacename buffs are
      unused, and used as workspace by the sort. */
-  sort_rrset(header, plen, rr_desc, rrsetidx, rrset, daemon->workspacename, keyname);
-         
+  sort_rrset(header, plen, rr_desc, rrsetidx, rrset, daemon->workspacename,
+             keyname);
+
   /* Now try all the sigs to try and find one which validates */
-  for (j = 0; j <sigidx; j++)
-    {
-      unsigned char *psav, *sig, *digest;
-      int i, wire_len, sig_len;
-      const struct nettle_hash *hash;
-      void *ctx;
-      char *name_start;
-      u32 nsigttl;
-      
-      p = sigs[j];
-      GETSHORT(rdlen, p); /* rdlen >= 18 checked previously */
-      psav = p;
-      
-      p += 2; /* type_covered - already checked */
-      algo = *p++;
-      labels = *p++;
-      GETLONG(orig_ttl, p);
-      GETLONG(sig_expiration, p);
-      GETLONG(sig_inception, p);
-      GETSHORT(key_tag, p);
-      
-      if (!extract_name(header, plen, &p, keyname, 1, 0))
-	return STAT_BOGUS;
-
-      if (!check_date_range(sig_inception, sig_expiration) ||
-	  labels > name_labels ||
-	  !(hash = hash_find(algo_digest_name(algo))) ||
-	  !hash_init(hash, &ctx, &digest))
-	continue;
-      
-      /* OK, we have the signature record, see if the relevant DNSKEY is in the cache. */
-      if (!key && !(crecp = cache_find_by_name(NULL, keyname, now, F_DNSKEY)))
-	return STAT_NEED_KEY;
-      
-      sig = p;
-      sig_len = rdlen - (p - psav);
-              
-      nsigttl = htonl(orig_ttl);
-      
-      hash->update(ctx, 18, psav);
-      wire_len = to_wire(keyname);
-      hash->update(ctx, (unsigned int)wire_len, (unsigned char*)keyname);
-      from_wire(keyname);
-      
-      for (i = 0; i < rrsetidx; ++i)
-	{
-	  int seg;
-	  unsigned char *end, *cp;
-	  u16 len, *dp;
-	  
-	  p = rrset[i];
-	  if (!extract_name(header, plen, &p, name, 1, 10)) 
-	    return STAT_BOGUS;
-
-	  name_start = name;
-	  
-	  /* if more labels than in RRsig name, hash *.<no labels in rrsig labels field>  4035 5.3.2 */
-	  if (labels < name_labels)
-	    {
-	      int k;
-	      for (k = name_labels - labels; k != 0; k--)
-		{
-		  while (*name_start != '.' && *name_start != 0)
-		    name_start++;
-		  if (k != 1 && *name_start == '.')
-		    name_start++;
-		}
-	      
-	      if (wildcard_out)
-		*wildcard_out = name_start+1;
-
-	      name_start--;
-	      *name_start = '*';
-	    }
-	  
-	  wire_len = to_wire(name_start);
-	  hash->update(ctx, (unsigned int)wire_len, (unsigned char *)name_start);
-	  hash->update(ctx, 4, p); /* class and type */
-	  hash->update(ctx, 4, (unsigned char *)&nsigttl);
-	  
-	  p += 8; /* skip class, type, ttl */
-	  GETSHORT(rdlen, p);
-	  if (!CHECK_LEN(header, p, plen, rdlen))
-	    return STAT_BOGUS; 
-	  
-	  end = p + rdlen;
-	  
-	  /* canonicalise rdata and calculate length of same, use name buffer as workspace.
-	     Note that name buffer is twice MAXDNAME long in DNSSEC mode. */
-	  cp = p;
-	  dp = rr_desc;
-	  for (len = 0; (seg = get_rdata(header, plen, end, name, MAXDNAME * 2, &cp, &dp)) != 0; len += seg);
-	  len += end - cp;
-	  len = htons(len);
-	  hash->update(ctx, 2, (unsigned char *)&len); 
-	  
-	  /* Now canonicalise again and digest. */
-	  cp = p;
-	  dp = rr_desc;
-	  while ((seg = get_rdata(header, plen, end, name, MAXDNAME * 2, &cp, &dp)))
-	    hash->update(ctx, seg, (unsigned char *)name);
-	  if (cp != end)
-	    hash->update(ctx, end - cp, cp);
-	}
-     
-      hash->digest(ctx, hash->digest_size, digest);
-      
-      /* namebuff used for workspace above, restore to leave unchanged on exit */
-      p = (unsigned char*)(rrset[0]);
-      extract_name(header, plen, &p, name, 1, 0);
+  for (j = 0; j < sigidx; j++) {
+    unsigned char *psav, *sig, *digest;
+    int i, wire_len, sig_len;
+    const struct nettle_hash *hash;
+    void *ctx;
+    char *name_start;
+    u32 nsigttl;
+
+    p = sigs[j];
+    GETSHORT(rdlen, p);         /* rdlen >= 18 checked previously */
+    psav = p;
+
+    p += 2;                     /* type_covered - already checked */
+    algo = *p++;
+    labels = *p++;
+    GETLONG(orig_ttl, p);
+    GETLONG(sig_expiration, p);
+    GETLONG(sig_inception, p);
+    GETSHORT(key_tag, p);
 
-      if (key)
-	{
-	  if (algo_in == algo && keytag_in == key_tag &&
-	      verify(key, keylen, sig, sig_len, digest, hash->digest_size, algo))
-	    return STAT_SECURE;
-	}
-      else
-	{
-	  /* iterate through all possible keys 4035 5.3.1 */
-	  for (; crecp; crecp = cache_find_by_name(crecp, keyname, now, F_DNSKEY))
-	    if (crecp->addr.key.algo == algo && 
-		crecp->addr.key.keytag == key_tag &&
-		crecp->uid == (unsigned int)class &&
-		verify(crecp->addr.key.keydata, crecp->addr.key.keylen, sig, sig_len, digest, hash->digest_size, algo))
-	      return (labels < name_labels) ? STAT_SECURE_WILDCARD : STAT_SECURE;
-	}
+    if (!extract_name(header, plen, &p, keyname, 1, 0))
+      return STAT_BOGUS;
+
+    if (!check_date_range(sig_inception, sig_expiration) ||
+        labels > name_labels ||
+        !(hash = hash_find(algo_digest_name(algo))) ||
+        !hash_init(hash, &ctx, &digest))
+      continue;
+
+    /* OK, we have the signature record, see if the relevant DNSKEY is in the cache. */
+    if (!key && !(crecp = cache_find_by_name(NULL, keyname, now, F_DNSKEY)))
+      return STAT_NEED_KEY;
+
+    sig = p;
+    sig_len = rdlen - (p - psav);
+
+    nsigttl = htonl(orig_ttl);
+
+    hash->update(ctx, 18, psav);
+    wire_len = to_wire(keyname);
+    hash->update(ctx, (unsigned int) wire_len, (unsigned char *) keyname);
+    from_wire(keyname);
+
+    for (i = 0; i < rrsetidx; ++i) {
+      int seg;
+      unsigned char *end, *cp;
+      u16 len, *dp;
+
+      p = rrset[i];
+      if (!extract_name(header, plen, &p, name, 1, 10))
+        return STAT_BOGUS;
+
+      name_start = name;
+
+      /* if more labels than in RRsig name, hash *.<no labels in rrsig labels field>  4035 5.3.2 */
+      if (labels < name_labels) {
+        int k;
+        for (k = name_labels - labels; k != 0; k--) {
+          while (*name_start != '.' && *name_start != 0)
+            name_start++;
+          if (k != 1 && *name_start == '.')
+            name_start++;
+        }
+
+        if (wildcard_out)
+          *wildcard_out = name_start + 1;
+
+        name_start--;
+        *name_start = '*';
+      }
+
+      wire_len = to_wire(name_start);
+      hash->update(ctx, (unsigned int) wire_len, (unsigned char *) name_start);
+      hash->update(ctx, 4, p);  /* class and type */
+      hash->update(ctx, 4, (unsigned char *) &nsigttl);
+
+      p += 8;                   /* skip class, type, ttl */
+      GETSHORT(rdlen, p);
+      if (!CHECK_LEN(header, p, plen, rdlen))
+        return STAT_BOGUS;
+
+      end = p + rdlen;
+
+      /* canonicalise rdata and calculate length of same, use name buffer as workspace.
+         Note that name buffer is twice MAXDNAME long in DNSSEC mode. */
+      cp = p;
+      dp = rr_desc;
+      for (len = 0;
+           (seg =
+            get_rdata(header, plen, end, name, MAXDNAME * 2, &cp, &dp)) != 0;
+           len += seg);
+      len += end - cp;
+      len = htons(len);
+      hash->update(ctx, 2, (unsigned char *) &len);
+
+      /* Now canonicalise again and digest. */
+      cp = p;
+      dp = rr_desc;
+      while ((seg = get_rdata(header, plen, end, name, MAXDNAME * 2, &cp, &dp)))
+        hash->update(ctx, seg, (unsigned char *) name);
+      if (cp != end)
+        hash->update(ctx, end - cp, cp);
+    }
+
+    hash->digest(ctx, hash->digest_size, digest);
+
+    /* namebuff used for workspace above, restore to leave unchanged on exit */
+    p = (unsigned char *) (rrset[0]);
+    extract_name(header, plen, &p, name, 1, 0);
+
+    if (key) {
+      if (algo_in == algo && keytag_in == key_tag &&
+          verify(key, keylen, sig, sig_len, digest, hash->digest_size, algo))
+        return STAT_SECURE;
+    } else {
+      /* iterate through all possible keys 4035 5.3.1 */
+      for (; crecp; crecp = cache_find_by_name(crecp, keyname, now, F_DNSKEY))
+        if (crecp->addr.key.algo == algo &&
+            crecp->addr.key.keytag == key_tag &&
+            crecp->uid == (unsigned int) class &&
+            verify(crecp->addr.key.keydata, crecp->addr.key.keylen, sig,
+                   sig_len, digest, hash->digest_size, algo))
+          return (labels < name_labels) ? STAT_SECURE_WILDCARD : STAT_SECURE;
     }
+  }
 
   return STAT_BOGUS;
 }
- 
+
 
 /* The DNS packet is expected to contain the answer to a DNSKEY query.
    Put all DNSKEYs in the answer which are valid into the cache.
@@ -957,9 +962,10 @@
 	 STAT_NEED_DS   DS records to validate a key not found, name in keyname 
 	 STAT_NEED_KEY  DNSKEY records to validate a key not found, name in keyname 
 */
-int dnssec_validate_by_ds(time_t now, struct dns_header *header, size_t plen, char *name, char *keyname, int class)
+int dnssec_validate_by_ds(time_t now, struct dns_header *header, size_t plen,
+                          char *name, char *keyname, int class)
 {
-  unsigned char *psave, *p = (unsigned char *)(header+1);
+  unsigned char *psave, *p = (unsigned char *) (header + 1);
   struct crec *crecp, *recp1;
   int rc, j, qtype, qclass, ttl, rdlen, flags, algo, valid, keytag;
   struct blockdata *key;
@@ -971,181 +977,175 @@
 
   GETSHORT(qtype, p);
   GETSHORT(qclass, p);
-  
+
   if (qtype != T_DNSKEY || qclass != class || ntohs(header->ancount) == 0)
     return STAT_BOGUS;
 
   /* See if we have cached a DS record which validates this key */
-  if (!(crecp = cache_find_by_name(NULL, name, now, F_DS)))
-    {
-      strcpy(keyname, name);
-      return STAT_NEED_DS;
-    }
-  
+  if (!(crecp = cache_find_by_name(NULL, name, now, F_DS))) {
+    strcpy(keyname, name);
+    return STAT_NEED_DS;
+  }
+
   /* NOTE, we need to find ONE DNSKEY which matches the DS */
-  for (valid = 0, j = ntohs(header->ancount); j != 0 && !valid; j--) 
-    {
+  for (valid = 0, j = ntohs(header->ancount); j != 0 && !valid; j--) {
+    /* Ensure we have type, class  TTL and length */
+    if (!(rc = extract_name(header, plen, &p, name, 0, 10)))
+      return STAT_BOGUS;        /* bad packet */
+
+    GETSHORT(qtype, p);
+    GETSHORT(qclass, p);
+    GETLONG(ttl, p);
+    GETSHORT(rdlen, p);
+
+    if (!CHECK_LEN(header, p, plen, rdlen) || rdlen < 4)
+      return STAT_BOGUS;        /* bad packet */
+
+    if (qclass != class || qtype != T_DNSKEY || rc == 2) {
+      p += rdlen;
+      continue;
+    }
+
+    psave = p;
+
+    GETSHORT(flags, p);
+    if (*p++ != 3)
+      return STAT_BOGUS;
+    algo = *p++;
+    keytag = dnskey_keytag(algo, flags, p, rdlen - 4);
+    key = NULL;
+
+    /* key must have zone key flag set */
+    if (flags & 0x100)
+      key = blockdata_alloc((char *) p, rdlen - 4);
+
+    p = psave;
+
+    if (!ADD_RDLEN(header, p, plen, rdlen)) {
+      if (key)
+        blockdata_free(key);
+      return STAT_BOGUS;        /* bad packet */
+    }
+
+    /* No zone key flag or malloc failure */
+    if (!key)
+      continue;
+
+    for (recp1 = crecp; recp1;
+         recp1 = cache_find_by_name(recp1, name, now, F_DS)) {
+      void *ctx;
+      unsigned char *digest, *ds_digest;
+      const struct nettle_hash *hash;
+      int sigcnt, rrcnt;
+
+      if (recp1->addr.ds.algo == algo &&
+          recp1->addr.ds.keytag == keytag &&
+          recp1->uid == (unsigned int) class &&
+          (hash = hash_find(ds_digest_name(recp1->addr.ds.digest))) &&
+          hash_init(hash, &ctx, &digest))
+      {
+        int wire_len = to_wire(name);
+
+        /* Note that digest may be different between DSs, so
+           we can't move this outside the loop. */
+        hash->update(ctx, (unsigned int) wire_len, (unsigned char *) name);
+        hash->update(ctx, (unsigned int) rdlen, psave);
+        hash->digest(ctx, hash->digest_size, digest);
+
+        from_wire(name);
+
+        if (!(recp1->flags & F_NEG) &&
+            recp1->addr.ds.keylen == (int) hash->digest_size &&
+            (ds_digest =
+             blockdata_retrieve(recp1->addr.key.keydata, recp1->addr.ds.keylen,
+                                NULL))
+            && memcmp(ds_digest, digest, recp1->addr.ds.keylen) == 0
+            && explore_rrset(header, plen, class, T_DNSKEY, name, keyname,
+                             &sigcnt, &rrcnt) && sigcnt != 0 && rrcnt != 0
+            && validate_rrset(now, header, plen, class, T_DNSKEY, sigcnt, rrcnt,
+                              name, keyname, NULL, key, rdlen - 4, algo,
+                              keytag) == STAT_SECURE) {
+          valid = 1;
+          break;
+        }
+      }
+    }
+    blockdata_free(key);
+  }
+
+  if (valid) {
+    /* DNSKEY RRset determined to be OK, now cache it. */
+    cache_start_insert();
+
+    p = skip_questions(header, plen);
+
+    for (j = ntohs(header->ancount); j != 0; j--) {
       /* Ensure we have type, class  TTL and length */
       if (!(rc = extract_name(header, plen, &p, name, 0, 10)))
-	return STAT_BOGUS; /* bad packet */
-  
-      GETSHORT(qtype, p); 
+        return STAT_BOGUS;      /* bad packet */
+
+      GETSHORT(qtype, p);
       GETSHORT(qclass, p);
       GETLONG(ttl, p);
       GETSHORT(rdlen, p);
- 
-      if (!CHECK_LEN(header, p, plen, rdlen) || rdlen < 4)
-	return STAT_BOGUS; /* bad packet */
-      
-      if (qclass != class || qtype != T_DNSKEY || rc == 2)
-	{
-	  p += rdlen;
-	  continue;
-	}
-            
-      psave = p;
-      
-      GETSHORT(flags, p);
-      if (*p++ != 3)
-	return STAT_BOGUS;
-      algo = *p++;
-      keytag = dnskey_keytag(algo, flags, p, rdlen - 4);
-      key = NULL;
-      
-      /* key must have zone key flag set */
-      if (flags & 0x100)
-	key = blockdata_alloc((char*)p, rdlen - 4);
-      
-      p = psave;
-      
-      if (!ADD_RDLEN(header, p, plen, rdlen))
-	{
-	  if (key)
-	    blockdata_free(key);
-	  return STAT_BOGUS; /* bad packet */
-	}
-
-      /* No zone key flag or malloc failure */
-      if (!key)
-	continue;
-      
-      for (recp1 = crecp; recp1; recp1 = cache_find_by_name(recp1, name, now, F_DS))
-	{
-	  void *ctx;
-	  unsigned char *digest, *ds_digest;
-	  const struct nettle_hash *hash;
-	  int sigcnt, rrcnt;
-
-	  if (recp1->addr.ds.algo == algo && 
-	      recp1->addr.ds.keytag == keytag &&
-	      recp1->uid == (unsigned int)class &&
-	      (hash = hash_find(ds_digest_name(recp1->addr.ds.digest))) &&
-	      hash_init(hash, &ctx, &digest))
-	    
-	    {
-	      int wire_len = to_wire(name);
-	      
-	      /* Note that digest may be different between DSs, so 
-		 we can't move this outside the loop. */
-	      hash->update(ctx, (unsigned int)wire_len, (unsigned char *)name);
-	      hash->update(ctx, (unsigned int)rdlen, psave);
-	      hash->digest(ctx, hash->digest_size, digest);
-	      
-	      from_wire(name);
-	      
-	      if (!(recp1->flags & F_NEG) &&
-		  recp1->addr.ds.keylen == (int)hash->digest_size &&
-		  (ds_digest = blockdata_retrieve(recp1->addr.key.keydata, recp1->addr.ds.keylen, NULL)) &&
-		  memcmp(ds_digest, digest, recp1->addr.ds.keylen) == 0 &&
-		  explore_rrset(header, plen, class, T_DNSKEY, name, keyname, &sigcnt, &rrcnt) &&
-		  sigcnt != 0 && rrcnt != 0 &&
-		  validate_rrset(now, header, plen, class, T_DNSKEY, sigcnt, rrcnt, name, keyname, 
-				 NULL, key, rdlen - 4, algo, keytag) == STAT_SECURE)
-		{
-		  valid = 1;
-		  break;
-		}
-	    }
-	}
-      blockdata_free(key);
-    }
-
-  if (valid)
-    {
-      /* DNSKEY RRset determined to be OK, now cache it. */
-      cache_start_insert();
-      
-      p = skip_questions(header, plen);
 
-      for (j = ntohs(header->ancount); j != 0; j--) 
-	{
-	  /* Ensure we have type, class  TTL and length */
-	  if (!(rc = extract_name(header, plen, &p, name, 0, 10)))
-	    return STAT_BOGUS; /* bad packet */
-	  
-	  GETSHORT(qtype, p); 
-	  GETSHORT(qclass, p);
-	  GETLONG(ttl, p);
-	  GETSHORT(rdlen, p);
-	    
-	  if (!CHECK_LEN(header, p, plen, rdlen))
-	    return STAT_BOGUS; /* bad packet */
-	  
-	  if (qclass == class && rc == 1)
-	    {
-	      psave = p;
-	      
-	      if (qtype == T_DNSKEY)
-		{
-		  if (rdlen < 4)
-		    return STAT_BOGUS; /* bad packet */
-		  
-		  GETSHORT(flags, p);
-		  if (*p++ != 3)
-		    return STAT_BOGUS;
-		  algo = *p++;
-		  keytag = dnskey_keytag(algo, flags, p, rdlen - 4);
-		  
-		  /* Cache needs to known class for DNSSEC stuff */
-		  a.addr.dnssec.class = class;
-		  
-		  if ((key = blockdata_alloc((char*)p, rdlen - 4)))
-		    {
-		      if (!(recp1 = cache_insert(name, &a, now, ttl, F_FORWARD | F_DNSKEY | F_DNSSECOK)))
-			{
-			  blockdata_free(key);
-			  return STAT_BOGUS;
-			}
-		      else
-			{
-			  a.addr.log.keytag = keytag;
-			  a.addr.log.algo = algo;
-			  if (verify_func(algo))
-			    log_query(F_NOEXTRA | F_KEYTAG | F_UPSTREAM, name, &a, "DNSKEY keytag %hu, algo %hu");
-			  else
-			    log_query(F_NOEXTRA | F_KEYTAG | F_UPSTREAM, name, &a, "DNSKEY keytag %hu, algo %hu (not supported)");
-			  
-			  recp1->addr.key.keylen = rdlen - 4;
-			  recp1->addr.key.keydata = key;
-			  recp1->addr.key.algo = algo;
-			  recp1->addr.key.keytag = keytag;
-			  recp1->addr.key.flags = flags;
-			}
-		    }
-		}
-	      	      
-	      p = psave;
-	    }
-
-	  if (!ADD_RDLEN(header, p, plen, rdlen))
-	    return STAT_BOGUS; /* bad packet */
-	}
-      
-      /* commit cache insert. */
-      cache_end_insert();
-      return STAT_OK;
+      if (!CHECK_LEN(header, p, plen, rdlen))
+        return STAT_BOGUS;      /* bad packet */
+
+      if (qclass == class && rc == 1) {
+        psave = p;
+
+        if (qtype == T_DNSKEY) {
+          if (rdlen < 4)
+            return STAT_BOGUS;  /* bad packet */
+
+          GETSHORT(flags, p);
+          if (*p++ != 3)
+            return STAT_BOGUS;
+          algo = *p++;
+          keytag = dnskey_keytag(algo, flags, p, rdlen - 4);
+
+          /* Cache needs to known class for DNSSEC stuff */
+          a.addr.dnssec.class = class;
+
+          if ((key = blockdata_alloc((char *) p, rdlen - 4))) {
+            if (!
+                (recp1 =
+                 cache_insert(name, &a, now, ttl,
+                              F_FORWARD | F_DNSKEY | F_DNSSECOK))) {
+              blockdata_free(key);
+              return STAT_BOGUS;
+            } else {
+              a.addr.log.keytag = keytag;
+              a.addr.log.algo = algo;
+              if (verify_func(algo))
+                log_query(F_NOEXTRA | F_KEYTAG | F_UPSTREAM, name, &a,
+                          "DNSKEY keytag %hu, algo %hu");
+              else
+                log_query(F_NOEXTRA | F_KEYTAG | F_UPSTREAM, name, &a,
+                          "DNSKEY keytag %hu, algo %hu (not supported)");
+
+              recp1->addr.key.keylen = rdlen - 4;
+              recp1->addr.key.keydata = key;
+              recp1->addr.key.algo = algo;
+              recp1->addr.key.keytag = keytag;
+              recp1->addr.key.flags = flags;
+            }
+          }
+        }
+
+        p = psave;
+      }
+
+      if (!ADD_RDLEN(header, p, plen, rdlen))
+        return STAT_BOGUS;      /* bad packet */
     }
 
+    /* commit cache insert. */
+    cache_end_insert();
+    return STAT_OK;
+  }
+
   log_query(F_NOEXTRA | F_UPSTREAM, name, NULL, "BOGUS DNSKEY");
   return STAT_BOGUS;
 }
@@ -1162,181 +1162,175 @@
    STAT_NEED_DS     DS record needed.
 */
 
-int dnssec_validate_ds(time_t now, struct dns_header *header, size_t plen, char *name, char *keyname, int class)
+int dnssec_validate_ds(time_t now, struct dns_header *header, size_t plen,
+                       char *name, char *keyname, int class)
 {
-  unsigned char *p = (unsigned char *)(header+1);
+  unsigned char *p = (unsigned char *) (header + 1);
   int qtype, qclass, rc, i, neganswer, nons;
   int aclass, atype, rdlen;
   unsigned long ttl;
   struct all_addr a;
 
-  if (ntohs(header->qdcount) != 1 ||
-      !(p = skip_name(p, header, plen, 4)))
+  if (ntohs(header->qdcount) != 1 || !(p = skip_name(p, header, plen, 4)))
     return STAT_BOGUS;
-  
+
   GETSHORT(qtype, p);
   GETSHORT(qclass, p);
 
   if (qtype != T_DS || qclass != class)
     rc = STAT_BOGUS;
   else
-    rc = dnssec_validate_reply(now, header, plen, name, keyname, NULL, 0, &neganswer, &nons);
+    rc = dnssec_validate_reply(now, header, plen, name, keyname, NULL, 0,
+                               &neganswer, &nons);
   /* Note dnssec_validate_reply() will have cached positive answers */
-  
+
   if (rc == STAT_INSECURE)
     rc = STAT_BOGUS;
- 
-  p = (unsigned char *)(header+1);
+
+  p = (unsigned char *) (header + 1);
   extract_name(header, plen, &p, name, 1, 4);
-  p += 4; /* qtype, qclass */
-  
+  p += 4;                       /* qtype, qclass */
+
   /* If the key needed to validate the DS is on the same domain as the DS, we'll
      loop getting nowhere. Stop that now. This can happen of the DS answer comes
      from the DS's zone, and not the parent zone. */
-  if (rc == STAT_BOGUS || (rc == STAT_NEED_KEY && hostname_isequal(name, keyname)))
-    {
-      log_query(F_NOEXTRA | F_UPSTREAM, name, NULL, "BOGUS DS");
-      return STAT_BOGUS;
-    }
-  
+  if (rc == STAT_BOGUS
+      || (rc == STAT_NEED_KEY && hostname_isequal(name, keyname))) {
+    log_query(F_NOEXTRA | F_UPSTREAM, name, NULL, "BOGUS DS");
+    return STAT_BOGUS;
+  }
+
   if (rc != STAT_SECURE)
     return rc;
-   
-  if (!neganswer)
-    {
+
+  if (!neganswer) {
+    cache_start_insert();
+
+    for (i = 0; i < ntohs(header->ancount); i++) {
+      if (!(rc = extract_name(header, plen, &p, name, 0, 10)))
+        return STAT_BOGUS;      /* bad packet */
+
+      GETSHORT(atype, p);
+      GETSHORT(aclass, p);
+      GETLONG(ttl, p);
+      GETSHORT(rdlen, p);
+
+      if (!CHECK_LEN(header, p, plen, rdlen))
+        return STAT_BOGUS;      /* bad packet */
+
+      if (aclass == class && atype == T_DS && rc == 1) {
+        int algo, digest, keytag;
+        unsigned char *psave = p;
+        struct blockdata *key;
+        struct crec *crecp;
+
+        if (rdlen < 4)
+          return STAT_BOGUS;    /* bad packet */
+
+        GETSHORT(keytag, p);
+        algo = *p++;
+        digest = *p++;
+
+        /* Cache needs to known class for DNSSEC stuff */
+        a.addr.dnssec.class = class;
+
+        if ((key = blockdata_alloc((char *) p, rdlen - 4))) {
+          if (!
+              (crecp =
+               cache_insert(name, &a, now, ttl,
+                            F_FORWARD | F_DS | F_DNSSECOK))) {
+            blockdata_free(key);
+            return STAT_BOGUS;
+          } else {
+            a.addr.log.keytag = keytag;
+            a.addr.log.algo = algo;
+            a.addr.log.digest = digest;
+            if (hash_find(ds_digest_name(digest)) && verify_func(algo))
+              log_query(F_NOEXTRA | F_KEYTAG | F_UPSTREAM, name, &a,
+                        "DS keytag %hu, algo %hu, digest %hu");
+            else
+              log_query(F_NOEXTRA | F_KEYTAG | F_UPSTREAM, name, &a,
+                        "DS keytag %hu, algo %hu, digest %hu (not supported)");
+
+            crecp->addr.ds.digest = digest;
+            crecp->addr.ds.keydata = key;
+            crecp->addr.ds.algo = algo;
+            crecp->addr.ds.keytag = keytag;
+            crecp->addr.ds.keylen = rdlen - 4;
+          }
+        }
+
+        p = psave;
+      }
+      if (!ADD_RDLEN(header, p, plen, rdlen))
+        return STAT_BOGUS;      /* bad packet */
+    }
+
+    cache_end_insert();
+
+  } else {
+    int flags = F_FORWARD | F_DS | F_NEG | F_DNSSECOK;
+    unsigned long minttl = ULONG_MAX;
+
+    if (!(p = skip_section(p, ntohs(header->ancount), header, plen)))
+      return STAT_BOGUS;
+
+    if (RCODE(header) == NXDOMAIN)
+      flags |= F_NXDOMAIN;
+
+    /* We only cache validated DS records, DNSSECOK flag hijacked
+       to store presence/absence of NS. */
+    if (nons)
+      flags &= ~F_DNSSECOK;
+
+    for (i = ntohs(header->nscount); i != 0; i--) {
+      if (!(p = skip_name(p, header, plen, 0)))
+        return STAT_BOGUS;
+
+      GETSHORT(atype, p);
+      GETSHORT(aclass, p);
+      GETLONG(ttl, p);
+      GETSHORT(rdlen, p);
+
+      if (!CHECK_LEN(header, p, plen, rdlen))
+        return STAT_BOGUS;      /* bad packet */
+
+      if (aclass != class || atype != T_SOA) {
+        p += rdlen;
+        continue;
+      }
+
+      if (ttl < minttl)
+        minttl = ttl;
+
+      /* MNAME */
+      if (!(p = skip_name(p, header, plen, 0)))
+        return STAT_BOGUS;
+      /* RNAME */
+      if (!(p = skip_name(p, header, plen, 20)))
+        return STAT_BOGUS;
+      p += 16;                  /* SERIAL REFRESH RETRY EXPIRE */
+
+      GETLONG(ttl, p);          /* minTTL */
+      if (ttl < minttl)
+        minttl = ttl;
+
+      break;
+    }
+
+    if (i != 0) {
       cache_start_insert();
-      
-      for (i = 0; i < ntohs(header->ancount); i++)
-	{
-	  if (!(rc = extract_name(header, plen, &p, name, 0, 10)))
-	    return STAT_BOGUS; /* bad packet */
-	  
-	  GETSHORT(atype, p);
-	  GETSHORT(aclass, p);
-	  GETLONG(ttl, p);
-	  GETSHORT(rdlen, p);
-	  
-	  if (!CHECK_LEN(header, p, plen, rdlen))
-	    return STAT_BOGUS; /* bad packet */
-	  
-	  if (aclass == class && atype == T_DS && rc == 1)
-	    { 
-	      int algo, digest, keytag;
-	      unsigned char *psave = p;
-	      struct blockdata *key;
-	      struct crec *crecp;
-
-	      if (rdlen < 4)
-		return STAT_BOGUS; /* bad packet */
-	      
-	      GETSHORT(keytag, p);
-	      algo = *p++;
-	      digest = *p++;
-	      
-	      /* Cache needs to known class for DNSSEC stuff */
-	      a.addr.dnssec.class = class;
-	      
-	      if ((key = blockdata_alloc((char*)p, rdlen - 4)))
-		{
-		  if (!(crecp = cache_insert(name, &a, now, ttl, F_FORWARD | F_DS | F_DNSSECOK)))
-		    {
-		      blockdata_free(key);
-		      return STAT_BOGUS;
-		    }
-		  else
-		    {
-		      a.addr.log.keytag = keytag;
-		      a.addr.log.algo = algo;
-		      a.addr.log.digest = digest;
-		      if (hash_find(ds_digest_name(digest)) && verify_func(algo))
-			log_query(F_NOEXTRA | F_KEYTAG | F_UPSTREAM, name, &a, "DS keytag %hu, algo %hu, digest %hu");
-		      else
-			log_query(F_NOEXTRA | F_KEYTAG | F_UPSTREAM, name, &a, "DS keytag %hu, algo %hu, digest %hu (not supported)");
-		      
-		      crecp->addr.ds.digest = digest;
-		      crecp->addr.ds.keydata = key;
-		      crecp->addr.ds.algo = algo;
-		      crecp->addr.ds.keytag = keytag;
-		      crecp->addr.ds.keylen = rdlen - 4; 
-		    } 
-		}
-	      
-	      p = psave;
-	    }
-	  if (!ADD_RDLEN(header, p, plen, rdlen))
-	    return STAT_BOGUS; /* bad packet */
-	}
+
+      a.addr.dnssec.class = class;
+      if (!cache_insert(name, &a, now, ttl, flags))
+        return STAT_BOGUS;
 
       cache_end_insert();
 
+      log_query(F_NOEXTRA | F_UPSTREAM, name, NULL, "no DS");
     }
-  else
-    {
-      int flags = F_FORWARD | F_DS | F_NEG | F_DNSSECOK;
-      unsigned long minttl = ULONG_MAX;
-      
-      if (!(p = skip_section(p, ntohs(header->ancount), header, plen)))
-	return STAT_BOGUS;
-      
-      if (RCODE(header) == NXDOMAIN)
-	flags |= F_NXDOMAIN;
-      
-      /* We only cache validated DS records, DNSSECOK flag hijacked 
-	 to store presence/absence of NS. */
-      if (nons)
-	flags &= ~F_DNSSECOK;
-      
-      for (i = ntohs(header->nscount); i != 0; i--)
-	{
-	  if (!(p = skip_name(p, header, plen, 0)))
-	    return STAT_BOGUS;
-	  
-	  GETSHORT(atype, p); 
-	  GETSHORT(aclass, p);
-	  GETLONG(ttl, p);
-	  GETSHORT(rdlen, p);
-	  
-	  if (!CHECK_LEN(header, p, plen, rdlen))
-	    return STAT_BOGUS; /* bad packet */
-	  
-	  if (aclass != class || atype != T_SOA)
-	    {
-	      p += rdlen;
-	      continue;
-	    }
-	  
-	  if (ttl < minttl)
-	    minttl = ttl;
-	  
-	  /* MNAME */
-	  if (!(p = skip_name(p, header, plen, 0)))
-	    return STAT_BOGUS;
-	  /* RNAME */
-	  if (!(p = skip_name(p, header, plen, 20)))
-	    return STAT_BOGUS;
-	  p += 16; /* SERIAL REFRESH RETRY EXPIRE */
-	  
-	  GETLONG(ttl, p); /* minTTL */
-	  if (ttl < minttl)
-	    minttl = ttl;
-	  
-	  break;
-	}
-      
-      if (i != 0)
-	{
-	  cache_start_insert();
-	  
-	  a.addr.dnssec.class = class;
-	  if (!cache_insert(name, &a, now, ttl, flags))
-	    return STAT_BOGUS;
-	  
-	  cache_end_insert();  
-	  
-	  log_query(F_NOEXTRA | F_UPSTREAM, name, NULL, "no DS");
-	}
-    }
-      
+  }
+
   return STAT_OK;
 }
 
@@ -1346,67 +1340,65 @@
 {
   char *sa, *ea, *ca, *sb, *eb, *cb;
   unsigned char ac, bc;
-  
-  sa = ea = (char *)a + strlen(a);
-  sb = eb = (char *)b + strlen(b);
- 
-  while (1)
-    {
-      while (sa != a && *(sa-1) != '.')
-	sa--;
-      
-      while (sb != b && *(sb-1) != '.')
-	sb--;
-
-      ca = sa;
-      cb = sb;
-
-      while (1) 
-	{
-	  if (ca == ea)
-	    {
-	      if (cb == eb)
-		break;
-	      
-	      return -1;
-	    }
-	  
-	  if (cb == eb)
-	    return 1;
-	  
-	  ac = (unsigned char) *ca++;
-	  bc = (unsigned char) *cb++;
-	  
-	  if (ac >= 'A' && ac <= 'Z')
-	    ac += 'a' - 'A';
-	  if (bc >= 'A' && bc <= 'Z')
-	    bc += 'a' - 'A';
-	  
-	  if (ac < bc)
-	    return -1;
-	  else if (ac != bc)
-	    return 1;
-	}
-
-     
-      if (sa == a)
-	{
-	  if (sb == b)
-	    return 0;
-	  
-	  return -1;
-	}
-      
+
+  sa = ea = (char *) a + strlen(a);
+  sb = eb = (char *) b + strlen(b);
+
+  while (1) {
+    while (sa != a && *(sa - 1) != '.')
+      sa--;
+
+    while (sb != b && *(sb - 1) != '.')
+      sb--;
+
+    ca = sa;
+    cb = sb;
+
+    while (1) {
+      if (ca == ea) {
+        if (cb == eb)
+          break;
+
+        return -1;
+      }
+
+      if (cb == eb)
+        return 1;
+
+      ac = (unsigned char) *ca++;
+      bc = (unsigned char) *cb++;
+
+      if (ac >= 'A' && ac <= 'Z')
+        ac += 'a' - 'A';
+      if (bc >= 'A' && bc <= 'Z')
+        bc += 'a' - 'A';
+
+      if (ac < bc)
+        return -1;
+      else if (ac != bc)
+        return 1;
+    }
+
+
+    if (sa == a) {
       if (sb == b)
-	return 1;
-      
-      ea = --sa;
-      eb = --sb;
+        return 0;
+
+      return -1;
     }
+
+    if (sb == b)
+      return 1;
+
+    ea = --sa;
+    eb = --sb;
+  }
 }
 
-static int prove_non_existence_nsec(struct dns_header *header, size_t plen, unsigned char **nsecs, int nsec_count,
-				    char *workspace1, char *workspace2, char *name, int type, int *nons)
+static int prove_non_existence_nsec(struct dns_header *header, size_t plen,
+                                    unsigned char **nsecs, int nsec_count,
+                                    char *workspace1, char *workspace2,
+                                    char *name, int type, int *nons)
 {
   int i, rc, rdlen;
   unsigned char *p, *psave;
@@ -1415,90 +1407,84 @@
 
   if (nons)
     *nons = 1;
-  
+
   /* Find NSEC record that proves name doesn't exist */
-  for (i = 0; i < nsec_count; i++)
-    {
-      p = nsecs[i];
-      if (!extract_name(header, plen, &p, workspace1, 1, 10))
-	return 0;
-      p += 8; /* class, type, TTL */
-      GETSHORT(rdlen, p);
-      psave = p;
-      if (!extract_name(header, plen, &p, workspace2, 1, 10))
-	return 0;
-      
-      rc = hostname_cmp(workspace1, name);
-      
-      if (rc == 0)
-	{
-	  /* 4035 para 5.4. Last sentence */
-	  if (type == T_NSEC || type == T_RRSIG)
-	    return 1;
-
-	  /* NSEC with the same name as the RR we're testing, check
-	     that the type in question doesn't appear in the type map */
-	  rdlen -= p - psave;
-	  /* rdlen is now length of type map, and p points to it */
-	  
-	  /* If we can prove that there's no NS record, return that information. */
-	  if (nons && rdlen >= 2 && p[0] == 0 && (p[2] & (0x80 >> T_NS)) != 0)
-	    *nons = 0;
-	  
-	  if (rdlen >= 2 && p[0] == 0)
-	    {
-	      /* A CNAME answer would also be valid, so if there's a CNAME is should 
-		 have been returned. */
-	      if ((p[2] & (0x80 >> T_CNAME)) != 0)
-		return 0;
-	      
-	      /* If the SOA bit is set for a DS record, then we have the
-		 DS from the wrong side of the delegation. */
-	      if (type == T_DS && (p[2] & (0x80 >> T_SOA)) != 0)
-		return 0;
-	    }
-
-	  while (rdlen >= 2)
-	    {
-	      if (!CHECK_LEN(header, p, plen, rdlen))
-		return 0;
-	      
-	      if (p[0] == type >> 8)
-		{
-		  /* Does the NSEC say our type exists? */
-		  if (offset < p[1] && (p[offset+2] & mask) != 0)
-		    return 0;
-		  
-		  break; /* finished checking */
-		}
-	      
-	      rdlen -= p[1];
-	      p +=  p[1];
-	    }
-	  
-	  return 1;
-	}
-      else if (rc == -1)
-	{
-	  /* Normal case, name falls between NSEC name and next domain name,
-	     wrap around case, name falls between NSEC name (rc == -1) and end */
-	  if (hostname_cmp(workspace2, name) >= 0 || hostname_cmp(workspace1, workspace2) >= 0)
-	    return 1;
-	}
-      else 
-	{
-	  /* wrap around case, name falls between start and next domain name */
-	  if (hostname_cmp(workspace1, workspace2) >= 0 && hostname_cmp(workspace2, name) >=0 )
-	    return 1;
-	}
+  for (i = 0; i < nsec_count; i++) {
+    p = nsecs[i];
+    if (!extract_name(header, plen, &p, workspace1, 1, 10))
+      return 0;
+    p += 8;                     /* class, type, TTL */
+    GETSHORT(rdlen, p);
+    psave = p;
+    if (!extract_name(header, plen, &p, workspace2, 1, 10))
+      return 0;
+
+    rc = hostname_cmp(workspace1, name);
+
+    if (rc == 0) {
+      /* 4035 para 5.4. Last sentence */
+      if (type == T_NSEC || type == T_RRSIG)
+        return 1;
+
+      /* NSEC with the same name as the RR we're testing, check
+         that the type in question doesn't appear in the type map */
+      rdlen -= p - psave;
+      /* rdlen is now length of type map, and p points to it */
+
+      /* If we can prove that there's no NS record, return that information. */
+      if (nons && rdlen >= 2 && p[0] == 0 && (p[2] & (0x80 >> T_NS)) != 0)
+        *nons = 0;
+
+      if (rdlen >= 2 && p[0] == 0) {
+        /* A CNAME answer would also be valid, so if there's a CNAME is should
+           have been returned. */
+        if ((p[2] & (0x80 >> T_CNAME)) != 0)
+          return 0;
+
+        /* If the SOA bit is set for a DS record, then we have the
+           DS from the wrong side of the delegation. */
+        if (type == T_DS && (p[2] & (0x80 >> T_SOA)) != 0)
+          return 0;
+      }
+
+      while (rdlen >= 2) {
+        if (!CHECK_LEN(header, p, plen, rdlen))
+          return 0;
+
+        if (p[0] == type >> 8) {
+          /* Does the NSEC say our type exists? */
+          if (offset < p[1] && (p[offset + 2] & mask) != 0)
+            return 0;
+
+          break;                /* finished checking */
+        }
+
+        rdlen -= p[1];
+        p += p[1];
+      }
+
+      return 1;
+    } else if (rc == -1) {
+      /* Normal case, name falls between NSEC name and next domain name,
+         wrap around case, name falls between NSEC name (rc == -1) and end */
+      if (hostname_cmp(workspace2, name) >= 0
+          || hostname_cmp(workspace1, workspace2) >= 0)
+        return 1;
+    } else {
+      /* wrap around case, name falls between start and next domain name */
+      if (hostname_cmp(workspace1, workspace2) >= 0
+          && hostname_cmp(workspace2, name) >= 0)
+        return 1;
     }
-  
+  }
+
   return 0;
 }
 
 /* return digest length, or zero on error */
-static int hash_name(char *in, unsigned char **out, struct nettle_hash const *hash, 
-		     unsigned char *salt, int salt_len, int iterations)
+static int hash_name(char *in, unsigned char **out,
+                     struct nettle_hash const *hash, unsigned char *salt,
+                     int salt_len, int iterations)
 {
   void *ctx;
   unsigned char *digest;
@@ -1506,18 +1492,17 @@
 
   if (!hash_init(hash, &ctx, &digest))
     return 0;
- 
-  hash->update(ctx, to_wire(in), (unsigned char *)in);
+
+  hash->update(ctx, to_wire(in), (unsigned char *) in);
   hash->update(ctx, salt_len, salt);
   hash->digest(ctx, hash->digest_size, digest);
 
-  for(i = 0; i < iterations; i++)
-    {
-      hash->update(ctx, hash->digest_size, digest);
-      hash->update(ctx, salt_len, salt);
-      hash->digest(ctx, hash->digest_size, digest);
-    }
-   
+  for (i = 0; i < iterations; i++) {
+    hash->update(ctx, hash->digest_size, digest);
+    hash->update(ctx, salt_len, salt);
+    hash->digest(ctx, hash->digest_size, digest);
+  }
+
   from_wire(in);
 
   *out = digest;
@@ -1529,234 +1514,230 @@
 {
   int oc, on, c, mask, i;
   unsigned char *p = out;
- 
-  for (c = *in, oc = 0, on = 0; c != 0 && c != '.'; c = *++in) 
-    {
-      if (c >= '0' && c <= '9')
-	c -= '0';
-      else if (c >= 'a' && c <= 'v')
-	c -= 'a', c += 10;
-      else if (c >= 'A' && c <= 'V')
-	c -= 'A', c += 10;
-      else
-	return 0;
-      
-      for (mask = 0x10, i = 0; i < 5; i++)
-        {
-	  if (c & mask)
-	    oc |= 1;
-	  mask = mask >> 1;
-	  if (((++on) & 7) == 0)
-	    *p++ = oc;
-	  oc = oc << 1;
-	}
+
+  for (c = *in, oc = 0, on = 0; c != 0 && c != '.'; c = *++in) {
+    if (c >= '0' && c <= '9')
+      c -= '0';
+    else if (c >= 'a' && c <= 'v')
+      c -= 'a', c += 10;
+    else if (c >= 'A' && c <= 'V')
+      c -= 'A', c += 10;
+    else
+      return 0;
+
+    for (mask = 0x10, i = 0; i < 5; i++) {
+      if (c & mask)
+        oc |= 1;
+      mask = mask >> 1;
+      if (((++on) & 7) == 0)
+        *p++ = oc;
+      oc = oc << 1;
     }
-  
+  }
+
   if ((on & 7) != 0)
     return 0;
 
   return p - out;
 }
 
-static int check_nsec3_coverage(struct dns_header *header, size_t plen, int digest_len, unsigned char *digest, int type,
-				char *workspace1, char *workspace2, unsigned char **nsecs, int nsec_count, int *nons)
+static int check_nsec3_coverage(struct dns_header *header, size_t plen,
+                                int digest_len, unsigned char *digest, int type,
+                                char *workspace1, char *workspace2,
+                                unsigned char **nsecs, int nsec_count,
+                                int *nons)
 {
   int i, hash_len, salt_len, base32_len, rdlen, flags;
   unsigned char *p, *psave;
 
   for (i = 0; i < nsec_count; i++)
-    if ((p = nsecs[i]))
-      {
-       	if (!extract_name(header, plen, &p, workspace1, 1, 0) ||
-	    !(base32_len = base32_decode(workspace1, (unsigned char *)workspace2)))
-	  return 0;
-	
-	p += 8; /* class, type, TTL */
-	GETSHORT(rdlen, p);
-	psave = p;
-	p++; /* algo */
-	flags = *p++; /* flags */
-	p += 2; /* iterations */
-	salt_len = *p++; /* salt_len */
-	p += salt_len; /* salt */
-	hash_len = *p++; /* p now points to next hashed name */
-	
-	if (!CHECK_LEN(header, p, plen, hash_len))
-	  return 0;
-	
-	if (digest_len == base32_len && hash_len == base32_len)
-	  {
-	    int rc = memcmp(workspace2, digest, digest_len);
-
-	    if (rc == 0)
-	      {
-		/* We found an NSEC3 whose hashed name exactly matches the query, so
-		   we just need to check the type map. p points to the RR data for the record. */
-		
-		int offset = (type & 0xff) >> 3;
-		int mask = 0x80 >> (type & 0x07);
-		
-		p += hash_len; /* skip next-domain hash */
-		rdlen -= p - psave;
-
-		if (!CHECK_LEN(header, p, plen, rdlen))
-		  return 0;
-		
-		if (rdlen >= 2 && p[0] == 0)
-		  {
-		    /* If we can prove that there's no NS record, return that information. */
-		    if (nons && (p[2] & (0x80 >> T_NS)) != 0)
-		      *nons = 0;
-		
-		    /* A CNAME answer would also be valid, so if there's a CNAME is should 
-		       have been returned. */
-		    if ((p[2] & (0x80 >> T_CNAME)) != 0)
-		      return 0;
-		    
-		    /* If the SOA bit is set for a DS record, then we have the
-		       DS from the wrong side of the delegation. */
-		    if (type == T_DS && (p[2] & (0x80 >> T_SOA)) != 0)
-		      return 0;
-		  }
-
-		while (rdlen >= 2)
-		  {
-		    if (p[0] == type >> 8)
-		      {
-			/* Does the NSEC3 say our type exists? */
-			if (offset < p[1] && (p[offset+2] & mask) != 0)
-			  return 0;
-			
-			break; /* finished checking */
-		      }
-		    
-		    rdlen -= p[1];
-		    p +=  p[1];
-		  }
-		
-		return 1;
-	      }
-	    else if (rc < 0)
-	      {
-		/* Normal case, hash falls between NSEC3 name-hash and next domain name-hash,
-		   wrap around case, name-hash falls between NSEC3 name-hash and end */
-		if (memcmp(p, digest, digest_len) >= 0 || memcmp(workspace2, p, digest_len) >= 0)
-		  {
-		    if ((flags & 0x01) && nons) /* opt out */
-		      *nons = 0;
-
-		    return 1;
-		  }
-	      }
-	    else 
-	      {
-		/* wrap around case, name falls between start and next domain name */
-		if (memcmp(workspace2, p, digest_len) >= 0 && memcmp(p, digest, digest_len) >= 0)
-		  {
-		    if ((flags & 0x01) && nons) /* opt out */
-		      *nons = 0;
-
-		    return 1;
-		  }
-	      }
-	  }
+    if ((p = nsecs[i])) {
+      if (!extract_name(header, plen, &p, workspace1, 1, 0) ||
+          !(base32_len =
+            base32_decode(workspace1, (unsigned char *) workspace2)))
+        return 0;
+
+      p += 8;                   /* class, type, TTL */
+      GETSHORT(rdlen, p);
+      psave = p;
+      p++;                      /* algo */
+      flags = *p++;             /* flags */
+      p += 2;                   /* iterations */
+      salt_len = *p++;          /* salt_len */
+      p += salt_len;            /* salt */
+      hash_len = *p++;          /* p now points to next hashed name */
+
+      if (!CHECK_LEN(header, p, plen, hash_len))
+        return 0;
+
+      if (digest_len == base32_len && hash_len == base32_len) {
+        int rc = memcmp(workspace2, digest, digest_len);
+
+        if (rc == 0) {
+          /* We found an NSEC3 whose hashed name exactly matches the query, so
+             we just need to check the type map. p points to the RR data for the record. */
+
+          int offset = (type & 0xff) >> 3;
+          int mask = 0x80 >> (type & 0x07);
+
+          p += hash_len;        /* skip next-domain hash */
+          rdlen -= p - psave;
+
+          if (!CHECK_LEN(header, p, plen, rdlen))
+            return 0;
+
+          if (rdlen >= 2 && p[0] == 0) {
+            /* If we can prove that there's no NS record, return that information. */
+            if (nons && (p[2] & (0x80 >> T_NS)) != 0)
+              *nons = 0;
+
+            /* A CNAME answer would also be valid, so if there's a CNAME is should
+               have been returned. */
+            if ((p[2] & (0x80 >> T_CNAME)) != 0)
+              return 0;
+
+            /* If the SOA bit is set for a DS record, then we have the
+               DS from the wrong side of the delegation. */
+            if (type == T_DS && (p[2] & (0x80 >> T_SOA)) != 0)
+              return 0;
+          }
+
+          while (rdlen >= 2) {
+            if (p[0] == type >> 8) {
+              /* Does the NSEC3 say our type exists? */
+              if (offset < p[1] && (p[offset + 2] & mask) != 0)
+                return 0;
+
+              break;            /* finished checking */
+            }
+
+            rdlen -= p[1];
+            p += p[1];
+          }
+
+          return 1;
+        } else if (rc < 0) {
+          /* Normal case, hash falls between NSEC3 name-hash and next domain name-hash,
+             wrap around case, name-hash falls between NSEC3 name-hash and end */
+          if (memcmp(p, digest, digest_len) >= 0
+              || memcmp(workspace2, p, digest_len) >= 0) {
+            if ((flags & 0x01) && nons) /* opt out */
+              *nons = 0;
+
+            return 1;
+          }
+        } else {
+          /* wrap around case, name falls between start and next domain name */
+          if (memcmp(workspace2, p, digest_len) >= 0
+              && memcmp(p, digest, digest_len) >= 0) {
+            if ((flags & 0x01) && nons) /* opt out */
+              *nons = 0;
+
+            return 1;
+          }
+        }
       }
+    }
 
   return 0;
 }
 
-static int prove_non_existence_nsec3(struct dns_header *header, size_t plen, unsigned char **nsecs, int nsec_count,
-				     char *workspace1, char *workspace2, char *name, int type, char *wildname, int *nons)
+static int prove_non_existence_nsec3(struct dns_header *header, size_t plen,
+                                     unsigned char **nsecs, int nsec_count,
+                                     char *workspace1, char *workspace2,
+                                     char *name, int type, char *wildname,
+                                     int *nons)
 {
   unsigned char *salt, *p, *digest;
   int digest_len, i, iterations, salt_len, base32_len, algo = 0;
   struct nettle_hash const *hash;
   char *closest_encloser, *next_closest, *wildcard;
-  
+
   if (nons)
     *nons = 1;
-  
+
   /* Look though the NSEC3 records to find the first one with 
      an algorithm we support.
 
      Take the algo, iterations, and salt of that record
      as the ones we're going to use, and prune any 
      that don't match. */
-  
-  for (i = 0; i < nsec_count; i++)
-    {
-      if (!(p = skip_name(nsecs[i], header, plen, 15)))
-	return 0; /* bad packet */
-      
-      p += 10; /* type, class, TTL, rdlen */
-      algo = *p++;
-      
-      if ((hash = hash_find(nsec3_digest_name(algo))))
-	break; /* known algo */
-    }
+
+  for (i = 0; i < nsec_count; i++) {
+    if (!(p = skip_name(nsecs[i], header, plen, 15)))
+      return 0;                 /* bad packet */
+
+    p += 10;                    /* type, class, TTL, rdlen */
+    algo = *p++;
+
+    if ((hash = hash_find(nsec3_digest_name(algo))))
+      break;                    /* known algo */
+  }
 
   /* No usable NSEC3s */
   if (i == nsec_count)
     return 0;
 
-  p++; /* flags */
+  p++;                          /* flags */
 
-  GETSHORT (iterations, p);
+  GETSHORT(iterations, p);
   /* Upper-bound iterations, to avoid DoS.
      Strictly, there are lower bounds for small keys, but
      since we don't have key size info here, at least limit
      to the largest bound, for 4096-bit keys. RFC 5155 10.3 */
   if (iterations > 2500)
     return 0;
-  
+
   salt_len = *p++;
   salt = p;
   if (!CHECK_LEN(header, salt, plen, salt_len))
-    return 0; /* bad packet */
-    
+    return 0;                   /* bad packet */
+
   /* Now prune so we only have NSEC3 records with same iterations, salt and algo */
-  for (i = 0; i < nsec_count; i++)
-    {
-      unsigned char *nsec3p = nsecs[i];
-      int this_iter, flags;
-
-      nsecs[i] = NULL; /* Speculative, will be restored if OK. */
-      
-      if (!(p = skip_name(nsec3p, header, plen, 15)))
-	return 0; /* bad packet */
-      
-      p += 10; /* type, class, TTL, rdlen */
-      
-      if (*p++ != algo)
-	continue;
- 
-      flags = *p++; /* flags */
-      
-      /* 5155 8.2 */
-      if (flags != 0 && flags != 1)
-	continue;
-
-      GETSHORT(this_iter, p);
-      if (this_iter != iterations)
-	continue;
-
-      if (salt_len != *p++)
-	continue;
-      
-      if (!CHECK_LEN(header, p, plen, salt_len))
-	return 0; /* bad packet */
-
-      if (memcmp(p, salt, salt_len) != 0)
-	continue;
+  for (i = 0; i < nsec_count; i++) {
+    unsigned char *nsec3p = nsecs[i];
+    int this_iter, flags;
 
-      /* All match, put the pointer back */
-      nsecs[i] = nsec3p;
-    }
+    nsecs[i] = NULL;            /* Speculative, will be restored if OK. */
+
+    if (!(p = skip_name(nsec3p, header, plen, 15)))
+      return 0;                 /* bad packet */
+
+    p += 10;                    /* type, class, TTL, rdlen */
+
+    if (*p++ != algo)
+      continue;
 
-  if ((digest_len = hash_name(name, &digest, hash, salt, salt_len, iterations)) == 0)
+    flags = *p++;               /* flags */
+
+    /* 5155 8.2 */
+    if (flags != 0 && flags != 1)
+      continue;
+
+    GETSHORT(this_iter, p);
+    if (this_iter != iterations)
+      continue;
+
+    if (salt_len != *p++)
+      continue;
+
+    if (!CHECK_LEN(header, p, plen, salt_len))
+      return 0;                 /* bad packet */
+
+    if (memcmp(p, salt, salt_len) != 0)
+      continue;
+
+    /* All match, put the pointer back */
+    nsecs[i] = nsec3p;
+  }
+
+  if ((digest_len =
+       hash_name(name, &digest, hash, salt, salt_len, iterations)) == 0)
     return 0;
-  
-  if (check_nsec3_coverage(header, plen, digest_len, digest, type, workspace1, workspace2, nsecs, nsec_count, nons))
+
+  if (check_nsec3_coverage
+      (header, plen, digest_len, digest, type, workspace1, workspace2, nsecs,
+       nsec_count, nons))
     return 1;
 
   /* Can't find an NSEC3 which covers the name directly, we need the "closest encloser NSEC3" 
@@ -1764,112 +1745,122 @@
   closest_encloser = name;
   next_closest = NULL;
 
-  do
-    {
-      if (*closest_encloser == '.')
-	closest_encloser++;
-
-      if (wildname && hostname_isequal(closest_encloser, wildname))
-	break;
-
-      if ((digest_len = hash_name(closest_encloser, &digest, hash, salt, salt_len, iterations)) == 0)
-	return 0;
-      
-      for (i = 0; i < nsec_count; i++)
-	if ((p = nsecs[i]))
-	  {
-	    if (!extract_name(header, plen, &p, workspace1, 1, 0) ||
-		!(base32_len = base32_decode(workspace1, (unsigned char *)workspace2)))
-	      return 0;
-	  
-	    if (digest_len == base32_len &&
-		memcmp(digest, workspace2, digest_len) == 0)
-	      break; /* Gotit */
-	  }
-      
-      if (i != nsec_count)
-	break;
-      
-      next_closest = closest_encloser;
-    }
+  do {
+    if (*closest_encloser == '.')
+      closest_encloser++;
+
+    if (wildname && hostname_isequal(closest_encloser, wildname))
+      break;
+
+    if ((digest_len =
+         hash_name(closest_encloser, &digest, hash, salt, salt_len,
+                   iterations)) == 0)
+      return 0;
+
+    for (i = 0; i < nsec_count; i++)
+      if ((p = nsecs[i])) {
+        if (!extract_name(header, plen, &p, workspace1, 1, 0) ||
+            !(base32_len =
+              base32_decode(workspace1, (unsigned char *) workspace2)))
+          return 0;
+
+        if (digest_len == base32_len &&
+            memcmp(digest, workspace2, digest_len) == 0)
+          break;                /* Gotit */
+      }
+
+    if (i != nsec_count)
+      break;
+
+    next_closest = closest_encloser;
+  }
   while ((closest_encloser = strchr(closest_encloser, '.')));
-  
+
   if (!closest_encloser || !next_closest)
     return 0;
-  
+
   /* Look for NSEC3 that proves the non-existence of the next-closest encloser */
-  if ((digest_len = hash_name(next_closest, &digest, hash, salt, salt_len, iterations)) == 0)
+  if ((digest_len =
+       hash_name(next_closest, &digest, hash, salt, salt_len, iterations)) == 0)
     return 0;
 
-  if (!check_nsec3_coverage(header, plen, digest_len, digest, type, workspace1, workspace2, nsecs, nsec_count, NULL))
+  if (!check_nsec3_coverage
+      (header, plen, digest_len, digest, type, workspace1, workspace2, nsecs,
+       nsec_count, NULL))
     return 0;
-  
+
   /* Finally, check that there's no seat of wildcard synthesis */
-  if (!wildname)
-    {
-      if (!(wildcard = strchr(next_closest, '.')) || wildcard == next_closest)
-	return 0;
-      
-      wildcard--;
-      *wildcard = '*';
-      
-      if ((digest_len = hash_name(wildcard, &digest, hash, salt, salt_len, iterations)) == 0)
-	return 0;
-      
-      if (!check_nsec3_coverage(header, plen, digest_len, digest, type, workspace1, workspace2, nsecs, nsec_count, NULL))
-	return 0;
-    }
-  
+  if (!wildname) {
+    if (!(wildcard = strchr(next_closest, '.')) || wildcard == next_closest)
+      return 0;
+
+    wildcard--;
+    *wildcard = '*';
+
+    if ((digest_len =
+         hash_name(wildcard, &digest, hash, salt, salt_len, iterations)) == 0)
+      return 0;
+
+    if (!check_nsec3_coverage
+        (header, plen, digest_len, digest, type, workspace1, workspace2, nsecs,
+         nsec_count, NULL))
+      return 0;
+  }
+
   return 1;
 }
 
-static int prove_non_existence(struct dns_header *header, size_t plen, char *keyname, char *name, int qtype, int qclass, char *wildname, int *nons)
+static int prove_non_existence(struct dns_header *header, size_t plen,
+                               char *keyname, char *name, int qtype, int qclass,
+                               char *wildname, int *nons)
 {
   static unsigned char **nsecset = NULL;
   static int nsecset_sz = 0;
-  
+
   int type_found = 0;
   unsigned char *p = skip_questions(header, plen);
   int type, class, rdlen, i, nsecs_found;
-  
+
   /* Move to NS section */
   if (!p || !(p = skip_section(p, ntohs(header->ancount), header, plen)))
     return 0;
-  
-  for (nsecs_found = 0, i = ntohs(header->nscount); i != 0; i--)
-    {
-      unsigned char *pstart = p;
-      
-      if (!(p = skip_name(p, header, plen, 10)))
-	return 0;
-      
-      GETSHORT(type, p); 
-      GETSHORT(class, p);
-      p += 4; /* TTL */
-      GETSHORT(rdlen, p);
 
-      if (class == qclass && (type == T_NSEC || type == T_NSEC3))
-	{
-	  /* No mixed NSECing 'round here, thankyouverymuch */
-	  if (type_found != 0 && type_found != type)
-	    return 0;
-
-	  type_found = type;
-
-	  if (!expand_workspace(&nsecset, &nsecset_sz, nsecs_found))
-	    return 0; 
-	  
-	  nsecset[nsecs_found++] = pstart;
-	}
-      
-      if (!ADD_RDLEN(header, p, plen, rdlen))
-	return 0;
+  for (nsecs_found = 0, i = ntohs(header->nscount); i != 0; i--) {
+    unsigned char *pstart = p;
+
+    if (!(p = skip_name(p, header, plen, 10)))
+      return 0;
+
+    GETSHORT(type, p);
+    GETSHORT(class, p);
+    p += 4;                     /* TTL */
+    GETSHORT(rdlen, p);
+
+    if (class == qclass && (type == T_NSEC || type == T_NSEC3)) {
+      /* No mixed NSECing 'round here, thankyouverymuch */
+      if (type_found != 0 && type_found != type)
+        return 0;
+
+      type_found = type;
+
+      if (!expand_workspace(&nsecset, &nsecset_sz, nsecs_found))
+        return 0;
+
+      nsecset[nsecs_found++] = pstart;
     }
-  
+
+    if (!ADD_RDLEN(header, p, plen, rdlen))
+      return 0;
+  }
+
   if (type_found == T_NSEC)
-    return prove_non_existence_nsec(header, plen, nsecset, nsecs_found, daemon->workspacename, keyname, name, qtype, nons);
+    return prove_non_existence_nsec(header, plen, nsecset, nsecs_found,
+                                    daemon->workspacename, keyname, name, qtype,
+                                    nons);
   else if (type_found == T_NSEC3)
-    return prove_non_existence_nsec3(header, plen, nsecset, nsecs_found, daemon->workspacename, keyname, name, qtype, wildname, nons);
+    return prove_non_existence_nsec3(header, plen, nsecset, nsecs_found,
+                                     daemon->workspacename, keyname, name,
+                                     qtype, wildname, nons);
   else
     return 0;
 }
@@ -1884,7 +1875,7 @@
 */
 static int zone_status(char *name, int class, char *keyname, time_t now)
 {
-  int name_start = strlen(name); /* for when TA is root */
+  int name_start = strlen(name);        /* for when TA is root */
   struct crec *crecp;
   char *p;
 
@@ -1892,73 +1883,66 @@
      This can either be one configured, or one previously cached.
      We can assume, if we don't find one first, that there is
      a trust anchor at the root. */
-  for (p = name; p; p = strchr(p, '.'))
-    {
-      if (*p == '.')
-	p++;
-
-      if (cache_find_by_name(NULL, p, now, F_DS))
-	{
-	  name_start = p - name;
-	  break;
-	}
+  for (p = name; p; p = strchr(p, '.')) {
+    if (*p == '.')
+      p++;
+
+    if (cache_find_by_name(NULL, p, now, F_DS)) {
+      name_start = p - name;
+      break;
     }
+  }
 
   /* Now work away from the trust anchor */
-  while (1)
-    {
-      strcpy(keyname, &name[name_start]);
-      
-      if (!(crecp = cache_find_by_name(NULL, keyname, now, F_DS)))
-	return STAT_NEED_DS;
-      
-       /* F_DNSSECOK misused in DS cache records to non-existence of NS record.
-	  F_NEG && !F_DNSSECOK implies that we've proved there's no DS record here,
-	  but that's because there's no NS record either, ie this isn't the start
-	  of a zone. We only prove that the DNS tree below a node is unsigned when
-	  we prove that we're at a zone cut AND there's no DS record. */
-      if (crecp->flags & F_NEG)
-	{
-	  if (crecp->flags & F_DNSSECOK)
-	    return STAT_INSECURE; /* proved no DS here */
-	}
-      else
-	{
-	  /* If all the DS records have digest and/or sig algos we don't support,
-	     then the zone is insecure. Note that if an algo
-	     appears in the DS, then RRSIGs for that algo MUST
-	     exist for each RRset: 4035 para 2.2  So if we find
-	     a DS here with digest and sig we can do, we're entitled
-	     to assume we can validate the zone and if we can't later,
-	     because an RRSIG is missing we return BOGUS.
-	  */
-	  do 
-	    {
-	      if (crecp->uid == (unsigned int)class &&
-		  hash_find(ds_digest_name(crecp->addr.ds.digest)) &&
-		  verify_func(crecp->addr.ds.algo))
-		break;
-	    }
-	  while ((crecp = cache_find_by_name(crecp, keyname, now, F_DS)));
-
-	  if (!crecp)
-	    return STAT_INSECURE;
-	}
-
-      if (name_start == 0)
-	break;
-
-      for (p = &name[name_start-2]; (*p != '.') && (p != name); p--);
-      
-      if (p != name)
-        p++;
-      
-      name_start = p - name;
-    } 
+  while (1) {
+    strcpy(keyname, &name[name_start]);
+
+    if (!(crecp = cache_find_by_name(NULL, keyname, now, F_DS)))
+      return STAT_NEED_DS;
+
+    /* F_DNSSECOK misused in DS cache records to non-existence of NS record.
+       F_NEG && !F_DNSSECOK implies that we've proved there's no DS record here,
+       but that's because there's no NS record either, ie this isn't the start
+       of a zone. We only prove that the DNS tree below a node is unsigned when
+       we prove that we're at a zone cut AND there's no DS record. */
+    if (crecp->flags & F_NEG) {
+      if (crecp->flags & F_DNSSECOK)
+        return STAT_INSECURE;   /* proved no DS here */
+    } else {
+      /* If all the DS records have digest and/or sig algos we don't support,
+         then the zone is insecure. Note that if an algo
+         appears in the DS, then RRSIGs for that algo MUST
+         exist for each RRset: 4035 para 2.2  So if we find
+         a DS here with digest and sig we can do, we're entitled
+         to assume we can validate the zone and if we can't later,
+         because an RRSIG is missing we return BOGUS.
+       */
+      do {
+        if (crecp->uid == (unsigned int) class &&
+            hash_find(ds_digest_name(crecp->addr.ds.digest)) &&
+            verify_func(crecp->addr.ds.algo))
+          break;
+      }
+      while ((crecp = cache_find_by_name(crecp, keyname, now, F_DS)));
+
+      if (!crecp)
+        return STAT_INSECURE;
+    }
+
+    if (name_start == 0)
+      break;
+
+    for (p = &name[name_start - 2]; (*p != '.') && (p != name); p--);
+
+    if (p != name)
+      p++;
+
+    name_start = p - name;
+  }
 
   return STAT_SECURE;
 }
-       
+
 /* Validate all the RRsets in the answer and authority sections of the reply (4035:3.2.3) 
    Return code:
    STAT_SECURE   if it validates.
@@ -1967,8 +1951,9 @@
    STAT_NEED_KEY need DNSKEY to complete validation (name is returned in keyname, class in *class)
    STAT_NEED_DS  need DS to complete validation (name is returned in keyname) 
 */
-int dnssec_validate_reply(time_t now, struct dns_header *header, size_t plen, char *name, char *keyname, 
-			  int *class, int check_unsigned, int *neganswer, int *nons)
+int dnssec_validate_reply(time_t now, struct dns_header *header, size_t plen,
+                          char *name, char *keyname, int *class,
+                          int check_unsigned, int *neganswer, int *nons)
 {
   static unsigned char **targets = NULL;
   static int target_sz = 0;
@@ -1979,202 +1964,192 @@
 
   if (neganswer)
     *neganswer = 0;
-  
+
   if (RCODE(header) == SERVFAIL || ntohs(header->qdcount) != 1)
     return STAT_BOGUS;
-  
+
   if (RCODE(header) != NXDOMAIN && RCODE(header) != NOERROR)
     return STAT_INSECURE;
 
-  p1 = (unsigned char *)(header+1);
-  
-   /* Find all the targets we're looking for answers to.
+  p1 = (unsigned char *) (header + 1);
+
+  /* Find all the targets we're looking for answers to.
      The zeroth array element is for the query, subsequent ones
      for CNAME targets, unless the query is for a CNAME. */
 
   if (!expand_workspace(&targets, &target_sz, 0))
     return STAT_BOGUS;
-  
+
   targets[0] = p1;
   targetidx = 1;
-   
+
   if (!extract_name(header, plen, &p1, name, 1, 4))
     return STAT_BOGUS;
-  
+
   GETSHORT(qtype, p1);
   GETSHORT(qclass, p1);
   ans_start = p1;
- 
+
   /* Can't validate an RRSIG query */
   if (qtype == T_RRSIG)
     return STAT_INSECURE;
-  
+
   if (qtype != T_CNAME)
-    for (j = ntohs(header->ancount); j != 0; j--) 
-      {
-	if (!(p1 = skip_name(p1, header, plen, 10)))
-	  return STAT_BOGUS; /* bad packet */
-	
-	GETSHORT(type2, p1); 
-	p1 += 6; /* class, TTL */
-	GETSHORT(rdlen2, p1);  
-	
-	if (type2 == T_CNAME)
-	  {
-	    if (!expand_workspace(&targets, &target_sz, targetidx))
-	      return STAT_BOGUS;
-	    
-	    targets[targetidx++] = p1; /* pointer to target name */
-	  }
-	
-	if (!ADD_RDLEN(header, p1, plen, rdlen2))
-	  return STAT_BOGUS;
+    for (j = ntohs(header->ancount); j != 0; j--) {
+      if (!(p1 = skip_name(p1, header, plen, 10)))
+        return STAT_BOGUS;      /* bad packet */
+
+      GETSHORT(type2, p1);
+      p1 += 6;                  /* class, TTL */
+      GETSHORT(rdlen2, p1);
+
+      if (type2 == T_CNAME) {
+        if (!expand_workspace(&targets, &target_sz, targetidx))
+          return STAT_BOGUS;
+
+        targets[targetidx++] = p1;      /* pointer to target name */
       }
-  
-  for (p1 = ans_start, i = 0; i < ntohs(header->ancount) + ntohs(header->nscount); i++)
-    {
-      if (!extract_name(header, plen, &p1, name, 1, 10))
-	return STAT_BOGUS; /* bad packet */
-      
-      GETSHORT(type1, p1);
-      GETSHORT(class1, p1);
-      p1 += 4; /* TTL */
-      GETSHORT(rdlen1, p1);
-      
-      /* Don't try and validate RRSIGs! */
-      if (type1 != T_RRSIG)
-	{
-	  /* Check if we've done this RRset already */
-	  for (p2 = ans_start, j = 0; j < i; j++)
-	    {
-	      if (!(rc = extract_name(header, plen, &p2, name, 0, 10)))
-		return STAT_BOGUS; /* bad packet */
-	      
-	      GETSHORT(type2, p2);
-	      GETSHORT(class2, p2);
-	      p2 += 4; /* TTL */
-	      GETSHORT(rdlen2, p2);
-	      
-	      if (type2 == type1 && class2 == class1 && rc == 1)
-		break; /* Done it before: name, type, class all match. */
-	      
-	      if (!ADD_RDLEN(header, p2, plen, rdlen2))
-		return STAT_BOGUS;
-	    }
-	  
-	  /* Not done, validate now */
-	  if (j == i)
-	    {
-	      int sigcnt, rrcnt;
-	      char *wildname;
-	      
-	      if (!explore_rrset(header, plen, class1, type1, name, keyname, &sigcnt, &rrcnt))
-		return STAT_BOGUS;
-
-	      /* No signatures for RRset. We can be configured to assume this is OK and return a INSECURE result. */
-	      if (sigcnt == 0)
-		{
-		  if (check_unsigned)
-		    {
-		      rc = zone_status(name, class1, keyname, now);
-		      if (rc == STAT_SECURE)
-			rc = STAT_BOGUS;
-		       if (class)
-			 *class = class1; /* Class for NEED_DS or NEED_KEY */
-		    }
-		  else 
-		    rc = STAT_INSECURE; 
-		  
-		  return rc;
-		}
-	      
-	      /* explore_rrset() gives us key name from sigs in keyname.
-		 Can't overwrite name here. */
-	      strcpy(daemon->workspacename, keyname);
-	      rc = zone_status(daemon->workspacename, class1, keyname, now);
-
-	      if (rc != STAT_SECURE)
-		{
-		  /* Zone is insecure, don't need to validate RRset */
-		  if (class)
-		    *class = class1; /* Class for NEED_DS or NEED_KEY */
-		  return rc;
-		} 
-	      
-	      rc = validate_rrset(now, header, plen, class1, type1, sigcnt, rrcnt, name, keyname, &wildname, NULL, 0, 0, 0);
-	      
-	      if (rc == STAT_BOGUS || rc == STAT_NEED_KEY || rc == STAT_NEED_DS)
-		{
-		  if (class)
-		    *class = class1; /* Class for DS or DNSKEY */
-		  return rc;
-		} 
-	      else 
-		{
-		  /* rc is now STAT_SECURE or STAT_SECURE_WILDCARD */
-		 
-		  /* Note if we've validated either the answer to the question
-		     or the target of a CNAME. Any not noted will need NSEC or
-		     to be in unsigned space. */
-
-		  for (j = 0; j <targetidx; j++)
-		    if ((p2 = targets[j]))
-		      {
-			if (!(rc = extract_name(header, plen, &p2, name, 0, 10)))
-			  return STAT_BOGUS; /* bad packet */
-			
-			if (class1 == qclass && rc == 1 && (type1 == T_CNAME || type1 == qtype || qtype == T_ANY ))
-			  targets[j] = NULL;
-		      }
-			    
-		   /* An attacker replay a wildcard answer with a different
-		      answer and overlay a genuine RR. To prove this
-		      hasn't happened, the answer must prove that
-		      the genuine record doesn't exist. Check that here. 
-		      Note that we may not yet have validated the NSEC/NSEC3 RRsets. 
-		      That's not a problem since if the RRsets later fail
-		      we'll return BOGUS then. */
-		  if (rc == STAT_SECURE_WILDCARD && !prove_non_existence(header, plen, keyname, name, type1, class1, wildname, NULL))
-		    return STAT_BOGUS;
-		}
-	    }
-	}
 
-      if (!ADD_RDLEN(header, p1, plen, rdlen1))
-	return STAT_BOGUS;
+      if (!ADD_RDLEN(header, p1, plen, rdlen2))
+        return STAT_BOGUS;
+    }
+
+  for (p1 = ans_start, i = 0;
+       i < ntohs(header->ancount) + ntohs(header->nscount); i++) {
+    if (!extract_name(header, plen, &p1, name, 1, 10))
+      return STAT_BOGUS;        /* bad packet */
+
+    GETSHORT(type1, p1);
+    GETSHORT(class1, p1);
+    p1 += 4;                    /* TTL */
+    GETSHORT(rdlen1, p1);
+
+    /* Don't try and validate RRSIGs! */
+    if (type1 != T_RRSIG) {
+      /* Check if we've done this RRset already */
+      for (p2 = ans_start, j = 0; j < i; j++) {
+        if (!(rc = extract_name(header, plen, &p2, name, 0, 10)))
+          return STAT_BOGUS;    /* bad packet */
+
+        GETSHORT(type2, p2);
+        GETSHORT(class2, p2);
+        p2 += 4;                /* TTL */
+        GETSHORT(rdlen2, p2);
+
+        if (type2 == type1 && class2 == class1 && rc == 1)
+          break;                /* Done it before: name, type, class all match. */
+
+        if (!ADD_RDLEN(header, p2, plen, rdlen2))
+          return STAT_BOGUS;
+      }
+
+      /* Not done, validate now */
+      if (j == i) {
+        int sigcnt, rrcnt;
+        char *wildname;
+
+        if (!explore_rrset
+            (header, plen, class1, type1, name, keyname, &sigcnt, &rrcnt))
+          return STAT_BOGUS;
+
+        /* No signatures for RRset. We can be configured to assume this is OK and return a INSECURE result. */
+        if (sigcnt == 0) {
+          if (check_unsigned) {
+            rc = zone_status(name, class1, keyname, now);
+            if (rc == STAT_SECURE)
+              rc = STAT_BOGUS;
+            if (class)
+              *class = class1;  /* Class for NEED_DS or NEED_KEY */
+          } else
+            rc = STAT_INSECURE;
+
+          return rc;
+        }
+
+        /* explore_rrset() gives us key name from sigs in keyname.
+           Can't overwrite name here. */
+        strcpy(daemon->workspacename, keyname);
+        rc = zone_status(daemon->workspacename, class1, keyname, now);
+
+        if (rc != STAT_SECURE) {
+          /* Zone is insecure, don't need to validate RRset */
+          if (class)
+            *class = class1;    /* Class for NEED_DS or NEED_KEY */
+          return rc;
+        }
+
+        rc = validate_rrset(now, header, plen, class1, type1, sigcnt, rrcnt,
+                            name, keyname, &wildname, NULL, 0, 0, 0);
+
+        if (rc == STAT_BOGUS || rc == STAT_NEED_KEY || rc == STAT_NEED_DS) {
+          if (class)
+            *class = class1;    /* Class for DS or DNSKEY */
+          return rc;
+        } else {
+          /* rc is now STAT_SECURE or STAT_SECURE_WILDCARD */
+
+          /* Note if we've validated either the answer to the question
+             or the target of a CNAME. Any not noted will need NSEC or
+             to be in unsigned space. */
+
+          for (j = 0; j < targetidx; j++)
+            if ((p2 = targets[j])) {
+              if (!(rc = extract_name(header, plen, &p2, name, 0, 10)))
+                return STAT_BOGUS;      /* bad packet */
+
+              if (class1 == qclass && rc == 1
+                  && (type1 == T_CNAME || type1 == qtype || qtype == T_ANY))
+                targets[j] = NULL;
+            }
+
+          /* An attacker replay a wildcard answer with a different
+             answer and overlay a genuine RR. To prove this
+             hasn't happened, the answer must prove that
+             the genuine record doesn't exist. Check that here.
+             Note that we may not yet have validated the NSEC/NSEC3 RRsets.
+             That's not a problem since if the RRsets later fail
+             we'll return BOGUS then. */
+          if (rc == STAT_SECURE_WILDCARD
+              && !prove_non_existence(header, plen, keyname, name, type1,
+                                      class1, wildname, NULL))
+            return STAT_BOGUS;
+        }
+      }
     }
 
+    if (!ADD_RDLEN(header, p1, plen, rdlen1))
+      return STAT_BOGUS;
+  }
+
   /* OK, all the RRsets validate, now see if we have a missing answer or CNAME target. */
-  for (j = 0; j <targetidx; j++)
-    if ((p2 = targets[j]))
-      {
-	if (neganswer)
-	  *neganswer = 1;
+  for (j = 0; j < targetidx; j++)
+    if ((p2 = targets[j])) {
+      if (neganswer)
+        *neganswer = 1;
+
+      if (!extract_name(header, plen, &p2, name, 1, 10))
+        return STAT_BOGUS;      /* bad packet */
+
+      /* NXDOMAIN or NODATA reply, unanswered question is (name, qclass, qtype) */
+
+      /* For anything other than a DS record, this situation is OK if either
+         the answer is in an unsigned zone, or there's a NSEC records. */
+      if (!prove_non_existence
+          (header, plen, keyname, name, qtype, qclass, NULL, nons)) {
+        /* Empty DS without NSECS */
+        if (qtype == T_DS)
+          return STAT_BOGUS;
+
+        if ((rc = zone_status(name, qclass, keyname, now)) != STAT_SECURE) {
+          if (class)
+            *class = qclass;    /* Class for NEED_DS or NEED_KEY */
+          return rc;
+        }
 
-	if (!extract_name(header, plen, &p2, name, 1, 10))
-	  return STAT_BOGUS; /* bad packet */
-	    
-	/* NXDOMAIN or NODATA reply, unanswered question is (name, qclass, qtype) */
-
-	/* For anything other than a DS record, this situation is OK if either
-	   the answer is in an unsigned zone, or there's a NSEC records. */
-	if (!prove_non_existence(header, plen, keyname, name, qtype, qclass, NULL, nons))
-	  {
-	    /* Empty DS without NSECS */
-	    if (qtype == T_DS)
-	      return STAT_BOGUS;
-	    
-	    if ((rc = zone_status(name, qclass, keyname, now)) != STAT_SECURE)
-	      {
-		if (class)
-		  *class = qclass; /* Class for NEED_DS or NEED_KEY */
-		return rc;
-	      } 
-	    
-	    return STAT_BOGUS; /* signed zone, no NSECs */
-	  }
+        return STAT_BOGUS;      /* signed zone, no NSECs */
       }
-  
+    }
+
   return STAT_SECURE;
 }
 
@@ -2182,45 +2157,45 @@
 /* Compute keytag (checksum to quickly index a key). See RFC4034 */
 int dnskey_keytag(int alg, int flags, unsigned char *key, int keylen)
 {
-  if (alg == 1)
-    {
-      /* Algorithm 1 (RSAMD5) has a different (older) keytag calculation algorithm.
-         See RFC4034, Appendix B.1 */
-      return key[keylen-4] * 256 + key[keylen-3];
-    }
-  else
-    {
-      unsigned long ac = flags + 0x300 + alg;
-      int i;
-
-      for (i = 0; i < keylen; ++i)
-        ac += (i & 1) ? key[i] : key[i] << 8;
-
-      ac += (ac >> 16) & 0xffff;
-      return ac & 0xffff;
-    }
-}
-
-size_t dnssec_generate_query(struct dns_header *header, unsigned char *end, char *name, int class, 
-			     int type, union mysockaddr *addr, int edns_pktsz)
+  if (alg == 1) {
+    /* Algorithm 1 (RSAMD5) has a different (older) keytag calculation algorithm.
+       See RFC4034, Appendix B.1 */
+    return key[keylen - 4] * 256 + key[keylen - 3];
+  } else {
+    unsigned long ac = flags + 0x300 + alg;
+    int i;
+
+    for (i = 0; i < keylen; ++i)
+      ac += (i & 1) ? key[i] : key[i] << 8;
+
+    ac += (ac >> 16) & 0xffff;
+    return ac & 0xffff;
+  }
+}
+
+size_t dnssec_generate_query(struct dns_header * header, unsigned char *end,
+                             char *name, int class, int type,
+                             union mysockaddr * addr, int edns_pktsz)
 {
   unsigned char *p;
   char *types = querystr("dnssec-query", type);
   size_t ret;
 
-  if (addr->sa.sa_family == AF_INET) 
-    log_query(F_NOEXTRA | F_DNSSEC | F_IPV4, name, (struct all_addr *)&addr->in.sin_addr, types);
+  if (addr->sa.sa_family == AF_INET)
+    log_query(F_NOEXTRA | F_DNSSEC | F_IPV4, name,
+              (struct all_addr *) &addr->in.sin_addr, types);
 #ifdef HAVE_IPV6
   else
-    log_query(F_NOEXTRA | F_DNSSEC | F_IPV6, name, (struct all_addr *)&addr->in6.sin6_addr, types);
+    log_query(F_NOEXTRA | F_DNSSEC | F_IPV6, name,
+              (struct all_addr *) &addr->in6.sin6_addr, types);
 #endif
-  
+
   header->qdcount = htons(1);
   header->ancount = htons(0);
   header->nscount = htons(0);
   header->arcount = htons(0);
 
-  header->hb3 = HB3_RD; 
+  header->hb3 = HB3_RD;
   SET_OPCODE(header, QUERY);
   /* For debugging, set Checking Disabled, otherwise, have the upstream check too,
      this allows it to select auth servers when one is returning bad data. */
@@ -2228,14 +2203,14 @@
 
   /* ID filled in later */
 
-  p = (unsigned char *)(header+1);
-	
+  p = (unsigned char *) (header + 1);
+
   p = do_rfc1035_name(p, name, NULL);
   *p++ = 0;
   PUTSHORT(type, p);
   PUTSHORT(class, p);
 
-  ret = add_do_bit(header, p - (unsigned char *)header, end);
+  ret = add_do_bit(header, p - (unsigned char *) header, end);
 
   if (find_pseudoheader(header, ret, NULL, &p, NULL, NULL))
     PUTSHORT(edns_pktsz, p);
@@ -2243,35 +2218,35 @@
   return ret;
 }
 
-unsigned char* hash_questions(struct dns_header *header, size_t plen, char *name)
+unsigned char *hash_questions(struct dns_header *header, size_t plen,
+                              char *name)
 {
   int q;
   unsigned int len;
-  unsigned char *p = (unsigned char *)(header+1);
+  unsigned char *p = (unsigned char *) (header + 1);
   const struct nettle_hash *hash;
   void *ctx;
   unsigned char *digest;
-  
+
   if (!(hash = hash_find("sha1")) || !hash_init(hash, &ctx, &digest))
     return NULL;
-  
-  for (q = ntohs(header->qdcount); q != 0; q--) 
-    {
-      if (!extract_name(header, plen, &p, name, 1, 4))
-	break; /* bad packet */
-      
-      len = to_wire(name);
-      hash->update(ctx, len, (unsigned char *)name);
-      /* CRC the class and type as well */
-      hash->update(ctx, 4, p);
-
-      p += 4;
-      if (!CHECK_LEN(header, p, plen, 0))
-	break; /* bad packet */
-    }
-  
+
+  for (q = ntohs(header->qdcount); q != 0; q--) {
+    if (!extract_name(header, plen, &p, name, 1, 4))
+      break;                    /* bad packet */
+
+    len = to_wire(name);
+    hash->update(ctx, len, (unsigned char *) name);
+    /* CRC the class and type as well */
+    hash->update(ctx, 4, p);
+
+    p += 4;
+    if (!CHECK_LEN(header, p, plen, 0))
+      break;                    /* bad packet */
+  }
+
   hash->digest(ctx, hash->digest_size, digest);
   return digest;
 }
 
-#endif /* HAVE_DNSSEC */
+#endif                          /* HAVE_DNSSEC */
Index: dnsmasq-2.78/src/domain.c
===================================================================
--- dnsmasq-2.78.orig/src/domain.c	2017-10-02 21:13:51.000000000 +0800
+++ dnsmasq-2.78/src/domain.c	2018-10-29 16:14:19.401440024 +0800
@@ -17,9 +17,11 @@
 #include "dnsmasq.h"
 
 
-static struct cond_domain *search_domain(struct in_addr addr, struct cond_domain *c);
+static struct cond_domain *search_domain(struct in_addr addr,
+                                         struct cond_domain *c);
 #ifdef HAVE_IPV6
-static struct cond_domain *search_domain6(struct in6_addr *addr, struct cond_domain *c);
+static struct cond_domain *search_domain6(struct in6_addr *addr,
+                                          struct cond_domain *c);
 #endif
 
 
@@ -34,175 +36,167 @@
     prot = AF_INET6;
 #endif
 
-  for (c = daemon->synth_domains; c; c = c->next)
+  for (c = daemon->synth_domains; c; c = c->next) {
+    int found = 0;
+    char *tail, *pref;
+
+    for (tail = name, pref = c->prefix; *tail != 0 && pref && *pref != 0;
+         tail++, pref++) {
+      unsigned int c1 = (unsigned char) *pref;
+      unsigned int c2 = (unsigned char) *tail;
+
+      if (c1 >= 'A' && c1 <= 'Z')
+        c1 += 'a' - 'A';
+      if (c2 >= 'A' && c2 <= 'Z')
+        c2 += 'a' - 'A';
+
+      if (c1 != c2)
+        break;
+    }
+
+    if (pref && *pref != 0)
+      continue;                 /* prefix match fail */
+
+    /* NB, must not alter name if we return zero */
+    for (p = tail; *p; p++) {
+      char c = *p;
+
+      if ((c >= '0' && c <= '9') || c == '-')
+        continue;
+
+#ifdef HAVE_IPV6
+      if (prot == AF_INET6
+          && ((c >= 'A' && c <= 'F') || (c >= 'a' && c <= 'f')))
+        continue;
+#endif
+
+      break;
+    }
+
+    if (*p != '.')
+      continue;
+
+    *p = 0;
+
+#ifdef HAVE_IPV6
+    if (prot == AF_INET6 && strstr(tail, "--ffff-") == tail) {
+      /* special hack for v4-mapped. */
+      memcpy(tail, "::ffff:", 7);
+      for (p = tail + 7; *p; p++)
+        if (*p == '-')
+          *p = '.';
+    } else
+#endif
     {
-      int found = 0;
-      char *tail, *pref;
-      
-      for (tail = name, pref = c->prefix; *tail != 0 && pref && *pref != 0; tail++, pref++)
-	{
-	  unsigned int c1 = (unsigned char) *pref;
-	  unsigned int c2 = (unsigned char) *tail;
-	  
-	  if (c1 >= 'A' && c1 <= 'Z')
-	    c1 += 'a' - 'A';
-	  if (c2 >= 'A' && c2 <= 'Z')
-	    c2 += 'a' - 'A';
-	  
-	  if (c1 != c2)
-	    break;
-	}
-      
-      if (pref && *pref != 0)
-	continue; /* prefix match fail */
-      
-      /* NB, must not alter name if we return zero */
+      /* swap . or : for - */
       for (p = tail; *p; p++)
-	{
-	  char c = *p;
-	  
-	  if ((c >='0' && c <= '9') || c == '-')
-	    continue;
-	  
-#ifdef HAVE_IPV6
-	  if (prot == AF_INET6 && ((c >='A' && c <= 'F') || (c >='a' && c <= 'f'))) 
-	    continue;
-#endif
-	  
-	  break;
-	}
-      
-      if (*p != '.')
-	continue;
-      
-      *p = 0;	
-      
- #ifdef HAVE_IPV6
-      if (prot == AF_INET6 && strstr(tail, "--ffff-") == tail)
-	{
-	  /* special hack for v4-mapped. */
-	  memcpy(tail, "::ffff:", 7);
-	  for (p = tail + 7; *p; p++)
-	    if (*p == '-')
-	      *p = '.';
-	}
-      else
-#endif
-	{
-	  /* swap . or : for - */
-	  for (p = tail; *p; p++)
-	    if (*p == '-')
-	      {
-		if (prot == AF_INET)
-		  *p = '.';
-#ifdef HAVE_IPV6
-		else
-		  *p = ':';
-#endif
-	      }
-	}
-
-      if (hostname_isequal(c->domain, p+1) && inet_pton(prot, tail, addr))
-	{
-	  if (prot == AF_INET)
-	    {
-	      if (!c->is6 &&
-		  ntohl(addr->addr.addr4.s_addr) >= ntohl(c->start.s_addr) &&
-		  ntohl(addr->addr.addr4.s_addr) <= ntohl(c->end.s_addr))
-		found = 1;
-	    }
-#ifdef HAVE_IPV6
-	  else
-	    {
-	      u64 addrpart = addr6part(&addr->addr.addr6);
-	      
-	      if (c->is6 &&
-		  is_same_net6(&addr->addr.addr6, &c->start6, 64) &&
-		  addrpart >= addr6part(&c->start6) &&
-		  addrpart <= addr6part(&c->end6))
-		found = 1;
-	    }
-#endif
-	}
-      
-      /* restore name */
-      for (p = tail; *p; p++)
-	if (*p == '.' || *p == ':')
-	  *p = '-';
-      
-      *p = '.';
+        if (*p == '-') {
+          if (prot == AF_INET)
+            *p = '.';
+#ifdef HAVE_IPV6
+          else
+            *p = ':';
+#endif
+        }
+    }
 
-      if (found)
-	return 1;
+    if (hostname_isequal(c->domain, p + 1) && inet_pton(prot, tail, addr)) {
+      if (prot == AF_INET) {
+        if (!c->is6 &&
+            ntohl(addr->addr.addr4.s_addr) >= ntohl(c->start.s_addr) &&
+            ntohl(addr->addr.addr4.s_addr) <= ntohl(c->end.s_addr))
+          found = 1;
+      }
+#ifdef HAVE_IPV6
+      else {
+        u64 addrpart = addr6part(&addr->addr.addr6);
+
+        if (c->is6 &&
+            is_same_net6(&addr->addr.addr6, &c->start6, 64) &&
+            addrpart >= addr6part(&c->start6) &&
+            addrpart <= addr6part(&c->end6))
+          found = 1;
+      }
+#endif
     }
-  
+
+    /* restore name */
+    for (p = tail; *p; p++)
+      if (*p == '.' || *p == ':')
+        *p = '-';
+
+    *p = '.';
+
+    if (found)
+      return 1;
+  }
+
   return 0;
 }
 
 
 int is_rev_synth(int flag, struct all_addr *addr, char *name)
 {
-   struct cond_domain *c;
+  struct cond_domain *c;
+
+  if (flag & F_IPV4
+      && (c = search_domain(addr->addr.addr4, daemon->synth_domains))) {
+    char *p;
+
+    *name = 0;
+    if (c->prefix)
+      strncpy(name, c->prefix, MAXDNAME - ADDRSTRLEN);
+
+    inet_ntop(AF_INET, &addr->addr.addr4, name + strlen(name), ADDRSTRLEN);
+    for (p = name; *p; p++)
+      if (*p == '.')
+        *p = '-';
+
+    strncat(name, ".", MAXDNAME);
+    strncat(name, c->domain, MAXDNAME);
+
+    return 1;
+  }
+#ifdef HAVE_IPV6
+  if (flag & F_IPV6
+      && (c = search_domain6(&addr->addr.addr6, daemon->synth_domains))) {
+    char *p;
+
+    *name = 0;
+    if (c->prefix)
+      strncpy(name, c->prefix, MAXDNAME - ADDRSTRLEN);
+
+    inet_ntop(AF_INET6, &addr->addr.addr6, name + strlen(name), ADDRSTRLEN);
+
+    /* IPv6 presentation address can start with ":", but valid domain names
+       cannot start with "-" so prepend a zero in that case. */
+    if (!c->prefix && *name == ':') {
+      *name = '0';
+      inet_ntop(AF_INET6, &addr->addr.addr6, name + 1, ADDRSTRLEN);
+    }
 
-   if (flag & F_IPV4 && (c = search_domain(addr->addr.addr4, daemon->synth_domains))) 
-     {
-       char *p;
-       
-       *name = 0;
-       if (c->prefix)
-	 strncpy(name, c->prefix, MAXDNAME - ADDRSTRLEN);
-       
-       inet_ntop(AF_INET, &addr->addr.addr4, name + strlen(name), ADDRSTRLEN);
-       for (p = name; *p; p++)
-	 if (*p == '.')
-	   *p = '-';
-
-       strncat(name, ".", MAXDNAME);
-       strncat(name, c->domain, MAXDNAME);
-
-       return 1;
-     }
-
-#ifdef HAVE_IPV6
-   if (flag & F_IPV6 && (c = search_domain6(&addr->addr.addr6, daemon->synth_domains))) 
-     {
-       char *p;
-       
-       *name = 0;
-       if (c->prefix)
-	 strncpy(name, c->prefix, MAXDNAME - ADDRSTRLEN);
-       
-       inet_ntop(AF_INET6, &addr->addr.addr6, name + strlen(name), ADDRSTRLEN);
-
-       /* IPv6 presentation address can start with ":", but valid domain names
-	  cannot start with "-" so prepend a zero in that case. */
-       if (!c->prefix && *name == ':')
-	 {
-	   *name = '0';
-	   inet_ntop(AF_INET6, &addr->addr.addr6, name+1, ADDRSTRLEN);
-	 }
-
-       /* V4-mapped have periods.... */
-       for (p = name; *p; p++)
-	 if (*p == ':' || *p == '.')
-	   *p = '-';
-
-       strncat(name, ".", MAXDNAME);
-       strncat(name, c->domain, MAXDNAME);
-       
-       return 1;
-     }
+    /* V4-mapped have periods.... */
+    for (p = name; *p; p++)
+      if (*p == ':' || *p == '.')
+        *p = '-';
+
+    strncat(name, ".", MAXDNAME);
+    strncat(name, c->domain, MAXDNAME);
+
+    return 1;
+  }
 #endif
-   
-   return 0;
+
+  return 0;
 }
 
 
-static struct cond_domain *search_domain(struct in_addr addr, struct cond_domain *c)
+static struct cond_domain *search_domain(struct in_addr addr,
+                                         struct cond_domain *c)
 {
   for (; c; c = c->next)
     if (!c->is6 &&
-	ntohl(addr.s_addr) >= ntohl(c->start.s_addr) &&
+        ntohl(addr.s_addr) >= ntohl(c->start.s_addr) &&
         ntohl(addr.s_addr) <= ntohl(c->end.s_addr))
       return c;
 
@@ -217,20 +211,20 @@
     return c->domain;
 
   return daemon->domain_suffix;
-} 
+}
 
 #ifdef HAVE_IPV6
-static struct cond_domain *search_domain6(struct in6_addr *addr, struct cond_domain *c)
+static struct cond_domain *search_domain6(struct in6_addr *addr,
+                                          struct cond_domain *c)
 {
   u64 addrpart = addr6part(addr);
-  
+
   for (; c; c = c->next)
     if (c->is6 &&
-	is_same_net6(addr, &c->start6, 64) &&
-	addrpart >= addr6part(&c->start6) &&
-        addrpart <= addr6part(&c->end6))
+        is_same_net6(addr, &c->start6, 64) &&
+        addrpart >= addr6part(&c->start6) && addrpart <= addr6part(&c->end6))
       return c;
-  
+
   return NULL;
 }
 
@@ -242,5 +236,5 @@
     return c->domain;
 
   return daemon->domain_suffix;
-} 
+}
 #endif
Index: dnsmasq-2.78/src/edns0.c
===================================================================
--- dnsmasq-2.78.orig/src/edns0.c	2017-10-02 21:13:51.000000000 +0800
+++ dnsmasq-2.78/src/edns0.c	2018-10-29 16:14:19.401440024 +0800
@@ -16,300 +16,289 @@
 
 #include "dnsmasq.h"
 
-unsigned char *find_pseudoheader(struct dns_header *header, size_t plen, size_t  *len, unsigned char **p, int *is_sign, int *is_last)
+unsigned char *find_pseudoheader(struct dns_header *header, size_t plen,
+                                 size_t * len, unsigned char **p, int *is_sign,
+                                 int *is_last)
 {
   /* See if packet has an RFC2671 pseudoheader, and if so return a pointer to it. 
      also return length of pseudoheader in *len and pointer to the UDP size in *p
      Finally, check to see if a packet is signed. If it is we cannot change a single bit before
      forwarding. We look for TSIG in the addition section, and TKEY queries (for GSS-TSIG) */
-  
+
   int i, arcount = ntohs(header->arcount);
-  unsigned char *ansp = (unsigned char *)(header+1);
+  unsigned char *ansp = (unsigned char *) (header + 1);
   unsigned short rdlen, type, class;
   unsigned char *ret = NULL;
 
-  if (is_sign)
-    {
-      *is_sign = 0;
+  if (is_sign) {
+    *is_sign = 0;
 
-      if (OPCODE(header) == QUERY)
-	{
-	  for (i = ntohs(header->qdcount); i != 0; i--)
-	    {
-	      if (!(ansp = skip_name(ansp, header, plen, 4)))
-		return NULL;
-	      
-	      GETSHORT(type, ansp); 
-	      GETSHORT(class, ansp);
-	      
-	      if (class == C_IN && type == T_TKEY)
-		*is_sign = 1;
-	    }
-	}
-    }
-  else
-    {
-      if (!(ansp = skip_questions(header, plen)))
-	return NULL;
+    if (OPCODE(header) == QUERY) {
+      for (i = ntohs(header->qdcount); i != 0; i--) {
+        if (!(ansp = skip_name(ansp, header, plen, 4)))
+          return NULL;
+
+        GETSHORT(type, ansp);
+        GETSHORT(class, ansp);
+
+        if (class == C_IN && type == T_TKEY)
+          *is_sign = 1;
+      }
     }
-    
+  } else {
+    if (!(ansp = skip_questions(header, plen)))
+      return NULL;
+  }
+
   if (arcount == 0)
     return NULL;
-  
-  if (!(ansp = skip_section(ansp, ntohs(header->ancount) + ntohs(header->nscount), header, plen)))
-    return NULL; 
-  
-  for (i = 0; i < arcount; i++)
-    {
-      unsigned char *save, *start = ansp;
-      if (!(ansp = skip_name(ansp, header, plen, 10)))
-	return NULL; 
-
-      GETSHORT(type, ansp);
-      save = ansp;
-      GETSHORT(class, ansp);
-      ansp += 4; /* TTL */
-      GETSHORT(rdlen, ansp);
-      if (!ADD_RDLEN(header, ansp, plen, rdlen))
-	return NULL;
-      if (type == T_OPT)
-	{
-	  if (len)
-	    *len = ansp - start;
-
-	  if (p)
-	    *p = save;
-	  
-	  if (is_last)
-	    *is_last = (i == arcount-1);
-
-	  ret = start;
-	}
-      else if (is_sign && 
-	       i == arcount - 1 && 
-	       class == C_ANY && 
-	       type == T_TSIG)
-	*is_sign = 1;
-    }
-  
+
+  if (!
+      (ansp =
+       skip_section(ansp, ntohs(header->ancount) + ntohs(header->nscount),
+                    header, plen)))
+    return NULL;
+
+  for (i = 0; i < arcount; i++) {
+    unsigned char *save, *start = ansp;
+    if (!(ansp = skip_name(ansp, header, plen, 10)))
+      return NULL;
+
+    GETSHORT(type, ansp);
+    save = ansp;
+    GETSHORT(class, ansp);
+    ansp += 4;                  /* TTL */
+    GETSHORT(rdlen, ansp);
+    if (!ADD_RDLEN(header, ansp, plen, rdlen))
+      return NULL;
+    if (type == T_OPT) {
+      if (len)
+        *len = ansp - start;
+
+      if (p)
+        *p = save;
+
+      if (is_last)
+        *is_last = (i == arcount - 1);
+
+      ret = start;
+    } else if (is_sign && i == arcount - 1 && class == C_ANY && type == T_TSIG)
+      *is_sign = 1;
+  }
+
   return ret;
 }
- 
+
 
 /* replace == 2 ->delete existing option only. */
-size_t add_pseudoheader(struct dns_header *header, size_t plen, unsigned char *limit, 
-			unsigned short udp_sz, int optno, unsigned char *opt, size_t optlen, int set_do, int replace)
-{ 
+size_t add_pseudoheader(struct dns_header * header, size_t plen,
+                        unsigned char *limit, unsigned short udp_sz, int optno,
+                        unsigned char *opt, size_t optlen, int set_do,
+                        int replace)
+{
   unsigned char *lenp, *datap, *p, *udp_len, *buff = NULL;
   int rdlen = 0, is_sign, is_last;
   unsigned short flags = set_do ? 0x8000 : 0, rcode = 0;
 
   p = find_pseudoheader(header, plen, NULL, &udp_len, &is_sign, &is_last);
-  
+
   if (is_sign)
     return plen;
 
-  if (p)
-    {
-      /* Existing header */
-      int i;
-      unsigned short code, len;
-
-      p = udp_len;
-      GETSHORT(udp_sz, p);
-      GETSHORT(rcode, p);
-      GETSHORT(flags, p);
-
-      if (set_do)
-	{
-	  p -= 2;
-	  flags |= 0x8000;
-	  PUTSHORT(flags, p);
-	}
-
-      lenp = p;
-      GETSHORT(rdlen, p);
-      if (!CHECK_LEN(header, p, plen, rdlen))
-	return plen; /* bad packet */
-      datap = p;
-
-       /* no option to add */
-      if (optno == 0)
-	return plen;
-      	  
-      /* check if option already there */
-      for (i = 0; i + 4 < rdlen;)
-	{
-	  GETSHORT(code, p);
-	  GETSHORT(len, p);
-	  
-	  /* malformed option, delete the whole OPT RR and start again. */
-	  if (i + 4 + len > rdlen)
-	    {
-	      rdlen = 0;
-	      is_last = 0;
-	      break;
-	    }
-	  
-	  if (code == optno)
-	    {
-	      if (replace == 0)
-		return plen;
-
-	      /* delete option if we're to replace it. */
-	      p -= 4;
-	      rdlen -= len + 4;
-	      memmove(p, p+len+4, rdlen - i);
-	      PUTSHORT(rdlen, lenp);
-	      lenp -= 2;
-	    }
-	  else
-	    {
-	      p += len;
-	      i += len + 4;
-	    }
-	}
-
-      /* If we're going to extend the RR, it has to be the last RR in the packet */
-      if (!is_last)
-	{
-	  /* First, take a copy of the options. */
-	  if (rdlen != 0 && (buff = whine_malloc(rdlen)))
-	    memcpy(buff, datap, rdlen);	      
-	  
-	  /* now, delete OPT RR */
-	  plen = rrfilter(header, plen, 0);
-	  
-	  /* Now, force addition of a new one */
-	  p = NULL;	  
-	}
-    }
-  
-  if (!p)
-    {
-      /* We are (re)adding the pseudoheader */
-      if (!(p = skip_questions(header, plen)) ||
-	  !(p = skip_section(p, 
-			     ntohs(header->ancount) + ntohs(header->nscount) + ntohs(header->arcount), 
-			     header, plen)))
-      {
-	free(buff);
-	return plen;
+  if (p) {
+    /* Existing header */
+    int i;
+    unsigned short code, len;
+
+    p = udp_len;
+    GETSHORT(udp_sz, p);
+    GETSHORT(rcode, p);
+    GETSHORT(flags, p);
+
+    if (set_do) {
+      p -= 2;
+      flags |= 0x8000;
+      PUTSHORT(flags, p);
+    }
+
+    lenp = p;
+    GETSHORT(rdlen, p);
+    if (!CHECK_LEN(header, p, plen, rdlen))
+      return plen;              /* bad packet */
+    datap = p;
+
+    /* no option to add */
+    if (optno == 0)
+      return plen;
+
+    /* check if option already there */
+    for (i = 0; i + 4 < rdlen;) {
+      GETSHORT(code, p);
+      GETSHORT(len, p);
+
+      /* malformed option, delete the whole OPT RR and start again. */
+      if (i + 4 + len > rdlen) {
+        rdlen = 0;
+        is_last = 0;
+        break;
       }
-      if (p + 11 > limit)
-      {
+
+      if (code == optno) {
+        if (replace == 0)
+          return plen;
+
+        /* delete option if we're to replace it. */
+        p -= 4;
+        rdlen -= len + 4;
+        memmove(p, p + len + 4, rdlen - i);
+        PUTSHORT(rdlen, lenp);
+        lenp -= 2;
+      } else {
+        p += len;
+        i += len + 4;
+      }
+    }
+
+    /* If we're going to extend the RR, it has to be the last RR in the packet */
+    if (!is_last) {
+      /* First, take a copy of the options. */
+      if (rdlen != 0 && (buff = whine_malloc(rdlen)))
+        memcpy(buff, datap, rdlen);
+
+      /* now, delete OPT RR */
+      plen = rrfilter(header, plen, 0);
+
+      /* Now, force addition of a new one */
+      p = NULL;
+    }
+  }
+
+  if (!p) {
+    /* We are (re)adding the pseudoheader */
+    if (!(p = skip_questions(header, plen)) ||
+        !(p = skip_section(p,
+                           ntohs(header->ancount) + ntohs(header->nscount) +
+                           ntohs(header->arcount), header, plen))) {
+      free(buff);
+      return plen;
+    }
+    if (p + 11 > limit) {
+      free(buff);
+      return plen;              /* Too big */
+    }
+    *p++ = 0;                   /* empty name */
+    PUTSHORT(T_OPT, p);
+    PUTSHORT(udp_sz, p);        /* max packet length, 512 if not given in EDNS0 header */
+    PUTSHORT(rcode, p);         /* extended RCODE and version */
+    PUTSHORT(flags, p);         /* DO flag */
+    lenp = p;
+    PUTSHORT(rdlen, p);         /* RDLEN */
+    datap = p;
+    /* Copy back any options */
+    if (buff) {
+      if (p + rdlen > limit) {
         free(buff);
-        return plen; /* Too big */
+        return plen;            /* Too big */
       }
-      *p++ = 0; /* empty name */
-      PUTSHORT(T_OPT, p);
-      PUTSHORT(udp_sz, p); /* max packet length, 512 if not given in EDNS0 header */
-      PUTSHORT(rcode, p);    /* extended RCODE and version */
-      PUTSHORT(flags, p); /* DO flag */
-      lenp = p;
-      PUTSHORT(rdlen, p);    /* RDLEN */
-      datap = p;
-      /* Copy back any options */
-      if (buff)
-	{
-          if (p + rdlen > limit)
-          {
-            free(buff);
-            return plen; /* Too big */
-          }
-	  memcpy(p, buff, rdlen);
-	  free(buff);
-	  p += rdlen;
-	}
-      
-      /* Only bump arcount if RR is going to fit */ 
-      if (((ssize_t)optlen) <= (limit - (p + 4)))
-	header->arcount = htons(ntohs(header->arcount) + 1);
+      memcpy(p, buff, rdlen);
+      free(buff);
+      p += rdlen;
     }
-  
-  if (((ssize_t)optlen) > (limit - (p + 4)))
-    return plen; /* Too big */
-  
+
+    /* Only bump arcount if RR is going to fit */
+    if (((ssize_t) optlen) <= (limit - (p + 4)))
+      header->arcount = htons(ntohs(header->arcount) + 1);
+  }
+
+  if (((ssize_t) optlen) > (limit - (p + 4)))
+    return plen;                /* Too big */
+
   /* Add new option */
-  if (optno != 0 && replace != 2)
-    {
-      if (p + 4 > limit)
-       return plen; /* Too big */
-      PUTSHORT(optno, p);
-      PUTSHORT(optlen, p);
-      if (p + optlen > limit)
-       return plen; /* Too big */
-      memcpy(p, opt, optlen);
-      p += optlen;  
-      PUTSHORT(p - datap, lenp);
-    }
-  return p - (unsigned char *)header;
+  if (optno != 0 && replace != 2) {
+    if (p + 4 > limit)
+      return plen;              /* Too big */
+    PUTSHORT(optno, p);
+    PUTSHORT(optlen, p);
+    if (p + optlen > limit)
+      return plen;              /* Too big */
+    memcpy(p, opt, optlen);
+    p += optlen;
+    PUTSHORT(p - datap, lenp);
+  }
+  return p - (unsigned char *) header;
 }
 
 size_t add_do_bit(struct dns_header *header, size_t plen, unsigned char *limit)
 {
-  return add_pseudoheader(header, plen, (unsigned char *)limit, PACKETSZ, 0, NULL, 0, 1, 0);
+  return add_pseudoheader(header, plen, (unsigned char *) limit, PACKETSZ, 0,
+                          NULL, 0, 1, 0);
 }
 
 static unsigned char char64(unsigned char c)
 {
-  return "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"[c & 0x3f];
+  return "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"[c &
+                                                                            0x3f];
 }
 
 static void encoder(unsigned char *in, char *out)
 {
-  out[0] = char64(in[0]>>2);
-  out[1] = char64((in[0]<<4) | (in[1]>>4));
-  out[2] = char64((in[1]<<2) | (in[2]>>6));
+  out[0] = char64(in[0] >> 2);
+  out[1] = char64((in[0] << 4) | (in[1] >> 4));
+  out[2] = char64((in[1] << 2) | (in[2] >> 6));
   out[3] = char64(in[2]);
 }
 
-static size_t add_dns_client(struct dns_header *header, size_t plen, unsigned char *limit, union mysockaddr *l3, time_t now)
+static size_t add_dns_client(struct dns_header *header, size_t plen,
+                             unsigned char *limit, union mysockaddr *l3,
+                             time_t now)
 {
-  int maclen, replace = 2; /* can't get mac address, just delete any incoming. */
+  int maclen, replace = 2;      /* can't get mac address, just delete any incoming. */
   unsigned char mac[DHCP_CHADDR_MAX];
-  char encode[18]; /* handle 6 byte MACs */
+  char encode[18];              /* handle 6 byte MACs */
+
+  if ((maclen = find_mac(l3, mac, 1, now)) == 6) {
+    replace = 1;
 
-  if ((maclen = find_mac(l3, mac, 1, now)) == 6)
-    {
-      replace = 1;
-
-      if (option_bool(OPT_MAC_HEX))
-	print_mac(encode, mac, maclen);
-      else
-	{
-	  encoder(mac, encode);
-	  encoder(mac+3, encode+4);
-	  encode[8] = 0;
-	}
+    if (option_bool(OPT_MAC_HEX))
+      print_mac(encode, mac, maclen);
+    else {
+      encoder(mac, encode);
+      encoder(mac + 3, encode + 4);
+      encode[8] = 0;
     }
+  }
 
-  return add_pseudoheader(header, plen, limit, PACKETSZ, EDNS0_OPTION_NOMDEVICEID, (unsigned char *)encode, strlen(encode), 0, replace); 
+  return add_pseudoheader(header, plen, limit, PACKETSZ,
+                          EDNS0_OPTION_NOMDEVICEID, (unsigned char *) encode,
+                          strlen(encode), 0, replace);
 }
 
 
-static size_t add_mac(struct dns_header *header, size_t plen, unsigned char *limit, union mysockaddr *l3, time_t now)
+static size_t add_mac(struct dns_header *header, size_t plen,
+                      unsigned char *limit, union mysockaddr *l3, time_t now)
 {
   int maclen;
   unsigned char mac[DHCP_CHADDR_MAX];
 
   if ((maclen = find_mac(l3, mac, 1, now)) != 0)
-    plen = add_pseudoheader(header, plen, limit, PACKETSZ, EDNS0_OPTION_MAC, mac, maclen, 0, 0); 
-    
-  return plen; 
+    plen =
+        add_pseudoheader(header, plen, limit, PACKETSZ, EDNS0_OPTION_MAC, mac,
+                         maclen, 0, 0);
+
+  return plen;
 }
 
 struct subnet_opt {
   u16 family;
   u8 source_netmask, scope_netmask;
-#ifdef HAVE_IPV6 
+#ifdef HAVE_IPV6
   u8 addr[IN6ADDRSZ];
 #else
   u8 addr[INADDRSZ];
 #endif
 };
 
-static void *get_addrp(union mysockaddr *addr, const short family) 
+static void *get_addrp(union mysockaddr *addr, const short family)
 {
 #ifdef HAVE_IPV6
   if (family == AF_INET6)
@@ -322,7 +311,7 @@
 static size_t calc_subnet_opt(struct subnet_opt *opt, union mysockaddr *source)
 {
   /* http://tools.ietf.org/html/draft-vandergaast-edns-client-subnet-02 */
-  
+
   int len;
   void *addrp = NULL;
   int sa_family = source->sa.sa_family;
@@ -331,119 +320,115 @@
   opt->scope_netmask = 0;
 
 #ifdef HAVE_IPV6
-  if (source->sa.sa_family == AF_INET6 && daemon->add_subnet6)
-    {
-      opt->source_netmask = daemon->add_subnet6->mask;
-      if (daemon->add_subnet6->addr_used) 
-	{
-	  sa_family = daemon->add_subnet6->addr.sa.sa_family;
-	  addrp = get_addrp(&daemon->add_subnet6->addr, sa_family);
-	} 
-      else 
-	addrp = &source->in6.sin6_addr;
-    }
+  if (source->sa.sa_family == AF_INET6 && daemon->add_subnet6) {
+    opt->source_netmask = daemon->add_subnet6->mask;
+    if (daemon->add_subnet6->addr_used) {
+      sa_family = daemon->add_subnet6->addr.sa.sa_family;
+      addrp = get_addrp(&daemon->add_subnet6->addr, sa_family);
+    } else
+      addrp = &source->in6.sin6_addr;
+  }
 #endif
 
-  if (source->sa.sa_family == AF_INET && daemon->add_subnet4)
-    {
-      opt->source_netmask = daemon->add_subnet4->mask;
-      if (daemon->add_subnet4->addr_used)
-	{
-	  sa_family = daemon->add_subnet4->addr.sa.sa_family;
-	  addrp = get_addrp(&daemon->add_subnet4->addr, sa_family);
-	} 
-	else 
-	  addrp = &source->in.sin_addr;
-    }
-  
+  if (source->sa.sa_family == AF_INET && daemon->add_subnet4) {
+    opt->source_netmask = daemon->add_subnet4->mask;
+    if (daemon->add_subnet4->addr_used) {
+      sa_family = daemon->add_subnet4->addr.sa.sa_family;
+      addrp = get_addrp(&daemon->add_subnet4->addr, sa_family);
+    } else
+      addrp = &source->in.sin_addr;
+  }
 #ifdef HAVE_IPV6
   opt->family = htons(sa_family == AF_INET6 ? 2 : 1);
 #else
   opt->family = htons(1);
 #endif
-  
+
   len = 0;
-  
-  if (addrp && opt->source_netmask != 0)
-    {
-      len = ((opt->source_netmask - 1) >> 3) + 1;
-      memcpy(opt->addr, addrp, len);
-      if (opt->source_netmask & 7)
-	opt->addr[len-1] &= 0xff << (8 - (opt->source_netmask & 7));
-    }
-  
+
+  if (addrp && opt->source_netmask != 0) {
+    len = ((opt->source_netmask - 1) >> 3) + 1;
+    memcpy(opt->addr, addrp, len);
+    if (opt->source_netmask & 7)
+      opt->addr[len - 1] &= 0xff << (8 - (opt->source_netmask & 7));
+  }
+
   return len + 4;
 }
- 
-static size_t add_source_addr(struct dns_header *header, size_t plen, unsigned char *limit, union mysockaddr *source)
+
+static size_t add_source_addr(struct dns_header *header, size_t plen,
+                              unsigned char *limit, union mysockaddr *source)
 {
   /* http://tools.ietf.org/html/draft-vandergaast-edns-client-subnet-02 */
-  
+
   int len;
   struct subnet_opt opt;
-  
+
   len = calc_subnet_opt(&opt, source);
-  return add_pseudoheader(header, plen, (unsigned char *)limit, PACKETSZ, EDNS0_OPTION_CLIENT_SUBNET, (unsigned char *)&opt, len, 0, 0);
+  return add_pseudoheader(header, plen, (unsigned char *) limit, PACKETSZ,
+                          EDNS0_OPTION_CLIENT_SUBNET, (unsigned char *) &opt,
+                          len, 0, 0);
 }
 
-int check_source(struct dns_header *header, size_t plen, unsigned char *pseudoheader, union mysockaddr *peer)
+int check_source(struct dns_header *header, size_t plen,
+                 unsigned char *pseudoheader, union mysockaddr *peer)
 {
   /* Section 9.2, Check that subnet option in reply matches. */
-  
+
   int len, calc_len;
   struct subnet_opt opt;
   unsigned char *p;
   int code, i, rdlen;
-  
-   calc_len = calc_subnet_opt(&opt, peer);
-   
-   if (!(p = skip_name(pseudoheader, header, plen, 10)))
-     return 1;
-   
-   p += 8; /* skip UDP length and RCODE */
-   
-   GETSHORT(rdlen, p);
-   if (!CHECK_LEN(header, p, plen, rdlen))
-     return 1; /* bad packet */
-   
-   /* check if option there */
-   for (i = 0; i + 4 < rdlen; i += len + 4)
-     {
-       GETSHORT(code, p);
-       GETSHORT(len, p);
-       if (code == EDNS0_OPTION_CLIENT_SUBNET)
-	 {
-	   /* make sure this doesn't mismatch. */
-	   opt.scope_netmask = p[3];
-	   if (len != calc_len || memcmp(p, &opt, len) != 0)
-	     return 0;
-	 }
-       p += len;
-     }
-   
-   return 1;
+
+  calc_len = calc_subnet_opt(&opt, peer);
+
+  if (!(p = skip_name(pseudoheader, header, plen, 10)))
+    return 1;
+
+  p += 8;                       /* skip UDP length and RCODE */
+
+  GETSHORT(rdlen, p);
+  if (!CHECK_LEN(header, p, plen, rdlen))
+    return 1;                   /* bad packet */
+
+  /* check if option there */
+  for (i = 0; i + 4 < rdlen; i += len + 4) {
+    GETSHORT(code, p);
+    GETSHORT(len, p);
+    if (code == EDNS0_OPTION_CLIENT_SUBNET) {
+      /* make sure this doesn't mismatch. */
+      opt.scope_netmask = p[3];
+      if (len != calc_len || memcmp(p, &opt, len) != 0)
+        return 0;
+    }
+    p += len;
+  }
+
+  return 1;
 }
 
-size_t add_edns0_config(struct dns_header *header, size_t plen, unsigned char *limit, 
-			union mysockaddr *source, time_t now, int *check_subnet)    
+size_t add_edns0_config(struct dns_header * header, size_t plen,
+                        unsigned char *limit, union mysockaddr * source,
+                        time_t now, int *check_subnet)
 {
   *check_subnet = 0;
 
   if (option_bool(OPT_ADD_MAC))
-    plen  = add_mac(header, plen, limit, source, now);
-  
+    plen = add_mac(header, plen, limit, source, now);
+
   if (option_bool(OPT_MAC_B64) || option_bool(OPT_MAC_HEX))
     plen = add_dns_client(header, plen, limit, source, now);
 
   if (daemon->dns_client_id)
-    plen = add_pseudoheader(header, plen, limit, PACKETSZ, EDNS0_OPTION_NOMCPEID, 
-			    (unsigned char *)daemon->dns_client_id, strlen(daemon->dns_client_id), 0, 1);
-  
-  if (option_bool(OPT_CLIENT_SUBNET))
-    {
-      plen = add_source_addr(header, plen, limit, source); 
-      *check_subnet = 1;
-    }
-	  
+    plen =
+        add_pseudoheader(header, plen, limit, PACKETSZ, EDNS0_OPTION_NOMCPEID,
+                         (unsigned char *) daemon->dns_client_id,
+                         strlen(daemon->dns_client_id), 0, 1);
+
+  if (option_bool(OPT_CLIENT_SUBNET)) {
+    plen = add_source_addr(header, plen, limit, source);
+    *check_subnet = 1;
+  }
+
   return plen;
 }
Index: dnsmasq-2.78/src/forward.c
===================================================================
--- dnsmasq-2.78.orig/src/forward.c	2017-10-02 21:13:51.000000000 +0800
+++ dnsmasq-2.78/src/forward.c	2018-10-29 16:14:19.413440024 +0800
@@ -18,21 +18,19 @@
 
 static struct frec *lookup_frec(unsigned short id, void *hash);
 static struct frec *lookup_frec_by_sender(unsigned short id,
-					  union mysockaddr *addr,
-					  void *hash);
+                                          union mysockaddr *addr, void *hash);
 static unsigned short get_id(void);
 static void free_frec(struct frec *f);
 
 /* Send a UDP packet with its source address set as "source" 
    unless nowild is true, when we just send it with the kernel default */
-int send_from(int fd, int nowild, char *packet, size_t len, 
-	      union mysockaddr *to, struct all_addr *source,
-	      unsigned int iface)
+int send_from(int fd, int nowild, char *packet, size_t len,
+              union mysockaddr *to, struct all_addr *source, unsigned int iface)
 {
   struct msghdr msg;
-  struct iovec iov[1]; 
+  struct iovec iov[1];
   union {
-    struct cmsghdr align; /* this ensures alignment */
+    struct cmsghdr align;       /* this ensures alignment */
 #if defined(HAVE_LINUX_NETWORK)
     char control[CMSG_SPACE(sizeof(struct in_pktinfo))];
 #elif defined(IP_SENDSRCADDR)
@@ -42,7 +40,7 @@
     char control6[CMSG_SPACE(sizeof(struct in6_pktinfo))];
 #endif
   } control_u;
-  
+
   iov[0].iov_base = packet;
   iov[0].iov_len = len;
 
@@ -53,186 +51,171 @@
   msg.msg_namelen = sa_len(to);
   msg.msg_iov = iov;
   msg.msg_iovlen = 1;
-  
-  if (!nowild)
-    {
-      struct cmsghdr *cmptr;
-      msg.msg_control = &control_u;
-      msg.msg_controllen = sizeof(control_u);
-      cmptr = CMSG_FIRSTHDR(&msg);
 
-      if (to->sa.sa_family == AF_INET)
-	{
+  if (!nowild) {
+    struct cmsghdr *cmptr;
+    msg.msg_control = &control_u;
+    msg.msg_controllen = sizeof(control_u);
+    cmptr = CMSG_FIRSTHDR(&msg);
+
+    if (to->sa.sa_family == AF_INET) {
 #if defined(HAVE_LINUX_NETWORK)
-	  struct in_pktinfo p;
-	  p.ipi_ifindex = 0;
-	  p.ipi_spec_dst = source->addr.addr4;
-	  memcpy(CMSG_DATA(cmptr), &p, sizeof(p));
-	  msg.msg_controllen = cmptr->cmsg_len = CMSG_LEN(sizeof(struct in_pktinfo));
-	  cmptr->cmsg_level = IPPROTO_IP;
-	  cmptr->cmsg_type = IP_PKTINFO;
+      struct in_pktinfo p;
+      p.ipi_ifindex = 0;
+      p.ipi_spec_dst = source->addr.addr4;
+      memcpy(CMSG_DATA(cmptr), &p, sizeof(p));
+      msg.msg_controllen = cmptr->cmsg_len =
+          CMSG_LEN(sizeof(struct in_pktinfo));
+      cmptr->cmsg_level = IPPROTO_IP;
+      cmptr->cmsg_type = IP_PKTINFO;
 #elif defined(IP_SENDSRCADDR)
-	  memcpy(CMSG_DATA(cmptr), &(source->addr.addr4), sizeof(source->addr.addr4));
-	  msg.msg_controllen = cmptr->cmsg_len = CMSG_LEN(sizeof(struct in_addr));
-	  cmptr->cmsg_level = IPPROTO_IP;
-	  cmptr->cmsg_type = IP_SENDSRCADDR;
-#endif
-	}
-      else
-#ifdef HAVE_IPV6
-	{
-	  struct in6_pktinfo p;
-	  p.ipi6_ifindex = iface; /* Need iface for IPv6 to handle link-local addrs */
-	  p.ipi6_addr = source->addr.addr6;
-	  memcpy(CMSG_DATA(cmptr), &p, sizeof(p));
-	  msg.msg_controllen = cmptr->cmsg_len = CMSG_LEN(sizeof(struct in6_pktinfo));
-	  cmptr->cmsg_type = daemon->v6pktinfo;
-	  cmptr->cmsg_level = IPPROTO_IPV6;
-	}
+      memcpy(CMSG_DATA(cmptr), &(source->addr.addr4),
+             sizeof(source->addr.addr4));
+      msg.msg_controllen = cmptr->cmsg_len = CMSG_LEN(sizeof(struct in_addr));
+      cmptr->cmsg_level = IPPROTO_IP;
+      cmptr->cmsg_type = IP_SENDSRCADDR;
+#endif
+    } else
+#ifdef HAVE_IPV6
+    {
+      struct in6_pktinfo p;
+      p.ipi6_ifindex = iface;   /* Need iface for IPv6 to handle link-local addrs */
+      p.ipi6_addr = source->addr.addr6;
+      memcpy(CMSG_DATA(cmptr), &p, sizeof(p));
+      msg.msg_controllen = cmptr->cmsg_len =
+          CMSG_LEN(sizeof(struct in6_pktinfo));
+      cmptr->cmsg_type = daemon->v6pktinfo;
+      cmptr->cmsg_level = IPPROTO_IPV6;
+    }
 #else
-      (void)iface; /* eliminate warning */
+      (void) iface;             /* eliminate warning */
 #endif
-    }
-  
+  }
+
   while (retry_send(sendmsg(fd, &msg, 0)));
 
   /* If interface is still in DAD, EINVAL results - ignore that. */
-  if (errno != 0 && errno != EINVAL)
-    {
-      my_syslog(LOG_ERR, _("failed to send packet: %s"), strerror(errno));
-      return 0;
-    }
-  
+  if (errno != 0 && errno != EINVAL) {
+    my_syslog(LOG_ERR, _("failed to send packet: %s"), strerror(errno));
+    return 0;
+  }
+
   return 1;
 }
-          
-static unsigned int search_servers(time_t now, struct all_addr **addrpp, unsigned int qtype,
-				   char *qdomain, int *type, char **domain, int *norebind)
-			      
+
+static unsigned int search_servers(time_t now, struct all_addr **addrpp,
+                                   unsigned int qtype, char *qdomain, int *type,
+                                   char **domain, int *norebind)
 {
   /* If the query ends in the domain in one of our servers, set
      domain to point to that name. We find the largest match to allow both
      domain.org and sub.domain.org to exist. */
-  
+
   unsigned int namelen = strlen(qdomain);
   unsigned int matchlen = 0;
   struct server *serv;
   unsigned int flags = 0;
-  
-  for (serv = daemon->servers; serv; serv=serv->next)
+
+  for (serv = daemon->servers; serv; serv = serv->next)
     if (qtype == F_DNSSECOK && !(serv->flags & SERV_DO_DNSSEC))
       continue;
-    /* domain matches take priority over NODOTS matches */
-    else if ((serv->flags & SERV_FOR_NODOTS) && *type != SERV_HAS_DOMAIN && !strchr(qdomain, '.') && namelen != 0)
-      {
-	unsigned int sflag = serv->addr.sa.sa_family == AF_INET ? F_IPV4 : F_IPV6; 
-	*type = SERV_FOR_NODOTS;
-	if (serv->flags & SERV_NO_ADDR)
-	  flags = F_NXDOMAIN;
-	else if (serv->flags & SERV_LITERAL_ADDRESS) 
-	  { 
-	    if (sflag & qtype)
-	      {
-		flags = sflag;
-		if (serv->addr.sa.sa_family == AF_INET) 
-		  *addrpp = (struct all_addr *)&serv->addr.in.sin_addr;
-#ifdef HAVE_IPV6
-		else
-		  *addrpp = (struct all_addr *)&serv->addr.in6.sin6_addr;
-#endif 
-	      }
-	    else if (!flags || (flags & F_NXDOMAIN))
-	      flags = F_NOERR;
-	  } 
+  /* domain matches take priority over NODOTS matches */
+    else if ((serv->flags & SERV_FOR_NODOTS) && *type != SERV_HAS_DOMAIN
+             && !strchr(qdomain, '.') && namelen != 0) {
+      unsigned int sflag = serv->addr.sa.sa_family == AF_INET ? F_IPV4 : F_IPV6;
+      *type = SERV_FOR_NODOTS;
+      if (serv->flags & SERV_NO_ADDR)
+        flags = F_NXDOMAIN;
+      else if (serv->flags & SERV_LITERAL_ADDRESS) {
+        if (sflag & qtype) {
+          flags = sflag;
+          if (serv->addr.sa.sa_family == AF_INET)
+            *addrpp = (struct all_addr *) &serv->addr.in.sin_addr;
+#ifdef HAVE_IPV6
+          else
+            *addrpp = (struct all_addr *) &serv->addr.in6.sin6_addr;
+#endif
+        } else if (!flags || (flags & F_NXDOMAIN))
+          flags = F_NOERR;
       }
-    else if (serv->flags & SERV_HAS_DOMAIN)
+    } else if (serv->flags & SERV_HAS_DOMAIN) {
+      unsigned int domainlen = strlen(serv->domain);
+      char *matchstart = qdomain + namelen - domainlen;
+      if (namelen >= domainlen &&
+          hostname_isequal(matchstart, serv->domain) &&
+          (domainlen == 0 || namelen == domainlen || *(matchstart - 1) == '.'))
       {
-	unsigned int domainlen = strlen(serv->domain);
-	char *matchstart = qdomain + namelen - domainlen;
-	if (namelen >= domainlen &&
-	    hostname_isequal(matchstart, serv->domain) &&
-	    (domainlen == 0 || namelen == domainlen || *(matchstart-1) == '.' ))
-	  {
-	    if ((serv->flags & SERV_NO_REBIND) && norebind)	
-	      *norebind = 1;
-	    else
-	      {
-		unsigned int sflag = serv->addr.sa.sa_family == AF_INET ? F_IPV4 : F_IPV6;
-		/* implement priority rules for --address and --server for same domain.
-		   --address wins if the address is for the correct AF
-		   --server wins otherwise. */
-		if (domainlen != 0 && domainlen == matchlen)
-		  {
-		    if ((serv->flags & SERV_LITERAL_ADDRESS))
-		      {
-			if (!(sflag & qtype) && flags == 0)
-			  continue;
-		      }
-		    else
-		      {
-			if (flags & (F_IPV4 | F_IPV6))
-			  continue;
-		      }
-		  }
-		
-		if (domainlen >= matchlen)
-		  {
-		    *type = serv->flags & (SERV_HAS_DOMAIN | SERV_USE_RESOLV | SERV_NO_REBIND | SERV_DO_DNSSEC);
-		    *domain = serv->domain;
-		    matchlen = domainlen;
-		    if (serv->flags & SERV_NO_ADDR)
-		      flags = F_NXDOMAIN;
-		    else if (serv->flags & SERV_LITERAL_ADDRESS)
-		      {
-			if (sflag & qtype)
-			  {
-			    flags = sflag;
-			    if (serv->addr.sa.sa_family == AF_INET) 
-			      *addrpp = (struct all_addr *)&serv->addr.in.sin_addr;
-#ifdef HAVE_IPV6
-			    else
-			      *addrpp = (struct all_addr *)&serv->addr.in6.sin6_addr;
-#endif
-			  }
-			else if (!flags || (flags & F_NXDOMAIN))
-			  flags = F_NOERR;
-		      }
-		    else
-		      flags = 0;
-		  } 
-	      }
-	  }
+        if ((serv->flags & SERV_NO_REBIND) && norebind)
+          *norebind = 1;
+        else {
+          unsigned int sflag =
+              serv->addr.sa.sa_family == AF_INET ? F_IPV4 : F_IPV6;
+          /* implement priority rules for --address and --server for same domain.
+             --address wins if the address is for the correct AF
+             --server wins otherwise. */
+          if (domainlen != 0 && domainlen == matchlen) {
+            if ((serv->flags & SERV_LITERAL_ADDRESS)) {
+              if (!(sflag & qtype) && flags == 0)
+                continue;
+            } else {
+              if (flags & (F_IPV4 | F_IPV6))
+                continue;
+            }
+          }
+
+          if (domainlen >= matchlen) {
+            *type =
+                serv->
+                flags & (SERV_HAS_DOMAIN | SERV_USE_RESOLV | SERV_NO_REBIND |
+                         SERV_DO_DNSSEC);
+            *domain = serv->domain;
+            matchlen = domainlen;
+            if (serv->flags & SERV_NO_ADDR)
+              flags = F_NXDOMAIN;
+            else if (serv->flags & SERV_LITERAL_ADDRESS) {
+              if (sflag & qtype) {
+                flags = sflag;
+                if (serv->addr.sa.sa_family == AF_INET)
+                  *addrpp = (struct all_addr *) &serv->addr.in.sin_addr;
+#ifdef HAVE_IPV6
+                else
+                  *addrpp = (struct all_addr *) &serv->addr.in6.sin6_addr;
+#endif
+              } else if (!flags || (flags & F_NXDOMAIN))
+                flags = F_NOERR;
+            } else
+              flags = 0;
+          }
+        }
       }
-  
-  if (flags == 0 && !(qtype & (F_QUERY | F_DNSSECOK)) && 
+    }
+
+  if (flags == 0 && !(qtype & (F_QUERY | F_DNSSECOK)) &&
       option_bool(OPT_NODOTS_LOCAL) && !strchr(qdomain, '.') && namelen != 0)
     /* don't forward A or AAAA queries for simple names, except the empty name */
     flags = F_NOERR;
-  
+
   if (flags == F_NXDOMAIN && check_for_local_domain(qdomain, now))
     flags = F_NOERR;
 
-  if (flags)
-    {
-      int logflags = 0;
-      
-      if (flags == F_NXDOMAIN || flags == F_NOERR)
-	logflags = F_NEG | qtype;
-  
-      log_query(logflags | flags | F_CONFIG | F_FORWARD, qdomain, *addrpp, NULL);
-    }
-  else if ((*type) & SERV_USE_RESOLV)
-    {
-      *type = 0; /* use normal servers for this domain */
-      *domain = NULL;
-    }
-  return  flags;
+  if (flags) {
+    int logflags = 0;
+
+    if (flags == F_NXDOMAIN || flags == F_NOERR)
+      logflags = F_NEG | qtype;
+
+    log_query(logflags | flags | F_CONFIG | F_FORWARD, qdomain, *addrpp, NULL);
+  } else if ((*type) & SERV_USE_RESOLV) {
+    *type = 0;                  /* use normal servers for this domain */
+    *domain = NULL;
+  }
+  return flags;
 }
 
 static int forward_query(int udpfd, union mysockaddr *udpaddr,
-			 struct all_addr *dst_addr, unsigned int dst_iface,
-			 struct dns_header *header, size_t plen, time_t now, 
-			 struct frec *forward, int ad_reqd, int do_bit)
+                         struct all_addr *dst_addr, unsigned int dst_iface,
+                         struct dns_header *header, size_t plen, time_t now,
+                         struct frec *forward, int ad_reqd, int do_bit)
 {
   char *domain = NULL;
   int type = SERV_DO_DNSSEC, norebind = 0;
@@ -246,481 +229,464 @@
   unsigned int crc = questions_crc(header, plen, daemon->namebuff);
   void *hash = &crc;
 #endif
- unsigned int gotname = extract_request(header, plen, daemon->namebuff, NULL);
+  unsigned int gotname = extract_request(header, plen, daemon->namebuff, NULL);
 
- (void)do_bit;
+  (void) do_bit;
 
   /* may be no servers available. */
-  if (forward || (hash && (forward = lookup_frec_by_sender(ntohs(header->id), udpaddr, hash))))
-    {
-      /* If we didn't get an answer advertising a maximal packet in EDNS,
-	 fall back to 1280, which should work everywhere on IPv6.
-	 If that generates an answer, it will become the new default
-	 for this server */
-      forward->flags |= FREC_TEST_PKTSZ;
-      
-#ifdef HAVE_DNSSEC
-      /* If we've already got an answer to this query, but we're awaiting keys for validation,
-	 there's no point retrying the query, retry the key query instead...... */
-      if (forward->blocking_query)
-	{
-	  int fd, is_sign;
-	  unsigned char *pheader;
-	  
-	  forward->flags &= ~FREC_TEST_PKTSZ;
-	  
-	  while (forward->blocking_query)
-	    forward = forward->blocking_query;
-	   
-	  forward->flags |= FREC_TEST_PKTSZ;
-	  
-	  blockdata_retrieve(forward->stash, forward->stash_len, (void *)header);
-	  plen = forward->stash_len;
-	  
-	  if (find_pseudoheader(header, plen, NULL, &pheader, &is_sign, NULL) && !is_sign)
-	    PUTSHORT(SAFE_PKTSZ, pheader);
-
-	  if (forward->sentto->addr.sa.sa_family == AF_INET) 
-	    log_query(F_NOEXTRA | F_DNSSEC | F_IPV4, "retry", (struct all_addr *)&forward->sentto->addr.in.sin_addr, "dnssec");
-#ifdef HAVE_IPV6
-	  else
-	    log_query(F_NOEXTRA | F_DNSSEC | F_IPV6, "retry", (struct all_addr *)&forward->sentto->addr.in6.sin6_addr, "dnssec");
-#endif
-  
-	  if (forward->sentto->sfd)
-	    fd = forward->sentto->sfd->fd;
-	  else
-	    {
-#ifdef HAVE_IPV6
-	      if (forward->sentto->addr.sa.sa_family == AF_INET6)
-		fd = forward->rfd6->fd;
-	      else
-#endif
-		fd = forward->rfd4->fd;
-	    }
-	  
-	  while (retry_send( sendto(fd, (char *)header, plen, 0,
-				    &forward->sentto->addr.sa,
-				    sa_len(&forward->sentto->addr))));
-	  
-	  return 1;
-	}
-#endif
-
-      /* retry on existing query, send to all available servers  */
-      domain = forward->sentto->domain;
-      forward->sentto->failed_queries++;
-      if (!option_bool(OPT_ORDER))
-	{
-	  forward->forwardall = 1;
-	  daemon->last_server = NULL;
-	}
-      type = forward->sentto->flags & SERV_TYPE;
+  if (forward
+      || (hash
+          && (forward =
+              lookup_frec_by_sender(ntohs(header->id), udpaddr, hash)))) {
+    /* If we didn't get an answer advertising a maximal packet in EDNS,
+       fall back to 1280, which should work everywhere on IPv6.
+       If that generates an answer, it will become the new default
+       for this server */
+    forward->flags |= FREC_TEST_PKTSZ;
+
 #ifdef HAVE_DNSSEC
-      do_dnssec = forward->sentto->flags & SERV_DO_DNSSEC;
+    /* If we've already got an answer to this query, but we're awaiting keys for validation,
+       there's no point retrying the query, retry the key query instead...... */
+    if (forward->blocking_query) {
+      int fd, is_sign;
+      unsigned char *pheader;
+
+      forward->flags &= ~FREC_TEST_PKTSZ;
+
+      while (forward->blocking_query)
+        forward = forward->blocking_query;
+
+      forward->flags |= FREC_TEST_PKTSZ;
+
+      blockdata_retrieve(forward->stash, forward->stash_len, (void *) header);
+      plen = forward->stash_len;
+
+      if (find_pseudoheader(header, plen, NULL, &pheader, &is_sign, NULL)
+          && !is_sign)
+        PUTSHORT(SAFE_PKTSZ, pheader);
+
+      if (forward->sentto->addr.sa.sa_family == AF_INET)
+        log_query(F_NOEXTRA | F_DNSSEC | F_IPV4, "retry",
+                  (struct all_addr *) &forward->sentto->addr.in.sin_addr,
+                  "dnssec");
+#ifdef HAVE_IPV6
+      else
+        log_query(F_NOEXTRA | F_DNSSEC | F_IPV6, "retry",
+                  (struct all_addr *) &forward->sentto->addr.in6.sin6_addr,
+                  "dnssec");
 #endif
 
-      if (!(start = forward->sentto->next))
-	start = daemon->servers; /* at end of list, recycle */
-      header->id = htons(forward->new_id);
+      if (forward->sentto->sfd)
+        fd = forward->sentto->sfd->fd;
+      else {
+#ifdef HAVE_IPV6
+        if (forward->sentto->addr.sa.sa_family == AF_INET6)
+          fd = forward->rfd6->fd;
+        else
+#endif
+          fd = forward->rfd4->fd;
+      }
+
+      while (retry_send(sendto(fd, (char *) header, plen, 0,
+                               &forward->sentto->addr.sa,
+                               sa_len(&forward->sentto->addr))));
+
+      return 1;
     }
-  else 
-    {
-      if (gotname)
-	flags = search_servers(now, &addrp, gotname, daemon->namebuff, &type, &domain, &norebind);
-      
+#endif
+
+    /* retry on existing query, send to all available servers  */
+    domain = forward->sentto->domain;
+    forward->sentto->failed_queries++;
+    if (!option_bool(OPT_ORDER)) {
+      forward->forwardall = 1;
+      daemon->last_server = NULL;
+    }
+    type = forward->sentto->flags & SERV_TYPE;
 #ifdef HAVE_DNSSEC
-      do_dnssec = type & SERV_DO_DNSSEC;
+    do_dnssec = forward->sentto->flags & SERV_DO_DNSSEC;
 #endif
-      type &= ~SERV_DO_DNSSEC;      
 
-      if (daemon->servers && !flags)
-	forward = get_new_frec(now, NULL, 0);
-      /* table full - flags == 0, return REFUSED */
-      
-      if (forward)
-	{
-	  forward->source = *udpaddr;
-	  forward->dest = *dst_addr;
-	  forward->iface = dst_iface;
-	  forward->orig_id = ntohs(header->id);
-	  forward->new_id = get_id();
-	  forward->fd = udpfd;
-	  memcpy(forward->hash, hash, HASH_SIZE);
-	  forward->forwardall = 0;
-	  forward->flags = 0;
-	  if (norebind)
-	    forward->flags |= FREC_NOREBIND;
-	  if (header->hb4 & HB4_CD)
-	    forward->flags |= FREC_CHECKING_DISABLED;
-	  if (ad_reqd)
-	    forward->flags |= FREC_AD_QUESTION;
+    if (!(start = forward->sentto->next))
+      start = daemon->servers;  /* at end of list, recycle */
+    header->id = htons(forward->new_id);
+  } else {
+    if (gotname)
+      flags =
+          search_servers(now, &addrp, gotname, daemon->namebuff, &type, &domain,
+                         &norebind);
+
 #ifdef HAVE_DNSSEC
-	  forward->work_counter = DNSSEC_WORK;
-	  if (do_bit)
-	    forward->flags |= FREC_DO_QUESTION;
-#endif
-	  
-	  header->id = htons(forward->new_id);
-	  
-	  /* In strict_order mode, always try servers in the order 
-	     specified in resolv.conf, if a domain is given 
-	     always try all the available servers,
-	     otherwise, use the one last known to work. */
-	  
-	  if (type == 0)
-	    {
-	      if (option_bool(OPT_ORDER))
-		start = daemon->servers;
-	      else if (!(start = daemon->last_server) ||
-		       daemon->forwardcount++ > FORWARD_TEST ||
-		       difftime(now, daemon->forwardtime) > FORWARD_TIME)
-		{
-		  start = daemon->servers;
-		  forward->forwardall = 1;
-		  daemon->forwardcount = 0;
-		  daemon->forwardtime = now;
-		}
-	    }
-	  else
-	    {
-	      start = daemon->servers;
-	      if (!option_bool(OPT_ORDER))
-		forward->forwardall = 1;
-	    }
-	}
+    do_dnssec = type & SERV_DO_DNSSEC;
+#endif
+    type &= ~SERV_DO_DNSSEC;
+
+    if (daemon->servers && !flags)
+      forward = get_new_frec(now, NULL, 0);
+    /* table full - flags == 0, return REFUSED */
+
+    if (forward) {
+      forward->source = *udpaddr;
+      forward->dest = *dst_addr;
+      forward->iface = dst_iface;
+      forward->orig_id = ntohs(header->id);
+      forward->new_id = get_id();
+      forward->fd = udpfd;
+      memcpy(forward->hash, hash, HASH_SIZE);
+      forward->forwardall = 0;
+      forward->flags = 0;
+      if (norebind)
+        forward->flags |= FREC_NOREBIND;
+      if (header->hb4 & HB4_CD)
+        forward->flags |= FREC_CHECKING_DISABLED;
+      if (ad_reqd)
+        forward->flags |= FREC_AD_QUESTION;
+#ifdef HAVE_DNSSEC
+      forward->work_counter = DNSSEC_WORK;
+      if (do_bit)
+        forward->flags |= FREC_DO_QUESTION;
+#endif
+
+      header->id = htons(forward->new_id);
+
+      /* In strict_order mode, always try servers in the order
+         specified in resolv.conf, if a domain is given
+         always try all the available servers,
+         otherwise, use the one last known to work. */
+
+      if (type == 0) {
+        if (option_bool(OPT_ORDER))
+          start = daemon->servers;
+        else if (!(start = daemon->last_server) ||
+                 daemon->forwardcount++ > FORWARD_TEST ||
+                 difftime(now, daemon->forwardtime) > FORWARD_TIME) {
+          start = daemon->servers;
+          forward->forwardall = 1;
+          daemon->forwardcount = 0;
+          daemon->forwardtime = now;
+        }
+      } else {
+        start = daemon->servers;
+        if (!option_bool(OPT_ORDER))
+          forward->forwardall = 1;
+      }
     }
+  }
 
   /* check for send errors here (no route to host) 
      if we fail to send to all nameservers, send back an error
      packet straight away (helps modem users when offline)  */
-  
-  if (!flags && forward)
-    {
-      struct server *firstsentto = start;
-      int subnet, forwarded = 0;
-      size_t edns0_len;
-
-      /* If a query is retried, use the log_id for the retry when logging the answer. */
-      forward->log_id = daemon->log_id;
-      
-      edns0_len  = add_edns0_config(header, plen, ((unsigned char *)header) + PACKETSZ, &forward->source, now, &subnet);
-      
-      if (edns0_len != plen)
-	{
-	  plen = edns0_len;
-	  forward->flags |= FREC_ADDED_PHEADER;
-	  
-	  if (subnet)
-	    forward->flags |= FREC_HAS_SUBNET;
-	}
-      
+
+  if (!flags && forward) {
+    struct server *firstsentto = start;
+    int subnet, forwarded = 0;
+    size_t edns0_len;
+
+    /* If a query is retried, use the log_id for the retry when logging the answer. */
+    forward->log_id = daemon->log_id;
+
+    edns0_len =
+        add_edns0_config(header, plen, ((unsigned char *) header) + PACKETSZ,
+                         &forward->source, now, &subnet);
+
+    if (edns0_len != plen) {
+      plen = edns0_len;
+      forward->flags |= FREC_ADDED_PHEADER;
+
+      if (subnet)
+        forward->flags |= FREC_HAS_SUBNET;
+    }
 #ifdef HAVE_DNSSEC
-      if (option_bool(OPT_DNSSEC_VALID) && do_dnssec)
-	{
-	  size_t new = add_do_bit(header, plen, ((unsigned char *) header) + PACKETSZ);
-	 
-	  if (new != plen)
-	    forward->flags |= FREC_ADDED_PHEADER;
-
-	  plen = new;
-	      
-	  /* For debugging, set Checking Disabled, otherwise, have the upstream check too,
-	     this allows it to select auth servers when one is returning bad data. */
-	  if (option_bool(OPT_DNSSEC_DEBUG))
-	    header->hb4 |= HB4_CD;
-
-	}
-#endif
-
-      /* If we're sending an EDNS0 with any options, we can't recreate the query from a reply. */
-      if (find_pseudoheader(header, plen, &edns0_len, NULL, NULL, NULL) && edns0_len > 11)
-	forward->flags |= FREC_HAS_EXTRADATA;
-      
-      while (1)
-	{ 
-	  /* only send to servers dealing with our domain.
-	     domain may be NULL, in which case server->domain 
-	     must be NULL also. */
-	  
-	  if (type == (start->flags & SERV_TYPE) &&
-	      (type != SERV_HAS_DOMAIN || hostname_isequal(domain, start->domain)) &&
-	      !(start->flags & (SERV_LITERAL_ADDRESS | SERV_LOOP)))
-	    {
-	      int fd;
-
-	      /* find server socket to use, may need to get random one. */
-	      if (start->sfd)
-		fd = start->sfd->fd;
-	      else 
-		{
-#ifdef HAVE_IPV6
-		  if (start->addr.sa.sa_family == AF_INET6)
-		    {
-		      if (!forward->rfd6 &&
-			  !(forward->rfd6 = allocate_rfd(AF_INET6)))
-			break;
-		      daemon->rfd_save = forward->rfd6;
-		      fd = forward->rfd6->fd;
-		    }
-		  else
-#endif
-		    {
-		      if (!forward->rfd4 &&
-			  !(forward->rfd4 = allocate_rfd(AF_INET)))
-			break;
-		      daemon->rfd_save = forward->rfd4;
-		      fd = forward->rfd4->fd;
-		    }
+    if (option_bool(OPT_DNSSEC_VALID) && do_dnssec) {
+      size_t new =
+          add_do_bit(header, plen, ((unsigned char *) header) + PACKETSZ);
+
+      if (new != plen)
+        forward->flags |= FREC_ADDED_PHEADER;
+
+      plen = new;
+
+      /* For debugging, set Checking Disabled, otherwise, have the upstream check too,
+         this allows it to select auth servers when one is returning bad data. */
+      if (option_bool(OPT_DNSSEC_DEBUG))
+        header->hb4 |= HB4_CD;
+
+    }
+#endif
+
+    /* If we're sending an EDNS0 with any options, we can't recreate the query from a reply. */
+    if (find_pseudoheader(header, plen, &edns0_len, NULL, NULL, NULL)
+        && edns0_len > 11)
+      forward->flags |= FREC_HAS_EXTRADATA;
+
+    while (1) {
+      /* only send to servers dealing with our domain.
+         domain may be NULL, in which case server->domain
+         must be NULL also. */
+
+      if (type == (start->flags & SERV_TYPE) &&
+          (type != SERV_HAS_DOMAIN || hostname_isequal(domain, start->domain))
+          && !(start->flags & (SERV_LITERAL_ADDRESS | SERV_LOOP))) {
+        int fd;
+
+        /* find server socket to use, may need to get random one. */
+        if (start->sfd)
+          fd = start->sfd->fd;
+        else {
+#ifdef HAVE_IPV6
+          if (start->addr.sa.sa_family == AF_INET6) {
+            if (!forward->rfd6 && !(forward->rfd6 = allocate_rfd(AF_INET6)))
+              break;
+            daemon->rfd_save = forward->rfd6;
+            fd = forward->rfd6->fd;
+          } else
+#endif
+          {
+            if (!forward->rfd4 && !(forward->rfd4 = allocate_rfd(AF_INET)))
+              break;
+            daemon->rfd_save = forward->rfd4;
+            fd = forward->rfd4->fd;
+          }
 
 #ifdef HAVE_CONNTRACK
-		  /* Copy connection mark of incoming query to outgoing connection. */
-		  if (option_bool(OPT_CONNTRACK))
-		    {
-		      unsigned int mark;
-		      if (get_incoming_mark(&forward->source, &forward->dest, 0, &mark))
-			setsockopt(fd, SOL_SOCKET, SO_MARK, &mark, sizeof(unsigned int));
-		    }
+          /* Copy connection mark of incoming query to outgoing connection. */
+          if (option_bool(OPT_CONNTRACK)) {
+            unsigned int mark;
+            if (get_incoming_mark(&forward->source, &forward->dest, 0, &mark))
+              setsockopt(fd, SOL_SOCKET, SO_MARK, &mark, sizeof(unsigned int));
+          }
 #endif
-		}
-	      
+        }
+
 #ifdef HAVE_DNSSEC
-	      if (option_bool(OPT_DNSSEC_VALID) && (forward->flags & FREC_ADDED_PHEADER))
-		{
-		  /* Difficult one here. If our client didn't send EDNS0, we will have set the UDP
-		     packet size to 512. But that won't provide space for the RRSIGS in many cases.
-		     The RRSIGS will be stripped out before the answer goes back, so the packet should
-		     shrink again. So, if we added a do-bit, bump the udp packet size to the value
-		     known to be OK for this server. We check returned size after stripping and set
-		     the truncated bit if it's still too big. */		  
-		  unsigned char *pheader;
-		  int is_sign;
-		  if (find_pseudoheader(header, plen, NULL, &pheader, &is_sign, NULL) && !is_sign)
-		    PUTSHORT(start->edns_pktsz, pheader);
-		}
-#endif
-
-	      if (retry_send(sendto(fd, (char *)header, plen, 0,
-				    &start->addr.sa,
-				    sa_len(&start->addr))))
-		continue;
-	    
-	      if (errno == 0)
-		{
-		  /* Keep info in case we want to re-send this packet */
-		  daemon->srv_save = start;
-		  daemon->packet_len = plen;
-		  
-		  if (!gotname)
-		    strcpy(daemon->namebuff, "query");
-		  if (start->addr.sa.sa_family == AF_INET)
-		    log_query(F_SERVER | F_IPV4 | F_FORWARD, daemon->namebuff, 
-			      (struct all_addr *)&start->addr.in.sin_addr, NULL); 
-#ifdef HAVE_IPV6
-		  else
-		    log_query(F_SERVER | F_IPV6 | F_FORWARD, daemon->namebuff, 
-			      (struct all_addr *)&start->addr.in6.sin6_addr, NULL);
-#endif 
-		  start->queries++;
-		  forwarded = 1;
-		  forward->sentto = start;
-		  if (!forward->forwardall) 
-		    break;
-		  forward->forwardall++;
-		}
-	    } 
-	  
-	  if (!(start = start->next))
- 	    start = daemon->servers;
-	  
-	  if (start == firstsentto)
-	    break;
-	}
-      
-      if (forwarded)
-	return 1;
-      
-      /* could not send on, prepare to return */ 
-      header->id = htons(forward->orig_id);
-      free_frec(forward); /* cancel */
-    }	  
-  
-  /* could not send on, return empty answer or address if known for whole domain */
-  if (udpfd != -1)
-    {
-      plen = setup_reply(header, plen, addrp, flags, daemon->local_ttl);
-      send_from(udpfd, option_bool(OPT_NOWILD) || option_bool(OPT_CLEVERBIND), (char *)header, plen, udpaddr, dst_addr, dst_iface);
+        if (option_bool(OPT_DNSSEC_VALID)
+            && (forward->flags & FREC_ADDED_PHEADER)) {
+          /* Difficult one here. If our client didn't send EDNS0, we will have set the UDP
+             packet size to 512. But that won't provide space for the RRSIGS in many cases.
+             The RRSIGS will be stripped out before the answer goes back, so the packet should
+             shrink again. So, if we added a do-bit, bump the udp packet size to the value
+             known to be OK for this server. We check returned size after stripping and set
+             the truncated bit if it's still too big. */
+          unsigned char *pheader;
+          int is_sign;
+          if (find_pseudoheader(header, plen, NULL, &pheader, &is_sign, NULL)
+              && !is_sign)
+            PUTSHORT(start->edns_pktsz, pheader);
+        }
+#endif
+
+        if (retry_send(sendto(fd, (char *) header, plen, 0,
+                              &start->addr.sa, sa_len(&start->addr))))
+          continue;
+
+        if (errno == 0) {
+          /* Keep info in case we want to re-send this packet */
+          daemon->srv_save = start;
+          daemon->packet_len = plen;
+
+          if (!gotname)
+            strcpy(daemon->namebuff, "query");
+          if (start->addr.sa.sa_family == AF_INET)
+            log_query(F_SERVER | F_IPV4 | F_FORWARD, daemon->namebuff,
+                      (struct all_addr *) &start->addr.in.sin_addr, NULL);
+#ifdef HAVE_IPV6
+          else
+            log_query(F_SERVER | F_IPV6 | F_FORWARD, daemon->namebuff,
+                      (struct all_addr *) &start->addr.in6.sin6_addr, NULL);
+#endif
+          start->queries++;
+          forwarded = 1;
+          forward->sentto = start;
+          if (!forward->forwardall)
+            break;
+          forward->forwardall++;
+        }
+      }
+
+      if (!(start = start->next))
+        start = daemon->servers;
+
+      if (start == firstsentto)
+        break;
     }
 
+    if (forwarded)
+      return 1;
+
+    /* could not send on, prepare to return */
+    header->id = htons(forward->orig_id);
+    free_frec(forward);         /* cancel */
+  }
+
+  /* could not send on, return empty answer or address if known for whole domain */
+  if (udpfd != -1) {
+    plen = setup_reply(header, plen, addrp, flags, daemon->local_ttl);
+    send_from(udpfd, option_bool(OPT_NOWILD)
+              || option_bool(OPT_CLEVERBIND), (char *) header, plen, udpaddr,
+              dst_addr, dst_iface);
+  }
+
   return 0;
 }
 
-static size_t process_reply(struct dns_header *header, time_t now, struct server *server, size_t n, int check_rebind, 
-			    int no_cache, int cache_secure, int bogusanswer, int ad_reqd, int do_bit, int added_pheader, 
-			    int check_subnet, union mysockaddr *query_source)
+static size_t process_reply(struct dns_header *header, time_t now,
+                            struct server *server, size_t n, int check_rebind,
+                            int no_cache, int cache_secure, int bogusanswer,
+                            int ad_reqd, int do_bit, int added_pheader,
+                            int check_subnet, union mysockaddr *query_source)
 {
   unsigned char *pheader, *sizep;
   char **sets = 0;
   int munged = 0, is_sign;
-  size_t plen; 
+  size_t plen;
 
-  (void)ad_reqd;
-  (void)do_bit;
-  (void)bogusanswer;
+  (void) ad_reqd;
+  (void) do_bit;
+  (void) bogusanswer;
 
 #ifdef HAVE_IPSET
-  if (daemon->ipsets && extract_request(header, n, daemon->namebuff, NULL))
-    {
-      /* Similar algorithm to search_servers. */
-      struct ipsets *ipset_pos;
-      unsigned int namelen = strlen(daemon->namebuff);
-      unsigned int matchlen = 0;
-      for (ipset_pos = daemon->ipsets; ipset_pos; ipset_pos = ipset_pos->next) 
-	{
-	  unsigned int domainlen = strlen(ipset_pos->domain);
-	  char *matchstart = daemon->namebuff + namelen - domainlen;
-	  if (namelen >= domainlen && hostname_isequal(matchstart, ipset_pos->domain) &&
-	      (domainlen == 0 || namelen == domainlen || *(matchstart - 1) == '.' ) &&
-	      domainlen >= matchlen) 
-	    {
-	      matchlen = domainlen;
-	      sets = ipset_pos->sets;
-	    }
-	}
+  if (daemon->ipsets && extract_request(header, n, daemon->namebuff, NULL)) {
+    /* Similar algorithm to search_servers. */
+    struct ipsets *ipset_pos;
+    unsigned int namelen = strlen(daemon->namebuff);
+    unsigned int matchlen = 0;
+    for (ipset_pos = daemon->ipsets; ipset_pos; ipset_pos = ipset_pos->next) {
+      unsigned int domainlen = strlen(ipset_pos->domain);
+      char *matchstart = daemon->namebuff + namelen - domainlen;
+      if (namelen >= domainlen
+          && hostname_isequal(matchstart, ipset_pos->domain) && (domainlen == 0
+                                                                 || namelen ==
+                                                                 domainlen
+                                                                 || *(matchstart
+                                                                      - 1) ==
+                                                                 '.')
+          && domainlen >= matchlen) {
+        matchlen = domainlen;
+        sets = ipset_pos->sets;
+      }
     }
+  }
 #endif
-  
-  if ((pheader = find_pseudoheader(header, n, &plen, &sizep, &is_sign, NULL)))
-    {
-      if (check_subnet && !check_source(header, plen, pheader, query_source))
-	{
-	  my_syslog(LOG_WARNING, _("discarding DNS reply: subnet option mismatch"));
-	  return 0;
-	}
-      
-      if (!is_sign)
-	{
-	  if (added_pheader)
-	    {
-	      /* client didn't send EDNS0, we added one, strip it off before returning answer. */
-	      n = rrfilter(header, n, 0);
-	      pheader = NULL;
-	    }
-	  else
-	    {
-	      unsigned short udpsz;
-
-	      /* If upstream is advertising a larger UDP packet size
-		 than we allow, trim it so that we don't get overlarge
-		 requests for the client. We can't do this for signed packets. */
-	      GETSHORT(udpsz, sizep);
-	      if (udpsz > daemon->edns_pktsz)
-		{
-		  sizep -= 2;
-		  PUTSHORT(daemon->edns_pktsz, sizep);
-		}
 
+  if ((pheader = find_pseudoheader(header, n, &plen, &sizep, &is_sign, NULL))) {
+    if (check_subnet && !check_source(header, plen, pheader, query_source)) {
+      my_syslog(LOG_WARNING, _("discarding DNS reply: subnet option mismatch"));
+      return 0;
+    }
+
+    if (!is_sign) {
+      if (added_pheader) {
+        /* client didn't send EDNS0, we added one, strip it off before returning answer. */
+        n = rrfilter(header, n, 0);
+        pheader = NULL;
+      } else {
+        unsigned short udpsz;
+
+        /* If upstream is advertising a larger UDP packet size
+           than we allow, trim it so that we don't get overlarge
+           requests for the client. We can't do this for signed packets. */
+        GETSHORT(udpsz, sizep);
+        if (udpsz > daemon->edns_pktsz) {
+          sizep -= 2;
+          PUTSHORT(daemon->edns_pktsz, sizep);
+        }
 #ifdef HAVE_DNSSEC
-	      /* If the client didn't set the do bit, but we did, reset it. */
-	      if (option_bool(OPT_DNSSEC_VALID) && !do_bit)
-		{
-		  unsigned short flags;
-		  sizep += 2; /* skip RCODE */
-		  GETSHORT(flags, sizep);
-		  flags &= ~0x8000;
-		  sizep -= 2;
-		  PUTSHORT(flags, sizep);
-		}
+        /* If the client didn't set the do bit, but we did, reset it. */
+        if (option_bool(OPT_DNSSEC_VALID) && !do_bit) {
+          unsigned short flags;
+          sizep += 2;           /* skip RCODE */
+          GETSHORT(flags, sizep);
+          flags &= ~0x8000;
+          sizep -= 2;
+          PUTSHORT(flags, sizep);
+        }
 #endif
-	    }
-	}
+      }
     }
-  
+  }
+
   /* RFC 4035 sect 4.6 para 3 */
   if (!is_sign && !option_bool(OPT_DNSSEC_PROXY))
-     header->hb4 &= ~HB4_AD;
-  
-  if (OPCODE(header) != QUERY || (RCODE(header) != NOERROR && RCODE(header) != NXDOMAIN))
+    header->hb4 &= ~HB4_AD;
+
+  if (OPCODE(header) != QUERY
+      || (RCODE(header) != NOERROR && RCODE(header) != NXDOMAIN))
     return resize_packet(header, n, pheader, plen);
-  
+
   /* Complain loudly if the upstream server is non-recursive. */
   if (!(header->hb4 & HB4_RA) && RCODE(header) == NOERROR &&
-      server && !(server->flags & SERV_WARNED_RECURSIVE))
-    {
-      prettyprint_addr(&server->addr, daemon->namebuff);
-      my_syslog(LOG_WARNING, _("nameserver %s refused to do a recursive query"), daemon->namebuff);
-      if (!option_bool(OPT_LOG))
-	server->flags |= SERV_WARNED_RECURSIVE;
-    }  
+      server && !(server->flags & SERV_WARNED_RECURSIVE)) {
+    prettyprint_addr(&server->addr, daemon->namebuff);
+    my_syslog(LOG_WARNING, _("nameserver %s refused to do a recursive query"),
+              daemon->namebuff);
+    if (!option_bool(OPT_LOG))
+      server->flags |= SERV_WARNED_RECURSIVE;
+  }
 
   if (daemon->bogus_addr && RCODE(header) != NXDOMAIN &&
-      check_for_bogus_wildcard(header, n, daemon->namebuff, daemon->bogus_addr, now))
-    {
+      check_for_bogus_wildcard(header, n, daemon->namebuff, daemon->bogus_addr,
+                               now)) {
+    munged = 1;
+    SET_RCODE(header, NXDOMAIN);
+    header->hb3 &= ~HB3_AA;
+    cache_secure = 0;
+  } else {
+    int doctored = 0;
+
+    if (RCODE(header) == NXDOMAIN &&
+        extract_request(header, n, daemon->namebuff, NULL) &&
+        check_for_local_domain(daemon->namebuff, now)) {
+      /* if we forwarded a query for a locally known name (because it was for
+         an unknown type) and the answer is NXDOMAIN, convert that to NODATA,
+         since we know that the domain exists, even if upstream doesn't */
       munged = 1;
-      SET_RCODE(header, NXDOMAIN);
-      header->hb3 &= ~HB3_AA;
+      header->hb3 |= HB3_AA;
+      SET_RCODE(header, NOERROR);
       cache_secure = 0;
     }
-  else 
-    {
-      int doctored = 0;
-      
-      if (RCODE(header) == NXDOMAIN && 
-	  extract_request(header, n, daemon->namebuff, NULL) &&
-	  check_for_local_domain(daemon->namebuff, now))
-	{
-	  /* if we forwarded a query for a locally known name (because it was for 
-	     an unknown type) and the answer is NXDOMAIN, convert that to NODATA,
-	     since we know that the domain exists, even if upstream doesn't */
-	  munged = 1;
-	  header->hb3 |= HB3_AA;
-	  SET_RCODE(header, NOERROR);
-	  cache_secure = 0;
-	}
-      
-      if (extract_addresses(header, n, daemon->namebuff, now, sets, is_sign, check_rebind, no_cache, cache_secure, &doctored))
-	{
-	  my_syslog(LOG_WARNING, _("possible DNS-rebind attack detected: %s"), daemon->namebuff);
-	  munged = 1;
-	  cache_secure = 0;
-	}
 
-      if (doctored)
-	cache_secure = 0;
-    }
-  
-#ifdef HAVE_DNSSEC
-  if (bogusanswer && !(header->hb4 & HB4_CD) && !option_bool(OPT_DNSSEC_DEBUG))
-    {
-      /* Bogus reply, turn into SERVFAIL */
-      SET_RCODE(header, SERVFAIL);
+    if (extract_addresses
+        (header, n, daemon->namebuff, now, sets, is_sign, check_rebind,
+         no_cache, cache_secure, &doctored)) {
+      my_syslog(LOG_WARNING, _("possible DNS-rebind attack detected: %s"),
+                daemon->namebuff);
       munged = 1;
+      cache_secure = 0;
     }
 
-  if (option_bool(OPT_DNSSEC_VALID))
-    {
-      header->hb4 &= ~HB4_AD;
-      
-      if (!(header->hb4 & HB4_CD) && ad_reqd && cache_secure)
-	header->hb4 |= HB4_AD;
-      
-      /* If the requestor didn't set the DO bit, don't return DNSSEC info. */
-      if (!do_bit)
-	n = rrfilter(header, n, 1);
-    }
+    if (doctored)
+      cache_secure = 0;
+  }
+
+#ifdef HAVE_DNSSEC
+  if (bogusanswer && !(header->hb4 & HB4_CD) && !option_bool(OPT_DNSSEC_DEBUG)) {
+    /* Bogus reply, turn into SERVFAIL */
+    SET_RCODE(header, SERVFAIL);
+    munged = 1;
+  }
+
+  if (option_bool(OPT_DNSSEC_VALID)) {
+    header->hb4 &= ~HB4_AD;
+
+    if (!(header->hb4 & HB4_CD) && ad_reqd && cache_secure)
+      header->hb4 |= HB4_AD;
+
+    /* If the requestor didn't set the DO bit, don't return DNSSEC info. */
+    if (!do_bit)
+      n = rrfilter(header, n, 1);
+  }
 #endif
 
   /* do this after extract_addresses. Ensure NODATA reply and remove
      nameserver info. */
-  
-  if (munged)
-    {
-      header->ancount = htons(0);
-      header->nscount = htons(0);
-      header->arcount = htons(0);
-      header->hb3 &= ~HB3_TC;
-    }
-  
+
+  if (munged) {
+    header->ancount = htons(0);
+    header->nscount = htons(0);
+    header->arcount = htons(0);
+    header->hb3 &= ~HB3_TC;
+  }
+
   /* the bogus-nxdomain stuff, doctor and NXDOMAIN->NODATA munging can all elide
      sections of the packet. Find the new length here and put back pseudoheader
      if it was removed. */
@@ -736,7 +702,9 @@
   union mysockaddr serveraddr;
   struct frec *forward;
   socklen_t addrlen = sizeof(serveraddr);
-  ssize_t n = recvfrom(fd, daemon->packet, daemon->packet_buff_sz, 0, &serveraddr.sa, &addrlen);
+  ssize_t n =
+      recvfrom(fd, daemon->packet, daemon->packet_buff_sz, 0, &serveraddr.sa,
+               &addrlen);
   size_t nn;
   struct server *server;
   void *hash;
@@ -746,43 +714,43 @@
 
   /* packet buffer overwritten */
   daemon->srv_save = NULL;
-  
+
   /* Determine the address of the server replying  so that we can mark that as good */
   serveraddr.sa.sa_family = family;
 #ifdef HAVE_IPV6
   if (serveraddr.sa.sa_family == AF_INET6)
     serveraddr.in6.sin6_flowinfo = 0;
 #endif
-  
-  header = (struct dns_header *)daemon->packet;
-  
-  if (n < (int)sizeof(struct dns_header) || !(header->hb3 & HB3_QR))
+
+  header = (struct dns_header *) daemon->packet;
+
+  if (n < (int) sizeof(struct dns_header) || !(header->hb3 & HB3_QR))
     return;
-  
+
   /* spoof check: answer must come from known server, */
   for (server = daemon->servers; server; server = server->next)
     if (!(server->flags & (SERV_LITERAL_ADDRESS | SERV_NO_ADDR)) &&
-	sockaddr_isequal(&server->addr, &serveraddr))
+        sockaddr_isequal(&server->addr, &serveraddr))
       break;
-  
+
   if (!server)
     return;
-  
+
 #ifdef HAVE_DNSSEC
   hash = hash_questions(header, n, daemon->namebuff);
 #else
   hash = &crc;
   crc = questions_crc(header, n, daemon->namebuff);
 #endif
-  
+
   if (!(forward = lookup_frec(ntohs(header->id), hash)))
     return;
-  
+
   /* log_query gets called indirectly all over the place, so 
      pass these in global variables - sorry. */
   daemon->log_display_id = forward->log_id;
   daemon->log_source_addr = &forward->source;
-  
+
   if (daemon->ignore_addr && RCODE(header) == NOERROR &&
       check_for_ignored_address(header, n, daemon->ignore_addr))
     return;
@@ -790,336 +758,344 @@
   /* Note: if we send extra options in the EDNS0 header, we can't recreate
      the query from the reply. */
   if (RCODE(header) == REFUSED &&
-      forward->forwardall == 0 &&
-      !(forward->flags & FREC_HAS_EXTRADATA))
+      forward->forwardall == 0 && !(forward->flags & FREC_HAS_EXTRADATA))
     /* for broken servers, attempt to send to another one. */
-    {
-      unsigned char *pheader;
-      size_t plen;
-      int is_sign;
-      
-      /* recreate query from reply */
-      pheader = find_pseudoheader(header, (size_t)n, &plen, NULL, &is_sign, NULL);
-      if (!is_sign)
-	{
-	  header->ancount = htons(0);
-	  header->nscount = htons(0);
-	  header->arcount = htons(0);
-	  if ((nn = resize_packet(header, (size_t)n, pheader, plen)))
-	    {
-	      header->hb3 &= ~(HB3_QR | HB3_AA | HB3_TC);
-	      header->hb4 &= ~(HB4_RA | HB4_RCODE | HB4_CD | HB4_AD);
-	      if (forward->flags & FREC_CHECKING_DISABLED)
-		header->hb4 |= HB4_CD;
-	      if (forward->flags & FREC_AD_QUESTION)
-		header->hb4 |= HB4_AD;
-	      if (forward->flags & FREC_DO_QUESTION)
-		add_do_bit(header, nn,  (unsigned char *)pheader + plen);
-	      forward_query(-1, NULL, NULL, 0, header, nn, now, forward, forward->flags & FREC_AD_QUESTION, forward->flags & FREC_DO_QUESTION);
-	      return;
-	    }
-	}
-    }   
-   
-  server = forward->sentto;
-  if ((forward->sentto->flags & SERV_TYPE) == 0)
-    {
-      if (RCODE(header) == REFUSED)
-	server = NULL;
-      else
-	{
-	  struct server *last_server;
-	  
-	  /* find good server by address if possible, otherwise assume the last one we sent to */ 
-	  for (last_server = daemon->servers; last_server; last_server = last_server->next)
-	    if (!(last_server->flags & (SERV_LITERAL_ADDRESS | SERV_HAS_DOMAIN | SERV_FOR_NODOTS | SERV_NO_ADDR)) &&
-		sockaddr_isequal(&last_server->addr, &serveraddr))
-	      {
-		server = last_server;
-		break;
-	      }
-	} 
-      if (!option_bool(OPT_ALL_SERVERS))
-	daemon->last_server = server;
+  {
+    unsigned char *pheader;
+    size_t plen;
+    int is_sign;
+
+    /* recreate query from reply */
+    pheader =
+        find_pseudoheader(header, (size_t) n, &plen, NULL, &is_sign, NULL);
+    if (!is_sign) {
+      header->ancount = htons(0);
+      header->nscount = htons(0);
+      header->arcount = htons(0);
+      if ((nn = resize_packet(header, (size_t) n, pheader, plen))) {
+        header->hb3 &= ~(HB3_QR | HB3_AA | HB3_TC);
+        header->hb4 &= ~(HB4_RA | HB4_RCODE | HB4_CD | HB4_AD);
+        if (forward->flags & FREC_CHECKING_DISABLED)
+          header->hb4 |= HB4_CD;
+        if (forward->flags & FREC_AD_QUESTION)
+          header->hb4 |= HB4_AD;
+        if (forward->flags & FREC_DO_QUESTION)
+          add_do_bit(header, nn, (unsigned char *) pheader + plen);
+        forward_query(-1, NULL, NULL, 0, header, nn, now, forward,
+                      forward->flags & FREC_AD_QUESTION,
+                      forward->flags & FREC_DO_QUESTION);
+        return;
+      }
     }
- 
+  }
+
+  server = forward->sentto;
+  if ((forward->sentto->flags & SERV_TYPE) == 0) {
+    if (RCODE(header) == REFUSED)
+      server = NULL;
+    else {
+      struct server *last_server;
+
+      /* find good server by address if possible, otherwise assume the last one we sent to */
+      for (last_server = daemon->servers; last_server;
+           last_server = last_server->next)
+        if (!
+            (last_server->
+             flags & (SERV_LITERAL_ADDRESS | SERV_HAS_DOMAIN | SERV_FOR_NODOTS |
+                      SERV_NO_ADDR))
+            && sockaddr_isequal(&last_server->addr, &serveraddr)) {
+          server = last_server;
+          break;
+        }
+    }
+    if (!option_bool(OPT_ALL_SERVERS))
+      daemon->last_server = server;
+  }
+
   /* We tried resending to this server with a smaller maximum size and got an answer.
      Make that permanent. To avoid reduxing the packet size for an single dropped packet,
      only do this when we get a truncated answer, or one larger than the safe size. */
-  if (server && (forward->flags & FREC_TEST_PKTSZ) && 
+  if (server && (forward->flags & FREC_TEST_PKTSZ) &&
       ((header->hb3 & HB3_TC) || n >= SAFE_PKTSZ))
     server->edns_pktsz = SAFE_PKTSZ;
-  
+
   /* If the answer is an error, keep the forward record in place in case
      we get a good reply from another server. Kill it when we've
      had replies from all to avoid filling the forwarding table when
      everything is broken */
   if (forward->forwardall == 0 || --forward->forwardall == 1 ||
-      (RCODE(header) != REFUSED && RCODE(header) != SERVFAIL))
-    {
-      int check_rebind = 0, no_cache_dnssec = 0, cache_secure = 0, bogusanswer = 0;
+      (RCODE(header) != REFUSED && RCODE(header) != SERVFAIL)) {
+    int check_rebind = 0, no_cache_dnssec = 0, cache_secure = 0, bogusanswer =
+        0;
+
+    if (option_bool(OPT_NO_REBIND))
+      check_rebind = !(forward->flags & FREC_NOREBIND);
+
+    /*   Don't cache replies where DNSSEC validation was turned off, either
+       the upstream server told us so, or the original query specified it.  */
+    if ((header->hb4 & HB4_CD) || (forward->flags & FREC_CHECKING_DISABLED))
+      no_cache_dnssec = 1;
 
-      if (option_bool(OPT_NO_REBIND))
-	check_rebind = !(forward->flags & FREC_NOREBIND);
-      
-      /*   Don't cache replies where DNSSEC validation was turned off, either
-	   the upstream server told us so, or the original query specified it.  */
-      if ((header->hb4 & HB4_CD) || (forward->flags & FREC_CHECKING_DISABLED))
-	no_cache_dnssec = 1;
-      
 #ifdef HAVE_DNSSEC
-      if (server && (server->flags & SERV_DO_DNSSEC) && 
-	  option_bool(OPT_DNSSEC_VALID) && !(forward->flags & FREC_CHECKING_DISABLED))
-	{
-	  int status = 0;
-
-	  /* We've had a reply already, which we're validating. Ignore this duplicate */
-	  if (forward->blocking_query)
-	    return;
-	  
-	   /* Truncated answer can't be validated.
-	      If this is an answer to a DNSSEC-generated query, we still
-	      need to get the client to retry over TCP, so return
-	      an answer with the TC bit set, even if the actual answer fits.
-	   */
-	  if (header->hb3 & HB3_TC)
-	    status = STAT_TRUNCATED;
-	  
-	  while (1)
-	    {
-	      /* As soon as anything returns BOGUS, we stop and unwind, to do otherwise
-		 would invite infinite loops, since the answers to DNSKEY and DS queries
-		 will not be cached, so they'll be repeated. */
-	      if (status != STAT_BOGUS && status != STAT_TRUNCATED && status != STAT_ABANDONED)
-		{
-		  if (forward->flags & FREC_DNSKEY_QUERY)
-		    status = dnssec_validate_by_ds(now, header, n, daemon->namebuff, daemon->keyname, forward->class);
-		  else if (forward->flags & FREC_DS_QUERY)
-		    status = dnssec_validate_ds(now, header, n, daemon->namebuff, daemon->keyname, forward->class);
-		  else
-		    status = dnssec_validate_reply(now, header, n, daemon->namebuff, daemon->keyname, &forward->class, 
-						   option_bool(OPT_DNSSEC_NO_SIGN) && (server->flags & SERV_DO_DNSSEC), NULL, NULL);
-		}
-	      
-	      /* Can't validate, as we're missing key data. Put this
-		 answer aside, whilst we get that. */     
-	      if (status == STAT_NEED_DS || status == STAT_NEED_KEY)
-		{
-		  struct frec *new, *orig;
-		  
-		  /* Free any saved query */
-		  if (forward->stash)
-		    blockdata_free(forward->stash);
-		  
-		  /* Now save reply pending receipt of key data */
-		  if (!(forward->stash = blockdata_alloc((char *)header, n)))
-		    return;
-		  forward->stash_len = n;
-		  
-		  /* Find the original query that started it all.... */
-		  for (orig = forward; orig->dependent; orig = orig->dependent);
-		  
-		  if (--orig->work_counter == 0 || !(new = get_new_frec(now, NULL, 1)))
-		    status = STAT_ABANDONED;
-		  else
-		    {
-		      int fd, type = SERV_DO_DNSSEC;
-		      struct frec *next = new->next;
-		      char *domain;
-		      
-		      *new = *forward; /* copy everything, then overwrite */
-		      new->next = next;
-		      new->blocking_query = NULL;
-
-		      /* Find server to forward to. This will normally be the 
-			 same as for the original query, but may be another if
-			 servers for domains are involved. */		      
-		      if (search_servers(now, NULL, F_DNSSECOK, daemon->keyname, &type, &domain, NULL) == 0)
-			{
-			  struct server *start = server, *new_server = NULL;
-			  
-			  while (1)
-			    {
-			      if (type == (start->flags & (SERV_TYPE | SERV_DO_DNSSEC)) &&
-				  (type != SERV_HAS_DOMAIN || hostname_isequal(domain, start->domain)) &&
-				  !(start->flags & (SERV_LITERAL_ADDRESS | SERV_LOOP)))
-				{
-				  new_server = start;
-				  if (server == start)
-				    {
-				      new_server = NULL;
-				      break;
-				    }
-				}
-			      
-			      if (!(start = start->next))
-				start = daemon->servers;
-			      if (start == server)
-				break;
-			    }
-			  
-			  if (new_server)
-			    server = new_server;
-			}
-		      
-		      new->sentto = server;
-		      new->rfd4 = NULL;
-#ifdef HAVE_IPV6
-		      new->rfd6 = NULL;
-#endif
-		      new->flags &= ~(FREC_DNSKEY_QUERY | FREC_DS_QUERY);
-		      
-		      new->dependent = forward; /* to find query awaiting new one. */
-		      forward->blocking_query = new; /* for garbage cleaning */
-		      /* validate routines leave name of required record in daemon->keyname */
-		      if (status == STAT_NEED_KEY)
-			{
-			  new->flags |= FREC_DNSKEY_QUERY; 
-			  nn = dnssec_generate_query(header, ((unsigned char *) header) + server->edns_pktsz,
-						     daemon->keyname, forward->class, T_DNSKEY, &server->addr, server->edns_pktsz);
-			}
-		      else 
-			{
-			  new->flags |= FREC_DS_QUERY;
-			  nn = dnssec_generate_query(header,((unsigned char *) header) + server->edns_pktsz,
-						     daemon->keyname, forward->class, T_DS, &server->addr, server->edns_pktsz);
-			}
-		      if ((hash = hash_questions(header, nn, daemon->namebuff)))
-			memcpy(new->hash, hash, HASH_SIZE);
-		      new->new_id = get_id();
-		      header->id = htons(new->new_id);
-		      /* Save query for retransmission */
-		      new->stash = blockdata_alloc((char *)header, nn);
-		      new->stash_len = nn;
-		      
-		      /* Don't resend this. */
-		      daemon->srv_save = NULL;
-		      
-		      if (server->sfd)
-			fd = server->sfd->fd;
-		      else
-			{
-			  fd = -1;
-#ifdef HAVE_IPV6
-			  if (server->addr.sa.sa_family == AF_INET6)
-			    {
-			      if (new->rfd6 || (new->rfd6 = allocate_rfd(AF_INET6)))
-				fd = new->rfd6->fd;
-			    }
-			  else
-#endif
-			    {
-			      if (new->rfd4 || (new->rfd4 = allocate_rfd(AF_INET)))
-				fd = new->rfd4->fd;
-			    }
-			}
-		      
-		      if (fd != -1)
-			{
+    if (server && (server->flags & SERV_DO_DNSSEC) &&
+        option_bool(OPT_DNSSEC_VALID)
+        && !(forward->flags & FREC_CHECKING_DISABLED)) {
+      int status = 0;
+
+      /* We've had a reply already, which we're validating. Ignore this duplicate */
+      if (forward->blocking_query)
+        return;
+
+      /* Truncated answer can't be validated.
+         If this is an answer to a DNSSEC-generated query, we still
+         need to get the client to retry over TCP, so return
+         an answer with the TC bit set, even if the actual answer fits.
+       */
+      if (header->hb3 & HB3_TC)
+        status = STAT_TRUNCATED;
+
+      while (1) {
+        /* As soon as anything returns BOGUS, we stop and unwind, to do otherwise
+           would invite infinite loops, since the answers to DNSKEY and DS queries
+           will not be cached, so they'll be repeated. */
+        if (status != STAT_BOGUS && status != STAT_TRUNCATED
+            && status != STAT_ABANDONED) {
+          if (forward->flags & FREC_DNSKEY_QUERY)
+            status =
+                dnssec_validate_by_ds(now, header, n, daemon->namebuff,
+                                      daemon->keyname, forward->class);
+          else if (forward->flags & FREC_DS_QUERY)
+            status =
+                dnssec_validate_ds(now, header, n, daemon->namebuff,
+                                   daemon->keyname, forward->class);
+          else
+            status =
+                dnssec_validate_reply(now, header, n, daemon->namebuff,
+                                      daemon->keyname, &forward->class,
+                                      option_bool(OPT_DNSSEC_NO_SIGN)
+                                      && (server->flags & SERV_DO_DNSSEC), NULL,
+                                      NULL);
+        }
+
+        /* Can't validate, as we're missing key data. Put this
+           answer aside, whilst we get that. */
+        if (status == STAT_NEED_DS || status == STAT_NEED_KEY) {
+          struct frec *new, *orig;
+
+          /* Free any saved query */
+          if (forward->stash)
+            blockdata_free(forward->stash);
+
+          /* Now save reply pending receipt of key data */
+          if (!(forward->stash = blockdata_alloc((char *) header, n)))
+            return;
+          forward->stash_len = n;
+
+          /* Find the original query that started it all.... */
+          for (orig = forward; orig->dependent; orig = orig->dependent);
+
+          if (--orig->work_counter == 0 || !(new = get_new_frec(now, NULL, 1)))
+            status = STAT_ABANDONED;
+          else {
+            int fd, type = SERV_DO_DNSSEC;
+            struct frec *next = new->next;
+            char *domain;
+
+            *new = *forward;    /* copy everything, then overwrite */
+            new->next = next;
+            new->blocking_query = NULL;
+
+            /* Find server to forward to. This will normally be the
+               same as for the original query, but may be another if
+               servers for domains are involved. */
+            if (search_servers
+                (now, NULL, F_DNSSECOK, daemon->keyname, &type, &domain,
+                 NULL) == 0) {
+              struct server *start = server, *new_server = NULL;
+
+              while (1) {
+                if (type == (start->flags & (SERV_TYPE | SERV_DO_DNSSEC)) &&
+                    (type != SERV_HAS_DOMAIN
+                     || hostname_isequal(domain, start->domain))
+                    && !(start->flags & (SERV_LITERAL_ADDRESS | SERV_LOOP))) {
+                  new_server = start;
+                  if (server == start) {
+                    new_server = NULL;
+                    break;
+                  }
+                }
+
+                if (!(start = start->next))
+                  start = daemon->servers;
+                if (start == server)
+                  break;
+              }
+
+              if (new_server)
+                server = new_server;
+            }
+
+            new->sentto = server;
+            new->rfd4 = NULL;
+#ifdef HAVE_IPV6
+            new->rfd6 = NULL;
+#endif
+            new->flags &= ~(FREC_DNSKEY_QUERY | FREC_DS_QUERY);
+
+            new->dependent = forward;   /* to find query awaiting new one. */
+            forward->blocking_query = new;      /* for garbage cleaning */
+            /* validate routines leave name of required record in daemon->keyname */
+            if (status == STAT_NEED_KEY) {
+              new->flags |= FREC_DNSKEY_QUERY;
+              nn = dnssec_generate_query(header,
+                                         ((unsigned char *) header) +
+                                         server->edns_pktsz, daemon->keyname,
+                                         forward->class, T_DNSKEY,
+                                         &server->addr, server->edns_pktsz);
+            } else {
+              new->flags |= FREC_DS_QUERY;
+              nn = dnssec_generate_query(header,
+                                         ((unsigned char *) header) +
+                                         server->edns_pktsz, daemon->keyname,
+                                         forward->class, T_DS, &server->addr,
+                                         server->edns_pktsz);
+            }
+            if ((hash = hash_questions(header, nn, daemon->namebuff)))
+              memcpy(new->hash, hash, HASH_SIZE);
+            new->new_id = get_id();
+            header->id = htons(new->new_id);
+            /* Save query for retransmission */
+            new->stash = blockdata_alloc((char *) header, nn);
+            new->stash_len = nn;
+
+            /* Don't resend this. */
+            daemon->srv_save = NULL;
+
+            if (server->sfd)
+              fd = server->sfd->fd;
+            else {
+              fd = -1;
+#ifdef HAVE_IPV6
+              if (server->addr.sa.sa_family == AF_INET6) {
+                if (new->rfd6 || (new->rfd6 = allocate_rfd(AF_INET6)))
+                  fd = new->rfd6->fd;
+              } else
+#endif
+              {
+                if (new->rfd4 || (new->rfd4 = allocate_rfd(AF_INET)))
+                  fd = new->rfd4->fd;
+              }
+            }
+
+            if (fd != -1) {
 #ifdef HAVE_CONNTRACK
-			  /* Copy connection mark of incoming query to outgoing connection. */
-			  if (option_bool(OPT_CONNTRACK))
-			    {
-			      unsigned int mark;
-			      if (get_incoming_mark(&orig->source, &orig->dest, 0, &mark))
-				setsockopt(fd, SOL_SOCKET, SO_MARK, &mark, sizeof(unsigned int));
-			    }
-#endif
-			  while (retry_send(sendto(fd, (char *)header, nn, 0, 
-						   &server->addr.sa, 
-						   sa_len(&server->addr)))); 
-			  server->queries++;
-			}
-		    }		  
-		  return;
-		}
-	  
-	      /* Validated original answer, all done. */
-	      if (!forward->dependent)
-		break;
-	      
-	      /* validated subsidiary query, (and cached result)
-		 pop that and return to the previous query we were working on. */
-	      struct frec *prev = forward->dependent;
-	      free_frec(forward);
-	      forward = prev;
-	      forward->blocking_query = NULL; /* already gone */
-	      blockdata_retrieve(forward->stash, forward->stash_len, (void *)header);
-	      n = forward->stash_len;
-	    }
-	
-	  
-	  no_cache_dnssec = 0;
-	  
-	  if (status == STAT_TRUNCATED)
-	    header->hb3 |= HB3_TC;
-	  else
-	    {
-	      char *result, *domain = "result";
-	      
-	      if (status == STAT_ABANDONED)
-		{
-		  result = "ABANDONED";
-		  status = STAT_BOGUS;
-		}
-	      else
-		result = (status == STAT_SECURE ? "SECURE" : (status == STAT_INSECURE ? "INSECURE" : "BOGUS"));
-	      
-	      if (status == STAT_BOGUS && extract_request(header, n, daemon->namebuff, NULL))
-		domain = daemon->namebuff;
-	      
-	      log_query(F_KEYTAG | F_SECSTAT, domain, NULL, result);
-	    }
-	  
-	  if (status == STAT_SECURE)
-	    cache_secure = 1;
-	  else if (status == STAT_BOGUS)
-	    {
-	      no_cache_dnssec = 1;
-	      bogusanswer = 1;
-	    }
-	}
-#endif     
-      
-      /* restore CD bit to the value in the query */
-      if (forward->flags & FREC_CHECKING_DISABLED)
-	header->hb4 |= HB4_CD;
-      else
-	header->hb4 &= ~HB4_CD;
-      
-      if ((nn = process_reply(header, now, forward->sentto, (size_t)n, check_rebind, no_cache_dnssec, cache_secure, bogusanswer, 
-			      forward->flags & FREC_AD_QUESTION, forward->flags & FREC_DO_QUESTION, 
-			      forward->flags & FREC_ADDED_PHEADER, forward->flags & FREC_HAS_SUBNET, &forward->source)))
-	{
-	  header->id = htons(forward->orig_id);
-	  header->hb4 |= HB4_RA; /* recursion if available */
+              /* Copy connection mark of incoming query to outgoing connection. */
+              if (option_bool(OPT_CONNTRACK)) {
+                unsigned int mark;
+                if (get_incoming_mark(&orig->source, &orig->dest, 0, &mark))
+                  setsockopt(fd, SOL_SOCKET, SO_MARK, &mark,
+                             sizeof(unsigned int));
+              }
+#endif
+              while (retry_send(sendto(fd, (char *) header, nn, 0,
+                                       &server->addr.sa,
+                                       sa_len(&server->addr))));
+              server->queries++;
+            }
+          }
+          return;
+        }
+
+        /* Validated original answer, all done. */
+        if (!forward->dependent)
+          break;
+
+        /* validated subsidiary query, (and cached result)
+           pop that and return to the previous query we were working on. */
+        struct frec *prev = forward->dependent;
+        free_frec(forward);
+        forward = prev;
+        forward->blocking_query = NULL; /* already gone */
+        blockdata_retrieve(forward->stash, forward->stash_len, (void *) header);
+        n = forward->stash_len;
+      }
+
+
+      no_cache_dnssec = 0;
+
+      if (status == STAT_TRUNCATED)
+        header->hb3 |= HB3_TC;
+      else {
+        char *result, *domain = "result";
+
+        if (status == STAT_ABANDONED) {
+          result = "ABANDONED";
+          status = STAT_BOGUS;
+        } else
+          result =
+              (status ==
+               STAT_SECURE ? "SECURE" : (status ==
+                                         STAT_INSECURE ? "INSECURE" : "BOGUS"));
+
+        if (status == STAT_BOGUS
+            && extract_request(header, n, daemon->namebuff, NULL))
+          domain = daemon->namebuff;
+
+        log_query(F_KEYTAG | F_SECSTAT, domain, NULL, result);
+      }
+
+      if (status == STAT_SECURE)
+        cache_secure = 1;
+      else if (status == STAT_BOGUS) {
+        no_cache_dnssec = 1;
+        bogusanswer = 1;
+      }
+    }
+#endif
+
+    /* restore CD bit to the value in the query */
+    if (forward->flags & FREC_CHECKING_DISABLED)
+      header->hb4 |= HB4_CD;
+    else
+      header->hb4 &= ~HB4_CD;
+
+    if ((nn =
+         process_reply(header, now, forward->sentto, (size_t) n, check_rebind,
+                       no_cache_dnssec, cache_secure, bogusanswer,
+                       forward->flags & FREC_AD_QUESTION,
+                       forward->flags & FREC_DO_QUESTION,
+                       forward->flags & FREC_ADDED_PHEADER,
+                       forward->flags & FREC_HAS_SUBNET, &forward->source))) {
+      header->id = htons(forward->orig_id);
+      header->hb4 |= HB4_RA;    /* recursion if available */
 #ifdef HAVE_DNSSEC
-	  /* We added an EDNSO header for the purpose of getting DNSSEC RRs, and set the value of the UDP payload size
-	     greater than the no-EDNS0-implied 512 to have if space for the RRSIGS. If, having stripped them and the EDNS0
-             header, the answer is still bigger than 512, truncate it and mark it so. The client then retries with TCP. */
-	  if (option_bool(OPT_DNSSEC_VALID) && (forward->flags & FREC_ADDED_PHEADER) && (nn > PACKETSZ))
-	    {
-	      header->ancount = htons(0);
-	      header->nscount = htons(0);
-	      header->arcount = htons(0);
-	      header->hb3 |= HB3_TC;
-	      nn = resize_packet(header, nn, NULL, 0);
-	    }
-#endif
-	  send_from(forward->fd, option_bool(OPT_NOWILD) || option_bool (OPT_CLEVERBIND), daemon->packet, nn, 
-		    &forward->source, &forward->dest, forward->iface);
-	}
-      free_frec(forward); /* cancel */
+      /* We added an EDNSO header for the purpose of getting DNSSEC RRs, and set the value of the UDP payload size
+         greater than the no-EDNS0-implied 512 to have if space for the RRSIGS. If, having stripped them and the EDNS0
+         header, the answer is still bigger than 512, truncate it and mark it so. The client then retries with TCP. */
+      if (option_bool(OPT_DNSSEC_VALID) && (forward->flags & FREC_ADDED_PHEADER)
+          && (nn > PACKETSZ)) {
+        header->ancount = htons(0);
+        header->nscount = htons(0);
+        header->arcount = htons(0);
+        header->hb3 |= HB3_TC;
+        nn = resize_packet(header, nn, NULL, 0);
+      }
+#endif
+      send_from(forward->fd, option_bool(OPT_NOWILD)
+                || option_bool(OPT_CLEVERBIND), daemon->packet, nn,
+                &forward->source, &forward->dest, forward->iface);
     }
+    free_frec(forward);         /* cancel */
+  }
 }
 
 
 void receive_query(struct listener *listen, time_t now)
 {
-  struct dns_header *header = (struct dns_header *)daemon->packet;
+  struct dns_header *header = (struct dns_header *) daemon->packet;
   union mysockaddr source_addr;
   unsigned char *pheader;
-  unsigned short type, udp_size = PACKETSZ; /* default if no EDNS0 */
+  unsigned short type, udp_size = PACKETSZ;     /* default if no EDNS0 */
   struct all_addr dst_addr;
   struct in_addr netmask, dst_addr_4;
   size_t m;
@@ -1132,7 +1108,7 @@
   struct msghdr msg;
   struct cmsghdr *cmptr;
   union {
-    struct cmsghdr align; /* this ensures alignment */
+    struct cmsghdr align;       /* this ensures alignment */
 #ifdef HAVE_IPV6
     char control6[CMSG_SPACE(sizeof(struct in6_pktinfo))];
 #endif
@@ -1140,14 +1116,14 @@
     char control[CMSG_SPACE(sizeof(struct in_pktinfo))];
 #elif defined(IP_RECVDSTADDR) && defined(HAVE_SOLARIS_NETWORK)
     char control[CMSG_SPACE(sizeof(struct in_addr)) +
-		 CMSG_SPACE(sizeof(unsigned int))];
+                 CMSG_SPACE(sizeof(unsigned int))];
 #elif defined(IP_RECVDSTADDR)
     char control[CMSG_SPACE(sizeof(struct in_addr)) +
-		 CMSG_SPACE(sizeof(struct sockaddr_dl))];
+                 CMSG_SPACE(sizeof(struct sockaddr_dl))];
 #endif
   } control_u;
 #ifdef HAVE_IPV6
-   /* Can always get recvd interface for IPv6 */
+  /* Can always get recvd interface for IPv6 */
   int check_dst = !option_bool(OPT_NOWILD) || listen->family == AF_INET6;
 #else
   int check_dst = !option_bool(OPT_NOWILD);
@@ -1155,24 +1131,22 @@
 
   /* packet buffer overwritten */
   daemon->srv_save = NULL;
-  
+
   dst_addr_4.s_addr = dst_addr.addr.addr4.s_addr = 0;
   netmask.s_addr = 0;
-  
-  if (option_bool(OPT_NOWILD) && listen->iface)
-    {
-      auth_dns = listen->iface->dns_auth;
-     
-      if (listen->family == AF_INET)
-	{
-	  dst_addr_4 = dst_addr.addr.addr4 = listen->iface->addr.in.sin_addr;
-	  netmask = listen->iface->netmask;
-	}
+
+  if (option_bool(OPT_NOWILD) && listen->iface) {
+    auth_dns = listen->iface->dns_auth;
+
+    if (listen->family == AF_INET) {
+      dst_addr_4 = dst_addr.addr.addr4 = listen->iface->addr.in.sin_addr;
+      netmask = listen->iface->netmask;
     }
-  
+  }
+
   iov[0].iov_base = daemon->packet;
   iov[0].iov_len = daemon->edns_pktsz;
-    
+
   msg.msg_control = control_u.control;
   msg.msg_controllen = sizeof(control_u);
   msg.msg_flags = 0;
@@ -1180,418 +1154,404 @@
   msg.msg_namelen = sizeof(source_addr);
   msg.msg_iov = iov;
   msg.msg_iovlen = 1;
-  
+
   if ((n = recvmsg(listen->fd, &msg, 0)) == -1)
     return;
-  
-  if (n < (int)sizeof(struct dns_header) || 
-      (msg.msg_flags & MSG_TRUNC) ||
-      (header->hb3 & HB3_QR))
+
+  if (n < (int) sizeof(struct dns_header) ||
+      (msg.msg_flags & MSG_TRUNC) || (header->hb3 & HB3_QR))
     return;
 
   /* Clear buffer beyond request to avoid risk of
      information disclosure. */
   memset(daemon->packet + n, 0, daemon->edns_pktsz - n);
-  
+
   source_addr.sa.sa_family = listen->family;
-  
-  if (listen->family == AF_INET)
-    {
-       /* Source-port == 0 is an error, we can't send back to that. 
-	  http://www.ietf.org/mail-archive/web/dnsop/current/msg11441.html */
-      if (source_addr.in.sin_port == 0)
-	return;
-    }
-#ifdef HAVE_IPV6
-  else
-    {
-      /* Source-port == 0 is an error, we can't send back to that. */
-      if (source_addr.in6.sin6_port == 0)
-	return;
-      source_addr.in6.sin6_flowinfo = 0;
-    }
+
+  if (listen->family == AF_INET) {
+    /* Source-port == 0 is an error, we can't send back to that.
+       http://www.ietf.org/mail-archive/web/dnsop/current/msg11441.html */
+    if (source_addr.in.sin_port == 0)
+      return;
+  }
+#ifdef HAVE_IPV6
+  else {
+    /* Source-port == 0 is an error, we can't send back to that. */
+    if (source_addr.in6.sin6_port == 0)
+      return;
+    source_addr.in6.sin6_flowinfo = 0;
+  }
 #endif
-  
+
   /* We can be configured to only accept queries from at-most-one-hop-away addresses. */
-  if (option_bool(OPT_LOCAL_SERVICE))
-    {
-      struct addrlist *addr;
+  if (option_bool(OPT_LOCAL_SERVICE)) {
+    struct addrlist *addr;
 #ifdef HAVE_IPV6
-      if (listen->family == AF_INET6) 
-	{
-	  for (addr = daemon->interface_addrs; addr; addr = addr->next)
-	    if ((addr->flags & ADDRLIST_IPV6) &&
-		is_same_net6(&addr->addr.addr.addr6, &source_addr.in6.sin6_addr, addr->prefixlen))
-	      break;
-	}
-      else
-#endif
-	{
-	  struct in_addr netmask;
-	  for (addr = daemon->interface_addrs; addr; addr = addr->next)
-	    {
-	      netmask.s_addr = htonl(~(in_addr_t)0 << (32 - addr->prefixlen));
-	      if (!(addr->flags & ADDRLIST_IPV6) &&
-		  is_same_net(addr->addr.addr.addr4, source_addr.in.sin_addr, netmask))
-		break;
-	    }
-	}
-      if (!addr)
-	{
-	  static int warned = 0;
-	  if (!warned)
-	    {
-	      my_syslog(LOG_WARNING, _("Ignoring query from non-local network"));
-	      warned = 1;
-	    }
-	  return;
-	}
+    if (listen->family == AF_INET6) {
+      for (addr = daemon->interface_addrs; addr; addr = addr->next)
+        if ((addr->flags & ADDRLIST_IPV6) &&
+            is_same_net6(&addr->addr.addr.addr6, &source_addr.in6.sin6_addr,
+                         addr->prefixlen))
+          break;
+    } else
+#endif
+    {
+      struct in_addr netmask;
+      for (addr = daemon->interface_addrs; addr; addr = addr->next) {
+        netmask.s_addr = htonl(~(in_addr_t) 0 << (32 - addr->prefixlen));
+        if (!(addr->flags & ADDRLIST_IPV6) &&
+            is_same_net(addr->addr.addr.addr4, source_addr.in.sin_addr,
+                        netmask))
+          break;
+      }
     }
-		
-  if (check_dst)
-    {
-      struct ifreq ifr;
+    if (!addr) {
+      static int warned = 0;
+      if (!warned) {
+        my_syslog(LOG_WARNING, _("Ignoring query from non-local network"));
+        warned = 1;
+      }
+      return;
+    }
+  }
+
+  if (check_dst) {
+    struct ifreq ifr;
 
-      if (msg.msg_controllen < sizeof(struct cmsghdr))
-	return;
+    if (msg.msg_controllen < sizeof(struct cmsghdr))
+      return;
 
 #if defined(HAVE_LINUX_NETWORK)
-      if (listen->family == AF_INET)
-	for (cmptr = CMSG_FIRSTHDR(&msg); cmptr; cmptr = CMSG_NXTHDR(&msg, cmptr))
-	  if (cmptr->cmsg_level == IPPROTO_IP && cmptr->cmsg_type == IP_PKTINFO)
-	    {
-	      union {
-		unsigned char *c;
-		struct in_pktinfo *p;
-	      } p;
-	      p.c = CMSG_DATA(cmptr);
-	      dst_addr_4 = dst_addr.addr.addr4 = p.p->ipi_spec_dst;
-	      if_index = p.p->ipi_ifindex;
-	    }
+    if (listen->family == AF_INET)
+      for (cmptr = CMSG_FIRSTHDR(&msg); cmptr; cmptr = CMSG_NXTHDR(&msg, cmptr))
+        if (cmptr->cmsg_level == IPPROTO_IP && cmptr->cmsg_type == IP_PKTINFO) {
+          union {
+            unsigned char *c;
+            struct in_pktinfo *p;
+          } p;
+          p.c = CMSG_DATA(cmptr);
+          dst_addr_4 = dst_addr.addr.addr4 = p.p->ipi_spec_dst;
+          if_index = p.p->ipi_ifindex;
+        }
 #elif defined(IP_RECVDSTADDR) && defined(IP_RECVIF)
-      if (listen->family == AF_INET)
-	{
-	  for (cmptr = CMSG_FIRSTHDR(&msg); cmptr; cmptr = CMSG_NXTHDR(&msg, cmptr))
-	    {
-	      union {
-		unsigned char *c;
-		unsigned int *i;
-		struct in_addr *a;
+    if (listen->family == AF_INET) {
+      for (cmptr = CMSG_FIRSTHDR(&msg); cmptr; cmptr = CMSG_NXTHDR(&msg, cmptr)) {
+        union {
+          unsigned char *c;
+          unsigned int *i;
+          struct in_addr *a;
 #ifndef HAVE_SOLARIS_NETWORK
-		struct sockaddr_dl *s;
+          struct sockaddr_dl *s;
 #endif
-	      } p;
-	       p.c = CMSG_DATA(cmptr);
-	       if (cmptr->cmsg_level == IPPROTO_IP && cmptr->cmsg_type == IP_RECVDSTADDR)
-		 dst_addr_4 = dst_addr.addr.addr4 = *(p.a);
-	       else if (cmptr->cmsg_level == IPPROTO_IP && cmptr->cmsg_type == IP_RECVIF)
+        } p;
+        p.c = CMSG_DATA(cmptr);
+        if (cmptr->cmsg_level == IPPROTO_IP
+            && cmptr->cmsg_type == IP_RECVDSTADDR)
+          dst_addr_4 = dst_addr.addr.addr4 = *(p.a);
+        else if (cmptr->cmsg_level == IPPROTO_IP
+                 && cmptr->cmsg_type == IP_RECVIF)
 #ifdef HAVE_SOLARIS_NETWORK
-		 if_index = *(p.i);
+          if_index = *(p.i);
 #else
-  	         if_index = p.s->sdl_index;
+          if_index = p.s->sdl_index;
 #endif
-	    }
-	}
+      }
+    }
 #endif
-      
+
 #ifdef HAVE_IPV6
-      if (listen->family == AF_INET6)
-	{
-	  for (cmptr = CMSG_FIRSTHDR(&msg); cmptr; cmptr = CMSG_NXTHDR(&msg, cmptr))
-	    if (cmptr->cmsg_level == IPPROTO_IPV6 && cmptr->cmsg_type == daemon->v6pktinfo)
-	      {
-		union {
-		  unsigned char *c;
-		  struct in6_pktinfo *p;
-		} p;
-		p.c = CMSG_DATA(cmptr);
-		  
-		dst_addr.addr.addr6 = p.p->ipi6_addr;
-		if_index = p.p->ipi6_ifindex;
-	      }
-	}
-#endif
-      
-      /* enforce available interface configuration */
-      
-      if (!indextoname(listen->fd, if_index, ifr.ifr_name))
-	return;
-      
-      if (!iface_check(listen->family, &dst_addr, ifr.ifr_name, &auth_dns))
-	{
-	   if (!option_bool(OPT_CLEVERBIND))
-	     enumerate_interfaces(0); 
-	   if (!loopback_exception(listen->fd, listen->family, &dst_addr, ifr.ifr_name) &&
-	       !label_exception(if_index, listen->family, &dst_addr))
-	     return;
-	}
-
-      if (listen->family == AF_INET && option_bool(OPT_LOCALISE))
-	{
-	  struct irec *iface;
-	  
-	  /* get the netmask of the interface which has the address we were sent to.
-	     This is no necessarily the interface we arrived on. */
-	  
-	  for (iface = daemon->interfaces; iface; iface = iface->next)
-	    if (iface->addr.sa.sa_family == AF_INET &&
-		iface->addr.in.sin_addr.s_addr == dst_addr_4.s_addr)
-	      break;
-	  
-	  /* interface may be new */
-	  if (!iface && !option_bool(OPT_CLEVERBIND))
-	    enumerate_interfaces(0); 
-	  
-	  for (iface = daemon->interfaces; iface; iface = iface->next)
-	    if (iface->addr.sa.sa_family == AF_INET &&
-		iface->addr.in.sin_addr.s_addr == dst_addr_4.s_addr)
-	      break;
-	  
-	  /* If we failed, abandon localisation */
-	  if (iface)
-	    netmask = iface->netmask;
-	  else
-	    dst_addr_4.s_addr = 0;
-	}
+    if (listen->family == AF_INET6) {
+      for (cmptr = CMSG_FIRSTHDR(&msg); cmptr; cmptr = CMSG_NXTHDR(&msg, cmptr))
+        if (cmptr->cmsg_level == IPPROTO_IPV6
+            && cmptr->cmsg_type == daemon->v6pktinfo) {
+          union {
+            unsigned char *c;
+            struct in6_pktinfo *p;
+          } p;
+          p.c = CMSG_DATA(cmptr);
+
+          dst_addr.addr.addr6 = p.p->ipi6_addr;
+          if_index = p.p->ipi6_ifindex;
+        }
+    }
+#endif
+
+    /* enforce available interface configuration */
+
+    if (!indextoname(listen->fd, if_index, ifr.ifr_name))
+      return;
+
+    if (!iface_check(listen->family, &dst_addr, ifr.ifr_name, &auth_dns)) {
+      if (!option_bool(OPT_CLEVERBIND))
+        enumerate_interfaces(0);
+      if (!loopback_exception
+          (listen->fd, listen->family, &dst_addr, ifr.ifr_name)
+          && !label_exception(if_index, listen->family, &dst_addr))
+        return;
+    }
+
+    if (listen->family == AF_INET && option_bool(OPT_LOCALISE)) {
+      struct irec *iface;
+
+      /* get the netmask of the interface which has the address we were sent to.
+         This is no necessarily the interface we arrived on. */
+
+      for (iface = daemon->interfaces; iface; iface = iface->next)
+        if (iface->addr.sa.sa_family == AF_INET &&
+            iface->addr.in.sin_addr.s_addr == dst_addr_4.s_addr)
+          break;
+
+      /* interface may be new */
+      if (!iface && !option_bool(OPT_CLEVERBIND))
+        enumerate_interfaces(0);
+
+      for (iface = daemon->interfaces; iface; iface = iface->next)
+        if (iface->addr.sa.sa_family == AF_INET &&
+            iface->addr.in.sin_addr.s_addr == dst_addr_4.s_addr)
+          break;
+
+      /* If we failed, abandon localisation */
+      if (iface)
+        netmask = iface->netmask;
+      else
+        dst_addr_4.s_addr = 0;
     }
-   
+  }
+
   /* log_query gets called indirectly all over the place, so 
      pass these in global variables - sorry. */
   daemon->log_display_id = ++daemon->log_id;
   daemon->log_source_addr = &source_addr;
-  
-  if (extract_request(header, (size_t)n, daemon->namebuff, &type))
-    {
+
+  if (extract_request(header, (size_t) n, daemon->namebuff, &type)) {
 #ifdef HAVE_AUTH
-      struct auth_zone *zone;
+    struct auth_zone *zone;
 #endif
-      char *types = querystr(auth_dns ? "auth" : "query", type);
-      
-      if (listen->family == AF_INET) 
-	log_query(F_QUERY | F_IPV4 | F_FORWARD, daemon->namebuff, 
-		  (struct all_addr *)&source_addr.in.sin_addr, types);
+    char *types = querystr(auth_dns ? "auth" : "query", type);
+
+    if (listen->family == AF_INET)
+      log_query(F_QUERY | F_IPV4 | F_FORWARD, daemon->namebuff,
+                (struct all_addr *) &source_addr.in.sin_addr, types);
 #ifdef HAVE_IPV6
-      else
-	log_query(F_QUERY | F_IPV6 | F_FORWARD, daemon->namebuff, 
-		  (struct all_addr *)&source_addr.in6.sin6_addr, types);
+    else
+      log_query(F_QUERY | F_IPV6 | F_FORWARD, daemon->namebuff,
+                (struct all_addr *) &source_addr.in6.sin6_addr, types);
 #endif
 
 #ifdef HAVE_AUTH
-      /* find queries for zones we're authoritative for, and answer them directly */
-      if (!auth_dns && !option_bool(OPT_LOCALISE))
-	for (zone = daemon->auth_zones; zone; zone = zone->next)
-	  if (in_zone(zone, daemon->namebuff, NULL))
-	    {
-	      auth_dns = 1;
-	      local_auth = 1;
-	      break;
-	    }
+    /* find queries for zones we're authoritative for, and answer them directly */
+    if (!auth_dns && !option_bool(OPT_LOCALISE))
+      for (zone = daemon->auth_zones; zone; zone = zone->next)
+        if (in_zone(zone, daemon->namebuff, NULL)) {
+          auth_dns = 1;
+          local_auth = 1;
+          break;
+        }
 #endif
-      
-#ifdef HAVE_LOOP
-      /* Check for forwarding loop */
-      if (detect_loop(daemon->namebuff, type))
-	return;
-#endif
-    }
-  
-  if (find_pseudoheader(header, (size_t)n, NULL, &pheader, NULL, NULL))
-    { 
-      unsigned short flags;
-      
-      have_pseudoheader = 1;
-      GETSHORT(udp_size, pheader);
-      pheader += 2; /* ext_rcode */
-      GETSHORT(flags, pheader);
-      
-      if (flags & 0x8000)
-	do_bit = 1;/* do bit */ 
-	
-      /* If the client provides an EDNS0 UDP size, use that to limit our reply.
-	 (bounded by the maximum configured). If no EDNS0, then it
-	 defaults to 512 */
-      if (udp_size > daemon->edns_pktsz)
-	udp_size = daemon->edns_pktsz;
-      else if (udp_size < PACKETSZ)
-	udp_size = PACKETSZ; /* Sanity check - can't reduce below default. RFC 6891 6.2.3 */
-    }
 
+#ifdef HAVE_LOOP
+    /* Check for forwarding loop */
+    if (detect_loop(daemon->namebuff, type))
+      return;
+#endif
+  }
+
+  if (find_pseudoheader(header, (size_t) n, NULL, &pheader, NULL, NULL)) {
+    unsigned short flags;
+
+    have_pseudoheader = 1;
+    GETSHORT(udp_size, pheader);
+    pheader += 2;               /* ext_rcode */
+    GETSHORT(flags, pheader);
+
+    if (flags & 0x8000)
+      do_bit = 1;               /* do bit */
+
+    /* If the client provides an EDNS0 UDP size, use that to limit our reply.
+       (bounded by the maximum configured). If no EDNS0, then it
+       defaults to 512 */
+    if (udp_size > daemon->edns_pktsz)
+      udp_size = daemon->edns_pktsz;
+    else if (udp_size < PACKETSZ)
+      udp_size = PACKETSZ;      /* Sanity check - can't reduce below default. RFC 6891 6.2.3 */
+  }
 #ifdef HAVE_AUTH
-  if (auth_dns)
-    {
-      m = answer_auth(header, ((char *) header) + udp_size, (size_t)n, now, &source_addr, 
-		      local_auth, do_bit, have_pseudoheader);
-      if (m >= 1)
-	{
-	  send_from(listen->fd, option_bool(OPT_NOWILD) || option_bool(OPT_CLEVERBIND),
-		    (char *)header, m, &source_addr, &dst_addr, if_index);
-	  daemon->auth_answer++;
-	}
-    }
-  else
-#endif
-    {
-      int ad_reqd = do_bit;
-       /* RFC 6840 5.7 */
-      if (header->hb4 & HB4_AD)
-	ad_reqd = 1;
-
-      m = answer_request(header, ((char *) header) + udp_size, (size_t)n, 
-			 dst_addr_4, netmask, now, ad_reqd, do_bit, have_pseudoheader);
-      
-      if (m >= 1)
-	{
-	  send_from(listen->fd, option_bool(OPT_NOWILD) || option_bool(OPT_CLEVERBIND),
-		    (char *)header, m, &source_addr, &dst_addr, if_index);
-	  daemon->local_answer++;
-	}
-      else if (forward_query(listen->fd, &source_addr, &dst_addr, if_index,
-			     header, (size_t)n, now, NULL, ad_reqd, do_bit))
-	daemon->queries_forwarded++;
-      else
-	daemon->local_answer++;
-    }
+  if (auth_dns) {
+    m = answer_auth(header, ((char *) header) + udp_size, (size_t) n, now,
+                    &source_addr, local_auth, do_bit, have_pseudoheader);
+    if (m >= 1) {
+      send_from(listen->fd, option_bool(OPT_NOWILD)
+                || option_bool(OPT_CLEVERBIND), (char *) header, m,
+                &source_addr, &dst_addr, if_index);
+      daemon->auth_answer++;
+    }
+  } else
+#endif
+  {
+    int ad_reqd = do_bit;
+    /* RFC 6840 5.7 */
+    if (header->hb4 & HB4_AD)
+      ad_reqd = 1;
+
+    m = answer_request(header, ((char *) header) + udp_size, (size_t) n,
+                       dst_addr_4, netmask, now, ad_reqd, do_bit,
+                       have_pseudoheader);
+
+    if (m >= 1) {
+      send_from(listen->fd, option_bool(OPT_NOWILD)
+                || option_bool(OPT_CLEVERBIND), (char *) header, m,
+                &source_addr, &dst_addr, if_index);
+      daemon->local_answer++;
+    } else if (forward_query(listen->fd, &source_addr, &dst_addr, if_index,
+                             header, (size_t) n, now, NULL, ad_reqd, do_bit))
+      daemon->queries_forwarded++;
+    else
+      daemon->local_answer++;
+  }
 }
 
 #ifdef HAVE_DNSSEC
 /* Recurse up the key hierarchy */
-static int tcp_key_recurse(time_t now, int status, struct dns_header *header, size_t n, 
-			   int class, char *name, char *keyname, struct server *server, 
-			   int have_mark, unsigned int mark, int *keycount)
+static int tcp_key_recurse(time_t now, int status, struct dns_header *header,
+                           size_t n, int class, char *name, char *keyname,
+                           struct server *server, int have_mark,
+                           unsigned int mark, int *keycount)
 {
   int new_status;
   unsigned char *packet = NULL;
   unsigned char *payload = NULL;
   struct dns_header *new_header = NULL;
   u16 *length = NULL;
- 
-  while (1)
-    {
-      int type = SERV_DO_DNSSEC;
-      char *domain;
-      size_t m; 
-      unsigned char c1, c2;
-      struct server *firstsendto = NULL;
-      
-      /* limit the amount of work we do, to avoid cycling forever on loops in the DNS */
-      if (--(*keycount) == 0)
-	new_status = STAT_ABANDONED;
-      else if (status == STAT_NEED_KEY)
-	new_status = dnssec_validate_by_ds(now, header, n, name, keyname, class);
-      else if (status == STAT_NEED_DS)
-	new_status = dnssec_validate_ds(now, header, n, name, keyname, class);
-      else 
-	new_status = dnssec_validate_reply(now, header, n, name, keyname, &class,
-					   option_bool(OPT_DNSSEC_NO_SIGN) && (server->flags & SERV_DO_DNSSEC), NULL, NULL);
-      
-      if (new_status != STAT_NEED_DS && new_status != STAT_NEED_KEY)
-	break;
-
-      /* Can't validate because we need a key/DS whose name now in keyname.
-	 Make query for same, and recurse to validate */
-      if (!packet)
-	{
-	  packet = whine_malloc(65536 + MAXDNAME + RRFIXEDSZ + sizeof(u16));
-	  payload = &packet[2];
-	  new_header = (struct dns_header *)payload;
-	  length = (u16 *)packet;
-	}
-      
-      if (!packet)
-	{
-	  new_status = STAT_ABANDONED;
-	  break;
-	}
-	 
-      m = dnssec_generate_query(new_header, ((unsigned char *) new_header) + 65536, keyname, class, 
-				new_status == STAT_NEED_KEY ? T_DNSKEY : T_DS, &server->addr, server->edns_pktsz);
-      
-      *length = htons(m);
-
-      /* Find server to forward to. This will normally be the 
-	 same as for the original query, but may be another if
-	 servers for domains are involved. */		      
-      if (search_servers(now, NULL, F_DNSSECOK, keyname, &type, &domain, NULL) != 0)
-	{
-	  new_status = STAT_ABANDONED;
-	  break;
-	}
-	
-      while (1)
-	{
-	  if (!firstsendto)
-	    firstsendto = server;
-	  else
-	    {
-	      if (!(server = server->next))
-		server = daemon->servers;
-	      if (server == firstsendto)
-		{
-		  /* can't find server to accept our query. */
-		  new_status = STAT_ABANDONED;
-		  break;
-		}
-	    }
-	  
-	  if (type != (server->flags & (SERV_TYPE | SERV_DO_DNSSEC)) ||
-	      (type == SERV_HAS_DOMAIN && !hostname_isequal(domain, server->domain)) ||
-	      (server->flags & (SERV_LITERAL_ADDRESS | SERV_LOOP)))
-	    continue;
-	    
-	  retry:
-	    /* may need to make new connection. */
-	    if (server->tcpfd == -1)
-	      {
-		if ((server->tcpfd = socket(server->addr.sa.sa_family, SOCK_STREAM, 0)) == -1)
-		  continue; /* No good, next server */
-		
+
+  while (1) {
+    int type = SERV_DO_DNSSEC;
+    char *domain;
+    size_t m;
+    unsigned char c1, c2;
+    struct server *firstsendto = NULL;
+
+    /* limit the amount of work we do, to avoid cycling forever on loops in the DNS */
+    if (--(*keycount) == 0)
+      new_status = STAT_ABANDONED;
+    else if (status == STAT_NEED_KEY)
+      new_status = dnssec_validate_by_ds(now, header, n, name, keyname, class);
+    else if (status == STAT_NEED_DS)
+      new_status = dnssec_validate_ds(now, header, n, name, keyname, class);
+    else
+      new_status = dnssec_validate_reply(now, header, n, name, keyname, &class,
+                                         option_bool(OPT_DNSSEC_NO_SIGN)
+                                         && (server->flags & SERV_DO_DNSSEC),
+                                         NULL, NULL);
+
+    if (new_status != STAT_NEED_DS && new_status != STAT_NEED_KEY)
+      break;
+
+    /* Can't validate because we need a key/DS whose name now in keyname.
+       Make query for same, and recurse to validate */
+    if (!packet) {
+      packet = whine_malloc(65536 + MAXDNAME + RRFIXEDSZ + sizeof(u16));
+      payload = &packet[2];
+      new_header = (struct dns_header *) payload;
+      length = (u16 *) packet;
+    }
+
+    if (!packet) {
+      new_status = STAT_ABANDONED;
+      break;
+    }
+
+    m = dnssec_generate_query(new_header,
+                              ((unsigned char *) new_header) + 65536, keyname,
+                              class,
+                              new_status == STAT_NEED_KEY ? T_DNSKEY : T_DS,
+                              &server->addr, server->edns_pktsz);
+
+    *length = htons(m);
+
+    /* Find server to forward to. This will normally be the
+       same as for the original query, but may be another if
+       servers for domains are involved. */
+    if (search_servers(now, NULL, F_DNSSECOK, keyname, &type, &domain, NULL) !=
+        0) {
+      new_status = STAT_ABANDONED;
+      break;
+    }
+
+    while (1) {
+      if (!firstsendto)
+        firstsendto = server;
+      else {
+        if (!(server = server->next))
+          server = daemon->servers;
+        if (server == firstsendto) {
+          /* can't find server to accept our query. */
+          new_status = STAT_ABANDONED;
+          break;
+        }
+      }
+
+      if (type != (server->flags & (SERV_TYPE | SERV_DO_DNSSEC)) ||
+          (type == SERV_HAS_DOMAIN && !hostname_isequal(domain, server->domain))
+          || (server->flags & (SERV_LITERAL_ADDRESS | SERV_LOOP)))
+        continue;
+
+    retry:
+      /* may need to make new connection. */
+      if (server->tcpfd == -1) {
+        if ((server->tcpfd =
+             socket(server->addr.sa.sa_family, SOCK_STREAM, 0)) == -1)
+          continue;             /* No good, next server */
+
 #ifdef HAVE_CONNTRACK
-		/* Copy connection mark of incoming query to outgoing connection. */
-		if (have_mark)
-		  setsockopt(server->tcpfd, SOL_SOCKET, SO_MARK, &mark, sizeof(unsigned int));
-#endif	
-		
-		if (!local_bind(server->tcpfd,  &server->source_addr, server->interface, 1) ||
-		    connect(server->tcpfd, &server->addr.sa, sa_len(&server->addr)) == -1)
-		  {
-		    close(server->tcpfd);
-		    server->tcpfd = -1;
-		    continue; /* No good, next server */
-		  }
-		
-		server->flags &= ~SERV_GOT_TCP;
-	      }
-	  
-	  if (!read_write(server->tcpfd, packet, m + sizeof(u16), 0) ||
-	      !read_write(server->tcpfd, &c1, 1, 1) ||
-	      !read_write(server->tcpfd, &c2, 1, 1) ||
-	      !read_write(server->tcpfd, payload, (c1 << 8) | c2, 1))
-	    {
-	      close(server->tcpfd);
-	      server->tcpfd = -1;
-	      /* We get data then EOF, reopen connection to same server,
-		 else try next. This avoids DoS from a server which accepts
-		 connections and then closes them. */
-	      if (server->flags & SERV_GOT_TCP)
-		goto retry;
-	      else
-		continue;
-	    }
-	  
-	  server->flags |= SERV_GOT_TCP;
-	  
-	  m = (c1 << 8) | c2;
-	  new_status = tcp_key_recurse(now, new_status, new_header, m, class, name, keyname, server, have_mark, mark, keycount);
-	  break;
-	}
-      
-      if (new_status != STAT_OK)
-	break;
+        /* Copy connection mark of incoming query to outgoing connection. */
+        if (have_mark)
+          setsockopt(server->tcpfd, SOL_SOCKET, SO_MARK, &mark,
+                     sizeof(unsigned int));
+#endif
+
+        if (!local_bind
+            (server->tcpfd, &server->source_addr, server->interface, 1)
+            || connect(server->tcpfd, &server->addr.sa,
+                       sa_len(&server->addr)) == -1) {
+          close(server->tcpfd);
+          server->tcpfd = -1;
+          continue;             /* No good, next server */
+        }
+
+        server->flags &= ~SERV_GOT_TCP;
+      }
+
+      if (!read_write(server->tcpfd, packet, m + sizeof(u16), 0) ||
+          !read_write(server->tcpfd, &c1, 1, 1) ||
+          !read_write(server->tcpfd, &c2, 1, 1) ||
+          !read_write(server->tcpfd, payload, (c1 << 8) | c2, 1)) {
+        close(server->tcpfd);
+        server->tcpfd = -1;
+        /* We get data then EOF, reopen connection to same server,
+           else try next. This avoids DoS from a server which accepts
+           connections and then closes them. */
+        if (server->flags & SERV_GOT_TCP)
+          goto retry;
+        else
+          continue;
+      }
+
+      server->flags |= SERV_GOT_TCP;
+
+      m = (c1 << 8) | c2;
+      new_status =
+          tcp_key_recurse(now, new_status, new_header, m, class, name, keyname,
+                          server, have_mark, mark, keycount);
+      break;
     }
-    
+
+    if (new_status != STAT_OK)
+      break;
+  }
+
   if (packet)
     free(packet);
-    
+
   return new_status;
 }
 #endif
@@ -1602,7 +1562,8 @@
    about resources for debug mode, when the fork is suppressed: that's
    done by the caller. */
 unsigned char *tcp_request(int confd, time_t now,
-			   union mysockaddr *local_addr, struct in_addr netmask, int auth_dns)
+                           union mysockaddr *local_addr, struct in_addr netmask,
+                           int auth_dns)
 {
   size_t size = 0;
   int norebind = 0;
@@ -1616,11 +1577,12 @@
   unsigned int gotname;
   unsigned char c1, c2;
   /* Max TCP packet + slop + size */
-  unsigned char *packet = whine_malloc(65536 + MAXDNAME + RRFIXEDSZ + sizeof(u16));
+  unsigned char *packet =
+      whine_malloc(65536 + MAXDNAME + RRFIXEDSZ + sizeof(u16));
   unsigned char *payload = &packet[2];
   /* largest field in header is 16-bits, so this is still sufficiently aligned */
-  struct dns_header *header = (struct dns_header *)payload;
-  u16 *length = (u16 *)packet;
+  struct dns_header *header = (struct dns_header *) payload;
+  u16 *length = (u16 *) packet;
   struct server *last_server;
   struct in_addr dst_addr_4;
   union mysockaddr peer_addr;
@@ -1630,390 +1592,398 @@
   unsigned int mark = 0;
   int have_mark = 0;
 
-  (void)mark;
-  (void)have_mark;
+  (void) mark;
+  (void) have_mark;
 
-  if (getpeername(confd, (struct sockaddr *)&peer_addr, &peer_len) == -1)
+  if (getpeername(confd, (struct sockaddr *) &peer_addr, &peer_len) == -1)
     return packet;
 
 #ifdef HAVE_CONNTRACK
   /* Get connection mark of incoming query to set on outgoing connections. */
-  if (option_bool(OPT_CONNTRACK))
-    {
-      struct all_addr local;
-#ifdef HAVE_IPV6		      
-      if (local_addr->sa.sa_family == AF_INET6)
-	local.addr.addr6 = local_addr->in6.sin6_addr;
-      else
+  if (option_bool(OPT_CONNTRACK)) {
+    struct all_addr local;
+#ifdef HAVE_IPV6
+    if (local_addr->sa.sa_family == AF_INET6)
+      local.addr.addr6 = local_addr->in6.sin6_addr;
+    else
+#endif
+      local.addr.addr4 = local_addr->in.sin_addr;
+
+    have_mark = get_incoming_mark(&peer_addr, &local, 1, &mark);
+  }
 #endif
-	local.addr.addr4 = local_addr->in.sin_addr;
-      
-      have_mark = get_incoming_mark(&peer_addr, &local, 1, &mark);
-    }
-#endif	
 
   /* We can be configured to only accept queries from at-most-one-hop-away addresses. */
-  if (option_bool(OPT_LOCAL_SERVICE))
-    {
-      struct addrlist *addr;
+  if (option_bool(OPT_LOCAL_SERVICE)) {
+    struct addrlist *addr;
 #ifdef HAVE_IPV6
-      if (peer_addr.sa.sa_family == AF_INET6) 
-	{
-	  for (addr = daemon->interface_addrs; addr; addr = addr->next)
-	    if ((addr->flags & ADDRLIST_IPV6) &&
-		is_same_net6(&addr->addr.addr.addr6, &peer_addr.in6.sin6_addr, addr->prefixlen))
-	      break;
-	}
-      else
-#endif
-	{
-	  struct in_addr netmask;
-	  for (addr = daemon->interface_addrs; addr; addr = addr->next)
-	    {
-	      netmask.s_addr = htonl(~(in_addr_t)0 << (32 - addr->prefixlen));
-	      if (!(addr->flags & ADDRLIST_IPV6) && 
-		  is_same_net(addr->addr.addr.addr4, peer_addr.in.sin_addr, netmask))
-		break;
-	    }
-	}
-      if (!addr)
-	{
-	  my_syslog(LOG_WARNING, _("Ignoring query from non-local network"));
-	  return packet;
-	}
+    if (peer_addr.sa.sa_family == AF_INET6) {
+      for (addr = daemon->interface_addrs; addr; addr = addr->next)
+        if ((addr->flags & ADDRLIST_IPV6) &&
+            is_same_net6(&addr->addr.addr.addr6, &peer_addr.in6.sin6_addr,
+                         addr->prefixlen))
+          break;
+    } else
+#endif
+    {
+      struct in_addr netmask;
+      for (addr = daemon->interface_addrs; addr; addr = addr->next) {
+        netmask.s_addr = htonl(~(in_addr_t) 0 << (32 - addr->prefixlen));
+        if (!(addr->flags & ADDRLIST_IPV6) &&
+            is_same_net(addr->addr.addr.addr4, peer_addr.in.sin_addr, netmask))
+          break;
+      }
     }
+    if (!addr) {
+      my_syslog(LOG_WARNING, _("Ignoring query from non-local network"));
+      return packet;
+    }
+  }
+
+  while (1) {
+    if (query_count == TCP_MAX_QUERIES ||
+        !packet ||
+        !read_write(confd, &c1, 1, 1) || !read_write(confd, &c2, 1, 1) ||
+        !(size = c1 << 8 | c2) || !read_write(confd, payload, size, 1))
+      return packet;
 
-  while (1)
-    {
-      if (query_count == TCP_MAX_QUERIES ||
-	  !packet ||
-	  !read_write(confd, &c1, 1, 1) || !read_write(confd, &c2, 1, 1) ||
-	  !(size = c1 << 8 | c2) ||
-	  !read_write(confd, payload, size, 1))
-       	return packet; 
-  
-      if (size < (int)sizeof(struct dns_header))
-	continue;
-
-      /* Clear buffer beyond request to avoid risk of
-	 information disclosure. */
-      memset(payload + size, 0, 65536 - size);
-      
-      query_count++;
-
-      /* log_query gets called indirectly all over the place, so 
-	 pass these in global variables - sorry. */
-      daemon->log_display_id = ++daemon->log_id;
-      daemon->log_source_addr = &peer_addr;
-      
-      /* save state of "cd" flag in query */
-      if ((checking_disabled = header->hb4 & HB4_CD))
-	no_cache_dnssec = 1;
-       
-      if ((gotname = extract_request(header, (unsigned int)size, daemon->namebuff, &qtype)))
-	{
+    if (size < (int) sizeof(struct dns_header))
+      continue;
+
+    /* Clear buffer beyond request to avoid risk of
+       information disclosure. */
+    memset(payload + size, 0, 65536 - size);
+
+    query_count++;
+
+    /* log_query gets called indirectly all over the place, so
+       pass these in global variables - sorry. */
+    daemon->log_display_id = ++daemon->log_id;
+    daemon->log_source_addr = &peer_addr;
+
+    /* save state of "cd" flag in query */
+    if ((checking_disabled = header->hb4 & HB4_CD))
+      no_cache_dnssec = 1;
+
+    if ((gotname =
+         extract_request(header, (unsigned int) size, daemon->namebuff,
+                         &qtype))) {
 #ifdef HAVE_AUTH
-	  struct auth_zone *zone;
+      struct auth_zone *zone;
 #endif
-	  char *types = querystr(auth_dns ? "auth" : "query", qtype);
-	  
-	  if (peer_addr.sa.sa_family == AF_INET) 
-	    log_query(F_QUERY | F_IPV4 | F_FORWARD, daemon->namebuff, 
-		      (struct all_addr *)&peer_addr.in.sin_addr, types);
-#ifdef HAVE_IPV6
-	  else
-	    log_query(F_QUERY | F_IPV6 | F_FORWARD, daemon->namebuff, 
-		      (struct all_addr *)&peer_addr.in6.sin6_addr, types);
+      char *types = querystr(auth_dns ? "auth" : "query", qtype);
+
+      if (peer_addr.sa.sa_family == AF_INET)
+        log_query(F_QUERY | F_IPV4 | F_FORWARD, daemon->namebuff,
+                  (struct all_addr *) &peer_addr.in.sin_addr, types);
+#ifdef HAVE_IPV6
+      else
+        log_query(F_QUERY | F_IPV6 | F_FORWARD, daemon->namebuff,
+                  (struct all_addr *) &peer_addr.in6.sin6_addr, types);
 #endif
-	  
+
 #ifdef HAVE_AUTH
-	  /* find queries for zones we're authoritative for, and answer them directly */
-	  if (!auth_dns && !option_bool(OPT_LOCALISE))
-	    for (zone = daemon->auth_zones; zone; zone = zone->next)
-	      if (in_zone(zone, daemon->namebuff, NULL))
-		{
-		  auth_dns = 1;
-		  local_auth = 1;
-		  break;
-		}
-#endif
-	}
-      
-      if (local_addr->sa.sa_family == AF_INET)
-	dst_addr_4 = local_addr->in.sin_addr;
-      else
-	dst_addr_4.s_addr = 0;
-      
-      do_bit = 0;
-
-      if (find_pseudoheader(header, (size_t)size, NULL, &pheader, NULL, NULL))
-	{ 
-	  unsigned short flags;
-	  
-	  have_pseudoheader = 1;
-	  pheader += 4; /* udp_size, ext_rcode */
-	  GETSHORT(flags, pheader);
-      
-	  if (flags & 0x8000)
-	    do_bit = 1; /* do bit */ 
-	}
+      /* find queries for zones we're authoritative for, and answer them directly */
+      if (!auth_dns && !option_bool(OPT_LOCALISE))
+        for (zone = daemon->auth_zones; zone; zone = zone->next)
+          if (in_zone(zone, daemon->namebuff, NULL)) {
+            auth_dns = 1;
+            local_auth = 1;
+            break;
+          }
+#endif
+    }
+
+    if (local_addr->sa.sa_family == AF_INET)
+      dst_addr_4 = local_addr->in.sin_addr;
+    else
+      dst_addr_4.s_addr = 0;
 
+    do_bit = 0;
+
+    if (find_pseudoheader(header, (size_t) size, NULL, &pheader, NULL, NULL)) {
+      unsigned short flags;
+
+      have_pseudoheader = 1;
+      pheader += 4;             /* udp_size, ext_rcode */
+      GETSHORT(flags, pheader);
+
+      if (flags & 0x8000)
+        do_bit = 1;             /* do bit */
+    }
 #ifdef HAVE_AUTH
-      if (auth_dns)
-	m = answer_auth(header, ((char *) header) + 65536, (size_t)size, now, &peer_addr, 
-			local_auth, do_bit, have_pseudoheader);
-      else
+    if (auth_dns)
+      m = answer_auth(header, ((char *) header) + 65536, (size_t) size, now,
+                      &peer_addr, local_auth, do_bit, have_pseudoheader);
+    else
 #endif
-	{
-	   int ad_reqd = do_bit;
-	   /* RFC 6840 5.7 */
-	   if (header->hb4 & HB4_AD)
-	     ad_reqd = 1;
-	   
-	   /* m > 0 if answered from cache */
-	   m = answer_request(header, ((char *) header) + 65536, (size_t)size, 
-			      dst_addr_4, netmask, now, ad_reqd, do_bit, have_pseudoheader);
-	  
-	  /* Do this by steam now we're not in the select() loop */
-	  check_log_writer(1); 
-	  
-	  if (m == 0)
-	    {
-	      unsigned int flags = 0;
-	      struct all_addr *addrp = NULL;
-	      int type = SERV_DO_DNSSEC;
-	      char *domain = NULL;
-	      size_t new_size = add_edns0_config(header, size, ((unsigned char *) header) + 65536, &peer_addr, now, &check_subnet);
-
-	      if (size != new_size)
-		{
-		  added_pheader = 1;
-		  size = new_size;
-		}
-	      
-	      if (gotname)
-		flags = search_servers(now, &addrp, gotname, daemon->namebuff, &type, &domain, &norebind);
-	      
-	      type &= ~SERV_DO_DNSSEC;
-	      
-	      if (type != 0  || option_bool(OPT_ORDER) || !daemon->last_server)
-		last_server = daemon->servers;
-	      else
-		last_server = daemon->last_server;
-	      
-	      if (!flags && last_server)
-		{
-		  struct server *firstsendto = NULL;
+    {
+      int ad_reqd = do_bit;
+      /* RFC 6840 5.7 */
+      if (header->hb4 & HB4_AD)
+        ad_reqd = 1;
+
+      /* m > 0 if answered from cache */
+      m = answer_request(header, ((char *) header) + 65536, (size_t) size,
+                         dst_addr_4, netmask, now, ad_reqd, do_bit,
+                         have_pseudoheader);
+
+      /* Do this by steam now we're not in the select() loop */
+      check_log_writer(1);
+
+      if (m == 0) {
+        unsigned int flags = 0;
+        struct all_addr *addrp = NULL;
+        int type = SERV_DO_DNSSEC;
+        char *domain = NULL;
+        size_t new_size =
+            add_edns0_config(header, size, ((unsigned char *) header) + 65536,
+                             &peer_addr, now, &check_subnet);
+
+        if (size != new_size) {
+          added_pheader = 1;
+          size = new_size;
+        }
+
+        if (gotname)
+          flags =
+              search_servers(now, &addrp, gotname, daemon->namebuff, &type,
+                             &domain, &norebind);
+
+        type &= ~SERV_DO_DNSSEC;
+
+        if (type != 0 || option_bool(OPT_ORDER) || !daemon->last_server)
+          last_server = daemon->servers;
+        else
+          last_server = daemon->last_server;
+
+        if (!flags && last_server) {
+          struct server *firstsendto = NULL;
 #ifdef HAVE_DNSSEC
-		  unsigned char *newhash, hash[HASH_SIZE];
-		  if ((newhash = hash_questions(header, (unsigned int)size, daemon->namebuff)))
-		    memcpy(hash, newhash, HASH_SIZE);
-		  else
-		    memset(hash, 0, HASH_SIZE);
+          unsigned char *newhash, hash[HASH_SIZE];
+          if ((newhash =
+               hash_questions(header, (unsigned int) size, daemon->namebuff)))
+            memcpy(hash, newhash, HASH_SIZE);
+          else
+            memset(hash, 0, HASH_SIZE);
 #else
-		  unsigned int crc = questions_crc(header, (unsigned int)size, daemon->namebuff);
-#endif		  
-		  /* Loop round available servers until we succeed in connecting to one.
-		     Note that this code subtly ensures that consecutive queries on this connection
-		     which can go to the same server, do so. */
-		  while (1) 
-		    {
-		      if (!firstsendto)
-			firstsendto = last_server;
-		      else
-			{
-			  if (!(last_server = last_server->next))
-			    last_server = daemon->servers;
-			  
-			  if (last_server == firstsendto)
-			    break;
-			}
-		      
-		      /* server for wrong domain */
-		      if (type != (last_server->flags & SERV_TYPE) ||
-			  (type == SERV_HAS_DOMAIN && !hostname_isequal(domain, last_server->domain)) ||
-			  (last_server->flags & (SERV_LITERAL_ADDRESS | SERV_LOOP)))
-			continue;
-
-		    retry:
-		      if (last_server->tcpfd == -1)
-			{
-			  if ((last_server->tcpfd = socket(last_server->addr.sa.sa_family, SOCK_STREAM, 0)) == -1)
-			    continue;
-			  
+          unsigned int crc =
+              questions_crc(header, (unsigned int) size, daemon->namebuff);
+#endif
+          /* Loop round available servers until we succeed in connecting to one.
+             Note that this code subtly ensures that consecutive queries on this connection
+             which can go to the same server, do so. */
+          while (1) {
+            if (!firstsendto)
+              firstsendto = last_server;
+            else {
+              if (!(last_server = last_server->next))
+                last_server = daemon->servers;
+
+              if (last_server == firstsendto)
+                break;
+            }
+
+            /* server for wrong domain */
+            if (type != (last_server->flags & SERV_TYPE) ||
+                (type == SERV_HAS_DOMAIN
+                 && !hostname_isequal(domain, last_server->domain))
+                || (last_server->flags & (SERV_LITERAL_ADDRESS | SERV_LOOP)))
+              continue;
+
+          retry:
+            if (last_server->tcpfd == -1) {
+              if ((last_server->tcpfd =
+                   socket(last_server->addr.sa.sa_family, SOCK_STREAM,
+                          0)) == -1)
+                continue;
+
 #ifdef HAVE_CONNTRACK
-			  /* Copy connection mark of incoming query to outgoing connection. */
-			  if (have_mark)
-			    setsockopt(last_server->tcpfd, SOL_SOCKET, SO_MARK, &mark, sizeof(unsigned int));
-#endif	
-		      
-			  if ((!local_bind(last_server->tcpfd,  &last_server->source_addr, last_server->interface, 1) ||
-			       connect(last_server->tcpfd, &last_server->addr.sa, sa_len(&last_server->addr)) == -1))
-			    {
-			      close(last_server->tcpfd);
-			      last_server->tcpfd = -1;
-			      continue;
-			    }
-			  
-			  last_server->flags &= ~SERV_GOT_TCP;
-			}
-		      
+              /* Copy connection mark of incoming query to outgoing connection. */
+              if (have_mark)
+                setsockopt(last_server->tcpfd, SOL_SOCKET, SO_MARK, &mark,
+                           sizeof(unsigned int));
+#endif
+
+              if ((!local_bind
+                   (last_server->tcpfd, &last_server->source_addr,
+                    last_server->interface, 1)
+                   || connect(last_server->tcpfd, &last_server->addr.sa,
+                              sa_len(&last_server->addr)) == -1)) {
+                close(last_server->tcpfd);
+                last_server->tcpfd = -1;
+                continue;
+              }
+
+              last_server->flags &= ~SERV_GOT_TCP;
+            }
 #ifdef HAVE_DNSSEC
-		      if (option_bool(OPT_DNSSEC_VALID) && (last_server->flags & SERV_DO_DNSSEC))
-			{
-			  new_size = add_do_bit(header, size, ((unsigned char *) header) + 65536);
-			  
-			  if (size != new_size)
-			    {
-			      added_pheader = 1;
-			      size = new_size;
-			    }
-			  
-			  /* For debugging, set Checking Disabled, otherwise, have the upstream check too,
-			     this allows it to select auth servers when one is returning bad data. */
-			  if (option_bool(OPT_DNSSEC_DEBUG))
-			    header->hb4 |= HB4_CD;
-			}
-#endif
-					      
-		      *length = htons(size);
-
-		      /* get query name again for logging - may have been overwritten */
-		      if (!(gotname = extract_request(header, (unsigned int)size, daemon->namebuff, &qtype)))
-			strcpy(daemon->namebuff, "query");
-		      
-		      if (!read_write(last_server->tcpfd, packet, size + sizeof(u16), 0) ||
-			  !read_write(last_server->tcpfd, &c1, 1, 1) ||
-			  !read_write(last_server->tcpfd, &c2, 1, 1) ||
-			  !read_write(last_server->tcpfd, payload, (c1 << 8) | c2, 1))
-			{
-			  close(last_server->tcpfd);
-			  last_server->tcpfd = -1;
-			  /* We get data then EOF, reopen connection to same server,
-			     else try next. This avoids DoS from a server which accepts
-			     connections and then closes them. */
-			  if (last_server->flags & SERV_GOT_TCP)
-			    goto retry;
-			  else
-			    continue;
-			}
-		      
-		      last_server->flags |= SERV_GOT_TCP;
-
-		      m = (c1 << 8) | c2;
-		      
-		      if (last_server->addr.sa.sa_family == AF_INET)
-			log_query(F_SERVER | F_IPV4 | F_FORWARD, daemon->namebuff, 
-				  (struct all_addr *)&last_server->addr.in.sin_addr, NULL); 
-#ifdef HAVE_IPV6
-		      else
-			log_query(F_SERVER | F_IPV6 | F_FORWARD, daemon->namebuff, 
-				  (struct all_addr *)&last_server->addr.in6.sin6_addr, NULL);
-#endif 
+            if (option_bool(OPT_DNSSEC_VALID)
+                && (last_server->flags & SERV_DO_DNSSEC)) {
+              new_size =
+                  add_do_bit(header, size, ((unsigned char *) header) + 65536);
+
+              if (size != new_size) {
+                added_pheader = 1;
+                size = new_size;
+              }
+
+              /* For debugging, set Checking Disabled, otherwise, have the upstream check too,
+                 this allows it to select auth servers when one is returning bad data. */
+              if (option_bool(OPT_DNSSEC_DEBUG))
+                header->hb4 |= HB4_CD;
+            }
+#endif
+
+            *length = htons(size);
+
+            /* get query name again for logging - may have been overwritten */
+            if (!
+                (gotname =
+                 extract_request(header, (unsigned int) size, daemon->namebuff,
+                                 &qtype)))
+              strcpy(daemon->namebuff, "query");
+
+            if (!read_write(last_server->tcpfd, packet, size + sizeof(u16), 0)
+                || !read_write(last_server->tcpfd, &c1, 1, 1)
+                || !read_write(last_server->tcpfd, &c2, 1, 1)
+                || !read_write(last_server->tcpfd, payload, (c1 << 8) | c2,
+                               1)) {
+              close(last_server->tcpfd);
+              last_server->tcpfd = -1;
+              /* We get data then EOF, reopen connection to same server,
+                 else try next. This avoids DoS from a server which accepts
+                 connections and then closes them. */
+              if (last_server->flags & SERV_GOT_TCP)
+                goto retry;
+              else
+                continue;
+            }
+
+            last_server->flags |= SERV_GOT_TCP;
+
+            m = (c1 << 8) | c2;
+
+            if (last_server->addr.sa.sa_family == AF_INET)
+              log_query(F_SERVER | F_IPV4 | F_FORWARD, daemon->namebuff,
+                        (struct all_addr *) &last_server->addr.in.sin_addr,
+                        NULL);
+#ifdef HAVE_IPV6
+            else
+              log_query(F_SERVER | F_IPV6 | F_FORWARD, daemon->namebuff,
+                        (struct all_addr *) &last_server->addr.in6.sin6_addr,
+                        NULL);
+#endif
 
 #ifdef HAVE_DNSSEC
-		      if (option_bool(OPT_DNSSEC_VALID) && !checking_disabled && (last_server->flags & SERV_DO_DNSSEC))
-			{
-			  int keycount = DNSSEC_WORK; /* Limit to number of DNSSEC questions, to catch loops and avoid filling cache. */
-			  int status = tcp_key_recurse(now, STAT_OK, header, m, 0, daemon->namebuff, daemon->keyname, 
-						       last_server, have_mark, mark, &keycount);
-			  char *result, *domain = "result";
-			  
-			  if (status == STAT_ABANDONED)
-			    {
-			      result = "ABANDONED";
-			      status = STAT_BOGUS;
-			    }
-			  else
-			    result = (status == STAT_SECURE ? "SECURE" : (status == STAT_INSECURE ? "INSECURE" : "BOGUS"));
-			  
-			  if (status == STAT_BOGUS && extract_request(header, m, daemon->namebuff, NULL))
-			    domain = daemon->namebuff;
-
-			  log_query(F_KEYTAG | F_SECSTAT, domain, NULL, result);
-			  
-			  if (status == STAT_BOGUS)
-			    {
-			      no_cache_dnssec = 1;
-			      bogusanswer = 1;
-			    }
-
-			  if (status == STAT_SECURE)
-			    cache_secure = 1;
-			}
-#endif
-
-		      /* restore CD bit to the value in the query */
-		      if (checking_disabled)
-			header->hb4 |= HB4_CD;
-		      else
-			header->hb4 &= ~HB4_CD;
-		      
-		      /* There's no point in updating the cache, since this process will exit and
-			 lose the information after a few queries. We make this call for the alias and 
-			 bogus-nxdomain side-effects. */
-		      /* If the crc of the question section doesn't match the crc we sent, then
-			 someone might be attempting to insert bogus values into the cache by 
-			 sending replies containing questions and bogus answers. */
+            if (option_bool(OPT_DNSSEC_VALID) && !checking_disabled
+                && (last_server->flags & SERV_DO_DNSSEC)) {
+              int keycount = DNSSEC_WORK;       /* Limit to number of DNSSEC questions, to catch loops and avoid filling cache. */
+              int status =
+                  tcp_key_recurse(now, STAT_OK, header, m, 0, daemon->namebuff,
+                                  daemon->keyname,
+                                  last_server, have_mark, mark, &keycount);
+              char *result, *domain = "result";
+
+              if (status == STAT_ABANDONED) {
+                result = "ABANDONED";
+                status = STAT_BOGUS;
+              } else
+                result =
+                    (status ==
+                     STAT_SECURE ? "SECURE" : (status ==
+                                               STAT_INSECURE ? "INSECURE" :
+                                               "BOGUS"));
+
+              if (status == STAT_BOGUS
+                  && extract_request(header, m, daemon->namebuff, NULL))
+                domain = daemon->namebuff;
+
+              log_query(F_KEYTAG | F_SECSTAT, domain, NULL, result);
+
+              if (status == STAT_BOGUS) {
+                no_cache_dnssec = 1;
+                bogusanswer = 1;
+              }
+
+              if (status == STAT_SECURE)
+                cache_secure = 1;
+            }
+#endif
+
+            /* restore CD bit to the value in the query */
+            if (checking_disabled)
+              header->hb4 |= HB4_CD;
+            else
+              header->hb4 &= ~HB4_CD;
+
+            /* There's no point in updating the cache, since this process will exit and
+               lose the information after a few queries. We make this call for the alias and
+               bogus-nxdomain side-effects. */
+            /* If the crc of the question section doesn't match the crc we sent, then
+               someone might be attempting to insert bogus values into the cache by
+               sending replies containing questions and bogus answers. */
 #ifdef HAVE_DNSSEC
-		      newhash = hash_questions(header, (unsigned int)m, daemon->namebuff);
-		      if (!newhash || memcmp(hash, newhash, HASH_SIZE) != 0)
-			{ 
-			  m = 0;
-			  break;
-			}
-#else			  
-		      if (crc != questions_crc(header, (unsigned int)m, daemon->namebuff))
-			{
-			  m = 0;
-			  break;
-			}
-#endif
-
-		      m = process_reply(header, now, last_server, (unsigned int)m, 
-					option_bool(OPT_NO_REBIND) && !norebind, no_cache_dnssec, cache_secure, bogusanswer,
-					ad_reqd, do_bit, added_pheader, check_subnet, &peer_addr); 
-		      
-		      break;
-		    }
-		}
-	
-	      /* In case of local answer or no connections made. */
-	      if (m == 0)
-		m = setup_reply(header, (unsigned int)size, addrp, flags, daemon->local_ttl);
-	    }
-	}
-	  
-      check_log_writer(1);
-      
-      *length = htons(m);
-           
-      if (m == 0 || !read_write(confd, packet, m + sizeof(u16), 0))
-	return packet;
+            newhash =
+                hash_questions(header, (unsigned int) m, daemon->namebuff);
+            if (!newhash || memcmp(hash, newhash, HASH_SIZE) != 0) {
+              m = 0;
+              break;
+            }
+#else
+            if (crc !=
+                questions_crc(header, (unsigned int) m, daemon->namebuff)) {
+              m = 0;
+              break;
+            }
+#endif
+
+            m = process_reply(header, now, last_server, (unsigned int) m,
+                              option_bool(OPT_NO_REBIND)
+                              && !norebind, no_cache_dnssec, cache_secure,
+                              bogusanswer, ad_reqd, do_bit, added_pheader,
+                              check_subnet, &peer_addr);
+
+            break;
+          }
+        }
+
+        /* In case of local answer or no connections made. */
+        if (m == 0)
+          m = setup_reply(header, (unsigned int) size, addrp, flags,
+                          daemon->local_ttl);
+      }
     }
+
+    check_log_writer(1);
+
+    *length = htons(m);
+
+    if (m == 0 || !read_write(confd, packet, m + sizeof(u16), 0))
+      return packet;
+  }
 }
 
 static struct frec *allocate_frec(time_t now)
 {
   struct frec *f;
-  
-  if ((f = (struct frec *)whine_malloc(sizeof(struct frec))))
-    {
-      f->next = daemon->frec_list;
-      f->time = now;
-      f->sentto = NULL;
-      f->rfd4 = NULL;
-      f->flags = 0;
+
+  if ((f = (struct frec *) whine_malloc(sizeof(struct frec)))) {
+    f->next = daemon->frec_list;
+    f->time = now;
+    f->sentto = NULL;
+    f->rfd4 = NULL;
+    f->flags = 0;
 #ifdef HAVE_IPV6
-      f->rfd6 = NULL;
+    f->rfd6 = NULL;
 #endif
 #ifdef HAVE_DNSSEC
-      f->dependent = NULL;
-      f->blocking_query = NULL;
-      f->stash = NULL;
+    f->dependent = NULL;
+    f->blocking_query = NULL;
+    f->stash = NULL;
 #endif
-      daemon->frec_list = f;
-    }
+    daemon->frec_list = f;
+  }
 
   return f;
 }
@@ -2027,31 +1997,28 @@
      (eg) TFTP. Once we have a reasonable number, randomness should be OK */
 
   for (i = 0; i < RANDOM_SOCKS; i++)
-    if (daemon->randomsocks[i].refcount == 0)
-      {
-	if ((daemon->randomsocks[i].fd = random_sock(family)) == -1)
-	  break;
-      
-	daemon->randomsocks[i].refcount = 1;
-	daemon->randomsocks[i].family = family;
-	return &daemon->randomsocks[i];
-      }
+    if (daemon->randomsocks[i].refcount == 0) {
+      if ((daemon->randomsocks[i].fd = random_sock(family)) == -1)
+        break;
+
+      daemon->randomsocks[i].refcount = 1;
+      daemon->randomsocks[i].family = family;
+      return &daemon->randomsocks[i];
+    }
 
   /* No free ones or cannot get new socket, grab an existing one */
-  for (i = 0; i < RANDOM_SOCKS; i++)
-    {
-      int j = (i+finger) % RANDOM_SOCKS;
-      if (daemon->randomsocks[j].refcount != 0 &&
-	  daemon->randomsocks[j].family == family && 
-	  daemon->randomsocks[j].refcount != 0xffff)
-	{
-	  finger = j;
-	  daemon->randomsocks[j].refcount++;
-	  return &daemon->randomsocks[j];
-	}
+  for (i = 0; i < RANDOM_SOCKS; i++) {
+    int j = (i + finger) % RANDOM_SOCKS;
+    if (daemon->randomsocks[j].refcount != 0 &&
+        daemon->randomsocks[j].family == family &&
+        daemon->randomsocks[j].refcount != 0xffff) {
+      finger = j;
+      daemon->randomsocks[j].refcount++;
+      return &daemon->randomsocks[j];
     }
+  }
 
-  return NULL; /* doom */
+  return NULL;                  /* doom */
 }
 
 void free_rfd(struct randfd *rfd)
@@ -2066,18 +2033,17 @@
   f->rfd4 = NULL;
   f->sentto = NULL;
   f->flags = 0;
-  
+
 #ifdef HAVE_IPV6
   free_rfd(f->rfd6);
   f->rfd6 = NULL;
 #endif
 
 #ifdef HAVE_DNSSEC
-  if (f->stash)
-    {
-      blockdata_free(f->stash);
-      f->stash = NULL;
-    }
+  if (f->stash) {
+    blockdata_free(f->stash);
+    f->stash = NULL;
+  }
 
   /* Anything we're waiting on is pointless now, too */
   if (f->blocking_query)
@@ -2099,81 +2065,76 @@
 {
   struct frec *f, *oldest, *target;
   int count;
-  
+
   if (wait)
     *wait = 0;
 
-  for (f = daemon->frec_list, oldest = NULL, target =  NULL, count = 0; f; f = f->next, count++)
+  for (f = daemon->frec_list, oldest = NULL, target = NULL, count = 0; f;
+       f = f->next, count++)
     if (!f->sentto)
       target = f;
-    else 
-      {
+    else {
 #ifdef HAVE_DNSSEC
-	    /* Don't free DNSSEC sub-queries here, as we may end up with
-	       dangling references to them. They'll go when their "real" query 
-	       is freed. */
-	    if (!f->dependent)
-#endif
-	      {
-		if (difftime(now, f->time) >= 4*TIMEOUT)
-		  {
-		    free_frec(f);
-		    target = f;
-		  }
-	     
-	    
-		if (!oldest || difftime(f->time, oldest->time) <= 0)
-		  oldest = f;
-	      }
-      }
+      /* Don't free DNSSEC sub-queries here, as we may end up with
+         dangling references to them. They'll go when their "real" query
+         is freed. */
+      if (!f->dependent)
+#endif
+      {
+        if (difftime(now, f->time) >= 4 * TIMEOUT) {
+          free_frec(f);
+          target = f;
+        }
 
-  if (target)
-    {
-      target->time = now;
-      return target;
+
+        if (!oldest || difftime(f->time, oldest->time) <= 0)
+          oldest = f;
+      }
     }
-  
+
+  if (target) {
+    target->time = now;
+    return target;
+  }
+
   /* can't find empty one, use oldest if there is one
      and it's older than timeout */
-  if (!force && oldest && ((int)difftime(now, oldest->time)) >= TIMEOUT)
-    { 
-      /* keep stuff for twice timeout if we can by allocating a new
-	 record instead */
-      if (difftime(now, oldest->time) < 2*TIMEOUT && 
-	  count <= daemon->ftabsize &&
-	  (f = allocate_frec(now)))
-	return f;
-
-      if (!wait)
-	{
-	  free_frec(oldest);
-	  oldest->time = now;
-	}
-      return oldest;
+  if (!force && oldest && ((int) difftime(now, oldest->time)) >= TIMEOUT) {
+    /* keep stuff for twice timeout if we can by allocating a new
+       record instead */
+    if (difftime(now, oldest->time) < 2 * TIMEOUT &&
+        count <= daemon->ftabsize && (f = allocate_frec(now)))
+      return f;
+
+    if (!wait) {
+      free_frec(oldest);
+      oldest->time = now;
     }
-  
+    return oldest;
+  }
+
   /* none available, calculate time 'till oldest record expires */
-  if (!force && count > daemon->ftabsize)
-    {
-      static time_t last_log = 0;
-      
-      if (oldest && wait)
-	*wait = oldest->time + (time_t)TIMEOUT - now;
-      
-      if ((int)difftime(now, last_log) > 5)
-	{
-	  last_log = now;
-	  my_syslog(LOG_WARNING, _("Maximum number of concurrent DNS queries reached (max: %d)"), daemon->ftabsize);
-	}
+  if (!force && count > daemon->ftabsize) {
+    static time_t last_log = 0;
 
-      return NULL;
+    if (oldest && wait)
+      *wait = oldest->time + (time_t) TIMEOUT - now;
+
+    if ((int) difftime(now, last_log) > 5) {
+      last_log = now;
+      my_syslog(LOG_WARNING,
+                _("Maximum number of concurrent DNS queries reached (max: %d)"),
+                daemon->ftabsize);
     }
-  
+
+    return NULL;
+  }
+
   if (!(f = allocate_frec(now)) && wait)
     /* wait one second on malloc failure */
     *wait = 1;
 
-  return f; /* OK if malloc fails and this is NULL */
+  return f;                     /* OK if malloc fails and this is NULL */
 }
 
 /* crc is all-ones if not known. */
@@ -2181,59 +2142,57 @@
 {
   struct frec *f;
 
-  for(f = daemon->frec_list; f; f = f->next)
-    if (f->sentto && f->new_id == id && 
-	(!hash || memcmp(hash, f->hash, HASH_SIZE) == 0))
+  for (f = daemon->frec_list; f; f = f->next)
+    if (f->sentto && f->new_id == id &&
+        (!hash || memcmp(hash, f->hash, HASH_SIZE) == 0))
       return f;
-      
+
   return NULL;
 }
 
 static struct frec *lookup_frec_by_sender(unsigned short id,
-					  union mysockaddr *addr,
-					  void *hash)
+                                          union mysockaddr *addr, void *hash)
 {
   struct frec *f;
-  
-  for(f = daemon->frec_list; f; f = f->next)
+
+  for (f = daemon->frec_list; f; f = f->next)
     if (f->sentto &&
-	f->orig_id == id && 
-	memcmp(hash, f->hash, HASH_SIZE) == 0 &&
-	sockaddr_isequal(&f->source, addr))
+        f->orig_id == id &&
+        memcmp(hash, f->hash, HASH_SIZE) == 0 &&
+        sockaddr_isequal(&f->source, addr))
       return f;
-   
+
   return NULL;
 }
- 
+
 /* Send query packet again, if we can. */
 void resend_query()
 {
-  if (daemon->srv_save)
-    {
-      int fd;
-      
-      if (daemon->srv_save->sfd)
-	fd = daemon->srv_save->sfd->fd;
-      else if (daemon->rfd_save && daemon->rfd_save->refcount != 0)
-	fd = daemon->rfd_save->fd;
-      else
-	return;
-      
-      while(retry_send(sendto(fd, daemon->packet, daemon->packet_len, 0,
-			      &daemon->srv_save->addr.sa, 
-			      sa_len(&daemon->srv_save->addr)))); 
-    }
+  if (daemon->srv_save) {
+    int fd;
+
+    if (daemon->srv_save->sfd)
+      fd = daemon->srv_save->sfd->fd;
+    else if (daemon->rfd_save && daemon->rfd_save->refcount != 0)
+      fd = daemon->rfd_save->fd;
+    else
+      return;
+
+    while (retry_send(sendto(fd, daemon->packet, daemon->packet_len, 0,
+                             &daemon->srv_save->addr.sa,
+                             sa_len(&daemon->srv_save->addr))));
+  }
 }
 
 /* A server record is going away, remove references to it */
 void server_gone(struct server *server)
 {
   struct frec *f;
-  
+
   for (f = daemon->frec_list; f; f = f->next)
     if (f->sentto && f->sentto == server)
       free_frec(f);
-  
+
   if (daemon->last_server == server)
     daemon->last_server = NULL;
 
@@ -2245,15 +2204,10 @@
 static unsigned short get_id(void)
 {
   unsigned short ret = 0;
-  
-  do 
+
+  do
     ret = rand16();
   while (lookup_frec(ret, NULL));
-  
+
   return ret;
 }
-
-
-
-
-
Index: dnsmasq-2.78/src/helper.c
===================================================================
--- dnsmasq-2.78.orig/src/helper.c	2017-10-02 21:13:51.000000000 +0800
+++ dnsmasq-2.78/src/helper.c	2018-10-29 16:14:19.417440025 +0800
@@ -31,13 +31,14 @@
 */
 
 static void my_setenv(const char *name, const char *value, int *error);
-static unsigned char *grab_extradata(unsigned char *buf, unsigned char *end,  char *env, int *err);
+static unsigned char *grab_extradata(unsigned char *buf, unsigned char *end,
+                                     char *env, int *err);
 
 #ifdef HAVE_LUASCRIPT
 #define LUA_COMPAT_ALL
-#include <lua.h>  
-#include <lualib.h>  
-#include <lauxlib.h>  
+#include <lua.h>
+#include <lualib.h>
+#include <lauxlib.h>
 
 #ifndef lua_open
 #define lua_open()     luaL_newstate()
@@ -45,12 +46,12 @@
 
 lua_State *lua;
 
-static unsigned char *grab_extradata_lua(unsigned char *buf, unsigned char *end, char *field);
+static unsigned char *grab_extradata_lua(unsigned char *buf, unsigned char *end,
+                                         char *field);
 #endif
 
 
-struct script_data
-{
+struct script_data {
   int flags;
   int action, hwaddr_len, hwaddr_type;
   int clid_len, hostname_len, ed_len;
@@ -85,17 +86,15 @@
 
   /* create the pipe through which the main program sends us commands,
      then fork our process. */
-  if (pipe(pipefd) == -1 || !fix_fd(pipefd[1]) || (pid = fork()) == -1)
-    {
-      send_event(err_fd, EVENT_PIPE_ERR, errno, NULL);
-      _exit(0);
-    }
-
-  if (pid != 0)
-    {
-      close(pipefd[0]); /* close reader side */
-      return pipefd[1];
-    }
+  if (pipe(pipefd) == -1 || !fix_fd(pipefd[1]) || (pid = fork()) == -1) {
+    send_event(err_fd, EVENT_PIPE_ERR, errno, NULL);
+    _exit(0);
+  }
+
+  if (pid != 0) {
+    close(pipefd[0]);           /* close reader side */
+    return pipefd[1];
+  }
 
   /* ignore SIGTERM, so that we can clean up when the main process gets hit
      and SIGALRM so that we can use sleep() */
@@ -105,595 +104,541 @@
   sigaction(SIGTERM, &sigact, NULL);
   sigaction(SIGALRM, &sigact, NULL);
 
-  if (!option_bool(OPT_DEBUG) && uid != 0)
-    {
-      gid_t dummy;
-      if (setgroups(0, &dummy) == -1 || 
-	  setgid(gid) == -1 || 
-	  setuid(uid) == -1)
-	{
-	  if (option_bool(OPT_NO_FORK))
-	    /* send error to daemon process if no-fork */
-	    send_event(event_fd, EVENT_USER_ERR, errno, daemon->scriptuser);
-	  else
-	    {
-	      /* kill daemon */
-	      send_event(event_fd, EVENT_DIE, 0, NULL);
-	      /* return error */
-	      send_event(err_fd, EVENT_USER_ERR, errno, daemon->scriptuser);
-	    }
-	  _exit(0);
-	}
+  if (!option_bool(OPT_DEBUG) && uid != 0) {
+    gid_t dummy;
+    if (setgroups(0, &dummy) == -1 || setgid(gid) == -1 || setuid(uid) == -1) {
+      if (option_bool(OPT_NO_FORK))
+        /* send error to daemon process if no-fork */
+        send_event(event_fd, EVENT_USER_ERR, errno, daemon->scriptuser);
+      else {
+        /* kill daemon */
+        send_event(event_fd, EVENT_DIE, 0, NULL);
+        /* return error */
+        send_event(err_fd, EVENT_USER_ERR, errno, daemon->scriptuser);
+      }
+      _exit(0);
     }
+  }
 
   /* close all the sockets etc, we don't need them here. 
      Don't close err_fd, in case the lua-init fails.
      Note that we have to do this before lua init
      so we don't close any lua fds. */
   for (max_fd--; max_fd >= 0; max_fd--)
-    if (max_fd != STDOUT_FILENO && max_fd != STDERR_FILENO && 
-	max_fd != STDIN_FILENO && max_fd != pipefd[0] && 
-	max_fd != event_fd && max_fd != err_fd)
+    if (max_fd != STDOUT_FILENO && max_fd != STDERR_FILENO &&
+        max_fd != STDIN_FILENO && max_fd != pipefd[0] &&
+        max_fd != event_fd && max_fd != err_fd)
       close(max_fd);
 
 #ifdef HAVE_LUASCRIPT
-  if (daemon->luascript)
-    {
-      const char *lua_err = NULL;
-      lua = lua_open();
-      luaL_openlibs(lua);
-      
-      /* get Lua to load our script file */
-      if (luaL_dofile(lua, daemon->luascript) != 0)
-	lua_err = lua_tostring(lua, -1);
-      else
-	{
-	  lua_getglobal(lua, "lease");
-	  if (lua_type(lua, -1) != LUA_TFUNCTION) 
-	    lua_err = _("lease() function missing in Lua script");
-	}
-      
-      if (lua_err)
-	{
-	  if (option_bool(OPT_NO_FORK) || option_bool(OPT_DEBUG))
-	    /* send error to daemon process if no-fork */
-	    send_event(event_fd, EVENT_LUA_ERR, 0, (char *)lua_err);
-	  else
-	    {
-	      /* kill daemon */
-	      send_event(event_fd, EVENT_DIE, 0, NULL);
-	      /* return error */
-	      send_event(err_fd, EVENT_LUA_ERR, 0, (char *)lua_err);
-	    }
-	  _exit(0);
-	}
-      
-      lua_pop(lua, 1);  /* remove nil from stack */
-      lua_getglobal(lua, "init");
-      if (lua_type(lua, -1) == LUA_TFUNCTION)
-	lua_call(lua, 0, 0);
-      else
-	lua_pop(lua, 1);  /* remove nil from stack */	
+  if (daemon->luascript) {
+    const char *lua_err = NULL;
+    lua = lua_open();
+    luaL_openlibs(lua);
+
+    /* get Lua to load our script file */
+    if (luaL_dofile(lua, daemon->luascript) != 0)
+      lua_err = lua_tostring(lua, -1);
+    else {
+      lua_getglobal(lua, "lease");
+      if (lua_type(lua, -1) != LUA_TFUNCTION)
+        lua_err = _("lease() function missing in Lua script");
+    }
+
+    if (lua_err) {
+      if (option_bool(OPT_NO_FORK) || option_bool(OPT_DEBUG))
+        /* send error to daemon process if no-fork */
+        send_event(event_fd, EVENT_LUA_ERR, 0, (char *) lua_err);
+      else {
+        /* kill daemon */
+        send_event(event_fd, EVENT_DIE, 0, NULL);
+        /* return error */
+        send_event(err_fd, EVENT_LUA_ERR, 0, (char *) lua_err);
+      }
+      _exit(0);
     }
+
+    lua_pop(lua, 1);            /* remove nil from stack */
+    lua_getglobal(lua, "init");
+    if (lua_type(lua, -1) == LUA_TFUNCTION)
+      lua_call(lua, 0, 0);
+    else
+      lua_pop(lua, 1);          /* remove nil from stack */
+  }
 #endif
 
   /* All init done, close our copy of the error pipe, so that main process can return */
   if (err_fd != -1)
     close(err_fd);
-    
+
   /* loop here */
-  while(1)
-    {
-      struct script_data data;
-      char *p, *action_str, *hostname = NULL, *domain = NULL;
-      unsigned char *buf = (unsigned char *)daemon->namebuff;
-      unsigned char *end, *extradata, *alloc_buff = NULL;
-      int is6, err = 0;
-      int pipeout[2];
-
-      free(alloc_buff);
-      
-      /* we read zero bytes when pipe closed: this is our signal to exit */ 
-      if (!read_write(pipefd[0], (unsigned char *)&data, sizeof(data), 1))
-	{
+  while (1) {
+    struct script_data data;
+    char *p, *action_str, *hostname = NULL, *domain = NULL;
+    unsigned char *buf = (unsigned char *) daemon->namebuff;
+    unsigned char *end, *extradata, *alloc_buff = NULL;
+    int is6, err = 0;
+    int pipeout[2];
+
+    free(alloc_buff);
+
+    /* we read zero bytes when pipe closed: this is our signal to exit */
+    if (!read_write(pipefd[0], (unsigned char *) &data, sizeof(data), 1)) {
 #ifdef HAVE_LUASCRIPT
-	  if (daemon->luascript)
-	    {
-	      lua_getglobal(lua, "shutdown");
-	      if (lua_type(lua, -1) == LUA_TFUNCTION)
-		lua_call(lua, 0, 0);
-	    }
-#endif
-	  _exit(0);
-	}
- 
-      is6 = !!(data.flags & (LEASE_TA | LEASE_NA));
-      
-      if (data.action == ACTION_DEL)
-	action_str = "del";
-      else if (data.action == ACTION_ADD)
-	action_str = "add";
-      else if (data.action == ACTION_OLD || data.action == ACTION_OLD_HOSTNAME)
-	action_str = "old";
-      else if (data.action == ACTION_TFTP)
-	{
-	  action_str = "tftp";
-	  is6 = (data.flags != AF_INET);
-	}
-      else if (data.action == ACTION_ARP)
-	{
-	  action_str = "arp-add";
-	  is6 = (data.flags != AF_INET);
-	}
-       else if (data.action == ACTION_ARP_DEL)
-	{
-	  action_str = "arp-del";
-	  is6 = (data.flags != AF_INET);
-	  data.action = ACTION_ARP;
-	}
-       else 
-	continue;
-
-      	
-      /* stringify MAC into dhcp_buff */
-      p = daemon->dhcp_buff;
-      if (data.hwaddr_type != ARPHRD_ETHER || data.hwaddr_len == 0) 
-	p += sprintf(p, "%.2x-", data.hwaddr_type);
-      for (i = 0; (i < data.hwaddr_len) && (i < DHCP_CHADDR_MAX); i++)
-	{
-	  p += sprintf(p, "%.2x", data.hwaddr[i]);
-	  if (i != data.hwaddr_len - 1)
-	    p += sprintf(p, ":");
-	}
-      
-      /* supplied data may just exceed normal buffer (unlikely) */
-      if ((data.hostname_len + data.ed_len + data.clid_len) > MAXDNAME && 
-	  !(alloc_buff = buf = malloc(data.hostname_len + data.ed_len + data.clid_len)))
-	continue;
-      
-      if (!read_write(pipefd[0], buf, 
-		      data.hostname_len + data.ed_len + data.clid_len, 1))
-	continue;
-
-      /* CLID into packet */
-      for (p = daemon->packet, i = 0; i < data.clid_len; i++)
-	{
-	  p += sprintf(p, "%.2x", buf[i]);
-	  if (i != data.clid_len - 1) 
-	      p += sprintf(p, ":");
-	}
+      if (daemon->luascript) {
+        lua_getglobal(lua, "shutdown");
+        if (lua_type(lua, -1) == LUA_TFUNCTION)
+          lua_call(lua, 0, 0);
+      }
+#endif
+      _exit(0);
+    }
+
+    is6 = ! !(data.flags & (LEASE_TA | LEASE_NA));
+
+    if (data.action == ACTION_DEL)
+      action_str = "del";
+    else if (data.action == ACTION_ADD)
+      action_str = "add";
+    else if (data.action == ACTION_OLD || data.action == ACTION_OLD_HOSTNAME)
+      action_str = "old";
+    else if (data.action == ACTION_TFTP) {
+      action_str = "tftp";
+      is6 = (data.flags != AF_INET);
+    } else if (data.action == ACTION_ARP) {
+      action_str = "arp-add";
+      is6 = (data.flags != AF_INET);
+    } else if (data.action == ACTION_ARP_DEL) {
+      action_str = "arp-del";
+      is6 = (data.flags != AF_INET);
+      data.action = ACTION_ARP;
+    } else
+      continue;
+
+
+    /* stringify MAC into dhcp_buff */
+    p = daemon->dhcp_buff;
+    if (data.hwaddr_type != ARPHRD_ETHER || data.hwaddr_len == 0)
+      p += sprintf(p, "%.2x-", data.hwaddr_type);
+    for (i = 0; (i < data.hwaddr_len) && (i < DHCP_CHADDR_MAX); i++) {
+      p += sprintf(p, "%.2x", data.hwaddr[i]);
+      if (i != data.hwaddr_len - 1)
+        p += sprintf(p, ":");
+    }
+
+    /* supplied data may just exceed normal buffer (unlikely) */
+    if ((data.hostname_len + data.ed_len + data.clid_len) > MAXDNAME &&
+        !(alloc_buff = buf =
+          malloc(data.hostname_len + data.ed_len + data.clid_len)))
+      continue;
+
+    if (!read_write(pipefd[0], buf,
+                    data.hostname_len + data.ed_len + data.clid_len, 1))
+      continue;
+
+    /* CLID into packet */
+    for (p = daemon->packet, i = 0; i < data.clid_len; i++) {
+      p += sprintf(p, "%.2x", buf[i]);
+      if (i != data.clid_len - 1)
+        p += sprintf(p, ":");
+    }
 
 #ifdef HAVE_DHCP6
-      if (is6)
-	{
-	  /* or IAID and server DUID for IPv6 */
-	  sprintf(daemon->dhcp_buff3, "%s%u", data.flags & LEASE_TA ? "T" : "", data.iaid);	
-	  for (p = daemon->dhcp_packet.iov_base, i = 0; i < daemon->duid_len; i++)
-	    {
-	      p += sprintf(p, "%.2x", daemon->duid[i]);
-	      if (i != daemon->duid_len - 1) 
-		p += sprintf(p, ":");
-	    }
-
-	}
-#endif
-
-      buf += data.clid_len;
-
-      if (data.hostname_len != 0)
-	{
-	  char *dot;
-	  hostname = (char *)buf;
-	  hostname[data.hostname_len - 1] = 0;
-	  if (data.action != ACTION_TFTP)
-	    {
-	      if (!legal_hostname(hostname))
-		hostname = NULL;
-	      else if ((dot = strchr(hostname, '.')))
-		{
-		  domain = dot+1;
-		  *dot = 0;
-		} 
-	    }
-	}
-    
-      extradata = buf + data.hostname_len;
-    
-      if (!is6)
-	inet_ntop(AF_INET, &data.addr, daemon->addrbuff, ADDRSTRLEN);
+    if (is6) {
+      /* or IAID and server DUID for IPv6 */
+      sprintf(daemon->dhcp_buff3, "%s%u", data.flags & LEASE_TA ? "T" : "",
+              data.iaid);
+      for (p = daemon->dhcp_packet.iov_base, i = 0; i < daemon->duid_len; i++) {
+        p += sprintf(p, "%.2x", daemon->duid[i]);
+        if (i != daemon->duid_len - 1)
+          p += sprintf(p, ":");
+      }
+
+    }
+#endif
+
+    buf += data.clid_len;
+
+    if (data.hostname_len != 0) {
+      char *dot;
+      hostname = (char *) buf;
+      hostname[data.hostname_len - 1] = 0;
+      if (data.action != ACTION_TFTP) {
+        if (!legal_hostname(hostname))
+          hostname = NULL;
+        else if ((dot = strchr(hostname, '.'))) {
+          domain = dot + 1;
+          *dot = 0;
+        }
+      }
+    }
+
+    extradata = buf + data.hostname_len;
+
+    if (!is6)
+      inet_ntop(AF_INET, &data.addr, daemon->addrbuff, ADDRSTRLEN);
 #ifdef HAVE_IPV6
-      else
-	inet_ntop(AF_INET6, &data.addr6, daemon->addrbuff, ADDRSTRLEN);
+    else
+      inet_ntop(AF_INET6, &data.addr6, daemon->addrbuff, ADDRSTRLEN);
 #endif
 
 #ifdef HAVE_TFTP
-      /* file length */
-      if (data.action == ACTION_TFTP)
-	sprintf(is6 ? daemon->packet : daemon->dhcp_buff, "%lu", (unsigned long)data.file_len);
+    /* file length */
+    if (data.action == ACTION_TFTP)
+      sprintf(is6 ? daemon->packet : daemon->dhcp_buff, "%lu",
+              (unsigned long) data.file_len);
 #endif
 
 #ifdef HAVE_LUASCRIPT
-      if (daemon->luascript)
-	{
-	  if (data.action == ACTION_TFTP)
-	    {
-	      lua_getglobal(lua, "tftp"); 
-	      if (lua_type(lua, -1) != LUA_TFUNCTION)
-		lua_pop(lua, 1); /* tftp function optional */
-	      else
-		{
-		  lua_pushstring(lua, action_str); /* arg1 - action */
-		  lua_newtable(lua);               /* arg2 - data table */
-		  lua_pushstring(lua, daemon->addrbuff);
-		  lua_setfield(lua, -2, "destination_address");
-		  lua_pushstring(lua, hostname);
-		  lua_setfield(lua, -2, "file_name"); 
-		  lua_pushstring(lua, is6 ? daemon->packet : daemon->dhcp_buff);
-		  lua_setfield(lua, -2, "file_size");
-		  lua_call(lua, 2, 0);	/* pass 2 values, expect 0 */
-		}
-	    }
-	  else if (data.action == ACTION_ARP)
-	    {
-	      lua_getglobal(lua, "arp"); 
-	      if (lua_type(lua, -1) != LUA_TFUNCTION)
-		lua_pop(lua, 1); /* arp function optional */
-	      else
-		{
-		  lua_pushstring(lua, action_str); /* arg1 - action */
-		  lua_newtable(lua);               /* arg2 - data table */
-		  lua_pushstring(lua, daemon->addrbuff);
-		  lua_setfield(lua, -2, "client_address");
-		  lua_pushstring(lua, daemon->dhcp_buff);
-		  lua_setfield(lua, -2, "mac_address");
-		  lua_call(lua, 2, 0);	/* pass 2 values, expect 0 */
-		}
-	    }
-	  else
-	    {
-	      lua_getglobal(lua, "lease");     /* function to call */
-	      lua_pushstring(lua, action_str); /* arg1 - action */
-	      lua_newtable(lua);               /* arg2 - data table */
-	      
-	      if (is6)
-		{
-		  lua_pushstring(lua, daemon->packet);
-		  lua_setfield(lua, -2, "client_duid");
-		  lua_pushstring(lua, daemon->dhcp_packet.iov_base);
-		  lua_setfield(lua, -2, "server_duid");
-		  lua_pushstring(lua, daemon->dhcp_buff3);
-		  lua_setfield(lua, -2, "iaid");
-		}
-	      
-	      if (!is6 && data.clid_len != 0)
-		{
-		  lua_pushstring(lua, daemon->packet);
-		  lua_setfield(lua, -2, "client_id");
-		}
-	      
-	      if (strlen(data.interface) != 0)
-		{
-		  lua_pushstring(lua, data.interface);
-		  lua_setfield(lua, -2, "interface");
-		}
-	      
-#ifdef HAVE_BROKEN_RTC	
-	      lua_pushnumber(lua, data.length);
-	      lua_setfield(lua, -2, "lease_length");
+    if (daemon->luascript) {
+      if (data.action == ACTION_TFTP) {
+        lua_getglobal(lua, "tftp");
+        if (lua_type(lua, -1) != LUA_TFUNCTION)
+          lua_pop(lua, 1);      /* tftp function optional */
+        else {
+          lua_pushstring(lua, action_str);      /* arg1 - action */
+          lua_newtable(lua);    /* arg2 - data table */
+          lua_pushstring(lua, daemon->addrbuff);
+          lua_setfield(lua, -2, "destination_address");
+          lua_pushstring(lua, hostname);
+          lua_setfield(lua, -2, "file_name");
+          lua_pushstring(lua, is6 ? daemon->packet : daemon->dhcp_buff);
+          lua_setfield(lua, -2, "file_size");
+          lua_call(lua, 2, 0);  /* pass 2 values, expect 0 */
+        }
+      } else if (data.action == ACTION_ARP) {
+        lua_getglobal(lua, "arp");
+        if (lua_type(lua, -1) != LUA_TFUNCTION)
+          lua_pop(lua, 1);      /* arp function optional */
+        else {
+          lua_pushstring(lua, action_str);      /* arg1 - action */
+          lua_newtable(lua);    /* arg2 - data table */
+          lua_pushstring(lua, daemon->addrbuff);
+          lua_setfield(lua, -2, "client_address");
+          lua_pushstring(lua, daemon->dhcp_buff);
+          lua_setfield(lua, -2, "mac_address");
+          lua_call(lua, 2, 0);  /* pass 2 values, expect 0 */
+        }
+      } else {
+        lua_getglobal(lua, "lease");    /* function to call */
+        lua_pushstring(lua, action_str);        /* arg1 - action */
+        lua_newtable(lua);      /* arg2 - data table */
+
+        if (is6) {
+          lua_pushstring(lua, daemon->packet);
+          lua_setfield(lua, -2, "client_duid");
+          lua_pushstring(lua, daemon->dhcp_packet.iov_base);
+          lua_setfield(lua, -2, "server_duid");
+          lua_pushstring(lua, daemon->dhcp_buff3);
+          lua_setfield(lua, -2, "iaid");
+        }
+
+        if (!is6 && data.clid_len != 0) {
+          lua_pushstring(lua, daemon->packet);
+          lua_setfield(lua, -2, "client_id");
+        }
+
+        if (strlen(data.interface) != 0) {
+          lua_pushstring(lua, data.interface);
+          lua_setfield(lua, -2, "interface");
+        }
+#ifdef HAVE_BROKEN_RTC
+        lua_pushnumber(lua, data.length);
+        lua_setfield(lua, -2, "lease_length");
 #else
-	      lua_pushnumber(lua, data.expires);
-	      lua_setfield(lua, -2, "lease_expires");
+        lua_pushnumber(lua, data.expires);
+        lua_setfield(lua, -2, "lease_expires");
 #endif
-	      
-	      if (hostname)
-		{
-		  lua_pushstring(lua, hostname);
-		  lua_setfield(lua, -2, "hostname");
-		}
-	      
-	      if (domain)
-		{
-		  lua_pushstring(lua, domain);
-		  lua_setfield(lua, -2, "domain");
-		}
-	      
-	      end = extradata + data.ed_len;
-	      buf = extradata;
-	      
-	      if (!is6)
-		buf = grab_extradata_lua(buf, end, "vendor_class");
+
+        if (hostname) {
+          lua_pushstring(lua, hostname);
+          lua_setfield(lua, -2, "hostname");
+        }
+
+        if (domain) {
+          lua_pushstring(lua, domain);
+          lua_setfield(lua, -2, "domain");
+        }
+
+        end = extradata + data.ed_len;
+        buf = extradata;
+
+        if (!is6)
+          buf = grab_extradata_lua(buf, end, "vendor_class");
 #ifdef HAVE_DHCP6
-	      else  if (data.vendorclass_count != 0)
-		{
-		  sprintf(daemon->dhcp_buff2, "vendor_class_id");
-		  buf = grab_extradata_lua(buf, end, daemon->dhcp_buff2);
-		  for (i = 0; i < data.vendorclass_count - 1; i++)
-		    {
-		      sprintf(daemon->dhcp_buff2, "vendor_class%i", i);
-		      buf = grab_extradata_lua(buf, end, daemon->dhcp_buff2);
-		    }
-		}
-#endif
-	      
-	      buf = grab_extradata_lua(buf, end, "supplied_hostname");
-	      
-	      if (!is6)
-		{
-		  buf = grab_extradata_lua(buf, end, "cpewan_oui");
-		  buf = grab_extradata_lua(buf, end, "cpewan_serial");   
-		  buf = grab_extradata_lua(buf, end, "cpewan_class");
-		  buf = grab_extradata_lua(buf, end, "circuit_id");
-		  buf = grab_extradata_lua(buf, end, "subscriber_id");
-		  buf = grab_extradata_lua(buf, end, "remote_id");
-		}
-	      
-	      buf = grab_extradata_lua(buf, end, "tags");
-	      
-	      if (is6)
-		buf = grab_extradata_lua(buf, end, "relay_address");
-	      else if (data.giaddr.s_addr != 0)
-		{
-		  lua_pushstring(lua, inet_ntoa(data.giaddr));
-		  lua_setfield(lua, -2, "relay_address");
-		}
-	      
-	      for (i = 0; buf; i++)
-		{
-		  sprintf(daemon->dhcp_buff2, "user_class%i", i);
-		  buf = grab_extradata_lua(buf, end, daemon->dhcp_buff2);
-		}
-	      
-	      if (data.action != ACTION_DEL && data.remaining_time != 0)
-		{
-		  lua_pushnumber(lua, data.remaining_time);
-		  lua_setfield(lua, -2, "time_remaining");
-		}
-	      
-	      if (data.action == ACTION_OLD_HOSTNAME && hostname)
-		{
-		  lua_pushstring(lua, hostname);
-		  lua_setfield(lua, -2, "old_hostname");
-		}
-	      
-	      if (!is6 || data.hwaddr_len != 0)
-		{
-		  lua_pushstring(lua, daemon->dhcp_buff);
-		  lua_setfield(lua, -2, "mac_address");
-		}
-	      
-	      lua_pushstring(lua, daemon->addrbuff);
-	      lua_setfield(lua, -2, "ip_address");
-	    
-	      lua_call(lua, 2, 0);	/* pass 2 values, expect 0 */
-	    }
-	}
-#endif
-
-      /* no script, just lua */
-      if (!daemon->lease_change_command)
-	continue;
-
-      /* Pipe to capture stdout and stderr from script */
-      if (!option_bool(OPT_DEBUG) && pipe(pipeout) == -1)
-	continue;
-      
-      /* possible fork errors are all temporary resource problems */
-      while ((pid = fork()) == -1 && (errno == EAGAIN || errno == ENOMEM))
-	sleep(2);
-
-      if (pid == -1)
-        {
-	  if (!option_bool(OPT_DEBUG))
-	    {
-	      close(pipeout[0]);
-	      close(pipeout[1]);
-	    }
-	  continue;
-        }
-      
-      /* wait for child to complete */
-      if (pid != 0)
-	{
-	  if (!option_bool(OPT_DEBUG))
-	    {
-	      FILE *fp;
-	  
-	      close(pipeout[1]);
-	      
-	      /* Read lines sent to stdout/err by the script and pass them back to be logged */
-	      if (!(fp = fdopen(pipeout[0], "r")))
-		close(pipeout[0]);
-	      else
-		{
-		  while (fgets(daemon->packet, daemon->packet_buff_sz, fp))
-		    {
-		      /* do not include new lines, log will append them */
-		      size_t len = strlen(daemon->packet);
-		      if (len > 0)
-			{
-			  --len;
-			  if (daemon->packet[len] == '\n')
-			    daemon->packet[len] = 0;
-			}
-		      send_event(event_fd, EVENT_SCRIPT_LOG, 0, daemon->packet);
-		    }
-		  fclose(fp);
-		}
-	    }
-	  
-	  /* reap our children's children, if necessary */
-	  while (1)
-	    {
-	      int status;
-	      pid_t rc = wait(&status);
-	      
-	      if (rc == pid)
-		{
-		  /* On error send event back to main process for logging */
-		  if (WIFSIGNALED(status))
-		    send_event(event_fd, EVENT_KILLED, WTERMSIG(status), NULL);
-		  else if (WIFEXITED(status) && WEXITSTATUS(status) != 0)
-		    send_event(event_fd, EVENT_EXITED, WEXITSTATUS(status), NULL);
-		  break;
-		}
-	      
-	      if (rc == -1 && errno != EINTR)
-		break;
-	    }
-	  
-	  continue;
-	}
-
-      if (!option_bool(OPT_DEBUG))
-	{
-	  /* map stdout/stderr of script to pipeout */
-	  close(pipeout[0]);
-	  dup2(pipeout[1], STDOUT_FILENO);
-	  dup2(pipeout[1], STDERR_FILENO);
-	  close(pipeout[1]);
-	}
-      
-      if (data.action != ACTION_TFTP && data.action != ACTION_ARP)
-	{
+        else if (data.vendorclass_count != 0) {
+          sprintf(daemon->dhcp_buff2, "vendor_class_id");
+          buf = grab_extradata_lua(buf, end, daemon->dhcp_buff2);
+          for (i = 0; i < data.vendorclass_count - 1; i++) {
+            sprintf(daemon->dhcp_buff2, "vendor_class%i", i);
+            buf = grab_extradata_lua(buf, end, daemon->dhcp_buff2);
+          }
+        }
+#endif
+
+        buf = grab_extradata_lua(buf, end, "supplied_hostname");
+
+        if (!is6) {
+          buf = grab_extradata_lua(buf, end, "cpewan_oui");
+          buf = grab_extradata_lua(buf, end, "cpewan_serial");
+          buf = grab_extradata_lua(buf, end, "cpewan_class");
+          buf = grab_extradata_lua(buf, end, "circuit_id");
+          buf = grab_extradata_lua(buf, end, "subscriber_id");
+          buf = grab_extradata_lua(buf, end, "remote_id");
+        }
+
+        buf = grab_extradata_lua(buf, end, "tags");
+
+        if (is6)
+          buf = grab_extradata_lua(buf, end, "relay_address");
+        else if (data.giaddr.s_addr != 0) {
+          lua_pushstring(lua, inet_ntoa(data.giaddr));
+          lua_setfield(lua, -2, "relay_address");
+        }
+
+        for (i = 0; buf; i++) {
+          sprintf(daemon->dhcp_buff2, "user_class%i", i);
+          buf = grab_extradata_lua(buf, end, daemon->dhcp_buff2);
+        }
+
+        if (data.action != ACTION_DEL && data.remaining_time != 0) {
+          lua_pushnumber(lua, data.remaining_time);
+          lua_setfield(lua, -2, "time_remaining");
+        }
+
+        if (data.action == ACTION_OLD_HOSTNAME && hostname) {
+          lua_pushstring(lua, hostname);
+          lua_setfield(lua, -2, "old_hostname");
+        }
+
+        if (!is6 || data.hwaddr_len != 0) {
+          lua_pushstring(lua, daemon->dhcp_buff);
+          lua_setfield(lua, -2, "mac_address");
+        }
+
+        lua_pushstring(lua, daemon->addrbuff);
+        lua_setfield(lua, -2, "ip_address");
+
+        lua_call(lua, 2, 0);    /* pass 2 values, expect 0 */
+      }
+    }
+#endif
+
+    /* no script, just lua */
+    if (!daemon->lease_change_command)
+      continue;
+
+    /* Pipe to capture stdout and stderr from script */
+    if (!option_bool(OPT_DEBUG) && pipe(pipeout) == -1)
+      continue;
+
+    /* possible fork errors are all temporary resource problems */
+    while ((pid = fork()) == -1 && (errno == EAGAIN || errno == ENOMEM))
+      sleep(2);
+
+    if (pid == -1) {
+      if (!option_bool(OPT_DEBUG)) {
+        close(pipeout[0]);
+        close(pipeout[1]);
+      }
+      continue;
+    }
+
+    /* wait for child to complete */
+    if (pid != 0) {
+      if (!option_bool(OPT_DEBUG)) {
+        FILE *fp;
+
+        close(pipeout[1]);
+
+        /* Read lines sent to stdout/err by the script and pass them back to be logged */
+        if (!(fp = fdopen(pipeout[0], "r")))
+          close(pipeout[0]);
+        else {
+          while (fgets(daemon->packet, daemon->packet_buff_sz, fp)) {
+            /* do not include new lines, log will append them */
+            size_t len = strlen(daemon->packet);
+            if (len > 0) {
+              --len;
+              if (daemon->packet[len] == '\n')
+                daemon->packet[len] = 0;
+            }
+            send_event(event_fd, EVENT_SCRIPT_LOG, 0, daemon->packet);
+          }
+          fclose(fp);
+        }
+      }
+
+      /* reap our children's children, if necessary */
+      while (1) {
+        int status;
+        pid_t rc = wait(&status);
+
+        if (rc == pid) {
+          /* On error send event back to main process for logging */
+          if (WIFSIGNALED(status))
+            send_event(event_fd, EVENT_KILLED, WTERMSIG(status), NULL);
+          else if (WIFEXITED(status) && WEXITSTATUS(status) != 0)
+            send_event(event_fd, EVENT_EXITED, WEXITSTATUS(status), NULL);
+          break;
+        }
+
+        if (rc == -1 && errno != EINTR)
+          break;
+      }
+
+      continue;
+    }
+
+    if (!option_bool(OPT_DEBUG)) {
+      /* map stdout/stderr of script to pipeout */
+      close(pipeout[0]);
+      dup2(pipeout[1], STDOUT_FILENO);
+      dup2(pipeout[1], STDERR_FILENO);
+      close(pipeout[1]);
+    }
+
+    if (data.action != ACTION_TFTP && data.action != ACTION_ARP) {
 #ifdef HAVE_DHCP6
-	  my_setenv("DNSMASQ_IAID", is6 ? daemon->dhcp_buff3 : NULL, &err);
-	  my_setenv("DNSMASQ_SERVER_DUID", is6 ? daemon->dhcp_packet.iov_base : NULL, &err); 
-	  my_setenv("DNSMASQ_MAC", is6 && data.hwaddr_len != 0 ? daemon->dhcp_buff : NULL, &err);
-#endif
-	  
-	  my_setenv("DNSMASQ_CLIENT_ID", !is6 && data.clid_len != 0 ? daemon->packet : NULL, &err);
-	  my_setenv("DNSMASQ_INTERFACE", strlen(data.interface) != 0 ? data.interface : NULL, &err);
-	  
+      my_setenv("DNSMASQ_IAID", is6 ? daemon->dhcp_buff3 : NULL, &err);
+      my_setenv("DNSMASQ_SERVER_DUID",
+                is6 ? daemon->dhcp_packet.iov_base : NULL, &err);
+      my_setenv("DNSMASQ_MAC", is6
+                && data.hwaddr_len != 0 ? daemon->dhcp_buff : NULL, &err);
+#endif
+
+      my_setenv("DNSMASQ_CLIENT_ID", !is6
+                && data.clid_len != 0 ? daemon->packet : NULL, &err);
+      my_setenv("DNSMASQ_INTERFACE",
+                strlen(data.interface) != 0 ? data.interface : NULL, &err);
+
 #ifdef HAVE_BROKEN_RTC
-	  sprintf(daemon->dhcp_buff2, "%u", data.length);
-	  my_setenv("DNSMASQ_LEASE_LENGTH", daemon->dhcp_buff2, &err);
+      sprintf(daemon->dhcp_buff2, "%u", data.length);
+      my_setenv("DNSMASQ_LEASE_LENGTH", daemon->dhcp_buff2, &err);
 #else
-	  sprintf(daemon->dhcp_buff2, "%lu", (unsigned long)data.expires);
-	  my_setenv("DNSMASQ_LEASE_EXPIRES", daemon->dhcp_buff2, &err); 
+      sprintf(daemon->dhcp_buff2, "%lu", (unsigned long) data.expires);
+      my_setenv("DNSMASQ_LEASE_EXPIRES", daemon->dhcp_buff2, &err);
 #endif
-	  
-	  my_setenv("DNSMASQ_DOMAIN", domain, &err);
-	  
-	  end = extradata + data.ed_len;
-	  buf = extradata;
-	  
-	  if (!is6)
-	    buf = grab_extradata(buf, end, "DNSMASQ_VENDOR_CLASS", &err);
+
+      my_setenv("DNSMASQ_DOMAIN", domain, &err);
+
+      end = extradata + data.ed_len;
+      buf = extradata;
+
+      if (!is6)
+        buf = grab_extradata(buf, end, "DNSMASQ_VENDOR_CLASS", &err);
 #ifdef HAVE_DHCP6
-	  else
-	    {
-	      if (data.vendorclass_count != 0)
-		{
-		  buf = grab_extradata(buf, end, "DNSMASQ_VENDOR_CLASS_ID", &err);
-		  for (i = 0; i < data.vendorclass_count - 1; i++)
-		    {
-		      sprintf(daemon->dhcp_buff2, "DNSMASQ_VENDOR_CLASS%i", i);
-		      buf = grab_extradata(buf, end, daemon->dhcp_buff2, &err);
-		    }
-		}
-	    }
-#endif
-	  
-	  buf = grab_extradata(buf, end, "DNSMASQ_SUPPLIED_HOSTNAME", &err);
-	  
-	  if (!is6)
-	    {
-	      buf = grab_extradata(buf, end, "DNSMASQ_CPEWAN_OUI", &err);
-	      buf = grab_extradata(buf, end, "DNSMASQ_CPEWAN_SERIAL", &err);   
-	      buf = grab_extradata(buf, end, "DNSMASQ_CPEWAN_CLASS", &err);
-	      buf = grab_extradata(buf, end, "DNSMASQ_CIRCUIT_ID", &err);
-	      buf = grab_extradata(buf, end, "DNSMASQ_SUBSCRIBER_ID", &err);
-	      buf = grab_extradata(buf, end, "DNSMASQ_REMOTE_ID", &err);
-	      buf = grab_extradata(buf, end, "DNSMASQ_REQUESTED_OPTIONS", &err);
-	    }
-	  
-	  buf = grab_extradata(buf, end, "DNSMASQ_TAGS", &err);
-
-	  if (is6)
-	    buf = grab_extradata(buf, end, "DNSMASQ_RELAY_ADDRESS", &err);
-	  else 
-	    my_setenv("DNSMASQ_RELAY_ADDRESS", data.giaddr.s_addr != 0 ? inet_ntoa(data.giaddr) : NULL, &err); 
-	  
-	  for (i = 0; buf; i++)
-	    {
-	      sprintf(daemon->dhcp_buff2, "DNSMASQ_USER_CLASS%i", i);
-	      buf = grab_extradata(buf, end, daemon->dhcp_buff2, &err);
-	    }
-	  
-	  sprintf(daemon->dhcp_buff2, "%u", data.remaining_time);
-	  my_setenv("DNSMASQ_TIME_REMAINING", data.action != ACTION_DEL && data.remaining_time != 0 ? daemon->dhcp_buff2 : NULL, &err);
-	  
-	  my_setenv("DNSMASQ_OLD_HOSTNAME", data.action == ACTION_OLD_HOSTNAME ? hostname : NULL, &err);
-	  if (data.action == ACTION_OLD_HOSTNAME)
-	    hostname = NULL;
-	  
-	  my_setenv("DNSMASQ_LOG_DHCP", option_bool(OPT_LOG_OPTS) ? "1" : NULL, &err);
-	}
-      
-      /* we need to have the event_fd around if exec fails */
-      if ((i = fcntl(event_fd, F_GETFD)) != -1)
-	fcntl(event_fd, F_SETFD, i | FD_CLOEXEC);
-      close(pipefd[0]);
-
-      p =  strrchr(daemon->lease_change_command, '/');
-      if (err == 0)
-	{
-	  execl(daemon->lease_change_command, 
-		p ? p+1 : daemon->lease_change_command, action_str, 
-		(is6 && data.action != ACTION_ARP) ? daemon->packet : daemon->dhcp_buff, 
-		daemon->addrbuff, hostname, (char*)NULL);
-	  err = errno;
-	}
-      /* failed, send event so the main process logs the problem */
-      send_event(event_fd, EVENT_EXEC_ERR, err, NULL);
-      _exit(0); 
-    }
+      else {
+        if (data.vendorclass_count != 0) {
+          buf = grab_extradata(buf, end, "DNSMASQ_VENDOR_CLASS_ID", &err);
+          for (i = 0; i < data.vendorclass_count - 1; i++) {
+            sprintf(daemon->dhcp_buff2, "DNSMASQ_VENDOR_CLASS%i", i);
+            buf = grab_extradata(buf, end, daemon->dhcp_buff2, &err);
+          }
+        }
+      }
+#endif
+
+      buf = grab_extradata(buf, end, "DNSMASQ_SUPPLIED_HOSTNAME", &err);
+
+      if (!is6) {
+        buf = grab_extradata(buf, end, "DNSMASQ_CPEWAN_OUI", &err);
+        buf = grab_extradata(buf, end, "DNSMASQ_CPEWAN_SERIAL", &err);
+        buf = grab_extradata(buf, end, "DNSMASQ_CPEWAN_CLASS", &err);
+        buf = grab_extradata(buf, end, "DNSMASQ_CIRCUIT_ID", &err);
+        buf = grab_extradata(buf, end, "DNSMASQ_SUBSCRIBER_ID", &err);
+        buf = grab_extradata(buf, end, "DNSMASQ_REMOTE_ID", &err);
+        buf = grab_extradata(buf, end, "DNSMASQ_REQUESTED_OPTIONS", &err);
+      }
+
+      buf = grab_extradata(buf, end, "DNSMASQ_TAGS", &err);
+
+      if (is6)
+        buf = grab_extradata(buf, end, "DNSMASQ_RELAY_ADDRESS", &err);
+      else
+        my_setenv("DNSMASQ_RELAY_ADDRESS",
+                  data.giaddr.s_addr != 0 ? inet_ntoa(data.giaddr) : NULL,
+                  &err);
+
+      for (i = 0; buf; i++) {
+        sprintf(daemon->dhcp_buff2, "DNSMASQ_USER_CLASS%i", i);
+        buf = grab_extradata(buf, end, daemon->dhcp_buff2, &err);
+      }
+
+      sprintf(daemon->dhcp_buff2, "%u", data.remaining_time);
+      my_setenv("DNSMASQ_TIME_REMAINING", data.action != ACTION_DEL
+                && data.remaining_time != 0 ? daemon->dhcp_buff2 : NULL, &err);
+
+      my_setenv("DNSMASQ_OLD_HOSTNAME",
+                data.action == ACTION_OLD_HOSTNAME ? hostname : NULL, &err);
+      if (data.action == ACTION_OLD_HOSTNAME)
+        hostname = NULL;
+
+      my_setenv("DNSMASQ_LOG_DHCP", option_bool(OPT_LOG_OPTS) ? "1" : NULL,
+                &err);
+    }
+
+    /* we need to have the event_fd around if exec fails */
+    if ((i = fcntl(event_fd, F_GETFD)) != -1)
+      fcntl(event_fd, F_SETFD, i | FD_CLOEXEC);
+    close(pipefd[0]);
+
+    p = strrchr(daemon->lease_change_command, '/');
+    if (err == 0) {
+      execl(daemon->lease_change_command,
+            p ? p + 1 : daemon->lease_change_command, action_str,
+            (is6
+             && data.action != ACTION_ARP) ? daemon->packet : daemon->dhcp_buff,
+            daemon->addrbuff, hostname, (char *) NULL);
+      err = errno;
+    }
+    /* failed, send event so the main process logs the problem */
+    send_event(event_fd, EVENT_EXEC_ERR, err, NULL);
+    _exit(0);
+  }
 }
 
 static void my_setenv(const char *name, const char *value, int *error)
 {
-  if (*error == 0)
-    {
-      if (!value)
-	unsetenv(name);
-      else if (setenv(name, value, 1) != 0)
-	*error = errno;
-    }
+  if (*error == 0) {
+    if (!value)
+      unsetenv(name);
+    else if (setenv(name, value, 1) != 0)
+      *error = errno;
+  }
 }
- 
-static unsigned char *grab_extradata(unsigned char *buf, unsigned char *end,  char *env, int *err)
+
+static unsigned char *grab_extradata(unsigned char *buf, unsigned char *end,
+                                     char *env, int *err)
 {
   unsigned char *next = NULL;
   char *val = NULL;
 
-  if (buf && (buf != end))
-    {
-      for (next = buf; ; next++)
-	if (next == end)
-	  {
-	    next = NULL;
-	    break;
-	  }
-	else if (*next == 0)
-	  break;
-
-      if (next && (next != buf))
-	{
-	  char *p;
-	  /* No "=" in value */
-	  if ((p = strchr((char *)buf, '=')))
-	    *p = 0;
-	  val = (char *)buf;
-	}
+  if (buf && (buf != end)) {
+    for (next = buf;; next++)
+      if (next == end) {
+        next = NULL;
+        break;
+      } else if (*next == 0)
+        break;
+
+    if (next && (next != buf)) {
+      char *p;
+      /* No "=" in value */
+      if ((p = strchr((char *) buf, '=')))
+        *p = 0;
+      val = (char *) buf;
     }
-  
+  }
+
   my_setenv(env, val, err);
-   
+
   return next ? next + 1 : NULL;
 }
 
 #ifdef HAVE_LUASCRIPT
-static unsigned char *grab_extradata_lua(unsigned char *buf, unsigned char *end, char *field)
+static unsigned char *grab_extradata_lua(unsigned char *buf, unsigned char *end,
+                                         char *field)
 {
   unsigned char *next;
 
@@ -703,12 +648,11 @@
   for (next = buf; *next != 0; next++)
     if (next == end)
       return NULL;
-  
-  if (next != buf)
-    {
-      lua_pushstring(lua,  (char *)buf);
-      lua_setfield(lua, -2, field);
-    }
+
+  if (next != buf) {
+    lua_pushstring(lua, (char *) buf);
+    lua_setfield(lua, -2, field);
+  }
 
   return next + 1;
 }
@@ -716,30 +660,30 @@
 
 static void buff_alloc(size_t size)
 {
-  if (size > buf_size)
-    {
-      struct script_data *new;
-      
-      /* start with reasonable size, will almost never need extending. */
-      if (size < sizeof(struct script_data) + 200)
-	size = sizeof(struct script_data) + 200;
-
-      if (!(new = whine_malloc(size)))
-	return;
-      if (buf)
-	free(buf);
-      buf = new;
-      buf_size = size;
-    }
+  if (size > buf_size) {
+    struct script_data *new;
+
+    /* start with reasonable size, will almost never need extending. */
+    if (size < sizeof(struct script_data) + 200)
+      size = sizeof(struct script_data) + 200;
+
+    if (!(new = whine_malloc(size)))
+      return;
+    if (buf)
+      free(buf);
+    buf = new;
+    buf_size = size;
+  }
 }
 
-/* pack up lease data into a buffer */    
-void queue_script(int action, struct dhcp_lease *lease, char *hostname, time_t now)
+/* pack up lease data into a buffer */
+void queue_script(int action, struct dhcp_lease *lease, char *hostname,
+                  time_t now)
 {
   unsigned char *p;
   unsigned int hostname_len = 0, clid_len = 0, ed_len = 0;
   int fd = daemon->dhcpfd;
-#ifdef HAVE_DHCP6 
+#ifdef HAVE_DHCP6
   if (!daemon->dhcp)
     fd = daemon->dhcp6fd;
 #endif
@@ -755,11 +699,11 @@
   if (hostname)
     hostname_len = strlen(hostname) + 1;
 
-  buff_alloc(sizeof(struct script_data) +  clid_len + ed_len + hostname_len);
+  buff_alloc(sizeof(struct script_data) + clid_len + ed_len + hostname_len);
 
   buf->action = action;
   buf->flags = lease->flags;
-#ifdef HAVE_DHCP6 
+#ifdef HAVE_DHCP6
   buf->vendorclass_count = lease->vendorclass_count;
   buf->addr6 = lease->addr6;
   buf->iaid = lease->iaid;
@@ -774,35 +718,32 @@
   memcpy(buf->hwaddr, lease->hwaddr, DHCP_CHADDR_MAX);
   if (!indextoname(fd, lease->last_interface, buf->interface))
     buf->interface[0] = 0;
-  
-#ifdef HAVE_BROKEN_RTC 
+
+#ifdef HAVE_BROKEN_RTC
   buf->length = lease->length;
 #else
   buf->expires = lease->expires;
 #endif
 
   if (lease->expires != 0)
-    buf->remaining_time = (unsigned int)difftime(lease->expires, now);
+    buf->remaining_time = (unsigned int) difftime(lease->expires, now);
   else
     buf->remaining_time = 0;
 
-  p = (unsigned char *)(buf+1);
-  if (clid_len != 0)
-    {
-      memcpy(p, lease->clid, clid_len);
-      p += clid_len;
-    }
-  if (hostname_len != 0)
-    {
-      memcpy(p, hostname, hostname_len);
-      p += hostname_len;
-    }
-  if (ed_len != 0)
-    {
-      memcpy(p, lease->extradata, ed_len);
-      p += ed_len;
-    }
-  bytes_in_buf = p - (unsigned char *)buf;
+  p = (unsigned char *) (buf + 1);
+  if (clid_len != 0) {
+    memcpy(p, lease->clid, clid_len);
+    p += clid_len;
+  }
+  if (hostname_len != 0) {
+    memcpy(p, hostname, hostname_len);
+    p += hostname_len;
+  }
+  if (ed_len != 0) {
+    memcpy(p, lease->extradata, ed_len);
+    p += ed_len;
+  }
+  bytes_in_buf = p - (unsigned char *) buf;
 }
 
 #ifdef HAVE_TFTP
@@ -814,9 +755,9 @@
   /* no script */
   if (daemon->helperfd == -1)
     return;
-  
+
   filename_len = strlen(filename) + 1;
-  buff_alloc(sizeof(struct script_data) +  filename_len);
+  buff_alloc(sizeof(struct script_data) + filename_len);
   memset(buf, 0, sizeof(struct script_data));
 
   buf->action = ACTION_TFTP;
@@ -830,33 +771,34 @@
     buf->addr6 = peer->in6.sin6_addr;
 #endif
 
-  memcpy((unsigned char *)(buf+1), filename, filename_len);
-  
-  bytes_in_buf = sizeof(struct script_data) +  filename_len;
+  memcpy((unsigned char *) (buf + 1), filename, filename_len);
+
+  bytes_in_buf = sizeof(struct script_data) + filename_len;
 }
 #endif
 
-void queue_arp(int action, unsigned char *mac, int maclen, int family, struct all_addr *addr)
+void queue_arp(int action, unsigned char *mac, int maclen, int family,
+               struct all_addr *addr)
 {
   /* no script */
   if (daemon->helperfd == -1)
     return;
-  
+
   buff_alloc(sizeof(struct script_data));
   memset(buf, 0, sizeof(struct script_data));
 
   buf->action = action;
   buf->hwaddr_len = maclen;
-  buf->hwaddr_type =  ARPHRD_ETHER; 
+  buf->hwaddr_type = ARPHRD_ETHER;
   if ((buf->flags = family) == AF_INET)
     buf->addr = addr->addr.addr4;
 #ifdef HAVE_IPV6
   else
     buf->addr6 = addr->addr.addr6;
 #endif
-  
+
   memcpy(buf->hwaddr, mac, maclen);
-  
+
   bytes_in_buf = sizeof(struct script_data);
 }
 
@@ -871,22 +813,16 @@
 
   if (bytes_in_buf == 0)
     return;
-  
-  if ((rc = write(daemon->helperfd, buf, bytes_in_buf)) != -1)
-    {
-      if (bytes_in_buf != (size_t)rc)
-	memmove(buf, buf + rc, bytes_in_buf - rc); 
-      bytes_in_buf -= rc;
-    }
-  else
-    {
-      if (errno == EAGAIN || errno == EINTR)
-	return;
-      bytes_in_buf = 0;
-    }
+
+  if ((rc = write(daemon->helperfd, buf, bytes_in_buf)) != -1) {
+    if (bytes_in_buf != (size_t) rc)
+      memmove(buf, buf + rc, bytes_in_buf - rc);
+    bytes_in_buf -= rc;
+  } else {
+    if (errno == EAGAIN || errno == EINTR)
+      return;
+    bytes_in_buf = 0;
+  }
 }
 
 #endif
-
-
-
Index: dnsmasq-2.78/src/inotify.c
===================================================================
--- dnsmasq-2.78.orig/src/inotify.c	2017-10-02 21:13:51.000000000 +0800
+++ dnsmasq-2.78/src/inotify.c	2018-10-29 16:14:19.417440025 +0800
@@ -18,7 +18,7 @@
 #ifdef HAVE_INOTIFY
 
 #include <sys/inotify.h>
-#include <sys/param.h> /* For MAXSYMLINKS */
+#include <sys/param.h>          /* For MAXSYMLINKS */
 
 /* the strategy is to set a inotify on the directories containing
    resolv files, for any files in the directory which are close-write 
@@ -45,44 +45,37 @@
   ssize_t rc, size = 64;
   char *buf;
 
-  while (1)
-    {
-      buf = safe_malloc(size);
-      rc = readlink(path, buf, (size_t)size);
-      
-      if (rc == -1)
-	{
-	  /* Not link or doesn't exist. */
-	  if (errno == EINVAL || errno == ENOENT)
-	    {
-	      free(buf);
-	      return NULL;
-	    }
-	  else
-	    die(_("cannot access path %s: %s"), path, EC_MISC);
-	}
-      else if (rc < size-1)
-	{
-	  char *d;
-	  
-	  buf[rc] = 0;
-	  if (buf[0] != '/' && ((d = strrchr(path, '/'))))
-	    {
-	      /* Add path to relative link */
-	      char *new_buf = safe_malloc((d - path) + strlen(buf) + 2);
-	      *(d+1) = 0;
-	      strcpy(new_buf, path);
-	      strcat(new_buf, buf);
-	      free(buf);
-	      buf = new_buf;
-	    }
-	  return buf;
-	}
-
-      /* Buffer too small, increase and retry */
-      size += 64;
-      free(buf);
+  while (1) {
+    buf = safe_malloc(size);
+    rc = readlink(path, buf, (size_t) size);
+
+    if (rc == -1) {
+      /* Not link or doesn't exist. */
+      if (errno == EINVAL || errno == ENOENT) {
+        free(buf);
+        return NULL;
+      } else
+        die(_("cannot access path %s: %s"), path, EC_MISC);
+    } else if (rc < size - 1) {
+      char *d;
+
+      buf[rc] = 0;
+      if (buf[0] != '/' && ((d = strrchr(path, '/')))) {
+        /* Add path to relative link */
+        char *new_buf = safe_malloc((d - path) + strlen(buf) + 2);
+        *(d + 1) = 0;
+        strcpy(new_buf, path);
+        strcat(new_buf, buf);
+        free(buf);
+        buf = new_buf;
+      }
+      return buf;
     }
+
+    /* Buffer too small, increase and retry */
+    size += 64;
+    free(buf);
+  }
 }
 
 void inotify_dnsmasq_init()
@@ -90,122 +83,119 @@
   struct resolvc *res;
   inotify_buffer = safe_malloc(INOTIFY_SZ);
   daemon->inotifyfd = inotify_init1(IN_NONBLOCK | IN_CLOEXEC);
-  
+
   if (daemon->inotifyfd == -1)
     die(_("failed to create inotify: %s"), NULL, EC_MISC);
 
   if (option_bool(OPT_NO_RESOLV))
     return;
-  
-  for (res = daemon->resolv_files; res; res = res->next)
-    {
-      char *d, *new_path, *path = safe_malloc(strlen(res->name) + 1);
-      int links = MAXSYMLINKS;
-
-      strcpy(path, res->name);
-
-      /* Follow symlinks until we reach a non-symlink, or a non-existent file. */
-      while ((new_path = my_readlink(path)))
-	{
-	  if (links-- == 0)
-	    die(_("too many symlinks following %s"), res->name, EC_MISC);
-	  free(path);
-	  path = new_path;
-	}
-
-      res->wd = -1;
-
-      if ((d = strrchr(path, '/')))
-	{
-	  *d = 0; /* make path just directory */
-	  res->wd = inotify_add_watch(daemon->inotifyfd, path, IN_CLOSE_WRITE | IN_MOVED_TO);
-
-	  res->file = d+1; /* pointer to filename */
-	  *d = '/';
-	  
-	  if (res->wd == -1 && errno == ENOENT)
-	    die(_("directory %s for resolv-file is missing, cannot poll"), res->name, EC_MISC);
-	}	  
-	 
-      if (res->wd == -1)
-	die(_("failed to create inotify for %s: %s"), res->name, EC_MISC);
-	
+
+  for (res = daemon->resolv_files; res; res = res->next) {
+    char *d, *new_path, *path = safe_malloc(strlen(res->name) + 1);
+    int links = MAXSYMLINKS;
+
+    strcpy(path, res->name);
+
+    /* Follow symlinks until we reach a non-symlink, or a non-existent file. */
+    while ((new_path = my_readlink(path))) {
+      if (links-- == 0)
+        die(_("too many symlinks following %s"), res->name, EC_MISC);
+      free(path);
+      path = new_path;
+    }
+
+    res->wd = -1;
+
+    if ((d = strrchr(path, '/'))) {
+      *d = 0;                   /* make path just directory */
+      res->wd =
+          inotify_add_watch(daemon->inotifyfd, path,
+                            IN_CLOSE_WRITE | IN_MOVED_TO);
+
+      res->file = d + 1;        /* pointer to filename */
+      *d = '/';
+
+      if (res->wd == -1 && errno == ENOENT)
+        die(_("directory %s for resolv-file is missing, cannot poll"),
+            res->name, EC_MISC);
     }
+
+    if (res->wd == -1)
+      die(_("failed to create inotify for %s: %s"), res->name, EC_MISC);
+
+  }
 }
 
 
 /* initialisation for dynamic-dir. Set inotify watch for each directory, and read pre-existing files */
-void set_dynamic_inotify(int flag, int total_size, struct crec **rhash, int revhashsz)
+void set_dynamic_inotify(int flag, int total_size, struct crec **rhash,
+                         int revhashsz)
 {
   struct hostsfile *ah;
-  
-  for (ah = daemon->dynamic_dirs; ah; ah = ah->next)
-    {
-      DIR *dir_stream = NULL;
-      struct dirent *ent;
-      struct stat buf;
-     
-      if (!(ah->flags & flag))
-	continue;
- 
-      if (stat(ah->fname, &buf) == -1 || !(S_ISDIR(buf.st_mode)))
-	{
-	  my_syslog(LOG_ERR, _("bad dynamic directory %s: %s"), 
-		    ah->fname, strerror(errno));
-	  continue;
-	}
-      
-       if (!(ah->flags & AH_WD_DONE))
-	 {
-	   ah->wd = inotify_add_watch(daemon->inotifyfd, ah->fname, IN_CLOSE_WRITE | IN_MOVED_TO);
-	   ah->flags |= AH_WD_DONE;
-	 }
-
-       /* Read contents of dir _after_ calling add_watch, in the hope of avoiding
-	  a race which misses files being added as we start */
-       if (ah->wd == -1 || !(dir_stream = opendir(ah->fname)))
-	 {
-	   my_syslog(LOG_ERR, _("failed to create inotify for %s: %s"),
-		     ah->fname, strerror(errno));
-	   continue;
-	 }
-
-       while ((ent = readdir(dir_stream)))
-	 {
-	   size_t lendir = strlen(ah->fname);
-	   size_t lenfile = strlen(ent->d_name);
-	   char *path;
-	   
-	   /* ignore emacs backups and dotfiles */
-	   if (lenfile == 0 || 
-	       ent->d_name[lenfile - 1] == '~' ||
-	       (ent->d_name[0] == '#' && ent->d_name[lenfile - 1] == '#') ||
-	       ent->d_name[0] == '.')
-	     continue;
-	   
-	   if ((path = whine_malloc(lendir + lenfile + 2)))
-	     {
-	       strcpy(path, ah->fname);
-	       strcat(path, "/");
-	       strcat(path, ent->d_name);
-	       
-	       /* ignore non-regular files */
-	       if (stat(path, &buf) != -1 && S_ISREG(buf.st_mode))
-		 {
-		   if (ah->flags & AH_HOSTS)
-		     total_size = read_hostsfile(path, ah->index, total_size, rhash, revhashsz);
+
+  for (ah = daemon->dynamic_dirs; ah; ah = ah->next) {
+    DIR *dir_stream = NULL;
+    struct dirent *ent;
+    struct stat buf;
+
+    if (!(ah->flags & flag))
+      continue;
+
+    if (stat(ah->fname, &buf) == -1 || !(S_ISDIR(buf.st_mode))) {
+      my_syslog(LOG_ERR, _("bad dynamic directory %s: %s"),
+                ah->fname, strerror(errno));
+      continue;
+    }
+
+    if (!(ah->flags & AH_WD_DONE)) {
+      ah->wd =
+          inotify_add_watch(daemon->inotifyfd, ah->fname,
+                            IN_CLOSE_WRITE | IN_MOVED_TO);
+      ah->flags |= AH_WD_DONE;
+    }
+
+    /* Read contents of dir _after_ calling add_watch, in the hope of avoiding
+       a race which misses files being added as we start */
+    if (ah->wd == -1 || !(dir_stream = opendir(ah->fname))) {
+      my_syslog(LOG_ERR, _("failed to create inotify for %s: %s"),
+                ah->fname, strerror(errno));
+      continue;
+    }
+
+    while ((ent = readdir(dir_stream))) {
+      size_t lendir = strlen(ah->fname);
+      size_t lenfile = strlen(ent->d_name);
+      char *path;
+
+      /* ignore emacs backups and dotfiles */
+      if (lenfile == 0 ||
+          ent->d_name[lenfile - 1] == '~' ||
+          (ent->d_name[0] == '#' && ent->d_name[lenfile - 1] == '#') ||
+          ent->d_name[0] == '.')
+        continue;
+
+      if ((path = whine_malloc(lendir + lenfile + 2))) {
+        strcpy(path, ah->fname);
+        strcat(path, "/");
+        strcat(path, ent->d_name);
+
+        /* ignore non-regular files */
+        if (stat(path, &buf) != -1 && S_ISREG(buf.st_mode)) {
+          if (ah->flags & AH_HOSTS)
+            total_size =
+                read_hostsfile(path, ah->index, total_size, rhash, revhashsz);
 #ifdef HAVE_DHCP
-		   else if (ah->flags & (AH_DHCP_HST | AH_DHCP_OPT))
-		     option_read_dynfile(path, ah->flags);
-#endif		   
-		 }
-
-	       free(path);
-	     }
-	 }
+          else if (ah->flags & (AH_DHCP_HST | AH_DHCP_OPT))
+            option_read_dynfile(path, ah->flags);
+#endif
+        }
 
-       closedir(dir_stream);
+        free(path);
+      }
     }
+
+    closedir(dir_stream);
+  }
 }
 
 int inotify_check(time_t now)
@@ -213,84 +203,78 @@
   int hit = 0;
   struct hostsfile *ah;
 
-  while (1)
-    {
-      int rc;
-      char *p;
-      struct resolvc *res;
-      struct inotify_event *in;
-
-      while ((rc = read(daemon->inotifyfd, inotify_buffer, INOTIFY_SZ)) == -1 && errno == EINTR);
-      
-      if (rc <= 0)
-	break;
-      
-      for (p = inotify_buffer; rc - (p - inotify_buffer) >= (int)sizeof(struct inotify_event); p += sizeof(struct inotify_event) + in->len) 
-	{
-	  in = (struct inotify_event*)p;
-	  
-	  for (res = daemon->resolv_files; res; res = res->next)
-	    if (res->wd == in->wd && in->len != 0 && strcmp(res->file, in->name) == 0)
-	      hit = 1;
-
-	  /* ignore emacs backups and dotfiles */
-	  if (in->len == 0 || 
-	      in->name[in->len - 1] == '~' ||
-	      (in->name[0] == '#' && in->name[in->len - 1] == '#') ||
-	      in->name[0] == '.')
-	    continue;
-	  
-	  for (ah = daemon->dynamic_dirs; ah; ah = ah->next)
-	    if (ah->wd == in->wd)
-	      {
-		size_t lendir = strlen(ah->fname);
-		char *path;
-		
-		if ((path = whine_malloc(lendir + in->len + 2)))
-		  {
-		    strcpy(path, ah->fname);
-		    strcat(path, "/");
-		    strcat(path, in->name);
-		     
-		    my_syslog(LOG_INFO, _("inotify, new or changed file %s"), path);
-
-		    if (ah->flags & AH_HOSTS)
-		      {
-			read_hostsfile(path, ah->index, 0, NULL, 0);
+  while (1) {
+    int rc;
+    char *p;
+    struct resolvc *res;
+    struct inotify_event *in;
+
+    while ((rc = read(daemon->inotifyfd, inotify_buffer, INOTIFY_SZ)) == -1
+           && errno == EINTR);
+
+    if (rc <= 0)
+      break;
+
+    for (p = inotify_buffer;
+         rc - (p - inotify_buffer) >= (int) sizeof(struct inotify_event);
+         p += sizeof(struct inotify_event) + in->len) {
+      in = (struct inotify_event *) p;
+
+      for (res = daemon->resolv_files; res; res = res->next)
+        if (res->wd == in->wd && in->len != 0
+            && strcmp(res->file, in->name) == 0)
+          hit = 1;
+
+      /* ignore emacs backups and dotfiles */
+      if (in->len == 0 ||
+          in->name[in->len - 1] == '~' ||
+          (in->name[0] == '#' && in->name[in->len - 1] == '#') ||
+          in->name[0] == '.')
+        continue;
+
+      for (ah = daemon->dynamic_dirs; ah; ah = ah->next)
+        if (ah->wd == in->wd) {
+          size_t lendir = strlen(ah->fname);
+          char *path;
+
+          if ((path = whine_malloc(lendir + in->len + 2))) {
+            strcpy(path, ah->fname);
+            strcat(path, "/");
+            strcat(path, in->name);
+
+            my_syslog(LOG_INFO, _("inotify, new or changed file %s"), path);
+
+            if (ah->flags & AH_HOSTS) {
+              read_hostsfile(path, ah->index, 0, NULL, 0);
 #ifdef HAVE_DHCP
-			if (daemon->dhcp || daemon->doing_dhcp6) 
-			  {
-			    /* Propagate the consequences of loading a new dhcp-host */
-			    dhcp_update_configs(daemon->dhcp_conf);
-			    lease_update_from_configs(); 
-			    lease_update_file(now); 
-			    lease_update_dns(1);
-			  }
+              if (daemon->dhcp || daemon->doing_dhcp6) {
+                /* Propagate the consequences of loading a new dhcp-host */
+                dhcp_update_configs(daemon->dhcp_conf);
+                lease_update_from_configs();
+                lease_update_file(now);
+                lease_update_dns(1);
+              }
 #endif
-		      }
+            }
 #ifdef HAVE_DHCP
-		    else if (ah->flags & AH_DHCP_HST)
-		      {
-			if (option_read_dynfile(path, AH_DHCP_HST))
-			  {
-			    /* Propagate the consequences of loading a new dhcp-host */
-			    dhcp_update_configs(daemon->dhcp_conf);
-			    lease_update_from_configs(); 
-			    lease_update_file(now); 
-			    lease_update_dns(1);
-			  }
-		      }
-		    else if (ah->flags & AH_DHCP_OPT)
-		      option_read_dynfile(path, AH_DHCP_OPT);
+            else if (ah->flags & AH_DHCP_HST) {
+              if (option_read_dynfile(path, AH_DHCP_HST)) {
+                /* Propagate the consequences of loading a new dhcp-host */
+                dhcp_update_configs(daemon->dhcp_conf);
+                lease_update_from_configs();
+                lease_update_file(now);
+                lease_update_dns(1);
+              }
+            } else if (ah->flags & AH_DHCP_OPT)
+              option_read_dynfile(path, AH_DHCP_OPT);
 #endif
-		    
-		    free(path);
-		  }
-	      }
-	}
+
+            free(path);
+          }
+        }
     }
+  }
   return hit;
 }
 
-#endif  /* INOTIFY */
-  
+#endif                          /* INOTIFY */
Index: dnsmasq-2.78/src/ip6addr.h
===================================================================
--- dnsmasq-2.78.orig/src/ip6addr.h	2017-10-02 21:13:51.000000000 +0800
+++ dnsmasq-2.78/src/ip6addr.h	2018-10-29 16:14:19.421440025 +0800
@@ -31,4 +31,3 @@
          && ((__const uint32_t *) (a))[1] == 0                                \
          && ((__const uint32_t *) (a))[2] == 0                                \
          && ((__const uint32_t *) (a))[3] == 0)
-
Index: dnsmasq-2.78/src/ipset.c
===================================================================
--- dnsmasq-2.78.orig/src/ipset.c	2017-10-02 21:13:51.000000000 +0800
+++ dnsmasq-2.78/src/ipset.c	2018-10-29 16:14:19.421440025 +0800
@@ -56,14 +56,14 @@
 #endif
 
 struct my_nlattr {
-        __u16           nla_len;
-        __u16           nla_type;
+  __u16 nla_len;
+  __u16 nla_type;
 };
 
 struct my_nfgenmsg {
-        __u8  nfgen_family;             /* AF_xxx */
-        __u8  version;          /* nfnetlink version */
-        __be16    res_id;               /* resource id */
+  __u8 nfgen_family;            /* AF_xxx */
+  __u8 version;                 /* nfnetlink version */
+  __be16 res_id;                /* resource id */
 };
 
 
@@ -71,17 +71,19 @@
 #define BUFF_SZ 256
 
 #define NL_ALIGN(len) (((len)+3) & ~(3))
-static const struct sockaddr_nl snl = { .nl_family = AF_NETLINK };
+static const struct sockaddr_nl snl = {.nl_family = AF_NETLINK };
+
 static int ipset_sock, old_kernel;
 static char *buffer;
 
-static inline void add_attr(struct nlmsghdr *nlh, uint16_t type, size_t len, const void *data)
+static inline void add_attr(struct nlmsghdr *nlh, uint16_t type, size_t len,
+                            const void *data)
 {
-  struct my_nlattr *attr = (void *)nlh + NL_ALIGN(nlh->nlmsg_len);
+  struct my_nlattr *attr = (void *) nlh + NL_ALIGN(nlh->nlmsg_len);
   uint16_t payload_len = NL_ALIGN(sizeof(struct my_nlattr)) + len;
   attr->nla_type = type;
   attr->nla_len = payload_len;
-  memcpy((void *)attr + NL_ALIGN(sizeof(struct my_nlattr)), data, len);
+  memcpy((void *) attr + NL_ALIGN(sizeof(struct my_nlattr)), data, len);
   nlh->nlmsg_len += NL_ALIGN(payload_len);
 }
 
@@ -90,31 +92,32 @@
   struct utsname utsname;
   int version;
   char *split;
-  
+
   if (uname(&utsname) < 0)
     die(_("failed to find kernel version: %s"), NULL, EC_MISC);
-  
+
   split = strtok(utsname.release, ".");
   version = (split ? atoi(split) : 0);
   split = strtok(NULL, ".");
   version = version * 256 + (split ? atoi(split) : 0);
   split = strtok(NULL, ".");
   version = version * 256 + (split ? atoi(split) : 0);
-  old_kernel = (version < KERNEL_VERSION(2,6,32));
-  
+  old_kernel = (version < KERNEL_VERSION(2, 6, 32));
+
   if (old_kernel && (ipset_sock = socket(AF_INET, SOCK_RAW, IPPROTO_RAW)) != -1)
     return;
-  
-  if (!old_kernel && 
+
+  if (!old_kernel &&
       (buffer = safe_malloc(BUFF_SZ)) &&
       (ipset_sock = socket(AF_NETLINK, SOCK_RAW, NETLINK_NETFILTER)) != -1 &&
-      (bind(ipset_sock, (struct sockaddr *)&snl, sizeof(snl)) != -1))
+      (bind(ipset_sock, (struct sockaddr *) &snl, sizeof(snl)) != -1))
     return;
-  
-  die (_("failed to create IPset control socket: %s"), NULL, EC_MISC);
+
+  die(_("failed to create IPset control socket: %s"), NULL, EC_MISC);
 }
 
-static int new_add_to_ipset(const char *setname, const struct all_addr *ipaddr, int af, int remove)
+static int new_add_to_ipset(const char *setname, const struct all_addr *ipaddr,
+                            int af, int remove)
 {
   struct nlmsghdr *nlh;
   struct my_nfgenmsg *nfg;
@@ -126,49 +129,53 @@
   if (af == AF_INET6)
     addrsz = IN6ADDRSZ;
 #endif
-    
-  if (strlen(setname) >= IPSET_MAXNAMELEN) 
-    {
-      errno = ENAMETOOLONG;
-      return -1;
-    }
-  
+
+  if (strlen(setname) >= IPSET_MAXNAMELEN) {
+    errno = ENAMETOOLONG;
+    return -1;
+  }
+
   memset(buffer, 0, BUFF_SZ);
 
-  nlh = (struct nlmsghdr *)buffer;
+  nlh = (struct nlmsghdr *) buffer;
   nlh->nlmsg_len = NL_ALIGN(sizeof(struct nlmsghdr));
-  nlh->nlmsg_type = (remove ? IPSET_CMD_DEL : IPSET_CMD_ADD) | (NFNL_SUBSYS_IPSET << 8);
+  nlh->nlmsg_type =
+      (remove ? IPSET_CMD_DEL : IPSET_CMD_ADD) | (NFNL_SUBSYS_IPSET << 8);
   nlh->nlmsg_flags = NLM_F_REQUEST;
-  
-  nfg = (struct my_nfgenmsg *)(buffer + nlh->nlmsg_len);
+
+  nfg = (struct my_nfgenmsg *) (buffer + nlh->nlmsg_len);
   nlh->nlmsg_len += NL_ALIGN(sizeof(struct my_nfgenmsg));
   nfg->nfgen_family = af;
   nfg->version = NFNETLINK_V0;
   nfg->res_id = htons(0);
-  
+
   proto = IPSET_PROTOCOL;
   add_attr(nlh, IPSET_ATTR_PROTOCOL, sizeof(proto), &proto);
   add_attr(nlh, IPSET_ATTR_SETNAME, strlen(setname) + 1, setname);
-  nested[0] = (struct my_nlattr *)(buffer + NL_ALIGN(nlh->nlmsg_len));
+  nested[0] = (struct my_nlattr *) (buffer + NL_ALIGN(nlh->nlmsg_len));
   nlh->nlmsg_len += NL_ALIGN(sizeof(struct my_nlattr));
   nested[0]->nla_type = NLA_F_NESTED | IPSET_ATTR_DATA;
-  nested[1] = (struct my_nlattr *)(buffer + NL_ALIGN(nlh->nlmsg_len));
+  nested[1] = (struct my_nlattr *) (buffer + NL_ALIGN(nlh->nlmsg_len));
   nlh->nlmsg_len += NL_ALIGN(sizeof(struct my_nlattr));
   nested[1]->nla_type = NLA_F_NESTED | IPSET_ATTR_IP;
-  add_attr(nlh, 
-	   (af == AF_INET ? IPSET_ATTR_IPADDR_IPV4 : IPSET_ATTR_IPADDR_IPV6) | NLA_F_NET_BYTEORDER,
-	   addrsz, &ipaddr->addr);
-  nested[1]->nla_len = (void *)buffer + NL_ALIGN(nlh->nlmsg_len) - (void *)nested[1];
-  nested[0]->nla_len = (void *)buffer + NL_ALIGN(nlh->nlmsg_len) - (void *)nested[0];
-	
+  add_attr(nlh,
+           (af ==
+            AF_INET ? IPSET_ATTR_IPADDR_IPV4 : IPSET_ATTR_IPADDR_IPV6) |
+           NLA_F_NET_BYTEORDER, addrsz, &ipaddr->addr);
+  nested[1]->nla_len =
+      (void *) buffer + NL_ALIGN(nlh->nlmsg_len) - (void *) nested[1];
+  nested[0]->nla_len =
+      (void *) buffer + NL_ALIGN(nlh->nlmsg_len) - (void *) nested[0];
+
   while (retry_send(sendto(ipset_sock, buffer, nlh->nlmsg_len, 0,
-			   (struct sockaddr *)&snl, sizeof(snl))));
-								    
+                           (struct sockaddr *) &snl, sizeof(snl))));
+
   return errno == 0 ? 0 : -1;
 }
 
 
-static int old_add_to_ipset(const char *setname, const struct all_addr *ipaddr, int remove)
+static int old_add_to_ipset(const char *setname, const struct all_addr *ipaddr,
+                            int remove)
 {
   socklen_t size;
   struct ip_set_req_adt_get {
@@ -185,13 +192,12 @@
     uint16_t index;
     uint32_t ip;
   } req_adt;
-  
-  if (strlen(setname) >= sizeof(req_adt_get.set.name)) 
-    {
-      errno = ENAMETOOLONG;
-      return -1;
-    }
-  
+
+  if (strlen(setname) >= sizeof(req_adt_get.set.name)) {
+    errno = ENAMETOOLONG;
+    return -1;
+  }
+
   req_adt_get.op = 0x10;
   req_adt_get.version = 3;
   strcpy(req_adt_get.set.name, setname);
@@ -203,34 +209,38 @@
   req_adt.ip = ntohl(ipaddr->addr.addr4.s_addr);
   if (setsockopt(ipset_sock, SOL_IP, 83, &req_adt, sizeof(req_adt)) < 0)
     return -1;
-  
+
   return 0;
 }
 
 
 
-int add_to_ipset(const char *setname, const struct all_addr *ipaddr, int flags, int remove)
+int add_to_ipset(const char *setname, const struct all_addr *ipaddr, int flags,
+                 int remove)
 {
   int ret = 0, af = AF_INET;
 
 #ifdef HAVE_IPV6
-  if (flags & F_IPV6)
-    {
-      af = AF_INET6;
-      /* old method only supports IPv4 */
-      if (old_kernel)
-	{
-	  errno = EAFNOSUPPORT ;
-	  ret = -1;
-	}
+  if (flags & F_IPV6) {
+    af = AF_INET6;
+    /* old method only supports IPv4 */
+    if (old_kernel) {
+      errno = EAFNOSUPPORT;
+      ret = -1;
     }
+  }
 #endif
-  
-  if (ret != -1) 
-    ret = old_kernel ? old_add_to_ipset(setname, ipaddr, remove) : new_add_to_ipset(setname, ipaddr, af, remove);
+
+  if (ret != -1)
+    ret =
+        old_kernel ? old_add_to_ipset(setname, ipaddr,
+                                      remove) : new_add_to_ipset(setname,
+                                                                 ipaddr, af,
+                                                                 remove);
 
   if (ret == -1)
-     my_syslog(LOG_ERR, _("failed to update ipset %s: %s"), setname, strerror(errno));
+    my_syslog(LOG_ERR, _("failed to update ipset %s: %s"), setname,
+              strerror(errno));
 
   return ret;
 }
Index: dnsmasq-2.78/src/lease.c
===================================================================
--- dnsmasq-2.78.orig/src/lease.c	2017-10-02 21:13:51.000000000 +0800
+++ dnsmasq-2.78/src/lease.c	2018-10-29 16:14:19.425440025 +0800
@@ -21,7 +21,7 @@
 static struct dhcp_lease *leases = NULL, *old_leases = NULL;
 static int dns_dirty, file_dirty, leases_left;
 
-static int read_leases(time_t now, FILE *leasestream)
+static int read_leases(time_t now, FILE * leasestream)
 {
   unsigned long ei;
   struct all_addr addr;
@@ -38,96 +38,99 @@
      Check various buffers are big enough for the code below */
 
 #if (DHCP_BUFF_SZ < 255) || (MAXDNAME < 64) || (PACKETSZ+MAXDNAME+RRFIXEDSZ  < 764)
-# error Buffer size breakage in leasefile parsing.
+#error Buffer size breakage in leasefile parsing.
 #endif
 
-    while ((items=fscanf(leasestream, "%255s %255s", daemon->dhcp_buff3, daemon->dhcp_buff2)) == 2)
-      {
-	*daemon->namebuff = *daemon->dhcp_buff = *daemon->packet = '\0';
-	hw_len = hw_type = clid_len = 0;
-	
-#ifdef HAVE_DHCP6
-	if (strcmp(daemon->dhcp_buff3, "duid") == 0)
-	  {
-	    daemon->duid_len = parse_hex(daemon->dhcp_buff2, (unsigned char *)daemon->dhcp_buff2, 130, NULL, NULL);
-	    if (daemon->duid_len < 0)
-	      return 0;
-	    daemon->duid = safe_malloc(daemon->duid_len);
-	    memcpy(daemon->duid, daemon->dhcp_buff2, daemon->duid_len);
-	    continue;
-	  }
-#endif
-	
-	if (fscanf(leasestream, " %64s %255s %764s",
-		   daemon->namebuff, daemon->dhcp_buff, daemon->packet) != 3)
-	  return 0;
-	
-	if (inet_pton(AF_INET, daemon->namebuff, &addr.addr.addr4))
-	  {
-	    if ((lease = lease4_allocate(addr.addr.addr4)))
-	      domain = get_domain(lease->addr);
-	    
-	    hw_len = parse_hex(daemon->dhcp_buff2, (unsigned char *)daemon->dhcp_buff2, DHCP_CHADDR_MAX, NULL, &hw_type);
-	    /* For backwards compatibility, no explicit MAC address type means ether. */
-	    if (hw_type == 0 && hw_len != 0)
-	      hw_type = ARPHRD_ETHER; 
-	  }
-#ifdef HAVE_DHCP6
-	else if (inet_pton(AF_INET6, daemon->namebuff, &addr.addr.addr6))
-	  {
-	    char *s = daemon->dhcp_buff2;
-	    int lease_type = LEASE_NA;
-
-	    if (s[0] == 'T')
-	      {
-		lease_type = LEASE_TA;
-		s++;
-	      }
-	    
-	    if ((lease = lease6_allocate(&addr.addr.addr6, lease_type)))
-	      {
-		lease_set_iaid(lease, strtoul(s, NULL, 10));
-		domain = get_domain6((struct in6_addr *)lease->hwaddr);
-	      }
-	  }
-#endif
-	else
-	  return 0;
-
-	if (!lease)
-	  die (_("too many stored leases"), NULL, EC_MISC);
-
-	if (strcmp(daemon->packet, "*") != 0)
-	  clid_len = parse_hex(daemon->packet, (unsigned char *)daemon->packet, 255, NULL, NULL);
-	
-	lease_set_hwaddr(lease, (unsigned char *)daemon->dhcp_buff2, (unsigned char *)daemon->packet, 
-			 hw_len, hw_type, clid_len, now, 0);
-	
-	if (strcmp(daemon->dhcp_buff, "*") !=  0)
-	  lease_set_hostname(lease, daemon->dhcp_buff, 0, domain, NULL);
+  while ((items =
+          fscanf(leasestream, "%255s %255s", daemon->dhcp_buff3,
+                 daemon->dhcp_buff2)) == 2) {
+    *daemon->namebuff = *daemon->dhcp_buff = *daemon->packet = '\0';
+    hw_len = hw_type = clid_len = 0;
+
+#ifdef HAVE_DHCP6
+    if (strcmp(daemon->dhcp_buff3, "duid") == 0) {
+      daemon->duid_len =
+          parse_hex(daemon->dhcp_buff2, (unsigned char *) daemon->dhcp_buff2,
+                    130, NULL, NULL);
+      if (daemon->duid_len < 0)
+        return 0;
+      daemon->duid = safe_malloc(daemon->duid_len);
+      memcpy(daemon->duid, daemon->dhcp_buff2, daemon->duid_len);
+      continue;
+    }
+#endif
+
+    if (fscanf(leasestream, " %64s %255s %764s",
+               daemon->namebuff, daemon->dhcp_buff, daemon->packet) != 3)
+      return 0;
+
+    if (inet_pton(AF_INET, daemon->namebuff, &addr.addr.addr4)) {
+      if ((lease = lease4_allocate(addr.addr.addr4)))
+        domain = get_domain(lease->addr);
+
+      hw_len =
+          parse_hex(daemon->dhcp_buff2, (unsigned char *) daemon->dhcp_buff2,
+                    DHCP_CHADDR_MAX, NULL, &hw_type);
+      /* For backwards compatibility, no explicit MAC address type means ether. */
+      if (hw_type == 0 && hw_len != 0)
+        hw_type = ARPHRD_ETHER;
+    }
+#ifdef HAVE_DHCP6
+    else if (inet_pton(AF_INET6, daemon->namebuff, &addr.addr.addr6)) {
+      char *s = daemon->dhcp_buff2;
+      int lease_type = LEASE_NA;
+
+      if (s[0] == 'T') {
+        lease_type = LEASE_TA;
+        s++;
+      }
 
-	ei = atol(daemon->dhcp_buff3);
+      if ((lease = lease6_allocate(&addr.addr.addr6, lease_type))) {
+        lease_set_iaid(lease, strtoul(s, NULL, 10));
+        domain = get_domain6((struct in6_addr *) lease->hwaddr);
+      }
+    }
+#endif
+    else
+      return 0;
+
+    if (!lease)
+      die(_("too many stored leases"), NULL, EC_MISC);
+
+    if (strcmp(daemon->packet, "*") != 0)
+      clid_len =
+          parse_hex(daemon->packet, (unsigned char *) daemon->packet, 255, NULL,
+                    NULL);
+
+    lease_set_hwaddr(lease, (unsigned char *) daemon->dhcp_buff2,
+                     (unsigned char *) daemon->packet, hw_len, hw_type,
+                     clid_len, now, 0);
+
+    if (strcmp(daemon->dhcp_buff, "*") != 0)
+      lease_set_hostname(lease, daemon->dhcp_buff, 0, domain, NULL);
+
+    ei = atol(daemon->dhcp_buff3);
 
 #ifdef HAVE_BROKEN_RTC
-	if (ei != 0)
-	  lease->expires = (time_t)ei + now;
-	else
-	  lease->expires = (time_t)0;
-	lease->length = ei;
+    if (ei != 0)
+      lease->expires = (time_t) ei + now;
+    else
+      lease->expires = (time_t) 0;
+    lease->length = ei;
 #else
-	/* strictly time_t is opaque, but this hack should work on all sane systems,
-	   even when sizeof(time_t) == 8 */
-	lease->expires = (time_t)ei;
-#endif
-	
-	/* set these correctly: the "old" events are generated later from
-	   the startup synthesised SIGHUP. */
-	lease->flags &= ~(LEASE_NEW | LEASE_CHANGED);
-	
-	*daemon->dhcp_buff3 = *daemon->dhcp_buff2 = '\0';
-      }
-    
-    return (items == 0 || items == EOF);
+    /* strictly time_t is opaque, but this hack should work on all sane systems,
+       even when sizeof(time_t) == 8 */
+    lease->expires = (time_t) ei;
+#endif
+
+    /* set these correctly: the "old" events are generated later from
+       the startup synthesised SIGHUP. */
+    lease->flags &= ~(LEASE_NEW | LEASE_CHANGED);
+
+    *daemon->dhcp_buff3 = *daemon->dhcp_buff2 = '\0';
+  }
+
+  return (items == 0 || items == EOF);
 }
 
 void lease_init(time_t now)
@@ -136,72 +139,68 @@
 
   leases_left = daemon->dhcp_max;
 
-  if (option_bool(OPT_LEASE_RO))
-    {
-      /* run "<lease_change_script> init" once to get the
-	 initial state of the database. If leasefile-ro is
-	 set without a script, we just do without any
-	 lease database. */
+  if (option_bool(OPT_LEASE_RO)) {
+    /* run "<lease_change_script> init" once to get the
+       initial state of the database. If leasefile-ro is
+       set without a script, we just do without any
+       lease database. */
 #ifdef HAVE_SCRIPT
-      if (daemon->lease_change_command)
-	{
-	  strcpy(daemon->dhcp_buff, daemon->lease_change_command);
-	  strcat(daemon->dhcp_buff, " init");
-	  leasestream = popen(daemon->dhcp_buff, "r");
-	}
-      else
-#endif
-	{
-          file_dirty = dns_dirty = 0;
-          return;
-        }
-
-    }
-  else
+    if (daemon->lease_change_command) {
+      strcpy(daemon->dhcp_buff, daemon->lease_change_command);
+      strcat(daemon->dhcp_buff, " init");
+      leasestream = popen(daemon->dhcp_buff, "r");
+    } else
+#endif
     {
-      /* NOTE: need a+ mode to create file if it doesn't exist */
-      leasestream = daemon->lease_stream = fopen(daemon->lease_file, "a+");
-
-      if (!leasestream)
-	die(_("cannot open or create lease file %s: %s"), daemon->lease_file, EC_FILE);
-
-      /* a+ mode leaves pointer at end. */
-      rewind(leasestream);
+      file_dirty = dns_dirty = 0;
+      return;
     }
 
-  if (leasestream)
-    {
-      if (!read_leases(now, leasestream))
-	my_syslog(MS_DHCP | LOG_ERR, _("failed to parse lease database, invalid line: %s %s %s %s ..."),
-		  daemon->dhcp_buff3, daemon->dhcp_buff2,
-		  daemon->namebuff, daemon->dhcp_buff);
-
-      if (ferror(leasestream))
-	die(_("failed to read lease file %s: %s"), daemon->lease_file, EC_FILE);
-    }
-  
+  } else {
+    /* NOTE: need a+ mode to create file if it doesn't exist */
+    leasestream = daemon->lease_stream = fopen(daemon->lease_file, "a+");
+
+    if (!leasestream)
+      die(_("cannot open or create lease file %s: %s"), daemon->lease_file,
+          EC_FILE);
+
+    /* a+ mode leaves pointer at end. */
+    rewind(leasestream);
+  }
+
+  if (leasestream) {
+    if (!read_leases(now, leasestream))
+      my_syslog(MS_DHCP | LOG_ERR,
+                _
+                ("failed to parse lease database, invalid line: %s %s %s %s ..."),
+                daemon->dhcp_buff3, daemon->dhcp_buff2, daemon->namebuff,
+                daemon->dhcp_buff);
+
+    if (ferror(leasestream))
+      die(_("failed to read lease file %s: %s"), daemon->lease_file, EC_FILE);
+  }
 #ifdef HAVE_SCRIPT
-  if (!daemon->lease_stream)
-    {
-      int rc = 0;
+  if (!daemon->lease_stream) {
+    int rc = 0;
 
-      /* shell returns 127 for "command not found", 126 for bad permissions. */
-      if (!leasestream || (rc = pclose(leasestream)) == -1 || WEXITSTATUS(rc) == 127 || WEXITSTATUS(rc) == 126)
-	{
-	  if (WEXITSTATUS(rc) == 127)
-	    errno = ENOENT;
-	  else if (WEXITSTATUS(rc) == 126)
-	    errno = EACCES;
-
-	  die(_("cannot run lease-init script %s: %s"), daemon->lease_change_command, EC_FILE);
-	}
-      
-      if (WEXITSTATUS(rc) != 0)
-	{
-	  sprintf(daemon->dhcp_buff, "%d", WEXITSTATUS(rc));
-	  die(_("lease-init script returned exit code %s"), daemon->dhcp_buff, WEXITSTATUS(rc) + EC_INIT_OFFSET);
-	}
+    /* shell returns 127 for "command not found", 126 for bad permissions. */
+    if (!leasestream || (rc = pclose(leasestream)) == -1
+        || WEXITSTATUS(rc) == 127 || WEXITSTATUS(rc) == 126) {
+      if (WEXITSTATUS(rc) == 127)
+        errno = ENOENT;
+      else if (WEXITSTATUS(rc) == 126)
+        errno = EACCES;
+
+      die(_("cannot run lease-init script %s: %s"),
+          daemon->lease_change_command, EC_FILE);
+    }
+
+    if (WEXITSTATUS(rc) != 0) {
+      sprintf(daemon->dhcp_buff, "%d", WEXITSTATUS(rc));
+      die(_("lease-init script returned exit code %s"), daemon->dhcp_buff,
+          WEXITSTATUS(rc) + EC_INIT_OFFSET);
     }
+  }
 #endif
 
   /* Some leases may have expired */
@@ -213,27 +212,30 @@
 void lease_update_from_configs(void)
 {
   /* changes to the config may change current leases. */
-  
+
   struct dhcp_lease *lease;
   struct dhcp_config *config;
   char *name;
-  
+
   for (lease = leases; lease; lease = lease->next)
     if (lease->flags & (LEASE_TA | LEASE_NA))
       continue;
-    else if ((config = find_config(daemon->dhcp_conf, NULL, lease->clid, lease->clid_len, 
-				   lease->hwaddr, lease->hwaddr_len, lease->hwaddr_type, NULL)) && 
-	     (config->flags & CONFIG_NAME) &&
-	     (!(config->flags & CONFIG_ADDR) || config->addr.s_addr == lease->addr.s_addr))
-      lease_set_hostname(lease, config->hostname, 1, get_domain(lease->addr), NULL);
+    else if ((config =
+              find_config(daemon->dhcp_conf, NULL, lease->clid, lease->clid_len,
+                          lease->hwaddr, lease->hwaddr_len, lease->hwaddr_type,
+                          NULL)) && (config->flags & CONFIG_NAME)
+             && (!(config->flags & CONFIG_ADDR)
+                 || config->addr.s_addr == lease->addr.s_addr))
+      lease_set_hostname(lease, config->hostname, 1, get_domain(lease->addr),
+                         NULL);
     else if ((name = host_from_dns(lease->addr)))
-      lease_set_hostname(lease, name, 1, get_domain(lease->addr), NULL); /* updates auth flag only */
+      lease_set_hostname(lease, name, 1, get_domain(lease->addr), NULL);        /* updates auth flag only */
 }
 
 static void ourprintf(int *errp, char *format, ...)
 {
   va_list ap;
-  
+
   va_start(ap, format);
   if (!(*errp) && vfprintf(daemon->lease_stream, format, ap) < 0)
     *errp = errno;
@@ -246,141 +248,129 @@
   time_t next_event;
   int i, err = 0;
 
-  if (file_dirty != 0 && daemon->lease_stream)
-    {
-      errno = 0;
-      rewind(daemon->lease_stream);
-      if (errno != 0 || ftruncate(fileno(daemon->lease_stream), 0) != 0)
-	err = errno;
-      
-      for (lease = leases; lease; lease = lease->next)
-	{
+  if (file_dirty != 0 && daemon->lease_stream) {
+    errno = 0;
+    rewind(daemon->lease_stream);
+    if (errno != 0 || ftruncate(fileno(daemon->lease_stream), 0) != 0)
+      err = errno;
+
+    for (lease = leases; lease; lease = lease->next) {
 
 #ifdef HAVE_DHCP6
-	  if (lease->flags & (LEASE_TA | LEASE_NA))
-	    continue;
+      if (lease->flags & (LEASE_TA | LEASE_NA))
+        continue;
 #endif
 
 #ifdef HAVE_BROKEN_RTC
-	  ourprintf(&err, "%u ", lease->length);
+      ourprintf(&err, "%u ", lease->length);
 #else
-	  ourprintf(&err, "%lu ", (unsigned long)lease->expires);
+      ourprintf(&err, "%lu ", (unsigned long) lease->expires);
 #endif
 
-	  if (lease->hwaddr_type != ARPHRD_ETHER || lease->hwaddr_len == 0) 
-	    ourprintf(&err, "%.2x-", lease->hwaddr_type);
-	  for (i = 0; i < lease->hwaddr_len; i++)
-	    {
-	      ourprintf(&err, "%.2x", lease->hwaddr[i]);
-	      if (i != lease->hwaddr_len - 1)
-		ourprintf(&err, ":");
-	    }
-	  
-	  inet_ntop(AF_INET, &lease->addr, daemon->addrbuff, ADDRSTRLEN); 
-
-	  ourprintf(&err, " %s ", daemon->addrbuff);
-	  ourprintf(&err, "%s ", lease->hostname ? lease->hostname : "*");
-	  	  
-	  if (lease->clid && lease->clid_len != 0)
-	    {
-	      for (i = 0; i < lease->clid_len - 1; i++)
-		ourprintf(&err, "%.2x:", lease->clid[i]);
-	      ourprintf(&err, "%.2x\n", lease->clid[i]);
-	    }
-	  else
-	    ourprintf(&err, "*\n");	  
-	}
-      
-#ifdef HAVE_DHCP6  
-      if (daemon->duid)
-	{
-	  ourprintf(&err, "duid ");
-	  for (i = 0; i < daemon->duid_len - 1; i++)
-	    ourprintf(&err, "%.2x:", daemon->duid[i]);
-	  ourprintf(&err, "%.2x\n", daemon->duid[i]);
-	  
-	  for (lease = leases; lease; lease = lease->next)
-	    {
-	      
-	      if (!(lease->flags & (LEASE_TA | LEASE_NA)))
-		continue;
+      if (lease->hwaddr_type != ARPHRD_ETHER || lease->hwaddr_len == 0)
+        ourprintf(&err, "%.2x-", lease->hwaddr_type);
+      for (i = 0; i < lease->hwaddr_len; i++) {
+        ourprintf(&err, "%.2x", lease->hwaddr[i]);
+        if (i != lease->hwaddr_len - 1)
+          ourprintf(&err, ":");
+      }
+
+      inet_ntop(AF_INET, &lease->addr, daemon->addrbuff, ADDRSTRLEN);
+
+      ourprintf(&err, " %s ", daemon->addrbuff);
+      ourprintf(&err, "%s ", lease->hostname ? lease->hostname : "*");
+
+      if (lease->clid && lease->clid_len != 0) {
+        for (i = 0; i < lease->clid_len - 1; i++)
+          ourprintf(&err, "%.2x:", lease->clid[i]);
+        ourprintf(&err, "%.2x\n", lease->clid[i]);
+      } else
+        ourprintf(&err, "*\n");
+    }
+
+#ifdef HAVE_DHCP6
+    if (daemon->duid) {
+      ourprintf(&err, "duid ");
+      for (i = 0; i < daemon->duid_len - 1; i++)
+        ourprintf(&err, "%.2x:", daemon->duid[i]);
+      ourprintf(&err, "%.2x\n", daemon->duid[i]);
+
+      for (lease = leases; lease; lease = lease->next) {
+
+        if (!(lease->flags & (LEASE_TA | LEASE_NA)))
+          continue;
 
 #ifdef HAVE_BROKEN_RTC
-	      ourprintf(&err, "%u ", lease->length);
+        ourprintf(&err, "%u ", lease->length);
 #else
-	      ourprintf(&err, "%lu ", (unsigned long)lease->expires);
+        ourprintf(&err, "%lu ", (unsigned long) lease->expires);
 #endif
-    
-	      inet_ntop(AF_INET6, &lease->addr6, daemon->addrbuff, ADDRSTRLEN);
-	 
-	      ourprintf(&err, "%s%u %s ", (lease->flags & LEASE_TA) ? "T" : "",
-			lease->iaid, daemon->addrbuff);
-	      ourprintf(&err, "%s ", lease->hostname ? lease->hostname : "*");
-	      
-	      if (lease->clid && lease->clid_len != 0)
-		{
-		  for (i = 0; i < lease->clid_len - 1; i++)
-		    ourprintf(&err, "%.2x:", lease->clid[i]);
-		  ourprintf(&err, "%.2x\n", lease->clid[i]);
-		}
-	      else
-		ourprintf(&err, "*\n");	  
-	    }
-	}
-#endif      
-	  
-      if (fflush(daemon->lease_stream) != 0 ||
-	  fsync(fileno(daemon->lease_stream)) < 0)
-	err = errno;
-      
-      if (!err)
-	file_dirty = 0;
+
+        inet_ntop(AF_INET6, &lease->addr6, daemon->addrbuff, ADDRSTRLEN);
+
+        ourprintf(&err, "%s%u %s ", (lease->flags & LEASE_TA) ? "T" : "",
+                  lease->iaid, daemon->addrbuff);
+        ourprintf(&err, "%s ", lease->hostname ? lease->hostname : "*");
+
+        if (lease->clid && lease->clid_len != 0) {
+          for (i = 0; i < lease->clid_len - 1; i++)
+            ourprintf(&err, "%.2x:", lease->clid[i]);
+          ourprintf(&err, "%.2x\n", lease->clid[i]);
+        } else
+          ourprintf(&err, "*\n");
+      }
     }
-  
+#endif
+
+    if (fflush(daemon->lease_stream) != 0 ||
+        fsync(fileno(daemon->lease_stream)) < 0)
+      err = errno;
+
+    if (!err)
+      file_dirty = 0;
+  }
+
   /* Set alarm for when the first lease expires. */
   next_event = 0;
 
 #ifdef HAVE_DHCP6
   /* do timed RAs and determine when the next is, also pings to potential SLAAC addresses */
-  if (daemon->doing_ra)
-    {
-      time_t event;
-      
-      if ((event = periodic_slaac(now, leases)) != 0)
-	{
-	  if (next_event == 0 || difftime(next_event, event) > 0.0)
-	    next_event = event;
-	}
-      
-      if ((event = periodic_ra(now)) != 0)
-	{
-	  if (next_event == 0 || difftime(next_event, event) > 0.0)
-	    next_event = event;
-	}
+  if (daemon->doing_ra) {
+    time_t event;
+
+    if ((event = periodic_slaac(now, leases)) != 0) {
+      if (next_event == 0 || difftime(next_event, event) > 0.0)
+        next_event = event;
     }
+
+    if ((event = periodic_ra(now)) != 0) {
+      if (next_event == 0 || difftime(next_event, event) > 0.0)
+        next_event = event;
+    }
+  }
 #endif
 
   for (lease = leases; lease; lease = lease->next)
     if (lease->expires != 0 &&
-	(next_event == 0 || difftime(next_event, lease->expires) > 0.0))
+        (next_event == 0 || difftime(next_event, lease->expires) > 0.0))
       next_event = lease->expires;
-   
-  if (err)
-    {
-      if (next_event == 0 || difftime(next_event, LEASE_RETRY + now) > 0.0)
-	next_event = LEASE_RETRY + now;
-      
-      my_syslog(MS_DHCP | LOG_ERR, _("failed to write %s: %s (retry in %us)"), 
-		daemon->lease_file, strerror(err),
-		(unsigned int)difftime(next_event, now));
-    }
+
+  if (err) {
+    if (next_event == 0 || difftime(next_event, LEASE_RETRY + now) > 0.0)
+      next_event = LEASE_RETRY + now;
+
+    my_syslog(MS_DHCP | LOG_ERR, _("failed to write %s: %s (retry in %us)"),
+              daemon->lease_file, strerror(err),
+              (unsigned int) difftime(next_event, now));
+  }
 
   send_alarm(next_event, now);
 }
 
 
 static int find_interface_v4(struct in_addr local, int if_index, char *label,
-			     struct in_addr netmask, struct in_addr broadcast, void *vparam)
+                             struct in_addr netmask, struct in_addr broadcast,
+                             void *vparam)
 {
   struct dhcp_lease *lease;
   int prefix = netmask_length(netmask);
@@ -391,32 +381,32 @@
 
   for (lease = leases; lease; lease = lease->next)
     if (!(lease->flags & (LEASE_TA | LEASE_NA)) &&
-	is_same_net(local, lease->addr, netmask) && 
-	prefix > lease->new_prefixlen) 
-      {
-	lease->new_interface = if_index;
-        lease->new_prefixlen = prefix;
-      }
+        is_same_net(local, lease->addr, netmask) &&
+        prefix > lease->new_prefixlen) {
+      lease->new_interface = if_index;
+      lease->new_prefixlen = prefix;
+    }
 
   return 1;
 }
 
 #ifdef HAVE_DHCP6
-static int find_interface_v6(struct in6_addr *local,  int prefix,
-			     int scope, int if_index, int flags, 
-			     int preferred, int valid, void *vparam)
+static int find_interface_v6(struct in6_addr *local, int prefix,
+                             int scope, int if_index, int flags,
+                             int preferred, int valid, void *vparam)
 {
   struct dhcp_lease *lease;
 
-  (void)scope;
-  (void)flags;
-  (void)preferred;
-  (void)valid;
-  (void)vparam;
+  (void) scope;
+  (void) flags;
+  (void) preferred;
+  (void) valid;
+  (void) vparam;
 
   for (lease = leases; lease; lease = lease->next)
     if ((lease->flags & (LEASE_TA | LEASE_NA)))
-      if (is_same_net6(local, &lease->addr6, prefix) && prefix > lease->new_prefixlen) {
+      if (is_same_net6(local, &lease->addr6, prefix)
+          && prefix > lease->new_prefixlen) {
         /* save prefix length for comparison, as we might get shorter matching
          * prefix in upcoming netlink GETADDR responses
          * */
@@ -427,7 +417,8 @@
   return 1;
 }
 
-void lease_ping_reply(struct in6_addr *sender, unsigned char *packet, char *interface)
+void lease_ping_reply(struct in6_addr *sender, unsigned char *packet,
+                      char *interface)
 {
   /* We may be doing RA but not DHCPv4, in which case the lease
      database may not exist and we have nothing to do anyway */
@@ -441,7 +432,7 @@
      new SLAAC addresses to existing leases. */
 
   struct dhcp_lease *lease;
-  
+
   if (daemon->dhcp)
     for (lease = leases; lease; lease = lease->next)
       slaac_add_addrs(lease, now, 0);
@@ -457,7 +448,7 @@
 void lease_find_interfaces(time_t now)
 {
   struct dhcp_lease *lease;
-  
+
   for (lease = leases; lease; lease = lease->next)
     lease->new_prefixlen = lease->new_interface = 0;
 
@@ -467,7 +458,7 @@
 #endif
 
   for (lease = leases; lease; lease = lease->next)
-    if (lease->new_interface != 0) 
+    if (lease->new_interface != 0)
       lease_set_interface(lease, lease->new_interface, now);
 }
 
@@ -475,11 +466,10 @@
 void lease_make_duid(time_t now)
 {
   /* If we're not doing DHCPv6, and there are not v6 leases, don't add the DUID to the database */
-  if (!daemon->duid && daemon->doing_dhcp6)
-    {
-      file_dirty = 1;
-      make_duid(now);
-    }
+  if (!daemon->duid && daemon->doing_dhcp6) {
+    file_dirty = 1;
+    make_duid(now);
+  }
 }
 #endif
 
@@ -490,118 +480,121 @@
 {
   struct dhcp_lease *lease;
 
-  if (daemon->port != 0 && (dns_dirty || force))
-    {
+  if (daemon->port != 0 && (dns_dirty || force)) {
 #ifndef HAVE_BROKEN_RTC
-      /* force transfer to authoritative secondaries */
-      daemon->soa_sn++;
+    /* force transfer to authoritative secondaries */
+    daemon->soa_sn++;
 #endif
-      
-      cache_unhash_dhcp();
 
-      for (lease = leases; lease; lease = lease->next)
-	{
-	  int prot = AF_INET;
-	  
-#ifdef HAVE_DHCP6
-	  if (lease->flags & (LEASE_TA | LEASE_NA))
-	    prot = AF_INET6;
-	  else if (lease->hostname || lease->fqdn)
-	    {
-	      struct slaac_address *slaac;
-
-	      for (slaac = lease->slaac_address; slaac; slaac = slaac->next)
-		if (slaac->backoff == 0)
-		  {
-		    if (lease->fqdn)
-		      cache_add_dhcp_entry(lease->fqdn, AF_INET6, (struct all_addr *)&slaac->addr, lease->expires);
-		    if (!option_bool(OPT_DHCP_FQDN) && lease->hostname)
-		      cache_add_dhcp_entry(lease->hostname, AF_INET6, (struct all_addr *)&slaac->addr, lease->expires);
-		  }
-	    }
-	  
-	  if (lease->fqdn)
-	    cache_add_dhcp_entry(lease->fqdn, prot, 
-				 prot == AF_INET ? (struct all_addr *)&lease->addr : (struct all_addr *)&lease->addr6,
-				 lease->expires);
-	     
-	  if (!option_bool(OPT_DHCP_FQDN) && lease->hostname)
-	    cache_add_dhcp_entry(lease->hostname, prot, 
-				 prot == AF_INET ? (struct all_addr *)&lease->addr : (struct all_addr *)&lease->addr6, 
-				 lease->expires);
-       
+    cache_unhash_dhcp();
+
+    for (lease = leases; lease; lease = lease->next) {
+      int prot = AF_INET;
+
+#ifdef HAVE_DHCP6
+      if (lease->flags & (LEASE_TA | LEASE_NA))
+        prot = AF_INET6;
+      else if (lease->hostname || lease->fqdn) {
+        struct slaac_address *slaac;
+
+        for (slaac = lease->slaac_address; slaac; slaac = slaac->next)
+          if (slaac->backoff == 0) {
+            if (lease->fqdn)
+              cache_add_dhcp_entry(lease->fqdn, AF_INET6,
+                                   (struct all_addr *) &slaac->addr,
+                                   lease->expires);
+            if (!option_bool(OPT_DHCP_FQDN) && lease->hostname)
+              cache_add_dhcp_entry(lease->hostname, AF_INET6,
+                                   (struct all_addr *) &slaac->addr,
+                                   lease->expires);
+          }
+      }
+
+      if (lease->fqdn)
+        cache_add_dhcp_entry(lease->fqdn, prot,
+                             prot ==
+                             AF_INET ? (struct all_addr *) &lease->
+                             addr : (struct all_addr *) &lease->addr6,
+                             lease->expires);
+
+      if (!option_bool(OPT_DHCP_FQDN) && lease->hostname)
+        cache_add_dhcp_entry(lease->hostname, prot,
+                             prot ==
+                             AF_INET ? (struct all_addr *) &lease->
+                             addr : (struct all_addr *) &lease->addr6,
+                             lease->expires);
+
 #else
-	  if (lease->fqdn)
-	    cache_add_dhcp_entry(lease->fqdn, prot, (struct all_addr *)&lease->addr, lease->expires);
-	  
-	  if (!option_bool(OPT_DHCP_FQDN) && lease->hostname)
-	    cache_add_dhcp_entry(lease->hostname, prot, (struct all_addr *)&lease->addr, lease->expires);
-#endif
-	}
-      
-      dns_dirty = 0;
+      if (lease->fqdn)
+        cache_add_dhcp_entry(lease->fqdn, prot,
+                             (struct all_addr *) &lease->addr, lease->expires);
+
+      if (!option_bool(OPT_DHCP_FQDN) && lease->hostname)
+        cache_add_dhcp_entry(lease->hostname, prot,
+                             (struct all_addr *) &lease->addr, lease->expires);
+#endif
     }
+
+    dns_dirty = 0;
+  }
 }
 
 void lease_prune(struct dhcp_lease *target, time_t now)
 {
   struct dhcp_lease *lease, *tmp, **up;
 
-  for (lease = leases, up = &leases; lease; lease = tmp)
-    {
-      tmp = lease->next;
-      if ((lease->expires != 0 && difftime(now, lease->expires) > 0) || lease == target)
-	{
-	  file_dirty = 1;
-	  if (lease->hostname)
-	    dns_dirty = 1;
-	  
- 	  *up = lease->next; /* unlink */
-	  
-	  /* Put on old_leases list 'till we
-	     can run the script */
-	  lease->next = old_leases;
-	  old_leases = lease;
-	  
-	  leases_left++;
-	}
-      else
-	up = &lease->next;
-    }
-} 
-	
-  
-struct dhcp_lease *lease_find_by_client(unsigned char *hwaddr, int hw_len, int hw_type,
-					unsigned char *clid, int clid_len)
+  for (lease = leases, up = &leases; lease; lease = tmp) {
+    tmp = lease->next;
+    if ((lease->expires != 0 && difftime(now, lease->expires) > 0)
+        || lease == target) {
+      file_dirty = 1;
+      if (lease->hostname)
+        dns_dirty = 1;
+
+      *up = lease->next;        /* unlink */
+
+      /* Put on old_leases list 'till we
+         can run the script */
+      lease->next = old_leases;
+      old_leases = lease;
+
+      leases_left++;
+    } else
+      up = &lease->next;
+  }
+}
+
+
+struct dhcp_lease *lease_find_by_client(unsigned char *hwaddr, int hw_len,
+                                        int hw_type, unsigned char *clid,
+                                        int clid_len)
 {
   struct dhcp_lease *lease;
 
   if (clid)
-    for (lease = leases; lease; lease = lease->next)
-      {
-#ifdef HAVE_DHCP6
-	if (lease->flags & (LEASE_TA | LEASE_NA))
-	  continue;
-#endif
-	if (lease->clid && clid_len == lease->clid_len &&
-	    memcmp(clid, lease->clid, clid_len) == 0)
-	  return lease;
-      }
-  
-  for (lease = leases; lease; lease = lease->next)	
-    {
+    for (lease = leases; lease; lease = lease->next) {
 #ifdef HAVE_DHCP6
       if (lease->flags & (LEASE_TA | LEASE_NA))
-	continue;
-#endif   
-      if ((!lease->clid || !clid) && 
-	  hw_len != 0 && 
-	  lease->hwaddr_len == hw_len &&
-	  lease->hwaddr_type == hw_type &&
-	  memcmp(hwaddr, lease->hwaddr, hw_len) == 0)
-	return lease;
+        continue;
+#endif
+      if (lease->clid && clid_len == lease->clid_len &&
+          memcmp(clid, lease->clid, clid_len) == 0)
+        return lease;
     }
 
+  for (lease = leases; lease; lease = lease->next) {
+#ifdef HAVE_DHCP6
+    if (lease->flags & (LEASE_TA | LEASE_NA))
+      continue;
+#endif
+    if ((!lease->clid || !clid) &&
+        hw_len != 0 &&
+        lease->hwaddr_len == hw_len &&
+        lease->hwaddr_type == hw_type &&
+        memcmp(hwaddr, lease->hwaddr, hw_len) == 0)
+      return lease;
+  }
+
   return NULL;
 }
 
@@ -609,41 +602,39 @@
 {
   struct dhcp_lease *lease;
 
-  for (lease = leases; lease; lease = lease->next)
-    {
+  for (lease = leases; lease; lease = lease->next) {
 #ifdef HAVE_DHCP6
-      if (lease->flags & (LEASE_TA | LEASE_NA))
-	continue;
-#endif  
-      if (lease->addr.s_addr == addr.s_addr)
-	return lease;
-    }
+    if (lease->flags & (LEASE_TA | LEASE_NA))
+      continue;
+#endif
+    if (lease->addr.s_addr == addr.s_addr)
+      return lease;
+  }
 
   return NULL;
 }
 
 #ifdef HAVE_DHCP6
 /* find address for {CLID, IAID, address} */
-struct dhcp_lease *lease6_find(unsigned char *clid, int clid_len, 
-			       int lease_type, int iaid, struct in6_addr *addr)
+struct dhcp_lease *lease6_find(unsigned char *clid, int clid_len,
+                               int lease_type, int iaid, struct in6_addr *addr)
 {
   struct dhcp_lease *lease;
-  
-  for (lease = leases; lease; lease = lease->next)
-    {
-      if (!(lease->flags & lease_type) || lease->iaid != iaid)
-	continue;
 
-      if (!IN6_ARE_ADDR_EQUAL(&lease->addr6, addr))
-	continue;
-      
-      if ((clid_len != lease->clid_len ||
-	   memcmp(clid, lease->clid, clid_len) != 0))
-	continue;
-      
-      return lease;
-    }
-  
+  for (lease = leases; lease; lease = lease->next) {
+    if (!(lease->flags & lease_type) || lease->iaid != iaid)
+      continue;
+
+    if (!IN6_ARE_ADDR_EQUAL(&lease->addr6, addr))
+      continue;
+
+    if ((clid_len != lease->clid_len ||
+         memcmp(clid, lease->clid, clid_len) != 0))
+      continue;
+
+    return lease;
+  }
+
   return NULL;
 }
 
@@ -651,13 +642,15 @@
 void lease6_reset(void)
 {
   struct dhcp_lease *lease;
-  
+
   for (lease = leases; lease; lease = lease->next)
     lease->flags &= ~LEASE_USED;
 }
 
 /* enumerate all leases belonging to {CLID, IAID} */
-struct dhcp_lease *lease6_find_by_client(struct dhcp_lease *first, int lease_type, unsigned char *clid, int clid_len, int iaid)
+struct dhcp_lease *lease6_find_by_client(struct dhcp_lease *first,
+                                         int lease_type, unsigned char *clid,
+                                         int clid_len, int iaid)
 {
   struct dhcp_lease *lease;
 
@@ -666,60 +659,58 @@
   else
     first = first->next;
 
-  for (lease = first; lease; lease = lease->next)
-    {
-      if (lease->flags & LEASE_USED)
-	continue;
+  for (lease = first; lease; lease = lease->next) {
+    if (lease->flags & LEASE_USED)
+      continue;
 
-      if (!(lease->flags & lease_type) || lease->iaid != iaid)
-	continue;
- 
-      if ((clid_len != lease->clid_len ||
-	   memcmp(clid, lease->clid, clid_len) != 0))
-	continue;
+    if (!(lease->flags & lease_type) || lease->iaid != iaid)
+      continue;
+
+    if ((clid_len != lease->clid_len ||
+         memcmp(clid, lease->clid, clid_len) != 0))
+      continue;
+
+    return lease;
+  }
 
-      return lease;
-    }
-  
   return NULL;
 }
 
-struct dhcp_lease *lease6_find_by_addr(struct in6_addr *net, int prefix, u64 addr)
+struct dhcp_lease *lease6_find_by_addr(struct in6_addr *net, int prefix,
+                                       u64 addr)
 {
   struct dhcp_lease *lease;
-    
-  for (lease = leases; lease; lease = lease->next)
-    {
-      if (!(lease->flags & (LEASE_TA | LEASE_NA)))
-	continue;
-      
-      if (is_same_net6(&lease->addr6, net, prefix) &&
-	  (prefix == 128 || addr6part(&lease->addr6) == addr))
-	return lease;
-    }
-  
+
+  for (lease = leases; lease; lease = lease->next) {
+    if (!(lease->flags & (LEASE_TA | LEASE_NA)))
+      continue;
+
+    if (is_same_net6(&lease->addr6, net, prefix) &&
+        (prefix == 128 || addr6part(&lease->addr6) == addr))
+      return lease;
+  }
+
   return NULL;
-} 
+}
 
 /* Find largest assigned address in context */
-u64 lease_find_max_addr6(struct dhcp_context *context)
+u64 lease_find_max_addr6(struct dhcp_context * context)
 {
   struct dhcp_lease *lease;
   u64 addr = addr6part(&context->start6);
-  
+
   if (!(context->flags & (CONTEXT_STATIC | CONTEXT_PROXY)))
-    for (lease = leases; lease; lease = lease->next)
-      {
-	if (!(lease->flags & (LEASE_TA | LEASE_NA)))
-	  continue;
-
-	if (is_same_net6(&lease->addr6, &context->start6, 64) &&
-	    addr6part(&lease->addr6) > addr6part(&context->start6) &&
-	    addr6part(&lease->addr6) <= addr6part(&context->end6) &&
-	    addr6part(&lease->addr6) > addr)
-	  addr = addr6part(&lease->addr6);
-      }
-  
+    for (lease = leases; lease; lease = lease->next) {
+      if (!(lease->flags & (LEASE_TA | LEASE_NA)))
+        continue;
+
+      if (is_same_net6(&lease->addr6, &context->start6, 64) &&
+          addr6part(&lease->addr6) > addr6part(&context->start6) &&
+          addr6part(&lease->addr6) <= addr6part(&context->end6) &&
+          addr6part(&lease->addr6) > addr)
+        addr = addr6part(&lease->addr6);
+    }
+
   return addr;
 }
 
@@ -730,20 +721,22 @@
 {
   struct dhcp_lease *lease;
   struct in_addr addr = context->start;
-  
+
   if (!(context->flags & (CONTEXT_STATIC | CONTEXT_PROXY)))
-    for (lease = leases; lease; lease = lease->next)
-      {
+    for (lease = leases; lease; lease = lease->next) {
 #ifdef HAVE_DHCP6
-	if (lease->flags & (LEASE_TA | LEASE_NA))
-	  continue;
+      if (lease->flags & (LEASE_TA | LEASE_NA))
+        continue;
 #endif
-	if (((unsigned)ntohl(lease->addr.s_addr)) > ((unsigned)ntohl(context->start.s_addr)) &&
-	    ((unsigned)ntohl(lease->addr.s_addr)) <= ((unsigned)ntohl(context->end.s_addr)) &&
-	    ((unsigned)ntohl(lease->addr.s_addr)) > ((unsigned)ntohl(addr.s_addr)))
-	  addr = lease->addr;
-      }
-  
+      if (((unsigned) ntohl(lease->addr.s_addr)) >
+          ((unsigned) ntohl(context->start.s_addr))
+          && ((unsigned) ntohl(lease->addr.s_addr)) <=
+          ((unsigned) ntohl(context->end.s_addr))
+          && ((unsigned) ntohl(lease->addr.s_addr)) >
+          ((unsigned) ntohl(addr.s_addr)))
+        addr = lease->addr;
+    }
+
   return addr;
 }
 
@@ -757,12 +750,12 @@
   lease->flags = LEASE_NEW;
   lease->expires = 1;
 #ifdef HAVE_BROKEN_RTC
-  lease->length = 0xffffffff; /* illegal value */
+  lease->length = 0xffffffff;   /* illegal value */
 #endif
-  lease->hwaddr_len = 256; /* illegal value */
+  lease->hwaddr_len = 256;      /* illegal value */
   lease->next = leases;
   leases = lease;
-  
+
   file_dirty = 1;
   leases_left--;
 
@@ -774,7 +767,7 @@
   struct dhcp_lease *lease = lease_allocate();
   if (lease)
     lease->addr = addr;
-  
+
   return lease;
 }
 
@@ -783,12 +776,11 @@
 {
   struct dhcp_lease *lease = lease_allocate();
 
-  if (lease)
-    {
-      lease->addr6 = *addrp;
-      lease->flags |= lease_type;
-      lease->iaid = 0;
-    }
+  if (lease) {
+    lease->addr6 = *addrp;
+    lease->flags |= lease_type;
+    lease->iaid = 0;
+  }
 
   return lease;
 }
@@ -798,108 +790,95 @@
 {
   time_t exp;
 
-  if (len == 0xffffffff)
-    {
+  if (len == 0xffffffff) {
+    exp = 0;
+    len = 0;
+  } else {
+    exp = now + (time_t) len;
+    /* Check for 2038 overflow. Make the lease
+       infinite in that case, as the least disruptive
+       thing we can do. */
+    if (difftime(exp, now) <= 0.0)
       exp = 0;
-      len = 0;
-    }
-  else
-    {
-      exp = now + (time_t)len;
-      /* Check for 2038 overflow. Make the lease
-	 infinite in that case, as the least disruptive
-	 thing we can do. */
-      if (difftime(exp, now) <= 0.0)
-	exp = 0;
-    }
+  }
 
-  if (exp != lease->expires)
-    {
-      dns_dirty = 1;
-      lease->expires = exp;
+  if (exp != lease->expires) {
+    dns_dirty = 1;
+    lease->expires = exp;
 #ifndef HAVE_BROKEN_RTC
-      lease->flags |= LEASE_AUX_CHANGED;
-      file_dirty = 1;
+    lease->flags |= LEASE_AUX_CHANGED;
+    file_dirty = 1;
 #endif
-    }
-  
+  }
 #ifdef HAVE_BROKEN_RTC
-  if (len != lease->length)
-    {
-      lease->length = len;
-      lease->flags |= LEASE_AUX_CHANGED;
-      file_dirty = 1; 
-    }
+  if (len != lease->length) {
+    lease->length = len;
+    lease->flags |= LEASE_AUX_CHANGED;
+    file_dirty = 1;
+  }
 #endif
-} 
+}
 
 #ifdef HAVE_DHCP6
 void lease_set_iaid(struct dhcp_lease *lease, int iaid)
 {
-  if (lease->iaid != iaid)
-    {
-      lease->iaid = iaid;
-      lease->flags |= LEASE_CHANGED;
-    }
+  if (lease->iaid != iaid) {
+    lease->iaid = iaid;
+    lease->flags |= LEASE_CHANGED;
+  }
 }
 #endif
 
 void lease_set_hwaddr(struct dhcp_lease *lease, const unsigned char *hwaddr,
-		      const unsigned char *clid, int hw_len, int hw_type,
-		      int clid_len, time_t now, int force)
+                      const unsigned char *clid, int hw_len, int hw_type,
+                      int clid_len, time_t now, int force)
 {
 #ifdef HAVE_DHCP6
   int change = force;
   lease->flags |= LEASE_HAVE_HWADDR;
 #endif
 
-  (void)force;
-  (void)now;
+  (void) force;
+  (void) now;
 
   if (hw_len != lease->hwaddr_len ||
-      hw_type != lease->hwaddr_type || 
-      (hw_len != 0 && memcmp(lease->hwaddr, hwaddr, hw_len) != 0))
-    {
-      if (hw_len != 0)
-	memcpy(lease->hwaddr, hwaddr, hw_len);
-      lease->hwaddr_len = hw_len;
-      lease->hwaddr_type = hw_type;
-      lease->flags |= LEASE_CHANGED;
-      file_dirty = 1; /* run script on change */
-    }
+      hw_type != lease->hwaddr_type ||
+      (hw_len != 0 && memcmp(lease->hwaddr, hwaddr, hw_len) != 0)) {
+    if (hw_len != 0)
+      memcpy(lease->hwaddr, hwaddr, hw_len);
+    lease->hwaddr_len = hw_len;
+    lease->hwaddr_type = hw_type;
+    lease->flags |= LEASE_CHANGED;
+    file_dirty = 1;             /* run script on change */
+  }
 
   /* only update clid when one is available, stops packets
      without a clid removing the record. Lease init uses
      clid_len == 0 for no clid. */
-  if (clid_len != 0 && clid)
-    {
-      if (!lease->clid)
-	lease->clid_len = 0;
+  if (clid_len != 0 && clid) {
+    if (!lease->clid)
+      lease->clid_len = 0;
 
-      if (lease->clid_len != clid_len)
-	{
-	  lease->flags |= LEASE_AUX_CHANGED;
-	  file_dirty = 1;
-	  free(lease->clid);
-	  if (!(lease->clid = whine_malloc(clid_len)))
-	    return;
-#ifdef HAVE_DHCP6
-	  change = 1;
-#endif	   
-	}
-      else if (memcmp(lease->clid, clid, clid_len) != 0)
-	{
-	  lease->flags |= LEASE_AUX_CHANGED;
-	  file_dirty = 1;
-#ifdef HAVE_DHCP6
-	  change = 1;
-#endif	
-	}
-      
-      lease->clid_len = clid_len;
-      memcpy(lease->clid, clid, clid_len);
+    if (lease->clid_len != clid_len) {
+      lease->flags |= LEASE_AUX_CHANGED;
+      file_dirty = 1;
+      free(lease->clid);
+      if (!(lease->clid = whine_malloc(clid_len)))
+        return;
+#ifdef HAVE_DHCP6
+      change = 1;
+#endif
+    } else if (memcmp(lease->clid, clid, clid_len) != 0) {
+      lease->flags |= LEASE_AUX_CHANGED;
+      file_dirty = 1;
+#ifdef HAVE_DHCP6
+      change = 1;
+#endif
     }
-  
+
+    lease->clid_len = clid_len;
+    memcpy(lease->clid, clid, clid_len);
+  }
 #ifdef HAVE_DHCP6
   if (change)
     slaac_add_addrs(lease, now, force);
@@ -909,40 +888,40 @@
 static void kill_name(struct dhcp_lease *lease)
 {
   /* run script to say we lost our old name */
-  
+
   /* this shouldn't happen unless updates are very quick and the
      script very slow, we just avoid a memory leak if it does. */
   free(lease->old_hostname);
-  
+
   /* If we know the fqdn, pass that. The helper will derive the
      unqualified name from it, free the unqualified name here. */
 
-  if (lease->fqdn)
-    {
-      lease->old_hostname = lease->fqdn;
-      free(lease->hostname);
-    }
-  else
+  if (lease->fqdn) {
+    lease->old_hostname = lease->fqdn;
+    free(lease->hostname);
+  } else
     lease->old_hostname = lease->hostname;
 
   lease->hostname = lease->fqdn = NULL;
 }
 
-void lease_set_hostname(struct dhcp_lease *lease, const char *name, int auth, char *domain, char *config_domain)
+void lease_set_hostname(struct dhcp_lease *lease, const char *name, int auth,
+                        char *domain, char *config_domain)
 {
   struct dhcp_lease *lease_tmp;
   char *new_name = NULL, *new_fqdn = NULL;
 
   if (config_domain && (!domain || !hostname_isequal(domain, config_domain)))
-    my_syslog(MS_DHCP | LOG_WARNING, _("Ignoring domain %s for DHCP host name %s"), config_domain, name);
-  
-  if (lease->hostname && name && hostname_isequal(lease->hostname, name))
-    {
-      if (auth)
-	lease->flags |= LEASE_AUTH_NAME;
-      return;
-    }
-  
+    my_syslog(MS_DHCP | LOG_WARNING,
+              _("Ignoring domain %s for DHCP host name %s"), config_domain,
+              name);
+
+  if (lease->hostname && name && hostname_isequal(lease->hostname, name)) {
+    if (auth)
+      lease->flags |= LEASE_AUTH_NAME;
+    return;
+  }
+
   if (!name && !lease->hostname)
     return;
 
@@ -953,83 +932,76 @@
      allowed the same name.
 
      Don't allow a name from the client to override a name from dnsmasq config. */
-  
-  if (name)
-    {
-      if ((new_name = whine_malloc(strlen(name) + 1)))
-	{
-	  strcpy(new_name, name);
-	  if (domain && (new_fqdn = whine_malloc(strlen(new_name) + strlen(domain) + 2)))
-	    {
-	      strcpy(new_fqdn, name);
-	      strcat(new_fqdn, ".");
-	      strcat(new_fqdn, domain);
-	    }
-	}
-	  
-      /* Depending on mode, we check either unqualified name or FQDN. */
-      for (lease_tmp = leases; lease_tmp; lease_tmp = lease_tmp->next)
-	{
-	  if (option_bool(OPT_DHCP_FQDN))
-	    {
-	      if (!new_fqdn || !lease_tmp->fqdn || !hostname_isequal(lease_tmp->fqdn, new_fqdn))
-		continue;
-	    }
-	  else
-	    {
-	      if (!new_name || !lease_tmp->hostname || !hostname_isequal(lease_tmp->hostname, new_name) )
-		continue; 
-	    }
-
-	  if (lease->flags & (LEASE_TA | LEASE_NA))
-	    {
-	      if (!(lease_tmp->flags & (LEASE_TA | LEASE_NA)))
-		continue;
-
-	      /* another lease for the same DUID is OK for IPv6 */
-	      if (lease->clid_len == lease_tmp->clid_len &&
-		  lease->clid && lease_tmp->clid &&
-		  memcmp(lease->clid, lease_tmp->clid, lease->clid_len) == 0)
-		continue;	      
-	    }
-	  else if (lease_tmp->flags & (LEASE_TA | LEASE_NA))
-	    continue;
-		   
-	  if ((lease_tmp->flags & LEASE_AUTH_NAME) && !auth)
-	    {
-	      free(new_name);
-	      free(new_fqdn);
-	      return;
-	    }
-	
-	  kill_name(lease_tmp);
-	  break;
-	}
+
+  if (name) {
+    if ((new_name = whine_malloc(strlen(name) + 1))) {
+      strcpy(new_name, name);
+      if (domain
+          && (new_fqdn = whine_malloc(strlen(new_name) + strlen(domain) + 2))) {
+        strcpy(new_fqdn, name);
+        strcat(new_fqdn, ".");
+        strcat(new_fqdn, domain);
+      }
+    }
+
+    /* Depending on mode, we check either unqualified name or FQDN. */
+    for (lease_tmp = leases; lease_tmp; lease_tmp = lease_tmp->next) {
+      if (option_bool(OPT_DHCP_FQDN)) {
+        if (!new_fqdn || !lease_tmp->fqdn
+            || !hostname_isequal(lease_tmp->fqdn, new_fqdn))
+          continue;
+      } else {
+        if (!new_name || !lease_tmp->hostname
+            || !hostname_isequal(lease_tmp->hostname, new_name))
+          continue;
+      }
+
+      if (lease->flags & (LEASE_TA | LEASE_NA)) {
+        if (!(lease_tmp->flags & (LEASE_TA | LEASE_NA)))
+          continue;
+
+        /* another lease for the same DUID is OK for IPv6 */
+        if (lease->clid_len == lease_tmp->clid_len &&
+            lease->clid && lease_tmp->clid &&
+            memcmp(lease->clid, lease_tmp->clid, lease->clid_len) == 0)
+          continue;
+      } else if (lease_tmp->flags & (LEASE_TA | LEASE_NA))
+        continue;
+
+      if ((lease_tmp->flags & LEASE_AUTH_NAME) && !auth) {
+        free(new_name);
+        free(new_fqdn);
+        return;
+      }
+
+      kill_name(lease_tmp);
+      break;
     }
+  }
 
   if (lease->hostname)
     kill_name(lease);
 
   lease->hostname = new_name;
   lease->fqdn = new_fqdn;
-  
+
   if (auth)
     lease->flags |= LEASE_AUTH_NAME;
-  
+
   file_dirty = 1;
-  dns_dirty = 1; 
-  lease->flags |= LEASE_CHANGED; /* run script on change */
+  dns_dirty = 1;
+  lease->flags |= LEASE_CHANGED;        /* run script on change */
 }
 
 void lease_set_interface(struct dhcp_lease *lease, int interface, time_t now)
 {
-  (void)now;
+  (void) now;
 
   if (lease->last_interface == interface)
     return;
 
   lease->last_interface = interface;
-  lease->flags |= LEASE_CHANGED; 
+  lease->flags |= LEASE_CHANGED;
 
 #ifdef HAVE_DHCP6
   slaac_add_addrs(lease, now, 0);
@@ -1039,9 +1011,9 @@
 void rerun_scripts(void)
 {
   struct dhcp_lease *lease;
-  
+
   for (lease = leases; lease; lease = lease->next)
-    lease->flags |= LEASE_CHANGED; 
+    lease->flags |= LEASE_CHANGED;
 }
 
 /* deleted leases get transferred to the old_leases list.
@@ -1053,7 +1025,7 @@
 {
   struct dhcp_lease *lease;
 
-  (void)now;
+  (void) now;
 
 #ifdef HAVE_DBUS
   /* If we're going to be sending DBus signals, but the connection is not yet up,
@@ -1062,128 +1034,115 @@
     return 0;
 #endif
 
-  if (old_leases)
-    {
-      lease = old_leases;
-                  
-      /* If the lease still has an old_hostname, do the "old" action on that first */
-      if (lease->old_hostname)
-	{
+  if (old_leases) {
+    lease = old_leases;
+
+    /* If the lease still has an old_hostname, do the "old" action on that first */
+    if (lease->old_hostname) {
 #ifdef HAVE_SCRIPT
-	  queue_script(ACTION_OLD_HOSTNAME, lease, lease->old_hostname, now);
+      queue_script(ACTION_OLD_HOSTNAME, lease, lease->old_hostname, now);
 #endif
-	  free(lease->old_hostname);
-	  lease->old_hostname = NULL;
-	  return 1;
-	}
-      else 
-	{
-#ifdef HAVE_DHCP6
-	  struct slaac_address *slaac, *tmp;
-	  for (slaac = lease->slaac_address; slaac; slaac = tmp)
-	    {
-	      tmp = slaac->next;
-	      free(slaac);
-	    }
+      free(lease->old_hostname);
+      lease->old_hostname = NULL;
+      return 1;
+    } else {
+#ifdef HAVE_DHCP6
+      struct slaac_address *slaac, *tmp;
+      for (slaac = lease->slaac_address; slaac; slaac = tmp) {
+        tmp = slaac->next;
+        free(slaac);
+      }
 #endif
-	  kill_name(lease);
+      kill_name(lease);
 #ifdef HAVE_SCRIPT
-	  queue_script(ACTION_DEL, lease, lease->old_hostname, now);
+      queue_script(ACTION_DEL, lease, lease->old_hostname, now);
 #endif
 #ifdef HAVE_DBUS
-	  emit_dbus_signal(ACTION_DEL, lease, lease->old_hostname);
+      emit_dbus_signal(ACTION_DEL, lease, lease->old_hostname);
 #endif
-	  old_leases = lease->next;
-	  
-	  free(lease->old_hostname); 
-	  free(lease->clid);
-	  free(lease->extradata);
-	  free(lease);
-	    
-	  return 1; 
-	}
+      old_leases = lease->next;
+
+      free(lease->old_hostname);
+      free(lease->clid);
+      free(lease->extradata);
+      free(lease);
+
+      return 1;
     }
-  
+  }
+
   /* make sure we announce the loss of a hostname before its new location. */
   for (lease = leases; lease; lease = lease->next)
-    if (lease->old_hostname)
-      {	
+    if (lease->old_hostname) {
 #ifdef HAVE_SCRIPT
-	queue_script(ACTION_OLD_HOSTNAME, lease, lease->old_hostname, now);
+      queue_script(ACTION_OLD_HOSTNAME, lease, lease->old_hostname, now);
 #endif
-	free(lease->old_hostname);
-	lease->old_hostname = NULL;
-	return 1;
-      }
-  
+      free(lease->old_hostname);
+      lease->old_hostname = NULL;
+      return 1;
+    }
+
   for (lease = leases; lease; lease = lease->next)
-    if ((lease->flags & (LEASE_NEW | LEASE_CHANGED)) || 
-	((lease->flags & LEASE_AUX_CHANGED) && option_bool(OPT_LEASE_RO)))
-      {
+    if ((lease->flags & (LEASE_NEW | LEASE_CHANGED)) ||
+        ((lease->flags & LEASE_AUX_CHANGED) && option_bool(OPT_LEASE_RO))) {
 #ifdef HAVE_SCRIPT
-	queue_script((lease->flags & LEASE_NEW) ? ACTION_ADD : ACTION_OLD, lease, 
-		     lease->fqdn ? lease->fqdn : lease->hostname, now);
+      queue_script((lease->flags & LEASE_NEW) ? ACTION_ADD : ACTION_OLD, lease,
+                   lease->fqdn ? lease->fqdn : lease->hostname, now);
 #endif
 #ifdef HAVE_DBUS
-	emit_dbus_signal((lease->flags & LEASE_NEW) ? ACTION_ADD : ACTION_OLD, lease,
-			 lease->fqdn ? lease->fqdn : lease->hostname);
+      emit_dbus_signal((lease->flags & LEASE_NEW) ? ACTION_ADD : ACTION_OLD,
+                       lease, lease->fqdn ? lease->fqdn : lease->hostname);
 #endif
-	lease->flags &= ~(LEASE_NEW | LEASE_CHANGED | LEASE_AUX_CHANGED);
-	
-	/* this is used for the "add" call, then junked, since they're not in the database */
-	free(lease->extradata);
-	lease->extradata = NULL;
-	
-	return 1;
-      }
+      lease->flags &= ~(LEASE_NEW | LEASE_CHANGED | LEASE_AUX_CHANGED);
 
-  return 0; /* nothing to do */
+      /* this is used for the "add" call, then junked, since they're not in the database */
+      free(lease->extradata);
+      lease->extradata = NULL;
+
+      return 1;
+    }
+
+  return 0;                     /* nothing to do */
 }
 
 #ifdef HAVE_SCRIPT
 /* delim == -1 -> delim = 0, but embedded 0s, creating extra records, are OK. */
-void lease_add_extradata(struct dhcp_lease *lease, unsigned char *data, unsigned int len, int delim)
+void lease_add_extradata(struct dhcp_lease *lease, unsigned char *data,
+                         unsigned int len, int delim)
 {
   unsigned int i;
-  
+
   if (delim == -1)
     delim = 0;
   else
     /* check for embedded NULLs */
     for (i = 0; i < len; i++)
-      if (data[i] == 0)
-	{
-	  len = i;
-	  break;
-	}
-  
-  if ((lease->extradata_size - lease->extradata_len) < (len + 1))
-    {
-      size_t newsz = lease->extradata_len + len + 100;
-      unsigned char *new = whine_malloc(newsz);
-  
-      if (!new)
-	return;
-      
-      if (lease->extradata)
-	{
-	  memcpy(new, lease->extradata, lease->extradata_len);
-	  free(lease->extradata);
-	}
+      if (data[i] == 0) {
+        len = i;
+        break;
+      }
+
+  if ((lease->extradata_size - lease->extradata_len) < (len + 1)) {
+    size_t newsz = lease->extradata_len + len + 100;
+    unsigned char *new = whine_malloc(newsz);
+
+    if (!new)
+      return;
 
-      lease->extradata = new;
-      lease->extradata_size = newsz;
+    if (lease->extradata) {
+      memcpy(new, lease->extradata, lease->extradata_len);
+      free(lease->extradata);
     }
 
+    lease->extradata = new;
+    lease->extradata_size = newsz;
+  }
+
   if (len != 0)
     memcpy(lease->extradata + lease->extradata_len, data, len);
   lease->extradata[lease->extradata_len + len] = delim;
-  lease->extradata_len += len + 1; 
+  lease->extradata_len += len + 1;
 }
 #endif
 
 #endif
-	  
-
-      
-
Index: dnsmasq-2.78/src/log.c
===================================================================
--- dnsmasq-2.78.orig/src/log.c	2017-10-02 21:13:51.000000000 +0800
+++ dnsmasq-2.78/src/log.c	2018-10-29 16:14:19.429440025 +0800
@@ -17,7 +17,7 @@
 #include "dnsmasq.h"
 
 #ifdef __ANDROID__
-#  include <android/log.h>
+#include <android/log.h>
 #endif
 
 /* Implement logging to /dev/log asynchronously. If syslogd is 
@@ -46,7 +46,7 @@
 
 struct log_entry {
   int offset, length;
-  pid_t pid; /* to avoid duplicates over a fork */
+  pid_t pid;                    /* to avoid duplicates over a fork */
   struct log_entry *next;
   char payload[MAX_MESSAGE];
 };
@@ -68,40 +68,37 @@
     log_fac = LOG_LOCAL0;
 #endif
 
-  if (daemon->log_file)
-    { 
-      log_to_file = 1;
-      daemon->max_logs = 0;
-      if (strcmp(daemon->log_file, "-") == 0)
-	{
-	  log_stderr = 1;
-	  echo_stderr = 0;
-	  log_fd = dup(STDERR_FILENO);
-	}
+  if (daemon->log_file) {
+    log_to_file = 1;
+    daemon->max_logs = 0;
+    if (strcmp(daemon->log_file, "-") == 0) {
+      log_stderr = 1;
+      echo_stderr = 0;
+      log_fd = dup(STDERR_FILENO);
     }
-  
+  }
+
   max_logs = daemon->max_logs;
 
-  if (!log_reopen(daemon->log_file))
-    {
-      send_event(errfd, EVENT_LOG_ERR, errno, daemon->log_file ? daemon->log_file : "");
-      _exit(0);
-    }
+  if (!log_reopen(daemon->log_file)) {
+    send_event(errfd, EVENT_LOG_ERR, errno,
+               daemon->log_file ? daemon->log_file : "");
+    _exit(0);
+  }
 
   /* if queuing is inhibited, make sure we allocate
      the one required buffer now. */
-  if (max_logs == 0)
-    {  
-      free_entries = safe_malloc(sizeof(struct log_entry));
-      free_entries->next = NULL;
-      entries_alloced = 1;
-    }
+  if (max_logs == 0) {
+    free_entries = safe_malloc(sizeof(struct log_entry));
+    free_entries->next = NULL;
+    entries_alloced = 1;
+  }
 
   /* If we're running as root and going to change uid later,
      change the ownership here so that the file is always owned by
      the dnsmasq user. Then logrotate can just copy the owner.
      Failure of the chown call is OK, (for instance when started as non-root) */
-  if (log_to_file && !log_stderr && ent_pw && ent_pw->pw_uid != 0 && 
+  if (log_to_file && !log_stderr && ent_pw && ent_pw->pw_uid != 0 &&
       fchown(log_fd, ent_pw->pw_uid, -1) != 0)
     ret = errno;
 
@@ -110,33 +107,34 @@
 
 int log_reopen(char *log_file)
 {
-  if (!log_stderr)
-    {      
-      if (log_fd != -1)
-	close(log_fd);
-      
-      /* NOTE: umask is set to 022 by the time this gets called */
-      
-      if (log_file)
-	log_fd = open(log_file, O_WRONLY|O_CREAT|O_APPEND, S_IRUSR|S_IWUSR|S_IRGRP);      
-      else
-	{
+  if (!log_stderr) {
+    if (log_fd != -1)
+      close(log_fd);
+
+    /* NOTE: umask is set to 022 by the time this gets called */
+
+    if (log_file)
+      log_fd =
+          open(log_file, O_WRONLY | O_CREAT | O_APPEND,
+               S_IRUSR | S_IWUSR | S_IRGRP);
+    else {
 #if defined(HAVE_SOLARIS_NETWORK) || defined(__ANDROID__)
-	  /* Solaris logging is "different", /dev/log is not unix-domain socket.
-	     Just leave log_fd == -1 and use the vsyslog call for everything.... */
-#   define _PATH_LOG ""  /* dummy */
-	  return 1;
+      /* Solaris logging is "different", /dev/log is not unix-domain socket.
+         Just leave log_fd == -1 and use the vsyslog call for everything.... */
+#define _PATH_LOG ""            /* dummy */
+      return 1;
 #else
-	  int flags;
-	  log_fd = socket(AF_UNIX, connection_type, 0);
-	  
-	  /* if max_logs is zero, leave the socket blocking */
-	  if (log_fd != -1 && max_logs != 0 && (flags = fcntl(log_fd, F_GETFL)) != -1)
-	    fcntl(log_fd, F_SETFL, flags | O_NONBLOCK);
+      int flags;
+      log_fd = socket(AF_UNIX, connection_type, 0);
+
+      /* if max_logs is zero, leave the socket blocking */
+      if (log_fd != -1 && max_logs != 0
+          && (flags = fcntl(log_fd, F_GETFL)) != -1)
+        fcntl(log_fd, F_SETFL, flags | O_NONBLOCK);
 #endif
-	}
     }
-  
+  }
+
   return log_fd != -1;
 }
 
@@ -146,128 +144,118 @@
   entries = tmp->next;
   tmp->next = free_entries;
   free_entries = tmp;
-}      
+}
 
 static void log_write(void)
 {
   ssize_t rc;
-   
-  while (entries)
-    {
-      /* The data in the payload is written with a terminating zero character 
-	 and the length reflects this. For a stream connection we need to 
-	 send the zero as a record terminator, but this isn't done for a 
-	 datagram connection, so treat the length as one less than reality 
-	 to elide the zero. If we're logging to a file, turn the zero into 
-	 a newline, and leave the length alone. */
-      int len_adjust = 0;
-
-      if (log_to_file)
-	entries->payload[entries->offset + entries->length - 1] = '\n';
-      else if (connection_type == SOCK_DGRAM)
-	len_adjust = 1;
-
-      /* Avoid duplicates over a fork() */
-      if (entries->pid != getpid())
-	{
-	  free_entry();
-	  continue;
-	}
-
-      connection_good = 1;
-
-      if ((rc = write(log_fd, entries->payload + entries->offset, entries->length - len_adjust)) != -1)
-	{
-	  entries->length -= rc;
-	  entries->offset += rc;
-	  if (entries->length == len_adjust)
-	    {
-	      free_entry();
-	      if (entries_lost != 0)
-		{
-		  int e = entries_lost;
-		  entries_lost = 0; /* avoid wild recursion */
-		  my_syslog(LOG_WARNING, _("overflow: %d log entries lost"), e);
-		}	  
-	    }
-	  continue;
-	}
-      
-      if (errno == EINTR)
-	continue;
-
-      if (errno == EAGAIN || errno == EWOULDBLOCK)
-	return; /* syslogd busy, go again when select() or poll() says so */
-      
-      if (errno == ENOBUFS)
-	{
-	  connection_good = 0;
-	  return;
-	}
-
-      /* errors handling after this assumes sockets */ 
-      if (!log_to_file)
-	{
-	  /* Once a stream socket hits EPIPE, we have to close and re-open
-	     (we ignore SIGPIPE) */
-	  if (errno == EPIPE)
-	    {
-	      if (log_reopen(NULL))
-		continue;
-	    }
-	  else if (errno == ECONNREFUSED || 
-		   errno == ENOTCONN || 
-		   errno == EDESTADDRREQ || 
-		   errno == ECONNRESET)
-	    {
-	      /* socket went (syslogd down?), try and reconnect. If we fail,
-		 stop trying until the next call to my_syslog() 
-		 ECONNREFUSED -> connection went down
-		 ENOTCONN -> nobody listening
-		 (ECONNRESET, EDESTADDRREQ are *BSD equivalents) */
-	      
-	      struct sockaddr_un logaddr;
-	      
+
+  while (entries) {
+    /* The data in the payload is written with a terminating zero character
+       and the length reflects this. For a stream connection we need to
+       send the zero as a record terminator, but this isn't done for a
+       datagram connection, so treat the length as one less than reality
+       to elide the zero. If we're logging to a file, turn the zero into
+       a newline, and leave the length alone. */
+    int len_adjust = 0;
+
+    if (log_to_file)
+      entries->payload[entries->offset + entries->length - 1] = '\n';
+    else if (connection_type == SOCK_DGRAM)
+      len_adjust = 1;
+
+    /* Avoid duplicates over a fork() */
+    if (entries->pid != getpid()) {
+      free_entry();
+      continue;
+    }
+
+    connection_good = 1;
+
+    if ((rc =
+         write(log_fd, entries->payload + entries->offset,
+               entries->length - len_adjust)) != -1) {
+      entries->length -= rc;
+      entries->offset += rc;
+      if (entries->length == len_adjust) {
+        free_entry();
+        if (entries_lost != 0) {
+          int e = entries_lost;
+          entries_lost = 0;     /* avoid wild recursion */
+          my_syslog(LOG_WARNING, _("overflow: %d log entries lost"), e);
+        }
+      }
+      continue;
+    }
+
+    if (errno == EINTR)
+      continue;
+
+    if (errno == EAGAIN || errno == EWOULDBLOCK)
+      return;                   /* syslogd busy, go again when select() or poll() says so */
+
+    if (errno == ENOBUFS) {
+      connection_good = 0;
+      return;
+    }
+
+    /* errors handling after this assumes sockets */
+    if (!log_to_file) {
+      /* Once a stream socket hits EPIPE, we have to close and re-open
+         (we ignore SIGPIPE) */
+      if (errno == EPIPE) {
+        if (log_reopen(NULL))
+          continue;
+      } else if (errno == ECONNREFUSED ||
+                 errno == ENOTCONN ||
+                 errno == EDESTADDRREQ || errno == ECONNRESET) {
+        /* socket went (syslogd down?), try and reconnect. If we fail,
+           stop trying until the next call to my_syslog()
+           ECONNREFUSED -> connection went down
+           ENOTCONN -> nobody listening
+           (ECONNRESET, EDESTADDRREQ are *BSD equivalents) */
+
+        struct sockaddr_un logaddr;
+
 #ifdef HAVE_SOCKADDR_SA_LEN
-	      logaddr.sun_len = sizeof(logaddr) - sizeof(logaddr.sun_path) + strlen(_PATH_LOG) + 1; 
+        logaddr.sun_len =
+            sizeof(logaddr) - sizeof(logaddr.sun_path) + strlen(_PATH_LOG) + 1;
 #endif
-	      logaddr.sun_family = AF_UNIX;
-	      strncpy(logaddr.sun_path, _PATH_LOG, sizeof(logaddr.sun_path));
-	      
-	      /* Got connection back? try again. */
-	      if (connect(log_fd, (struct sockaddr *)&logaddr, sizeof(logaddr)) != -1)
-		continue;
-	      
-	      /* errors from connect which mean we should keep trying */
-	      if (errno == ENOENT || 
-		  errno == EALREADY || 
-		  errno == ECONNREFUSED ||
-		  errno == EISCONN || 
-		  errno == EINTR ||
-		  errno == EAGAIN || 
-		  errno == EWOULDBLOCK)
-		{
-		  /* try again on next syslog() call */
-		  connection_good = 0;
-		  return;
-		}
-	      
-	      /* try the other sort of socket... */
-	      if (errno == EPROTOTYPE)
-		{
-		  connection_type = connection_type == SOCK_DGRAM ? SOCK_STREAM : SOCK_DGRAM;
-		  if (log_reopen(NULL))
-		    continue;
-		}
-	    }
-	}
-
-      /* give up - fall back to syslog() - this handles out-of-space
-	 when logging to a file, for instance. */
-      log_fd = -1;
-      my_syslog(LOG_CRIT, _("log failed: %s"), strerror(errno));
-      return;
+        logaddr.sun_family = AF_UNIX;
+        strncpy(logaddr.sun_path, _PATH_LOG, sizeof(logaddr.sun_path));
+
+        /* Got connection back? try again. */
+        if (connect(log_fd, (struct sockaddr *) &logaddr, sizeof(logaddr)) !=
+            -1)
+          continue;
+
+        /* errors from connect which mean we should keep trying */
+        if (errno == ENOENT ||
+            errno == EALREADY ||
+            errno == ECONNREFUSED ||
+            errno == EISCONN ||
+            errno == EINTR || errno == EAGAIN || errno == EWOULDBLOCK) {
+          /* try again on next syslog() call */
+          connection_good = 0;
+          return;
+        }
+
+        /* try the other sort of socket... */
+        if (errno == EPROTOTYPE) {
+          connection_type =
+              connection_type == SOCK_DGRAM ? SOCK_STREAM : SOCK_DGRAM;
+          if (log_reopen(NULL))
+            continue;
+        }
+      }
     }
+
+    /* give up - fall back to syslog() - this handles out-of-space
+       when logging to a file, for instance. */
+    log_fd = -1;
+    my_syslog(LOG_CRIT, _("log failed: %s"), strerror(errno));
+    return;
+  }
 }
 
 /* priority is one of LOG_DEBUG, LOG_INFO, LOG_NOTICE, etc. See sys/syslog.h.
@@ -290,7 +278,7 @@
     func = "-dhcp";
   else if ((LOG_FACMASK & priority) == MS_SCRIPT)
     func = "-script";
-	    
+
 #ifdef LOG_PRI
   priority = LOG_PRI(priority);
 #else
@@ -298,96 +286,92 @@
   priority &= LOG_PRIMASK;
 #endif
 
-  if (echo_stderr) 
-    {
-      fprintf(stderr, "dnsmasq%s: ", func);
-      va_start(ap, format);
-      vfprintf(stderr, format, ap);
-      va_end(ap);
-      fputc('\n', stderr);
-    }
+  if (echo_stderr) {
+    fprintf(stderr, "dnsmasq%s: ", func);
+    va_start(ap, format);
+    vfprintf(stderr, format, ap);
+    va_end(ap);
+    fputc('\n', stderr);
+  }
 
-  if (log_fd == -1)
-    {
+  if (log_fd == -1) {
 #ifdef __ANDROID__
-      /* do android-specific logging. 
-	 log_fd is always -1 on Android except when logging to a file. */
-      int alog_lvl;
-      
-      if (priority <= LOG_ERR)
-	alog_lvl = ANDROID_LOG_ERROR;
-      else if (priority == LOG_WARNING)
-	alog_lvl = ANDROID_LOG_WARN;
-      else if (priority <= LOG_INFO)
-	alog_lvl = ANDROID_LOG_INFO;
-      else
-	alog_lvl = ANDROID_LOG_DEBUG;
-
-      va_start(ap, format);
-      __android_log_vprint(alog_lvl, "dnsmasq", format, ap);
-      va_end(ap);
+    /* do android-specific logging.
+       log_fd is always -1 on Android except when logging to a file. */
+    int alog_lvl;
+
+    if (priority <= LOG_ERR)
+      alog_lvl = ANDROID_LOG_ERROR;
+    else if (priority == LOG_WARNING)
+      alog_lvl = ANDROID_LOG_WARN;
+    else if (priority <= LOG_INFO)
+      alog_lvl = ANDROID_LOG_INFO;
+    else
+      alog_lvl = ANDROID_LOG_DEBUG;
+
+    va_start(ap, format);
+    __android_log_vprint(alog_lvl, "dnsmasq", format, ap);
+    va_end(ap);
 #else
-      /* fall-back to syslog if we die during startup or 
-	 fail during running (always on Solaris). */
-      static int isopen = 0;
-
-      if (!isopen)
-	{
-	  openlog("dnsmasq", LOG_PID, log_fac);
-	  isopen = 1;
-	}
-      va_start(ap, format);  
-      vsyslog(priority, format, ap);
-      va_end(ap);
+    /* fall-back to syslog if we die during startup or
+       fail during running (always on Solaris). */
+    static int isopen = 0;
+
+    if (!isopen) {
+      openlog("dnsmasq", LOG_PID, log_fac);
+      isopen = 1;
+    }
+    va_start(ap, format);
+    vsyslog(priority, format, ap);
+    va_end(ap);
 #endif
 
-      return;
-    }
-  
+    return;
+  }
+
   if ((entry = free_entries))
     free_entries = entry->next;
-  else if (entries_alloced < max_logs && (entry = malloc(sizeof(struct log_entry))))
+  else if (entries_alloced < max_logs
+           && (entry = malloc(sizeof(struct log_entry))))
     entries_alloced++;
-  
+
   if (!entry)
     entries_lost++;
-  else
-    {
-      /* add to end of list, consumed from the start */
-      entry->next = NULL;
-      if (!entries)
-	entries = entry;
-      else
-	{
-	  struct log_entry *tmp;
-	  for (tmp = entries; tmp->next; tmp = tmp->next);
-	  tmp->next = entry;
-	}
-      
-      time(&time_now);
-      p = entry->payload;
-      if (!log_to_file)
-	p += sprintf(p, "<%d>", priority | log_fac);
-
-      /* Omit timestamp for default daemontools situation */
-      if (!log_stderr || !option_bool(OPT_NO_FORK)) 
-	p += sprintf(p, "%.15s ", ctime(&time_now) + 4);
-      
-      p += sprintf(p, "dnsmasq%s[%d]: ", func, (int)pid);
-        
-      len = p - entry->payload;
-      va_start(ap, format);  
-      len += vsnprintf(p, MAX_MESSAGE - len, format, ap) + 1; /* include zero-terminator */
-      va_end(ap);
-      entry->length = len > MAX_MESSAGE ? MAX_MESSAGE : len;
-      entry->offset = 0;
-      entry->pid = pid;
+  else {
+    /* add to end of list, consumed from the start */
+    entry->next = NULL;
+    if (!entries)
+      entries = entry;
+    else {
+      struct log_entry *tmp;
+      for (tmp = entries; tmp->next; tmp = tmp->next);
+      tmp->next = entry;
     }
-  
+
+    time(&time_now);
+    p = entry->payload;
+    if (!log_to_file)
+      p += sprintf(p, "<%d>", priority | log_fac);
+
+    /* Omit timestamp for default daemontools situation */
+    if (!log_stderr || !option_bool(OPT_NO_FORK))
+      p += sprintf(p, "%.15s ", ctime(&time_now) + 4);
+
+    p += sprintf(p, "dnsmasq%s[%d]: ", func, (int) pid);
+
+    len = p - entry->payload;
+    va_start(ap, format);
+    len += vsnprintf(p, MAX_MESSAGE - len, format, ap) + 1;     /* include zero-terminator */
+    va_end(ap);
+    entry->length = len > MAX_MESSAGE ? MAX_MESSAGE : len;
+    entry->offset = 0;
+    entry->pid = pid;
+  }
+
   /* almost always, logging won't block, so try and write this now,
      to save collecting too many log messages during a select loop. */
   log_write();
-  
+
   /* Since we're doing things asynchronously, a cache-dump, for instance,
      can now generate log lines very fast. With a small buffer (desirable),
      that means it can overflow the log-buffer very quickly,
@@ -397,30 +381,28 @@
      The scaling stuff ensures that when the queue is bigger than 8, the delay
      only occurs for the last 8 entries. Once the queue is full, we stop delaying
      to preserve performance.
-  */
+   */
+
+  if (entries && max_logs != 0) {
+    int d;
+
+    for (d = 0, entry = entries; entry; entry = entry->next, d++);
+
+    if (d == max_logs)
+      d = 0;
+    else if (max_logs > 8)
+      d -= max_logs - 8;
+
+    if (d > 0) {
+      struct timespec waiter;
+      waiter.tv_sec = 0;
+      waiter.tv_nsec = 1000000 << (d - 1);      /* 1 ms */
+      nanosleep(&waiter, NULL);
 
-  if (entries && max_logs != 0)
-    {
-      int d;
-      
-      for (d = 0,entry = entries; entry; entry = entry->next, d++);
-      
-      if (d == max_logs)
-	d = 0;
-      else if (max_logs > 8)
-	d -= max_logs - 8;
-
-      if (d > 0)
-	{
-	  struct timespec waiter;
-	  waiter.tv_sec = 0;
-	  waiter.tv_nsec = 1000000 << (d - 1); /* 1 ms */
-	  nanosleep(&waiter, NULL);
-      
-	  /* Have another go now */
-	  log_write();
-	}
-    } 
+      /* Have another go now */
+      log_write();
+    }
+  }
 }
 
 void set_log_writer(void)
@@ -438,38 +420,35 @@
 void flush_log(void)
 {
   /* write until queue empty, but don't loop forever if there's
-   no connection to the syslog in existence */
-  while (log_fd != -1)
-    {
-      struct timespec waiter;
-      log_write();
-      if (!entries || !connection_good)
-	{
-	  close(log_fd);	
-	  break;
-	}
-      waiter.tv_sec = 0;
-      waiter.tv_nsec = 1000000; /* 1 ms */
-      nanosleep(&waiter, NULL);
+     no connection to the syslog in existence */
+  while (log_fd != -1) {
+    struct timespec waiter;
+    log_write();
+    if (!entries || !connection_good) {
+      close(log_fd);
+      break;
     }
+    waiter.tv_sec = 0;
+    waiter.tv_nsec = 1000000;   /* 1 ms */
+    nanosleep(&waiter, NULL);
+  }
 }
 
 void die(char *message, char *arg1, int exit_code)
 {
   char *errmess = strerror(errno);
-  
+
   if (!arg1)
     arg1 = errmess;
 
-  if (!log_stderr)
-    {
-      echo_stderr = 1; /* print as well as log when we die.... */
-      fputc('\n', stderr); /* prettyfy  startup-script message */
-    }
+  if (!log_stderr) {
+    echo_stderr = 1;            /* print as well as log when we die.... */
+    fputc('\n', stderr);        /* prettyfy  startup-script message */
+  }
   my_syslog(LOG_CRIT, message, arg1, errmess);
   echo_stderr = 0;
   my_syslog(LOG_CRIT, _("FAILED to start up"));
   flush_log();
-  
+
   exit(exit_code);
 }
Index: dnsmasq-2.78/src/loop.c
===================================================================
--- dnsmasq-2.78.orig/src/loop.c	2017-10-02 21:13:51.000000000 +0800
+++ dnsmasq-2.78/src/loop.c	2018-10-29 16:14:19.429440025 +0800
@@ -21,45 +21,44 @@
 
 void loop_send_probes()
 {
-   struct server *serv;
-   
-   if (!option_bool(OPT_LOOP_DETECT))
-     return;
-
-   /* Loop through all upstream servers not for particular domains, and send a query to that server which is
-      identifiable, via the uid. If we see that query back again, then the server is looping, and we should not use it. */
-   for (serv = daemon->servers; serv; serv = serv->next)
-     if (!(serv->flags & 
-	   (SERV_LITERAL_ADDRESS | SERV_NO_ADDR | SERV_USE_RESOLV | SERV_NO_REBIND | SERV_HAS_DOMAIN | SERV_FOR_NODOTS | SERV_LOOP)))
-       {
-	 ssize_t len = loop_make_probe(serv->uid);
-	 int fd;
-	 struct randfd *rfd = NULL;
-	 
-	 if (serv->sfd)
-	   fd = serv->sfd->fd;
-	 else 
-	   {
-	     if (!(rfd = allocate_rfd(serv->addr.sa.sa_family)))
-	       continue;
-	     fd = rfd->fd;
-	   }
-
-	 while (retry_send(sendto(fd, daemon->packet, len, 0, 
-				  &serv->addr.sa, sa_len(&serv->addr))));
-	 
-	 free_rfd(rfd);
-       }
+  struct server *serv;
+
+  if (!option_bool(OPT_LOOP_DETECT))
+    return;
+
+  /* Loop through all upstream servers not for particular domains, and send a query to that server which is
+     identifiable, via the uid. If we see that query back again, then the server is looping, and we should not use it. */
+  for (serv = daemon->servers; serv; serv = serv->next)
+    if (!(serv->flags &
+          (SERV_LITERAL_ADDRESS | SERV_NO_ADDR | SERV_USE_RESOLV |
+           SERV_NO_REBIND | SERV_HAS_DOMAIN | SERV_FOR_NODOTS | SERV_LOOP))) {
+      ssize_t len = loop_make_probe(serv->uid);
+      int fd;
+      struct randfd *rfd = NULL;
+
+      if (serv->sfd)
+        fd = serv->sfd->fd;
+      else {
+        if (!(rfd = allocate_rfd(serv->addr.sa.sa_family)))
+          continue;
+        fd = rfd->fd;
+      }
+
+      while (retry_send(sendto(fd, daemon->packet, len, 0,
+                               &serv->addr.sa, sa_len(&serv->addr))));
+
+      free_rfd(rfd);
+    }
 }
-  
+
 static ssize_t loop_make_probe(u32 uid)
 {
-  struct dns_header *header = (struct dns_header *)daemon->packet;
-  unsigned char *p = (unsigned char *)(header+1);
+  struct dns_header *header = (struct dns_header *) daemon->packet;
+  unsigned char *p = (unsigned char *) (header + 1);
 
   /* packet buffer overwritten */
   daemon->srv_save = NULL;
-  
+
   header->id = rand16();
   header->ancount = header->nscount = header->arcount = htons(0);
   header->qdcount = htons(1);
@@ -68,25 +67,25 @@
   SET_OPCODE(header, QUERY);
 
   *p++ = 8;
-  sprintf((char *)p, "%.8x", uid);
+  sprintf((char *) p, "%.8x", uid);
   p += 8;
   *p++ = strlen(LOOP_TEST_DOMAIN);
-  strcpy((char *)p, LOOP_TEST_DOMAIN); /* Add terminating zero */
+  strcpy((char *) p, LOOP_TEST_DOMAIN); /* Add terminating zero */
   p += strlen(LOOP_TEST_DOMAIN) + 1;
 
   PUTSHORT(LOOP_TEST_TYPE, p);
   PUTSHORT(C_IN, p);
 
-  return p - (unsigned char *)header;
+  return p - (unsigned char *) header;
 }
-  
+
 
 int detect_loop(char *query, int type)
 {
   int i;
   u32 uid;
   struct server *serv;
-  
+
   if (!option_bool(OPT_LOOP_DETECT))
     return 0;
 
@@ -102,14 +101,14 @@
   uid = strtol(query, NULL, 16);
 
   for (serv = daemon->servers; serv; serv = serv->next)
-     if (!(serv->flags & 
-	   (SERV_LITERAL_ADDRESS | SERV_NO_ADDR | SERV_USE_RESOLV | SERV_NO_REBIND | SERV_HAS_DOMAIN | SERV_FOR_NODOTS | SERV_LOOP)) &&
-	 uid == serv->uid)
-       {
-	 serv->flags |= SERV_LOOP;
-	 check_servers(); /* log new state */
-	 return 1;
-       }
+    if (!(serv->flags &
+          (SERV_LITERAL_ADDRESS | SERV_NO_ADDR | SERV_USE_RESOLV |
+           SERV_NO_REBIND | SERV_HAS_DOMAIN | SERV_FOR_NODOTS | SERV_LOOP))
+        && uid == serv->uid) {
+      serv->flags |= SERV_LOOP;
+      check_servers();          /* log new state */
+      return 1;
+    }
 
   return 0;
 }
Index: dnsmasq-2.78/src/netlink.c
===================================================================
--- dnsmasq-2.78.orig/src/netlink.c	2017-10-02 21:13:51.000000000 +0800
+++ dnsmasq-2.78/src/netlink.c	2018-10-29 16:14:19.429440025 +0800
@@ -22,17 +22,17 @@
 #include <linux/netlink.h>
 #include <linux/rtnetlink.h>
 
-/* linux 2.6.19 buggers up the headers, patch it up here. */ 
+/* linux 2.6.19 buggers up the headers, patch it up here. */
 #ifndef IFA_RTA
-#  define IFA_RTA(r)  \
+#define IFA_RTA(r)  \
        ((struct rtattr*)(((char*)(r)) + NLMSG_ALIGN(sizeof(struct ifaddrmsg))))
 
-#  include <linux/if_addr.h>
+#include <linux/if_addr.h>
 #endif
 
 #ifndef NDA_RTA
-#  define NDA_RTA(r) ((struct rtattr*)(((char*)(r)) + NLMSG_ALIGN(sizeof(struct ndmsg)))) 
-#endif 
+#define NDA_RTA(r) ((struct rtattr*)(((char*)(r)) + NLMSG_ALIGN(sizeof(struct ndmsg))))
+#endif
 
 
 static struct iovec iov;
@@ -47,10 +47,10 @@
 
   addr.nl_family = AF_NETLINK;
   addr.nl_pad = 0;
-  addr.nl_pid = 0; /* autobind */
+  addr.nl_pid = 0;              /* autobind */
   addr.nl_groups = RTMGRP_IPV4_ROUTE;
   if (option_bool(OPT_CLEVERBIND))
-    addr.nl_groups |= RTMGRP_IPV4_IFADDR;  
+    addr.nl_groups |= RTMGRP_IPV4_IFADDR;
 #ifdef HAVE_IPV6
   addr.nl_groups |= RTMGRP_IPV6_ROUTE;
   if (option_bool(OPT_CLEVERBIND))
@@ -60,25 +60,25 @@
   if (daemon->doing_ra || daemon->doing_dhcp6)
     addr.nl_groups |= RTMGRP_IPV6_IFADDR;
 #endif
-  
+
   /* May not be able to have permission to set multicast groups don't die in that case */
-  if ((daemon->netlinkfd = socket(AF_NETLINK, SOCK_RAW, NETLINK_ROUTE)) != -1)
-    {
-      if (bind(daemon->netlinkfd, (struct sockaddr *)&addr, sizeof(addr)) == -1)
-	{
-	  addr.nl_groups = 0;
-	  if (errno != EPERM || bind(daemon->netlinkfd, (struct sockaddr *)&addr, sizeof(addr)) == -1)
-	    daemon->netlinkfd = -1;
-	}
+  if ((daemon->netlinkfd = socket(AF_NETLINK, SOCK_RAW, NETLINK_ROUTE)) != -1) {
+    if (bind(daemon->netlinkfd, (struct sockaddr *) &addr, sizeof(addr)) == -1) {
+      addr.nl_groups = 0;
+      if (errno != EPERM
+          || bind(daemon->netlinkfd, (struct sockaddr *) &addr,
+                  sizeof(addr)) == -1)
+        daemon->netlinkfd = -1;
     }
-  
-  if (daemon->netlinkfd == -1 || 
-      getsockname(daemon->netlinkfd, (struct sockaddr *)&addr, &slen) == -1)
+  }
+
+  if (daemon->netlinkfd == -1 ||
+      getsockname(daemon->netlinkfd, (struct sockaddr *) &addr, &slen) == -1)
     die(_("cannot create netlink socket: %s"), NULL, EC_MISC);
-   
-  /* save pid assigned by bind() and retrieved by getsockname() */ 
+
+  /* save pid assigned by bind() and retrieved by getsockname() */
   netlink_pid = addr.nl_pid;
-  
+
   iov.iov_len = 100;
   iov.iov_base = safe_malloc(iov.iov_len);
 }
@@ -89,54 +89,50 @@
   struct sockaddr_nl nladdr;
   ssize_t rc;
 
-  while (1)
-    {
-      msg.msg_control = NULL;
-      msg.msg_controllen = 0;
-      msg.msg_name = &nladdr;
-      msg.msg_namelen = sizeof(nladdr);
-      msg.msg_iov = &iov;
-      msg.msg_iovlen = 1;
-      msg.msg_flags = 0;
-      
-      while ((rc = recvmsg(daemon->netlinkfd, &msg, MSG_PEEK | MSG_TRUNC)) == -1 && errno == EINTR);
-      
-      /* make buffer big enough */
-      if (rc != -1 && (msg.msg_flags & MSG_TRUNC))
-	{
-	  /* Very new Linux kernels return the actual size needed, older ones always return truncated size */
-	  if ((size_t)rc == iov.iov_len)
-	    {
-	      if (expand_buf(&iov, rc + 100))
-		continue;
-	    }
-	  else
-	    expand_buf(&iov, rc);
-	}
-
-      /* read it for real */
-      msg.msg_flags = 0;
-      while ((rc = recvmsg(daemon->netlinkfd, &msg, 0)) == -1 && errno == EINTR);
-      
-      /* Make sure this is from the kernel */
-      if (rc == -1 || nladdr.nl_pid == 0)
-	break;
+  while (1) {
+    msg.msg_control = NULL;
+    msg.msg_controllen = 0;
+    msg.msg_name = &nladdr;
+    msg.msg_namelen = sizeof(nladdr);
+    msg.msg_iov = &iov;
+    msg.msg_iovlen = 1;
+    msg.msg_flags = 0;
+
+    while ((rc = recvmsg(daemon->netlinkfd, &msg, MSG_PEEK | MSG_TRUNC)) == -1
+           && errno == EINTR);
+
+    /* make buffer big enough */
+    if (rc != -1 && (msg.msg_flags & MSG_TRUNC)) {
+      /* Very new Linux kernels return the actual size needed, older ones always return truncated size */
+      if ((size_t) rc == iov.iov_len) {
+        if (expand_buf(&iov, rc + 100))
+          continue;
+      } else
+        expand_buf(&iov, rc);
     }
-      
+
+    /* read it for real */
+    msg.msg_flags = 0;
+    while ((rc = recvmsg(daemon->netlinkfd, &msg, 0)) == -1 && errno == EINTR);
+
+    /* Make sure this is from the kernel */
+    if (rc == -1 || nladdr.nl_pid == 0)
+      break;
+  }
+
   /* discard stuff which is truncated at this point (expand_buf() may fail) */
-  if (msg.msg_flags & MSG_TRUNC)
-    {
-      rc = -1;
-      errno = ENOMEM;
-    }
-  
+  if (msg.msg_flags & MSG_TRUNC) {
+    rc = -1;
+    errno = ENOMEM;
+  }
+
   return rc;
 }
-  
+
 
 /* family = AF_UNSPEC finds ARP table entries.
    family = AF_LOCAL finds MAC addresses. */
-int iface_enumerate(int family, void *parm, int (*callback)())
+int iface_enumerate(int family, void *parm, int (*callback) ())
 {
   struct sockaddr_nl addr;
   struct nlmsghdr *h;
@@ -146,15 +142,15 @@
 
   struct {
     struct nlmsghdr nlh;
-    struct rtgenmsg g; 
+    struct rtgenmsg g;
   } req;
 
   addr.nl_family = AF_NETLINK;
   addr.nl_pad = 0;
   addr.nl_groups = 0;
-  addr.nl_pid = 0; /* address to kernel */
- 
- again: 
+  addr.nl_pid = 0;              /* address to kernel */
+
+again:
   if (family == AF_UNSPEC)
     req.nlh.nlmsg_type = RTM_GETNEIGH;
   else if (family == AF_LOCAL)
@@ -163,168 +159,157 @@
     req.nlh.nlmsg_type = RTM_GETADDR;
 
   req.nlh.nlmsg_len = sizeof(req);
-  req.nlh.nlmsg_flags = NLM_F_ROOT | NLM_F_MATCH | NLM_F_REQUEST | NLM_F_ACK; 
+  req.nlh.nlmsg_flags = NLM_F_ROOT | NLM_F_MATCH | NLM_F_REQUEST | NLM_F_ACK;
   req.nlh.nlmsg_pid = 0;
   req.nlh.nlmsg_seq = ++seq;
-  req.g.rtgen_family = family; 
+  req.g.rtgen_family = family;
 
   /* Don't block in recvfrom if send fails */
-  while(retry_send(sendto(daemon->netlinkfd, (void *)&req, sizeof(req), 0, 
-			  (struct sockaddr *)&addr, sizeof(addr))));
+  while (retry_send(sendto(daemon->netlinkfd, (void *) &req, sizeof(req), 0,
+                           (struct sockaddr *) &addr, sizeof(addr))));
 
   if (errno != 0)
     return 0;
-    
-  while (1)
-    {
-      if ((len = netlink_recv()) == -1)
-	{
-	  if (errno == ENOBUFS)
-	    {
-	      sleep(1);
-	      goto again;
-	    }
-	  return 0;
-	}
-
-      for (h = (struct nlmsghdr *)iov.iov_base; NLMSG_OK(h, (size_t)len); h = NLMSG_NEXT(h, len))
-	if (h->nlmsg_pid != netlink_pid || h->nlmsg_type == NLMSG_ERROR)
-	  {
-	    /* May be multicast arriving async */
-	    nl_async(h);
-	  }
-	else if (h->nlmsg_seq != seq)
-	  {
-	    /* May be part of incomplete response to previous request after
-	       ENOBUFS. Drop it. */
-	    continue;
-	  }
-	else if (h->nlmsg_type == NLMSG_DONE)
-	  return callback_ok;
-	else if (h->nlmsg_type == RTM_NEWADDR && family != AF_UNSPEC && family != AF_LOCAL)
-	  {
-	    struct ifaddrmsg *ifa = NLMSG_DATA(h);  
-	    struct rtattr *rta = IFA_RTA(ifa);
-	    unsigned int len1 = h->nlmsg_len - NLMSG_LENGTH(sizeof(*ifa));
-	    
-	    if (ifa->ifa_family == family)
-	      {
-		if (ifa->ifa_family == AF_INET)
-		  {
-		    struct in_addr netmask, addr, broadcast;
-		    char *label = NULL;
-
-		    netmask.s_addr = htonl(~(in_addr_t)0 << (32 - ifa->ifa_prefixlen));
-
-		    addr.s_addr = 0;
-		    broadcast.s_addr = 0;
-		    
-		    while (RTA_OK(rta, len1))
-		      {
-			if (rta->rta_type == IFA_LOCAL)
-			  addr = *((struct in_addr *)(rta+1));
-			else if (rta->rta_type == IFA_BROADCAST)
-			  broadcast = *((struct in_addr *)(rta+1));
-			else if (rta->rta_type == IFA_LABEL)
-			  label = RTA_DATA(rta);
-			
-			rta = RTA_NEXT(rta, len1);
-		      }
-		    
-		    if (addr.s_addr && callback_ok)
-		      if (!((*callback)(addr, ifa->ifa_index, label,  netmask, broadcast, parm)))
-			callback_ok = 0;
-		  }
+
+  while (1) {
+    if ((len = netlink_recv()) == -1) {
+      if (errno == ENOBUFS) {
+        sleep(1);
+        goto again;
+      }
+      return 0;
+    }
+
+    for (h = (struct nlmsghdr *) iov.iov_base; NLMSG_OK(h, (size_t) len);
+         h = NLMSG_NEXT(h, len))
+      if (h->nlmsg_pid != netlink_pid || h->nlmsg_type == NLMSG_ERROR) {
+        /* May be multicast arriving async */
+        nl_async(h);
+      } else if (h->nlmsg_seq != seq) {
+        /* May be part of incomplete response to previous request after
+           ENOBUFS. Drop it. */
+        continue;
+      } else if (h->nlmsg_type == NLMSG_DONE)
+        return callback_ok;
+      else if (h->nlmsg_type == RTM_NEWADDR && family != AF_UNSPEC
+               && family != AF_LOCAL) {
+        struct ifaddrmsg *ifa = NLMSG_DATA(h);
+        struct rtattr *rta = IFA_RTA(ifa);
+        unsigned int len1 = h->nlmsg_len - NLMSG_LENGTH(sizeof(*ifa));
+
+        if (ifa->ifa_family == family) {
+          if (ifa->ifa_family == AF_INET) {
+            struct in_addr netmask, addr, broadcast;
+            char *label = NULL;
+
+            netmask.s_addr = htonl(~(in_addr_t) 0 << (32 - ifa->ifa_prefixlen));
+
+            addr.s_addr = 0;
+            broadcast.s_addr = 0;
+
+            while (RTA_OK(rta, len1)) {
+              if (rta->rta_type == IFA_LOCAL)
+                addr = *((struct in_addr *) (rta + 1));
+              else if (rta->rta_type == IFA_BROADCAST)
+                broadcast = *((struct in_addr *) (rta + 1));
+              else if (rta->rta_type == IFA_LABEL)
+                label = RTA_DATA(rta);
+
+              rta = RTA_NEXT(rta, len1);
+            }
+
+            if (addr.s_addr && callback_ok)
+              if (!
+                  ((*callback)
+                   (addr, ifa->ifa_index, label, netmask, broadcast, parm)))
+                callback_ok = 0;
+          }
 #ifdef HAVE_IPV6
-		else if (ifa->ifa_family == AF_INET6)
-		  {
-		    struct in6_addr *addrp = NULL;
-		    u32 valid = 0, preferred = 0;
-		    int flags = 0;
-		    
-		    while (RTA_OK(rta, len1))
-		      {
-			if (rta->rta_type == IFA_ADDRESS)
-			  addrp = ((struct in6_addr *)(rta+1)); 
-			else if (rta->rta_type == IFA_CACHEINFO)
-			  {
-			    struct ifa_cacheinfo *ifc = (struct ifa_cacheinfo *)(rta+1);
-			    preferred = ifc->ifa_prefered;
-			    valid = ifc->ifa_valid;
-			  }
-			rta = RTA_NEXT(rta, len1);
-		      }
-		    
-		    if (ifa->ifa_flags & IFA_F_TENTATIVE)
-		      flags |= IFACE_TENTATIVE;
-		    
-		    if (ifa->ifa_flags & IFA_F_DEPRECATED)
-		      flags |= IFACE_DEPRECATED;
-		    
-		    if (!(ifa->ifa_flags & IFA_F_TEMPORARY))
-		      flags |= IFACE_PERMANENT;
-    		    
-		    if (addrp && callback_ok)
-		      if (!((*callback)(addrp, (int)(ifa->ifa_prefixlen), (int)(ifa->ifa_scope), 
-					(int)(ifa->ifa_index), flags, 
-					(int) preferred, (int)valid, parm)))
-			callback_ok = 0;
-		  }
+          else if (ifa->ifa_family == AF_INET6) {
+            struct in6_addr *addrp = NULL;
+            u32 valid = 0, preferred = 0;
+            int flags = 0;
+
+            while (RTA_OK(rta, len1)) {
+              if (rta->rta_type == IFA_ADDRESS)
+                addrp = ((struct in6_addr *) (rta + 1));
+              else if (rta->rta_type == IFA_CACHEINFO) {
+                struct ifa_cacheinfo *ifc = (struct ifa_cacheinfo *) (rta + 1);
+                preferred = ifc->ifa_prefered;
+                valid = ifc->ifa_valid;
+              }
+              rta = RTA_NEXT(rta, len1);
+            }
+
+            if (ifa->ifa_flags & IFA_F_TENTATIVE)
+              flags |= IFACE_TENTATIVE;
+
+            if (ifa->ifa_flags & IFA_F_DEPRECATED)
+              flags |= IFACE_DEPRECATED;
+
+            if (!(ifa->ifa_flags & IFA_F_TEMPORARY))
+              flags |= IFACE_PERMANENT;
+
+            if (addrp && callback_ok)
+              if (!
+                  ((*callback)
+                   (addrp, (int) (ifa->ifa_prefixlen), (int) (ifa->ifa_scope),
+                    (int) (ifa->ifa_index), flags, (int) preferred, (int) valid,
+                    parm)))
+                callback_ok = 0;
+          }
 #endif
-	      }
-	  }
-	else if (h->nlmsg_type == RTM_NEWNEIGH && family == AF_UNSPEC)
-	  {
-	    struct ndmsg *neigh = NLMSG_DATA(h);  
-	    struct rtattr *rta = NDA_RTA(neigh);
-	    unsigned int len1 = h->nlmsg_len - NLMSG_LENGTH(sizeof(*neigh));
-	    size_t maclen = 0;
-	    char *inaddr = NULL, *mac = NULL;
-	    
-	    while (RTA_OK(rta, len1))
-	      {
-		if (rta->rta_type == NDA_DST)
-		  inaddr = (char *)(rta+1);
-		else if (rta->rta_type == NDA_LLADDR)
-		  {
-		    maclen = rta->rta_len - sizeof(struct rtattr);
-		    mac = (char *)(rta+1);
-		  }
-		
-		rta = RTA_NEXT(rta, len1);
-	      }
-
-	    if (!(neigh->ndm_state & (NUD_NOARP | NUD_INCOMPLETE | NUD_FAILED)) &&
-		inaddr && mac && callback_ok)
-	      if (!((*callback)(neigh->ndm_family, inaddr, mac, maclen, parm)))
-		callback_ok = 0;
-	  }
+        }
+      } else if (h->nlmsg_type == RTM_NEWNEIGH && family == AF_UNSPEC) {
+        struct ndmsg *neigh = NLMSG_DATA(h);
+        struct rtattr *rta = NDA_RTA(neigh);
+        unsigned int len1 = h->nlmsg_len - NLMSG_LENGTH(sizeof(*neigh));
+        size_t maclen = 0;
+        char *inaddr = NULL, *mac = NULL;
+
+        while (RTA_OK(rta, len1)) {
+          if (rta->rta_type == NDA_DST)
+            inaddr = (char *) (rta + 1);
+          else if (rta->rta_type == NDA_LLADDR) {
+            maclen = rta->rta_len - sizeof(struct rtattr);
+            mac = (char *) (rta + 1);
+          }
+
+          rta = RTA_NEXT(rta, len1);
+        }
+
+        if (!(neigh->ndm_state & (NUD_NOARP | NUD_INCOMPLETE | NUD_FAILED)) &&
+            inaddr && mac && callback_ok)
+          if (!((*callback) (neigh->ndm_family, inaddr, mac, maclen, parm)))
+            callback_ok = 0;
+      }
 #ifdef HAVE_DHCP6
-	else if (h->nlmsg_type == RTM_NEWLINK && family == AF_LOCAL)
-	  {
-	    struct ifinfomsg *link =  NLMSG_DATA(h);
-	    struct rtattr *rta = IFLA_RTA(link);
-	    unsigned int len1 = h->nlmsg_len - NLMSG_LENGTH(sizeof(*link));
-	    char *mac = NULL;
-	    size_t maclen = 0;
-
-	    while (RTA_OK(rta, len1))
-	      {
-		if (rta->rta_type == IFLA_ADDRESS)
-		  {
-		    maclen = rta->rta_len - sizeof(struct rtattr);
-		    mac = (char *)(rta+1);
-		  }
-		
-		rta = RTA_NEXT(rta, len1);
-	      }
-
-	    if (mac && callback_ok && !((link->ifi_flags & (IFF_LOOPBACK | IFF_POINTOPOINT))) && 
-		!((*callback)((int)link->ifi_index, (unsigned int)link->ifi_type, mac, maclen, parm)))
-	      callback_ok = 0;
-	  }
+      else if (h->nlmsg_type == RTM_NEWLINK && family == AF_LOCAL) {
+        struct ifinfomsg *link = NLMSG_DATA(h);
+        struct rtattr *rta = IFLA_RTA(link);
+        unsigned int len1 = h->nlmsg_len - NLMSG_LENGTH(sizeof(*link));
+        char *mac = NULL;
+        size_t maclen = 0;
+
+        while (RTA_OK(rta, len1)) {
+          if (rta->rta_type == IFLA_ADDRESS) {
+            maclen = rta->rta_len - sizeof(struct rtattr);
+            mac = (char *) (rta + 1);
+          }
+
+          rta = RTA_NEXT(rta, len1);
+        }
+
+        if (mac && callback_ok
+            && !((link->ifi_flags & (IFF_LOOPBACK | IFF_POINTOPOINT)))
+            &&
+            !((*callback)
+              ((int) link->ifi_index, (unsigned int) link->ifi_type, mac,
+               maclen, parm)))
+          callback_ok = 0;
+      }
 #endif
-    }
+  }
 }
 
 void netlink_multicast(void)
@@ -332,43 +317,39 @@
   ssize_t len;
   struct nlmsghdr *h;
   int flags;
-  
+
   /* don't risk blocking reading netlink messages here. */
   if ((flags = fcntl(daemon->netlinkfd, F_GETFL)) == -1 ||
-      fcntl(daemon->netlinkfd, F_SETFL, flags | O_NONBLOCK) == -1) 
+      fcntl(daemon->netlinkfd, F_SETFL, flags | O_NONBLOCK) == -1)
     return;
-  
+
   if ((len = netlink_recv()) != -1)
-    for (h = (struct nlmsghdr *)iov.iov_base; NLMSG_OK(h, (size_t)len); h = NLMSG_NEXT(h, len))
+    for (h = (struct nlmsghdr *) iov.iov_base; NLMSG_OK(h, (size_t) len);
+         h = NLMSG_NEXT(h, len))
       nl_async(h);
-  
+
   /* restore non-blocking status */
   fcntl(daemon->netlinkfd, F_SETFL, flags);
 }
 
 static void nl_async(struct nlmsghdr *h)
 {
-  if (h->nlmsg_type == NLMSG_ERROR)
-    {
-      struct nlmsgerr *err = NLMSG_DATA(h);
-      if (err->error != 0)
-	my_syslog(LOG_ERR, _("netlink returns error: %s"), strerror(-(err->error)));
-    }
-  else if (h->nlmsg_pid == 0 && h->nlmsg_type == RTM_NEWROUTE) 
-    {
-      /* We arrange to receive netlink multicast messages whenever the network route is added.
-	 If this happens and we still have a DNS packet in the buffer, we re-send it.
-	 This helps on DoD links, where frequently the packet which triggers dialling is
-	 a DNS query, which then gets lost. By re-sending, we can avoid the lookup
-	 failing. */ 
-      struct rtmsg *rtm = NLMSG_DATA(h);
-      
-      if (rtm->rtm_type == RTN_UNICAST && rtm->rtm_scope == RT_SCOPE_LINK)
-	queue_event(EVENT_NEWROUTE);
-    }
-  else if (h->nlmsg_type == RTM_NEWADDR || h->nlmsg_type == RTM_DELADDR) 
+  if (h->nlmsg_type == NLMSG_ERROR) {
+    struct nlmsgerr *err = NLMSG_DATA(h);
+    if (err->error != 0)
+      my_syslog(LOG_ERR, _("netlink returns error: %s"),
+                strerror(-(err->error)));
+  } else if (h->nlmsg_pid == 0 && h->nlmsg_type == RTM_NEWROUTE) {
+    /* We arrange to receive netlink multicast messages whenever the network route is added.
+       If this happens and we still have a DNS packet in the buffer, we re-send it.
+       This helps on DoD links, where frequently the packet which triggers dialling is
+       a DNS query, which then gets lost. By re-sending, we can avoid the lookup
+       failing. */
+    struct rtmsg *rtm = NLMSG_DATA(h);
+
+    if (rtm->rtm_type == RTN_UNICAST && rtm->rtm_scope == RT_SCOPE_LINK)
+      queue_event(EVENT_NEWROUTE);
+  } else if (h->nlmsg_type == RTM_NEWADDR || h->nlmsg_type == RTM_DELADDR)
     queue_event(EVENT_NEWADDR);
 }
 #endif
-
-      
Index: dnsmasq-2.78/src/network.c
===================================================================
--- dnsmasq-2.78.orig/src/network.c	2017-10-02 21:13:51.000000000 +0800
+++ dnsmasq-2.78/src/network.c	2018-10-29 16:14:19.437440025 +0800
@@ -21,7 +21,7 @@
 int indextoname(int fd, int index, char *name)
 {
   struct ifreq ifr;
-  
+
   if (index == 0)
     return 0;
 
@@ -40,7 +40,7 @@
 #include <zone.h>
 #include <alloca.h>
 #ifndef LIFC_UNDER_IPMP
-#  define LIFC_UNDER_IPMP 0
+#define LIFC_UNDER_IPMP 0
 #endif
 
 int indextoname(int fd, int index, char *name)
@@ -50,47 +50,45 @@
   int numifs, bufsize, i;
   struct lifconf lifc;
   struct lifreq *lifrp;
-  
+
   if (index == 0)
     return 0;
-  
-  if (getzoneid() == GLOBAL_ZONEID) 
-    {
-      if (!if_indextoname(index, name))
-	return 0;
-      return 1;
-    }
-  
+
+  if (getzoneid() == GLOBAL_ZONEID) {
+    if (!if_indextoname(index, name))
+      return 0;
+    return 1;
+  }
+
   lifc_flags = LIFC_NOXMIT | LIFC_TEMPORARY | LIFC_ALLZONES | LIFC_UNDER_IPMP;
   lifn.lifn_family = AF_UNSPEC;
   lifn.lifn_flags = lifc_flags;
-  if (ioctl(fd, SIOCGLIFNUM, &lifn) < 0) 
+  if (ioctl(fd, SIOCGLIFNUM, &lifn) < 0)
     return 0;
-  
+
   numifs = lifn.lifn_count;
   bufsize = numifs * sizeof(struct lifreq);
-  
+
   lifc.lifc_family = AF_UNSPEC;
   lifc.lifc_flags = lifc_flags;
   lifc.lifc_len = bufsize;
   lifc.lifc_buf = alloca(bufsize);
-  
-  if (ioctl(fd, SIOCGLIFCONF, &lifc) < 0)  
+
+  if (ioctl(fd, SIOCGLIFCONF, &lifc) < 0)
     return 0;
-  
+
   lifrp = lifc.lifc_req;
-  for (i = lifc.lifc_len / sizeof(struct lifreq); i; i--, lifrp++) 
-    {
-      struct lifreq lifr;
-      strncpy(lifr.lifr_name, lifrp->lifr_name, IF_NAMESIZE);
-      if (ioctl(fd, SIOCGLIFINDEX, &lifr) < 0) 
-	return 0;
-      
-      if (lifr.lifr_index == index) {
-	strncpy(name, lifr.lifr_name, IF_NAMESIZE);
-	return 1;
-      }
+  for (i = lifc.lifc_len / sizeof(struct lifreq); i; i--, lifrp++) {
+    struct lifreq lifr;
+    strncpy(lifr.lifr_name, lifrp->lifr_name, IF_NAMESIZE);
+    if (ioctl(fd, SIOCGLIFINDEX, &lifr) < 0)
+      return 0;
+
+    if (lifr.lifr_index == index) {
+      strncpy(name, lifr.lifr_name, IF_NAMESIZE);
+      return 1;
     }
+  }
   return 0;
 }
 
@@ -98,8 +96,8 @@
 #else
 
 int indextoname(int fd, int index, char *name)
-{ 
-  (void)fd;
+{
+  (void) fd;
 
   if (index == 0 || !if_indextoname(index, name))
     return 0;
@@ -118,63 +116,58 @@
      "used" flags.
 
      May be called with family == AF_LOCALto check interface by name only. */
-  
+
   if (auth)
     *auth = 0;
-  
-  if (daemon->if_names || daemon->if_addrs)
-    {
-      ret = 0;
 
-      for (tmp = daemon->if_names; tmp; tmp = tmp->next)
-	if (tmp->name && wildcard_match(tmp->name, name))
-	  ret = tmp->used = 1;
-	        
-      if (addr)
-	for (tmp = daemon->if_addrs; tmp; tmp = tmp->next)
-	  if (tmp->addr.sa.sa_family == family)
-	    {
-	      if (family == AF_INET &&
-		  tmp->addr.in.sin_addr.s_addr == addr->addr.addr4.s_addr)
-		ret = match_addr = tmp->used = 1;
-#ifdef HAVE_IPV6
-	      else if (family == AF_INET6 &&
-		       IN6_ARE_ADDR_EQUAL(&tmp->addr.in6.sin6_addr, 
-					  &addr->addr.addr6))
-		ret = match_addr = tmp->used = 1;
+  if (daemon->if_names || daemon->if_addrs) {
+    ret = 0;
+
+    for (tmp = daemon->if_names; tmp; tmp = tmp->next)
+      if (tmp->name && wildcard_match(tmp->name, name))
+        ret = tmp->used = 1;
+
+    if (addr)
+      for (tmp = daemon->if_addrs; tmp; tmp = tmp->next)
+        if (tmp->addr.sa.sa_family == family) {
+          if (family == AF_INET &&
+              tmp->addr.in.sin_addr.s_addr == addr->addr.addr4.s_addr)
+            ret = match_addr = tmp->used = 1;
+#ifdef HAVE_IPV6
+          else if (family == AF_INET6 &&
+                   IN6_ARE_ADDR_EQUAL(&tmp->addr.in6.sin6_addr,
+                                      &addr->addr.addr6))
+            ret = match_addr = tmp->used = 1;
 #endif
-	    }          
-    }
-  
+        }
+  }
+
   if (!match_addr)
     for (tmp = daemon->if_except; tmp; tmp = tmp->next)
       if (tmp->name && wildcard_match(tmp->name, name))
-	ret = 0;
-    
+        ret = 0;
+
 
   for (tmp = daemon->authinterface; tmp; tmp = tmp->next)
-    if (tmp->name)
-      {
-	if (strcmp(tmp->name, name) == 0 &&
-	    (tmp->addr.sa.sa_family == 0 || tmp->addr.sa.sa_family == family))
-	  break;
-      }
-    else if (addr && tmp->addr.sa.sa_family == AF_INET && family == AF_INET &&
-	     tmp->addr.in.sin_addr.s_addr == addr->addr.addr4.s_addr)
+    if (tmp->name) {
+      if (strcmp(tmp->name, name) == 0 &&
+          (tmp->addr.sa.sa_family == 0 || tmp->addr.sa.sa_family == family))
+        break;
+    } else if (addr && tmp->addr.sa.sa_family == AF_INET && family == AF_INET &&
+               tmp->addr.in.sin_addr.s_addr == addr->addr.addr4.s_addr)
       break;
 #ifdef HAVE_IPV6
     else if (addr && tmp->addr.sa.sa_family == AF_INET6 && family == AF_INET6 &&
-	     IN6_ARE_ADDR_EQUAL(&tmp->addr.in6.sin6_addr, &addr->addr.addr6))
+             IN6_ARE_ADDR_EQUAL(&tmp->addr.in6.sin6_addr, &addr->addr.addr6))
       break;
-#endif      
+#endif
 
-  if (tmp && auth) 
-    {
-      *auth = 1;
-      ret = 1;
-    }
+  if (tmp && auth) {
+    *auth = 1;
+    ret = 1;
+  }
 
-  return ret; 
+  return ret;
 }
 
 
@@ -183,30 +176,27 @@
    an interface other than the loopback. Accept packet if it arrived via a loopback 
    interface, even when we're not accepting packets that way, as long as the destination
    address is one we're believing. Interface list must be up-to-date before calling. */
-int loopback_exception(int fd, int family, struct all_addr *addr, char *name)    
+int loopback_exception(int fd, int family, struct all_addr *addr, char *name)
 {
   struct ifreq ifr;
   struct irec *iface;
 
   strncpy(ifr.ifr_name, name, IF_NAMESIZE);
-  if (ioctl(fd, SIOCGIFFLAGS, &ifr) != -1 &&
-      ifr.ifr_flags & IFF_LOOPBACK)
-    {
-      for (iface = daemon->interfaces; iface; iface = iface->next)
-	if (iface->addr.sa.sa_family == family)
-	  {
-	    if (family == AF_INET)
-	      {
-		if (iface->addr.in.sin_addr.s_addr == addr->addr.addr4.s_addr)
-		  return 1;
-	      }
+  if (ioctl(fd, SIOCGIFFLAGS, &ifr) != -1 && ifr.ifr_flags & IFF_LOOPBACK) {
+    for (iface = daemon->interfaces; iface; iface = iface->next)
+      if (iface->addr.sa.sa_family == family) {
+        if (family == AF_INET) {
+          if (iface->addr.in.sin_addr.s_addr == addr->addr.addr4.s_addr)
+            return 1;
+        }
 #ifdef HAVE_IPV6
-	    else if (IN6_ARE_ADDR_EQUAL(&iface->addr.in6.sin6_addr, &addr->addr.addr6))
-	      return 1;
+        else if (IN6_ARE_ADDR_EQUAL
+                 (&iface->addr.in6.sin6_addr, &addr->addr.addr6))
+          return 1;
 #endif
-	    
-	  }
-    }
+
+      }
+  }
   return 0;
 }
 
@@ -224,7 +214,7 @@
 
   for (iface = daemon->interfaces; iface; iface = iface->next)
     if (iface->index == index && iface->addr.sa.sa_family == AF_INET &&
-	iface->addr.in.sin_addr.s_addr == addr->addr.addr4.s_addr)
+        iface->addr.in.sin_addr.s_addr == addr->addr.addr4.s_addr)
       return 1;
 
   return 0;
@@ -236,12 +226,13 @@
 };
 
 static int iface_allowed(struct iface_param *param, int if_index, char *label,
-			 union mysockaddr *addr, struct in_addr netmask, int prefixlen, int iface_flags) 
+                         union mysockaddr *addr, struct in_addr netmask,
+                         int prefixlen, int iface_flags)
 {
   struct irec *iface;
   int mtu = 0, loopback;
   struct ifreq ifr;
-  int tftp_ok = !!option_bool(OPT_TFTP);
+  int tftp_ok = ! !option_bool(OPT_TFTP);
   int dhcp_ok = 1;
   int auth_dns = 0;
   int is_label = 0;
@@ -249,271 +240,241 @@
   struct iname *tmp;
 #endif
 
-  (void)prefixlen;
+  (void) prefixlen;
 
   if (!indextoname(param->fd, if_index, ifr.ifr_name) ||
       ioctl(param->fd, SIOCGIFFLAGS, &ifr) == -1)
     return 0;
-   
+
   loopback = ifr.ifr_flags & IFF_LOOPBACK;
-  
+
   if (loopback)
     dhcp_ok = 0;
-  
+
   if (ioctl(param->fd, SIOCGIFMTU, &ifr) != -1)
     mtu = ifr.ifr_mtu;
-  
+
   if (!label)
     label = ifr.ifr_name;
   else
     is_label = strcmp(label, ifr.ifr_name);
- 
+
   /* maintain a list of all addresses on all interfaces for --local-service option */
-  if (option_bool(OPT_LOCAL_SERVICE))
-    {
-      struct addrlist *al;
+  if (option_bool(OPT_LOCAL_SERVICE)) {
+    struct addrlist *al;
 
-      if (param->spare)
-	{
-	  al = param->spare;
-	  param->spare = al->next;
-	}
-      else
-	al = whine_malloc(sizeof(struct addrlist));
-      
-      if (al)
-	{
-	  al->next = daemon->interface_addrs;
-	  daemon->interface_addrs = al;
-	  al->prefixlen = prefixlen;
-	  
-	  if (addr->sa.sa_family == AF_INET)
-	    {
-	      al->addr.addr.addr4 = addr->in.sin_addr;
-	      al->flags = 0;
-	    }
-#ifdef HAVE_IPV6
-	  else
-	    {
-	      al->addr.addr.addr6 = addr->in6.sin6_addr;
-	      al->flags = ADDRLIST_IPV6;
-	    } 
+    if (param->spare) {
+      al = param->spare;
+      param->spare = al->next;
+    } else
+      al = whine_malloc(sizeof(struct addrlist));
+
+    if (al) {
+      al->next = daemon->interface_addrs;
+      daemon->interface_addrs = al;
+      al->prefixlen = prefixlen;
+
+      if (addr->sa.sa_family == AF_INET) {
+        al->addr.addr.addr4 = addr->in.sin_addr;
+        al->flags = 0;
+      }
+#ifdef HAVE_IPV6
+      else {
+        al->addr.addr.addr6 = addr->in6.sin6_addr;
+        al->flags = ADDRLIST_IPV6;
+      }
 #endif
-	}
     }
-  
+  }
 #ifdef HAVE_IPV6
-  if (addr->sa.sa_family != AF_INET6 || !IN6_IS_ADDR_LINKLOCAL(&addr->in6.sin6_addr))
+  if (addr->sa.sa_family != AF_INET6
+      || !IN6_IS_ADDR_LINKLOCAL(&addr->in6.sin6_addr))
 #endif
-    {
-      struct interface_name *int_name;
-      struct addrlist *al;
+  {
+    struct interface_name *int_name;
+    struct addrlist *al;
 #ifdef HAVE_AUTH
-      struct auth_zone *zone;
-      struct auth_name_list *name;
+    struct auth_zone *zone;
+    struct auth_name_list *name;
 
-      /* Find subnets in auth_zones */
-      for (zone = daemon->auth_zones; zone; zone = zone->next)
-	for (name = zone->interface_names; name; name = name->next)
-	  if (wildcard_match(name->name, label))
-	    {
-	      if (addr->sa.sa_family == AF_INET && (name->flags & AUTH4))
-		{
-		  if (param->spare)
-		    {
-		      al = param->spare;
-		      param->spare = al->next;
-		    }
-		  else
-		    al = whine_malloc(sizeof(struct addrlist));
-		  
-		  if (al)
-		    {
-		      al->next = zone->subnet;
-		      zone->subnet = al;
-		      al->prefixlen = prefixlen;
-		      al->addr.addr.addr4 = addr->in.sin_addr;
-		      al->flags = 0;
-		    }
-		}
-	      
-#ifdef HAVE_IPV6
-	      if (addr->sa.sa_family == AF_INET6 && (name->flags & AUTH6))
-		{
-		  if (param->spare)
-		    {
-		      al = param->spare;
-		      param->spare = al->next;
-		    }
-		  else
-		    al = whine_malloc(sizeof(struct addrlist));
-		  
-		  if (al)
-		    {
-		      al->next = zone->subnet;
-		      zone->subnet = al;
-		      al->prefixlen = prefixlen;
-		      al->addr.addr.addr6 = addr->in6.sin6_addr;
-		      al->flags = ADDRLIST_IPV6;
-		    }
-		} 
-#endif
-	      
-	    }
-#endif
-       
-      /* Update addresses from interface_names. These are a set independent
-	 of the set we're listening on. */  
-      for (int_name = daemon->int_names; int_name; int_name = int_name->next)
-	if (strncmp(label, int_name->intr, IF_NAMESIZE) == 0 && 
-	    (addr->sa.sa_family == int_name->family || int_name->family == 0))
-	  {
-	    if (param->spare)
-	      {
-		al = param->spare;
-		param->spare = al->next;
-	      }
-	    else
-	      al = whine_malloc(sizeof(struct addrlist));
-	    
-	    if (al)
-	      {
-		al->next = int_name->addr;
-		int_name->addr = al;
-		
-		if (addr->sa.sa_family == AF_INET)
-		  {
-		    al->addr.addr.addr4 = addr->in.sin_addr;
-		    al->flags = 0;
-		  }
-#ifdef HAVE_IPV6
-		else
-		 {
-		    al->addr.addr.addr6 = addr->in6.sin6_addr;
-		    al->flags = ADDRLIST_IPV6;
-		    /* Privacy addresses and addresses still undergoing DAD and deprecated addresses
-		       don't appear in forward queries, but will in reverse ones. */
-		    if (!(iface_flags & IFACE_PERMANENT) || (iface_flags & (IFACE_DEPRECATED | IFACE_TENTATIVE)))
-		      al->flags |= ADDRLIST_REVONLY;
-		 } 
+    /* Find subnets in auth_zones */
+    for (zone = daemon->auth_zones; zone; zone = zone->next)
+      for (name = zone->interface_names; name; name = name->next)
+        if (wildcard_match(name->name, label)) {
+          if (addr->sa.sa_family == AF_INET && (name->flags & AUTH4)) {
+            if (param->spare) {
+              al = param->spare;
+              param->spare = al->next;
+            } else
+              al = whine_malloc(sizeof(struct addrlist));
+
+            if (al) {
+              al->next = zone->subnet;
+              zone->subnet = al;
+              al->prefixlen = prefixlen;
+              al->addr.addr.addr4 = addr->in.sin_addr;
+              al->flags = 0;
+            }
+          }
+#ifdef HAVE_IPV6
+          if (addr->sa.sa_family == AF_INET6 && (name->flags & AUTH6)) {
+            if (param->spare) {
+              al = param->spare;
+              param->spare = al->next;
+            } else
+              al = whine_malloc(sizeof(struct addrlist));
+
+            if (al) {
+              al->next = zone->subnet;
+              zone->subnet = al;
+              al->prefixlen = prefixlen;
+              al->addr.addr.addr6 = addr->in6.sin6_addr;
+              al->flags = ADDRLIST_IPV6;
+            }
+          }
 #endif
-	      }
-	  }
-    }
- 
+
+        }
+#endif
+
+    /* Update addresses from interface_names. These are a set independent
+       of the set we're listening on. */
+    for (int_name = daemon->int_names; int_name; int_name = int_name->next)
+      if (strncmp(label, int_name->intr, IF_NAMESIZE) == 0 &&
+          (addr->sa.sa_family == int_name->family || int_name->family == 0)) {
+        if (param->spare) {
+          al = param->spare;
+          param->spare = al->next;
+        } else
+          al = whine_malloc(sizeof(struct addrlist));
+
+        if (al) {
+          al->next = int_name->addr;
+          int_name->addr = al;
+
+          if (addr->sa.sa_family == AF_INET) {
+            al->addr.addr.addr4 = addr->in.sin_addr;
+            al->flags = 0;
+          }
+#ifdef HAVE_IPV6
+          else {
+            al->addr.addr.addr6 = addr->in6.sin6_addr;
+            al->flags = ADDRLIST_IPV6;
+            /* Privacy addresses and addresses still undergoing DAD and deprecated addresses
+               don't appear in forward queries, but will in reverse ones. */
+            if (!(iface_flags & IFACE_PERMANENT)
+                || (iface_flags & (IFACE_DEPRECATED | IFACE_TENTATIVE)))
+              al->flags |= ADDRLIST_REVONLY;
+          }
+#endif
+        }
+      }
+  }
+
   /* check whether the interface IP has been added already 
      we call this routine multiple times. */
-  for (iface = daemon->interfaces; iface; iface = iface->next) 
-    if (sockaddr_isequal(&iface->addr, addr))
-      {
-	iface->dad = !!(iface_flags & IFACE_TENTATIVE);
-	iface->found = 1; /* for garbage collection */
-	return 1;
-      }
+  for (iface = daemon->interfaces; iface; iface = iface->next)
+    if (sockaddr_isequal(&iface->addr, addr)) {
+      iface->dad = ! !(iface_flags & IFACE_TENTATIVE);
+      iface->found = 1;         /* for garbage collection */
+      return 1;
+    }
 
- /* If we are restricting the set of interfaces to use, make
+  /* If we are restricting the set of interfaces to use, make
      sure that loopback interfaces are in that set. */
-  if (daemon->if_names && loopback)
-    {
-      struct iname *lo;
-      for (lo = daemon->if_names; lo; lo = lo->next)
-	if (lo->name && strcmp(lo->name, ifr.ifr_name) == 0)
-	  break;
-      
-      if (!lo && (lo = whine_malloc(sizeof(struct iname)))) 
-	{
-	  if ((lo->name = whine_malloc(strlen(ifr.ifr_name)+1)))
-	    {
-	      strcpy(lo->name, ifr.ifr_name);
-	      lo->used = 1;
-	      lo->next = daemon->if_names;
-	      daemon->if_names = lo;
-	    }
-	  else
-	    free(lo);
-	}
+  if (daemon->if_names && loopback) {
+    struct iname *lo;
+    for (lo = daemon->if_names; lo; lo = lo->next)
+      if (lo->name && strcmp(lo->name, ifr.ifr_name) == 0)
+        break;
+
+    if (!lo && (lo = whine_malloc(sizeof(struct iname)))) {
+      if ((lo->name = whine_malloc(strlen(ifr.ifr_name) + 1))) {
+        strcpy(lo->name, ifr.ifr_name);
+        lo->used = 1;
+        lo->next = daemon->if_names;
+        daemon->if_names = lo;
+      } else
+        free(lo);
     }
-  
+  }
+
   if (addr->sa.sa_family == AF_INET &&
-      !iface_check(AF_INET, (struct all_addr *)&addr->in.sin_addr, label, &auth_dns))
+      !iface_check(AF_INET, (struct all_addr *) &addr->in.sin_addr, label,
+                   &auth_dns))
     return 1;
 
 #ifdef HAVE_IPV6
   if (addr->sa.sa_family == AF_INET6 &&
-      !iface_check(AF_INET6, (struct all_addr *)&addr->in6.sin6_addr, label, &auth_dns))
+      !iface_check(AF_INET6, (struct all_addr *) &addr->in6.sin6_addr, label,
+                   &auth_dns))
     return 1;
 #endif
-    
+
 #ifdef HAVE_DHCP
   /* No DHCP where we're doing auth DNS. */
-  if (auth_dns)
-    {
-      tftp_ok = 0;
-      dhcp_ok = 0;
-    }
-  else
+  if (auth_dns) {
+    tftp_ok = 0;
+    dhcp_ok = 0;
+  } else
     for (tmp = daemon->dhcp_except; tmp; tmp = tmp->next)
-      if (tmp->name && wildcard_match(tmp->name, ifr.ifr_name))
-	{
-	  tftp_ok = 0;
-	  dhcp_ok = 0;
-	}
+      if (tmp->name && wildcard_match(tmp->name, ifr.ifr_name)) {
+        tftp_ok = 0;
+        dhcp_ok = 0;
+      }
 #endif
- 
-  
+
+
 #ifdef HAVE_TFTP
-  if (daemon->tftp_interfaces)
-    {
-      /* dedicated tftp interface list */
-      tftp_ok = 0;
-      for (tmp = daemon->tftp_interfaces; tmp; tmp = tmp->next)
-	if (tmp->name && wildcard_match(tmp->name, ifr.ifr_name))
-	  tftp_ok = 1;
-    }
+  if (daemon->tftp_interfaces) {
+    /* dedicated tftp interface list */
+    tftp_ok = 0;
+    for (tmp = daemon->tftp_interfaces; tmp; tmp = tmp->next)
+      if (tmp->name && wildcard_match(tmp->name, ifr.ifr_name))
+        tftp_ok = 1;
+  }
 #endif
-  
-  /* add to list */
-  if ((iface = whine_malloc(sizeof(struct irec))))
-    {
-      iface->addr = *addr;
-      iface->netmask = netmask;
-      iface->tftp_ok = tftp_ok;
-      iface->dhcp_ok = dhcp_ok;
-      iface->dns_auth = auth_dns;
-      iface->mtu = mtu;
-      iface->dad = !!(iface_flags & IFACE_TENTATIVE);
-      iface->found = 1;
-      iface->done = iface->multicast_done = iface->warned = 0;
-      iface->index = if_index;
-      iface->label = is_label;
-      if ((iface->name = whine_malloc(strlen(ifr.ifr_name)+1)))
-	{
-	  strcpy(iface->name, ifr.ifr_name);
-	  iface->next = daemon->interfaces;
-	  daemon->interfaces = iface;
-	  return 1;
-	}
-      free(iface);
 
+  /* add to list */
+  if ((iface = whine_malloc(sizeof(struct irec)))) {
+    iface->addr = *addr;
+    iface->netmask = netmask;
+    iface->tftp_ok = tftp_ok;
+    iface->dhcp_ok = dhcp_ok;
+    iface->dns_auth = auth_dns;
+    iface->mtu = mtu;
+    iface->dad = ! !(iface_flags & IFACE_TENTATIVE);
+    iface->found = 1;
+    iface->done = iface->multicast_done = iface->warned = 0;
+    iface->index = if_index;
+    iface->label = is_label;
+    if ((iface->name = whine_malloc(strlen(ifr.ifr_name) + 1))) {
+      strcpy(iface->name, ifr.ifr_name);
+      iface->next = daemon->interfaces;
+      daemon->interfaces = iface;
+      return 1;
     }
-  
-  errno = ENOMEM; 
+    free(iface);
+
+  }
+
+  errno = ENOMEM;
   return 0;
 }
 
 #ifdef HAVE_IPV6
-static int iface_allowed_v6(struct in6_addr *local, int prefix, 
-			    int scope, int if_index, int flags, 
-			    int preferred, int valid, void *vparam)
+static int iface_allowed_v6(struct in6_addr *local, int prefix,
+                            int scope, int if_index, int flags,
+                            int preferred, int valid, void *vparam)
 {
   union mysockaddr addr;
-  struct in_addr netmask; /* dummy */
+  struct in_addr netmask;       /* dummy */
   netmask.s_addr = 0;
 
-  (void)scope; /* warning */
-  (void)preferred;
-  (void)valid;
-  
+  (void) scope;                 /* warning */
+  (void) preferred;
+  (void) valid;
+
   memset(&addr, 0, sizeof(addr));
 #ifdef HAVE_SOCKADDR_SA_LEN
   addr.in6.sin6_len = sizeof(addr.in6);
@@ -526,18 +487,20 @@
     addr.in6.sin6_scope_id = if_index;
   else
     addr.in6.sin6_scope_id = 0;
-  
-  return iface_allowed((struct iface_param *)vparam, if_index, NULL, &addr, netmask, prefix, flags);
+
+  return iface_allowed((struct iface_param *) vparam, if_index, NULL, &addr,
+                       netmask, prefix, flags);
 }
 #endif
 
 static int iface_allowed_v4(struct in_addr local, int if_index, char *label,
-			    struct in_addr netmask, struct in_addr broadcast, void *vparam)
+                            struct in_addr netmask, struct in_addr broadcast,
+                            void *vparam)
 {
   union mysockaddr addr;
   int prefix, bit;
- 
-  (void)broadcast; /* warning */
+
+  (void) broadcast;             /* warning */
 
   memset(&addr, 0, sizeof(addr));
 #ifdef HAVE_SOCKADDR_SA_LEN
@@ -548,11 +511,13 @@
   addr.in.sin_port = htons(daemon->port);
 
   /* determine prefix length from netmask */
-  for (prefix = 32, bit = 1; (bit & ntohl(netmask.s_addr)) == 0 && prefix != 0; bit = bit << 1, prefix--);
+  for (prefix = 32, bit = 1; (bit & ntohl(netmask.s_addr)) == 0 && prefix != 0;
+       bit = bit << 1, prefix--);
 
-  return iface_allowed((struct iface_param *)vparam, if_index, label, &addr, netmask, prefix, 0);
+  return iface_allowed((struct iface_param *) vparam, if_index, label, &addr,
+                       netmask, prefix, 0);
 }
-   
+
 int enumerate_interfaces(int reset)
 {
   static struct addrlist *spare = NULL;
@@ -567,13 +532,12 @@
 #endif
 
   /* Do this max once per select cycle  - also inhibits netlink socket use
-   in TCP child processes. */
+     in TCP child processes. */
 
-  if (reset)
-    {
-      done = 0;
-      return 1;
-    }
+  if (reset) {
+    done = 0;
+    return 1;
+  }
 
   if (done)
     return 1;
@@ -582,105 +546,96 @@
 
   if ((param.fd = socket(PF_INET, SOCK_DGRAM, 0)) == -1)
     return 0;
- 
+
   /* Mark interfaces for garbage collection */
-  for (iface = daemon->interfaces; iface; iface = iface->next) 
+  for (iface = daemon->interfaces; iface; iface = iface->next)
     iface->found = 0;
 
   /* remove addresses stored against interface_names */
-  for (intname = daemon->int_names; intname; intname = intname->next)
-    {
-      for (addr = intname->addr; addr; addr = tmp)
-	{
-	  tmp = addr->next;
-	  addr->next = spare;
-	  spare = addr;
-	}
-      
-      intname->addr = NULL;
-    }
-
-  /* Remove list of addresses of local interfaces */
-  for (addr = daemon->interface_addrs; addr; addr = tmp)
-    {
+  for (intname = daemon->int_names; intname; intname = intname->next) {
+    for (addr = intname->addr; addr; addr = tmp) {
       tmp = addr->next;
       addr->next = spare;
       spare = addr;
     }
+
+    intname->addr = NULL;
+  }
+
+  /* Remove list of addresses of local interfaces */
+  for (addr = daemon->interface_addrs; addr; addr = tmp) {
+    tmp = addr->next;
+    addr->next = spare;
+    spare = addr;
+  }
   daemon->interface_addrs = NULL;
-  
+
 #ifdef HAVE_AUTH
   /* remove addresses stored against auth_zone subnets, but not 
-   ones configured as address literals */
+     ones configured as address literals */
   for (zone = daemon->auth_zones; zone; zone = zone->next)
-    if (zone->interface_names)
-      {
-	struct addrlist **up;
-	for (up = &zone->subnet, addr = zone->subnet; addr; addr = tmp)
-	  {
-	    tmp = addr->next;
-	    if (addr->flags & ADDRLIST_LITERAL)
-	      up = &addr->next;
-	    else
-	      {
-		*up = addr->next;
-		addr->next = spare;
-		spare = addr;
-	      }
-	  }
+    if (zone->interface_names) {
+      struct addrlist **up;
+      for (up = &zone->subnet, addr = zone->subnet; addr; addr = tmp) {
+        tmp = addr->next;
+        if (addr->flags & ADDRLIST_LITERAL)
+          up = &addr->next;
+        else {
+          *up = addr->next;
+          addr->next = spare;
+          spare = addr;
+        }
       }
+    }
 #endif
 
   param.spare = spare;
-  
+
 #ifdef HAVE_IPV6
   ret = iface_enumerate(AF_INET6, &param, iface_allowed_v6);
 #endif
 
   if (ret)
-    ret = iface_enumerate(AF_INET, &param, iface_allowed_v4); 
- 
+    ret = iface_enumerate(AF_INET, &param, iface_allowed_v4);
+
   errsave = errno;
   close(param.fd);
-  
-  if (option_bool(OPT_CLEVERBIND))
-    { 
-      /* Garbage-collect listeners listening on addresses that no longer exist.
-	 Does nothing when not binding interfaces or for listeners on localhost, 
-	 since the ->iface field is NULL. Note that this needs the protections
-	 against reentrancy, hence it's here.  It also means there's a possibility,
-	 in OPT_CLEVERBIND mode, that at listener will just disappear after
-	 a call to enumerate_interfaces, this is checked OK on all calls. */
-      struct listener *l, *tmp, **up;
-      
-      for (up = &daemon->listeners, l = daemon->listeners; l; l = tmp)
-	{
-	  tmp = l->next;
-	  
-	  if (!l->iface || l->iface->found)
-	    up = &l->next;
-	  else
-	    {
-	      *up = l->next;
-	      
-	      /* In case it ever returns */
-	      l->iface->done = 0;
-	      
-	      if (l->fd != -1)
-		close(l->fd);
-	      if (l->tcpfd != -1)
-		close(l->tcpfd);
-	      if (l->tftpfd != -1)
-		close(l->tftpfd);
-	      
-	      free(l);
-	    }
-	}
+
+  if (option_bool(OPT_CLEVERBIND)) {
+    /* Garbage-collect listeners listening on addresses that no longer exist.
+       Does nothing when not binding interfaces or for listeners on localhost,
+       since the ->iface field is NULL. Note that this needs the protections
+       against reentrancy, hence it's here.  It also means there's a possibility,
+       in OPT_CLEVERBIND mode, that at listener will just disappear after
+       a call to enumerate_interfaces, this is checked OK on all calls. */
+    struct listener *l, *tmp, **up;
+
+    for (up = &daemon->listeners, l = daemon->listeners; l; l = tmp) {
+      tmp = l->next;
+
+      if (!l->iface || l->iface->found)
+        up = &l->next;
+      else {
+        *up = l->next;
+
+        /* In case it ever returns */
+        l->iface->done = 0;
+
+        if (l->fd != -1)
+          close(l->fd);
+        if (l->tcpfd != -1)
+          close(l->tcpfd);
+        if (l->tftpfd != -1)
+          close(l->tftpfd);
+
+        free(l);
+      }
     }
-  
+  }
+
   errno = errsave;
   spare = param.spare;
-    
+
   return ret;
 }
 
@@ -692,7 +647,7 @@
   if ((flags = fcntl(fd, F_GETFL)) == -1 ||
       fcntl(fd, F_SETFL, flags | O_NONBLOCK) == -1)
     return 0;
-  
+
   return 1;
 }
 
@@ -700,82 +655,75 @@
 {
   int family = addr->sa.sa_family;
   int fd, rc, opt = 1;
-  
-  if ((fd = socket(family, type, 0)) == -1)
-    {
-      int port, errsave;
-      char *s;
 
-      /* No error if the kernel just doesn't support this IP flavour */
-      if (errno == EPROTONOSUPPORT ||
-	  errno == EAFNOSUPPORT ||
-	  errno == EINVAL)
-	return -1;
-      
-    err:
-      errsave = errno;
-      port = prettyprint_addr(addr, daemon->addrbuff);
-      if (!option_bool(OPT_NOWILD) && !option_bool(OPT_CLEVERBIND))
-	sprintf(daemon->addrbuff, "port %d", port);
-      s = _("failed to create listening socket for %s: %s");
-      
-      if (fd != -1)
-	close (fd);
-	
-      errno = errsave;
-
-      if (dienow)
-	{
-	  /* failure to bind addresses given by --listen-address at this point
-	     is OK if we're doing bind-dynamic */
-	  if (!option_bool(OPT_CLEVERBIND))
-	    die(s, daemon->addrbuff, EC_BADNET);
-	}
-      else
-	my_syslog(LOG_WARNING, s, daemon->addrbuff, strerror(errno));
-      
+  if ((fd = socket(family, type, 0)) == -1) {
+    int port, errsave;
+    char *s;
+
+    /* No error if the kernel just doesn't support this IP flavour */
+    if (errno == EPROTONOSUPPORT || errno == EAFNOSUPPORT || errno == EINVAL)
       return -1;
-    }	
-  
-  if (setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt)) == -1 || !fix_fd(fd))
+
+  err:
+    errsave = errno;
+    port = prettyprint_addr(addr, daemon->addrbuff);
+    if (!option_bool(OPT_NOWILD) && !option_bool(OPT_CLEVERBIND))
+      sprintf(daemon->addrbuff, "port %d", port);
+    s = _("failed to create listening socket for %s: %s");
+
+    if (fd != -1)
+      close(fd);
+
+    errno = errsave;
+
+    if (dienow) {
+      /* failure to bind addresses given by --listen-address at this point
+         is OK if we're doing bind-dynamic */
+      if (!option_bool(OPT_CLEVERBIND))
+        die(s, daemon->addrbuff, EC_BADNET);
+    } else
+      my_syslog(LOG_WARNING, s, daemon->addrbuff, strerror(errno));
+
+    return -1;
+  }
+
+  if (setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt)) == -1
+      || !fix_fd(fd))
     goto err;
-  
+
 #ifdef HAVE_IPV6
-  if (family == AF_INET6 && setsockopt(fd, IPPROTO_IPV6, IPV6_V6ONLY, &opt, sizeof(opt)) == -1)
+  if (family == AF_INET6
+      && setsockopt(fd, IPPROTO_IPV6, IPV6_V6ONLY, &opt, sizeof(opt)) == -1)
     goto err;
 #endif
-  
-  if ((rc = bind(fd, (struct sockaddr *)addr, sa_len(addr))) == -1)
+
+  if ((rc = bind(fd, (struct sockaddr *) addr, sa_len(addr))) == -1)
     goto err;
-  
-  if (type == SOCK_STREAM)
-    {
-      if (listen(fd, TCP_BACKLOG) == -1)
-	goto err;
-    }
-  else if (family == AF_INET)
-    {
-      if (!option_bool(OPT_NOWILD))
-	{
-#if defined(HAVE_LINUX_NETWORK) 
-	  if (setsockopt(fd, IPPROTO_IP, IP_PKTINFO, &opt, sizeof(opt)) == -1)
-	    goto err;
+
+  if (type == SOCK_STREAM) {
+    if (listen(fd, TCP_BACKLOG) == -1)
+      goto err;
+  } else if (family == AF_INET) {
+    if (!option_bool(OPT_NOWILD)) {
+#if defined(HAVE_LINUX_NETWORK)
+      if (setsockopt(fd, IPPROTO_IP, IP_PKTINFO, &opt, sizeof(opt)) == -1)
+        goto err;
 #elif defined(IP_RECVDSTADDR) && defined(IP_RECVIF)
-	  if (setsockopt(fd, IPPROTO_IP, IP_RECVDSTADDR, &opt, sizeof(opt)) == -1 ||
-	      setsockopt(fd, IPPROTO_IP, IP_RECVIF, &opt, sizeof(opt)) == -1)
-	    goto err;
+      if (setsockopt(fd, IPPROTO_IP, IP_RECVDSTADDR, &opt, sizeof(opt)) == -1 ||
+          setsockopt(fd, IPPROTO_IP, IP_RECVIF, &opt, sizeof(opt)) == -1)
+        goto err;
 #endif
-	}
     }
+  }
 #ifdef HAVE_IPV6
   else if (!set_ipv6pktinfo(fd))
     goto err;
 #endif
-  
+
   return fd;
 }
 
-#ifdef HAVE_IPV6  
+#ifdef HAVE_IPV6
 int set_ipv6pktinfo(int fd)
 {
   int opt = 1;
@@ -784,17 +732,18 @@
      handle all combinations of headers and kernel.
      OpenWrt note that this fixes the problem addressed by your very broken patch. */
   daemon->v6pktinfo = IPV6_PKTINFO;
-  
+
 #ifdef IPV6_RECVPKTINFO
   if (setsockopt(fd, IPPROTO_IPV6, IPV6_RECVPKTINFO, &opt, sizeof(opt)) != -1)
     return 1;
-# ifdef IPV6_2292PKTINFO
-  else if (errno == ENOPROTOOPT && setsockopt(fd, IPPROTO_IPV6, IPV6_2292PKTINFO, &opt, sizeof(opt)) != -1)
-    {
-      daemon->v6pktinfo = IPV6_2292PKTINFO;
-      return 1;
-    }
-# endif 
+#ifdef IPV6_2292PKTINFO
+  else if (errno == ENOPROTOOPT
+           && setsockopt(fd, IPPROTO_IPV6, IPV6_2292PKTINFO, &opt,
+                         sizeof(opt)) != -1) {
+    daemon->v6pktinfo = IPV6_2292PKTINFO;
+    return 1;
+  }
+#endif
 #else
   if (setsockopt(fd, IPPROTO_IPV6, IPV6_PKTINFO, &opt, sizeof(opt)) != -1)
     return 1;
@@ -807,7 +756,7 @@
 
 /* Find the interface on which a TCP connection arrived, if possible, or zero otherwise. */
 int tcp_interface(int fd, int af)
-{ 
+{
   int if_index = 0;
 
 #ifdef HAVE_LINUX_NETWORK
@@ -815,117 +764,108 @@
   struct cmsghdr *cmptr;
   struct msghdr msg;
   socklen_t len;
-  
+
   /* use mshdr so that the CMSDG_* macros are available */
   msg.msg_control = daemon->packet;
   msg.msg_controllen = len = daemon->packet_buff_sz;
-  
+
   /* we overwrote the buffer... */
   daemon->srv_save = NULL;
-  
-  if (af == AF_INET)
-    {
-      if (setsockopt(fd, IPPROTO_IP, IP_PKTINFO, &opt, sizeof(opt)) != -1 &&
-	  getsockopt(fd, IPPROTO_IP, IP_PKTOPTIONS, msg.msg_control, &len) != -1)
-	{
-	  msg.msg_controllen = len;
-	  for (cmptr = CMSG_FIRSTHDR(&msg); cmptr; cmptr = CMSG_NXTHDR(&msg, cmptr))
-	    if (cmptr->cmsg_level == IPPROTO_IP && cmptr->cmsg_type == IP_PKTINFO)
-	      {
-		union {
-		  unsigned char *c;
-		  struct in_pktinfo *p;
-		} p;
-		
-		p.c = CMSG_DATA(cmptr);
-		if_index = p.p->ipi_ifindex;
-	      }
-	}
+
+  if (af == AF_INET) {
+    if (setsockopt(fd, IPPROTO_IP, IP_PKTINFO, &opt, sizeof(opt)) != -1 &&
+        getsockopt(fd, IPPROTO_IP, IP_PKTOPTIONS, msg.msg_control, &len) != -1)
+    {
+      msg.msg_controllen = len;
+      for (cmptr = CMSG_FIRSTHDR(&msg); cmptr; cmptr = CMSG_NXTHDR(&msg, cmptr))
+        if (cmptr->cmsg_level == IPPROTO_IP && cmptr->cmsg_type == IP_PKTINFO) {
+          union {
+            unsigned char *c;
+            struct in_pktinfo *p;
+          } p;
+
+          p.c = CMSG_DATA(cmptr);
+          if_index = p.p->ipi_ifindex;
+        }
     }
+  }
 #ifdef HAVE_IPV6
-  else
-    {
-      /* Only the RFC-2292 API has the ability to find the interface for TCP connections,
-	 it was removed in RFC-3542 !!!! 
+  else {
+    /* Only the RFC-2292 API has the ability to find the interface for TCP connections,
+       it was removed in RFC-3542 !!!!
 
-	 Fortunately, Linux kept the 2292 ABI when it moved to 3542. The following code always
-	 uses the old ABI, and should work with pre- and post-3542 kernel headers */
+       Fortunately, Linux kept the 2292 ABI when it moved to 3542. The following code always
+       uses the old ABI, and should work with pre- and post-3542 kernel headers */
 
-#ifdef IPV6_2292PKTOPTIONS   
-#  define PKTOPTIONS IPV6_2292PKTOPTIONS
+#ifdef IPV6_2292PKTOPTIONS
+#define PKTOPTIONS IPV6_2292PKTOPTIONS
 #else
-#  define PKTOPTIONS IPV6_PKTOPTIONS
+#define PKTOPTIONS IPV6_PKTOPTIONS
 #endif
 
-      if (set_ipv6pktinfo(fd) &&
-	  getsockopt(fd, IPPROTO_IPV6, PKTOPTIONS, msg.msg_control, &len) != -1)
-	{
-          msg.msg_controllen = len;
-	  for (cmptr = CMSG_FIRSTHDR(&msg); cmptr; cmptr = CMSG_NXTHDR(&msg, cmptr))
-            if (cmptr->cmsg_level == IPPROTO_IPV6 && cmptr->cmsg_type == daemon->v6pktinfo)
-              {
-                union {
-                  unsigned char *c;
-                  struct in6_pktinfo *p;
-                } p;
-                p.c = CMSG_DATA(cmptr);
-		
-		if_index = p.p->ipi6_ifindex;
-              }
-	}
-    }
-#endif /* IPV6 */
-#endif /* Linux */
- 
+    if (set_ipv6pktinfo(fd) &&
+        getsockopt(fd, IPPROTO_IPV6, PKTOPTIONS, msg.msg_control, &len) != -1) {
+      msg.msg_controllen = len;
+      for (cmptr = CMSG_FIRSTHDR(&msg); cmptr; cmptr = CMSG_NXTHDR(&msg, cmptr))
+        if (cmptr->cmsg_level == IPPROTO_IPV6
+            && cmptr->cmsg_type == daemon->v6pktinfo) {
+          union {
+            unsigned char *c;
+            struct in6_pktinfo *p;
+          } p;
+          p.c = CMSG_DATA(cmptr);
+
+          if_index = p.p->ipi6_ifindex;
+        }
+    }
+  }
+#endif                          /* IPV6 */
+#endif                          /* Linux */
+
   return if_index;
 }
-      
-static struct listener *create_listeners(union mysockaddr *addr, int do_tftp, int dienow)
+
+static struct listener *create_listeners(union mysockaddr *addr, int do_tftp,
+                                         int dienow)
 {
   struct listener *l = NULL;
   int fd = -1, tcpfd = -1, tftpfd = -1;
 
-  (void)do_tftp;
+  (void) do_tftp;
 
-  if (daemon->port != 0)
-    {
-      fd = make_sock(addr, SOCK_DGRAM, dienow);
-      tcpfd = make_sock(addr, SOCK_STREAM, dienow);
-    }
-  
+  if (daemon->port != 0) {
+    fd = make_sock(addr, SOCK_DGRAM, dienow);
+    tcpfd = make_sock(addr, SOCK_STREAM, dienow);
+  }
 #ifdef HAVE_TFTP
-  if (do_tftp)
-    {
-      if (addr->sa.sa_family == AF_INET)
-	{
-	  /* port must be restored to DNS port for TCP code */
-	  short save = addr->in.sin_port;
-	  addr->in.sin_port = htons(TFTP_PORT);
-	  tftpfd = make_sock(addr, SOCK_DGRAM, dienow);
-	  addr->in.sin_port = save;
-	}
-#  ifdef HAVE_IPV6
-      else
-	{
-	  short save = addr->in6.sin6_port;
-	  addr->in6.sin6_port = htons(TFTP_PORT);
-	  tftpfd = make_sock(addr, SOCK_DGRAM, dienow);
-	  addr->in6.sin6_port = save;
-	}  
-#  endif
-    }
-#endif
-
-  if (fd != -1 || tcpfd != -1 || tftpfd != -1)
-    {
-      l = safe_malloc(sizeof(struct listener));
-      l->next = NULL;
-      l->family = addr->sa.sa_family;
-      l->fd = fd;
-      l->tcpfd = tcpfd;
-      l->tftpfd = tftpfd;	
-      l->iface = NULL;
+  if (do_tftp) {
+    if (addr->sa.sa_family == AF_INET) {
+      /* port must be restored to DNS port for TCP code */
+      short save = addr->in.sin_port;
+      addr->in.sin_port = htons(TFTP_PORT);
+      tftpfd = make_sock(addr, SOCK_DGRAM, dienow);
+      addr->in.sin_port = save;
     }
+#ifdef HAVE_IPV6
+    else {
+      short save = addr->in6.sin6_port;
+      addr->in6.sin6_port = htons(TFTP_PORT);
+      tftpfd = make_sock(addr, SOCK_DGRAM, dienow);
+      addr->in6.sin6_port = save;
+    }
+#endif
+  }
+#endif
+
+  if (fd != -1 || tcpfd != -1 || tftpfd != -1) {
+    l = safe_malloc(sizeof(struct listener));
+    l->next = NULL;
+    l->family = addr->sa.sa_family;
+    l->fd = fd;
+    l->tcpfd = tcpfd;
+    l->tftpfd = tftpfd;
+    l->iface = NULL;
+  }
 
   return l;
 }
@@ -943,21 +883,21 @@
   addr.in.sin_addr.s_addr = INADDR_ANY;
   addr.in.sin_port = htons(daemon->port);
 
-  l = create_listeners(&addr, !!option_bool(OPT_TFTP), 1);
+  l = create_listeners(&addr, ! !option_bool(OPT_TFTP), 1);
 
 #ifdef HAVE_IPV6
   memset(&addr, 0, sizeof(addr));
-#  ifdef HAVE_SOCKADDR_SA_LEN
+#ifdef HAVE_SOCKADDR_SA_LEN
   addr.in6.sin6_len = sizeof(addr.in6);
-#  endif
+#endif
   addr.in6.sin6_family = AF_INET6;
   addr.in6.sin6_addr = in6addr_any;
   addr.in6.sin6_port = htons(daemon->port);
- 
-  l6 = create_listeners(&addr, !!option_bool(OPT_TFTP), 1);
-  if (l) 
+
+  l6 = create_listeners(&addr, ! !option_bool(OPT_TFTP), 1);
+  if (l)
     l->next = l6;
-  else 
+  else
     l = l6;
 #endif
 
@@ -972,13 +912,12 @@
 
   for (iface = daemon->interfaces; iface; iface = iface->next)
     if (!iface->done && !iface->dad && iface->found &&
-	(new = create_listeners(&iface->addr, iface->tftp_ok, dienow)))
-      {
-	new->iface = iface;
-	new->next = daemon->listeners;
-	daemon->listeners = new;
-	iface->done = 1;
-      }
+        (new = create_listeners(&iface->addr, iface->tftp_ok, dienow))) {
+      new->iface = iface;
+      new->next = daemon->listeners;
+      daemon->listeners = new;
+      iface->done = 1;
+    }
 
   /* Check for --listen-address options that haven't been used because there's
      no interface with a matching address. These may be valid: eg it's possible
@@ -992,12 +931,12 @@
      (no netmask) and some MTU login the tftp code. */
 
   for (if_tmp = daemon->if_addrs; if_tmp; if_tmp = if_tmp->next)
-    if (!if_tmp->used && 
-	(new = create_listeners(&if_tmp->addr, !!option_bool(OPT_TFTP), dienow)))
-      {
-	new->next = daemon->listeners;
-	daemon->listeners = new;
-      }
+    if (!if_tmp->used &&
+        (new =
+         create_listeners(&if_tmp->addr, ! !option_bool(OPT_TFTP), dienow))) {
+      new->next = daemon->listeners;
+      daemon->listeners = new;
+    }
 }
 
 /* In --bind-interfaces, the only access control is the addresses we're listening on. 
@@ -1015,27 +954,28 @@
 
 void warn_bound_listeners(void)
 {
-  struct irec *iface; 	
+  struct irec *iface;
   int advice = 0;
 
   for (iface = daemon->interfaces; iface; iface = iface->next)
-    if (!iface->dns_auth)
-      {
-	if (iface->addr.sa.sa_family == AF_INET)
-	  {
-	    if (!private_net(iface->addr.in.sin_addr, 1))
-	      {
-		inet_ntop(AF_INET, &iface->addr.in.sin_addr, daemon->addrbuff, ADDRSTRLEN);
-		iface->warned = advice = 1;
-		my_syslog(LOG_WARNING, 
-			  _("LOUD WARNING: listening on %s may accept requests via interfaces other than %s"),
-			  daemon->addrbuff, iface->name);
-	      }
-	  }
+    if (!iface->dns_auth) {
+      if (iface->addr.sa.sa_family == AF_INET) {
+        if (!private_net(iface->addr.in.sin_addr, 1)) {
+          inet_ntop(AF_INET, &iface->addr.in.sin_addr, daemon->addrbuff,
+                    ADDRSTRLEN);
+          iface->warned = advice = 1;
+          my_syslog(LOG_WARNING,
+                    _
+                    ("LOUD WARNING: listening on %s may accept requests via interfaces other than %s"),
+                    daemon->addrbuff, iface->name);
+        }
       }
-  
+    }
+
   if (advice)
-    my_syslog(LOG_WARNING, _("LOUD WARNING: use --bind-dynamic rather than --bind-interfaces to avoid DNS amplification attacks via these interface(s)")); 
+    my_syslog(LOG_WARNING,
+              _
+              ("LOUD WARNING: use --bind-dynamic rather than --bind-interfaces to avoid DNS amplification attacks via these interface(s)"));
 }
 
 void warn_wild_labels(void)
@@ -1044,88 +984,93 @@
 
   for (iface = daemon->interfaces; iface; iface = iface->next)
     if (iface->found && iface->name && iface->label)
-      my_syslog(LOG_WARNING, _("warning: using interface %s instead"), iface->name);
+      my_syslog(LOG_WARNING, _("warning: using interface %s instead"),
+                iface->name);
 }
 
 void warn_int_names(void)
 {
   struct interface_name *intname;
- 
+
   for (intname = daemon->int_names; intname; intname = intname->next)
     if (!intname->addr)
-      my_syslog(LOG_WARNING, _("warning: no addresses found for interface %s"), intname->intr);
+      my_syslog(LOG_WARNING, _("warning: no addresses found for interface %s"),
+                intname->intr);
 }
- 
+
 int is_dad_listeners(void)
 {
   struct irec *iface;
-  
+
   if (option_bool(OPT_NOWILD))
     for (iface = daemon->interfaces; iface; iface = iface->next)
       if (iface->dad && !iface->done)
-	return 1;
-  
+        return 1;
+
   return 0;
 }
 
 #ifdef HAVE_DHCP6
-void join_multicast(int dienow)      
+void join_multicast(int dienow)
 {
   struct irec *iface, *tmp;
 
   for (iface = daemon->interfaces; iface; iface = iface->next)
-    if (iface->addr.sa.sa_family == AF_INET6 && iface->dhcp_ok && !iface->multicast_done)
-      {
-	/* There's an irec per address but we only want to join for multicast 
-	   once per interface. Weed out duplicates. */
-	for (tmp = daemon->interfaces; tmp; tmp = tmp->next)
-	  if (tmp->multicast_done && tmp->index == iface->index)
-	    break;
-	
-	iface->multicast_done = 1;
-	
-	if (!tmp)
-	  {
-	    struct ipv6_mreq mreq;
-	    int err = 0;
-
-	    mreq.ipv6mr_interface = iface->index;
-	    
-	    inet_pton(AF_INET6, ALL_RELAY_AGENTS_AND_SERVERS, &mreq.ipv6mr_multiaddr);
-	    
-	    if ((daemon->doing_dhcp6 || daemon->relay6) &&
-		setsockopt(daemon->dhcp6fd, IPPROTO_IPV6, IPV6_JOIN_GROUP, &mreq, sizeof(mreq)) == -1)
-	      err = errno;
-	    
-	    inet_pton(AF_INET6, ALL_SERVERS, &mreq.ipv6mr_multiaddr);
-	    
-	    if (daemon->doing_dhcp6 && 
-		setsockopt(daemon->dhcp6fd, IPPROTO_IPV6, IPV6_JOIN_GROUP, &mreq, sizeof(mreq)) == -1)
-	      err = errno;
-	    
-	    inet_pton(AF_INET6, ALL_ROUTERS, &mreq.ipv6mr_multiaddr);
-	    
-	    if (daemon->doing_ra &&
-		setsockopt(daemon->icmp6fd, IPPROTO_IPV6, IPV6_JOIN_GROUP, &mreq, sizeof(mreq)) == -1)
-	      err = errno;
-	    
-	    if (err)
-	      {
-		char *s = _("interface %s failed to join DHCPv6 multicast group: %s");
-		errno = err;
+    if (iface->addr.sa.sa_family == AF_INET6 && iface->dhcp_ok
+        && !iface->multicast_done) {
+      /* There's an irec per address but we only want to join for multicast
+         once per interface. Weed out duplicates. */
+      for (tmp = daemon->interfaces; tmp; tmp = tmp->next)
+        if (tmp->multicast_done && tmp->index == iface->index)
+          break;
+
+      iface->multicast_done = 1;
+
+      if (!tmp) {
+        struct ipv6_mreq mreq;
+        int err = 0;
+
+        mreq.ipv6mr_interface = iface->index;
+
+        inet_pton(AF_INET6, ALL_RELAY_AGENTS_AND_SERVERS,
+                  &mreq.ipv6mr_multiaddr);
+
+        if ((daemon->doing_dhcp6 || daemon->relay6) &&
+            setsockopt(daemon->dhcp6fd, IPPROTO_IPV6, IPV6_JOIN_GROUP, &mreq,
+                       sizeof(mreq)) == -1)
+          err = errno;
+
+        inet_pton(AF_INET6, ALL_SERVERS, &mreq.ipv6mr_multiaddr);
+
+        if (daemon->doing_dhcp6 &&
+            setsockopt(daemon->dhcp6fd, IPPROTO_IPV6, IPV6_JOIN_GROUP, &mreq,
+                       sizeof(mreq)) == -1)
+          err = errno;
+
+        inet_pton(AF_INET6, ALL_ROUTERS, &mreq.ipv6mr_multiaddr);
+
+        if (daemon->doing_ra &&
+            setsockopt(daemon->icmp6fd, IPPROTO_IPV6, IPV6_JOIN_GROUP, &mreq,
+                       sizeof(mreq)) == -1)
+          err = errno;
+
+        if (err) {
+          char *s = _("interface %s failed to join DHCPv6 multicast group: %s");
+          errno = err;
 
 #ifdef HAVE_LINUX_NETWORK
-		if (errno == ENOMEM)
-		  my_syslog(LOG_ERR, _("try increasing /proc/sys/net/core/optmem_max"));
+          if (errno == ENOMEM)
+            my_syslog(LOG_ERR,
+                      _("try increasing /proc/sys/net/core/optmem_max"));
 #endif
 
-		if (dienow)
-		  die(s, iface->name, EC_BADNET);
-		else
-		  my_syslog(LOG_ERR, s, iface->name, strerror(errno));
-	      }
-	  }
+          if (dienow)
+            die(s, iface->name, EC_BADNET);
+          else
+            my_syslog(LOG_ERR, s, iface->name, strerror(errno));
+        }
       }
+    }
 }
 #endif
 
@@ -1135,76 +1080,74 @@
 {
   int fd;
 
-  if ((fd = socket(family, SOCK_DGRAM, 0)) != -1)
-    {
-      union mysockaddr addr;
-      unsigned int ports_avail = ((unsigned short)daemon->max_port - (unsigned short)daemon->min_port) + 1;
-      int tries = ports_avail < 30 ? 3 * ports_avail : 100;
-
-      memset(&addr, 0, sizeof(addr));
-      addr.sa.sa_family = family;
-
-      /* don't loop forever if all ports in use. */
-
-      if (fix_fd(fd))
-	while(tries--)
-	  {
-	    unsigned short port = rand16();
-	    
-            if (daemon->min_port != 0 || daemon->max_port != MAX_PORT)
-              port = htons(daemon->min_port + (port % ((unsigned short)ports_avail)));
-	    
-	    if (family == AF_INET) 
-	      {
-		addr.in.sin_addr.s_addr = INADDR_ANY;
-		addr.in.sin_port = port;
+  if ((fd = socket(family, SOCK_DGRAM, 0)) != -1) {
+    union mysockaddr addr;
+    unsigned int ports_avail =
+        ((unsigned short) daemon->max_port -
+         (unsigned short) daemon->min_port) + 1;
+    int tries = ports_avail < 30 ? 3 * ports_avail : 100;
+
+    memset(&addr, 0, sizeof(addr));
+    addr.sa.sa_family = family;
+
+    /* don't loop forever if all ports in use. */
+
+    if (fix_fd(fd))
+      while (tries--) {
+        unsigned short port = rand16();
+
+        if (daemon->min_port != 0 || daemon->max_port != MAX_PORT)
+          port =
+              htons(daemon->min_port + (port % ((unsigned short) ports_avail)));
+
+        if (family == AF_INET) {
+          addr.in.sin_addr.s_addr = INADDR_ANY;
+          addr.in.sin_port = port;
 #ifdef HAVE_SOCKADDR_SA_LEN
-		addr.in.sin_len = sizeof(struct sockaddr_in);
+          addr.in.sin_len = sizeof(struct sockaddr_in);
 #endif
-	      }
+        }
 #ifdef HAVE_IPV6
-	    else
-	      {
-		addr.in6.sin6_addr = in6addr_any; 
-		addr.in6.sin6_port = port;
+        else {
+          addr.in6.sin6_addr = in6addr_any;
+          addr.in6.sin6_port = port;
 #ifdef HAVE_SOCKADDR_SA_LEN
-		addr.in6.sin6_len = sizeof(struct sockaddr_in6);
+          addr.in6.sin6_len = sizeof(struct sockaddr_in6);
 #endif
-	      }
+        }
 #endif
-	    
-	    if (bind(fd, (struct sockaddr *)&addr, sa_len(&addr)) == 0)
-	      return fd;
-	    
-	    if (errno != EADDRINUSE && errno != EACCES)
-	      break;
-	  }
 
-      close(fd);
-    }
+        if (bind(fd, (struct sockaddr *) &addr, sa_len(&addr)) == 0)
+          return fd;
+
+        if (errno != EADDRINUSE && errno != EACCES)
+          break;
+      }
 
-  return -1; 
+    close(fd);
+  }
+
+  return -1;
 }
-  
+
 
 int local_bind(int fd, union mysockaddr *addr, char *intname, int is_tcp)
 {
   union mysockaddr addr_copy = *addr;
 
   /* cannot set source _port_ for TCP connections. */
-  if (is_tcp)
-    {
-      if (addr_copy.sa.sa_family == AF_INET)
-	addr_copy.in.sin_port = 0;
+  if (is_tcp) {
+    if (addr_copy.sa.sa_family == AF_INET)
+      addr_copy.in.sin_port = 0;
 #ifdef HAVE_IPV6
-      else
-	addr_copy.in6.sin6_port = 0;
+    else
+      addr_copy.in6.sin6_port = 0;
 #endif
-    }
-  
-  if (bind(fd, (struct sockaddr *)&addr_copy, sa_len(&addr_copy)) == -1)
+  }
+
+  if (bind(fd, (struct sockaddr *) &addr_copy, sa_len(&addr_copy)) == -1)
     return 0;
-    
+
 #if defined(SO_BINDTODEVICE)
   if (intname[0] != 0 &&
       setsockopt(fd, SOL_SOCKET, SO_BINDTODEVICE, intname, IF_NAMESIZE) == -1)
@@ -1222,60 +1165,55 @@
 
   /* when using random ports, servers which would otherwise use
      the INADDR_ANY/port0 socket have sfd set to NULL */
-  if (!daemon->osport && intname[0] == 0)
-    {
-      errno = 0;
-      
-      if (addr->sa.sa_family == AF_INET &&
-	  addr->in.sin_addr.s_addr == INADDR_ANY &&
-	  addr->in.sin_port == htons(0)) 
-	return NULL;
+  if (!daemon->osport && intname[0] == 0) {
+    errno = 0;
+
+    if (addr->sa.sa_family == AF_INET &&
+        addr->in.sin_addr.s_addr == INADDR_ANY && addr->in.sin_port == htons(0))
+      return NULL;
 
 #ifdef HAVE_IPV6
-      if (addr->sa.sa_family == AF_INET6 &&
-	  memcmp(&addr->in6.sin6_addr, &in6addr_any, sizeof(in6addr_any)) == 0 &&
-	  addr->in6.sin6_port == htons(0)) 
-	return NULL;
+    if (addr->sa.sa_family == AF_INET6 &&
+        memcmp(&addr->in6.sin6_addr, &in6addr_any, sizeof(in6addr_any)) == 0 &&
+        addr->in6.sin6_port == htons(0))
+      return NULL;
 #endif
-    }
+  }
 
   if (intname && strlen(intname) != 0)
-    ifindex = if_nametoindex(intname); /* index == 0 when not binding to an interface */
-      
+    ifindex = if_nametoindex(intname);  /* index == 0 when not binding to an interface */
+
   /* may have a suitable one already */
-  for (sfd = daemon->sfds; sfd; sfd = sfd->next )
+  for (sfd = daemon->sfds; sfd; sfd = sfd->next)
     if (sockaddr_isequal(&sfd->source_addr, addr) &&
-	strcmp(intname, sfd->interface) == 0 &&
-	ifindex == sfd->ifindex) 
+        strcmp(intname, sfd->interface) == 0 && ifindex == sfd->ifindex)
       return sfd;
-  
+
   /* need to make a new one. */
-  errno = ENOMEM; /* in case malloc fails. */
+  errno = ENOMEM;               /* in case malloc fails. */
   if (!(sfd = whine_malloc(sizeof(struct serverfd))))
     return NULL;
-  
-  if ((sfd->fd = socket(addr->sa.sa_family, SOCK_DGRAM, 0)) == -1)
-    {
-      free(sfd);
-      return NULL;
-    }
-  
-  if (!local_bind(sfd->fd, addr, intname, 0) || !fix_fd(sfd->fd))
-    { 
-      errsave = errno; /* save error from bind. */
-      close(sfd->fd);
-      free(sfd);
-      errno = errsave;
-      return NULL;
-    }
 
-  strcpy(sfd->interface, intname); 
+  if ((sfd->fd = socket(addr->sa.sa_family, SOCK_DGRAM, 0)) == -1) {
+    free(sfd);
+    return NULL;
+  }
+
+  if (!local_bind(sfd->fd, addr, intname, 0) || !fix_fd(sfd->fd)) {
+    errsave = errno;            /* save error from bind. */
+    close(sfd->fd);
+    free(sfd);
+    errno = errsave;
+    return NULL;
+  }
+
+  strcpy(sfd->interface, intname);
   sfd->source_addr = *addr;
   sfd->next = daemon->sfds;
   sfd->ifindex = ifindex;
   daemon->sfds = sfd;
 
-  return sfd; 
+  return sfd;
 }
 
 /* create upstream sockets during startup, before root is dropped which may be needed
@@ -1283,45 +1221,44 @@
 void pre_allocate_sfds(void)
 {
   struct server *srv;
-  
-  if (daemon->query_port != 0)
-    {
-      union  mysockaddr addr;
-      memset(&addr, 0, sizeof(addr));
-      addr.in.sin_family = AF_INET;
-      addr.in.sin_addr.s_addr = INADDR_ANY;
-      addr.in.sin_port = htons(daemon->query_port);
+
+  if (daemon->query_port != 0) {
+    union mysockaddr addr;
+    memset(&addr, 0, sizeof(addr));
+    addr.in.sin_family = AF_INET;
+    addr.in.sin_addr.s_addr = INADDR_ANY;
+    addr.in.sin_port = htons(daemon->query_port);
 #ifdef HAVE_SOCKADDR_SA_LEN
-      addr.in.sin_len = sizeof(struct sockaddr_in);
+    addr.in.sin_len = sizeof(struct sockaddr_in);
 #endif
-      allocate_sfd(&addr, "");
+    allocate_sfd(&addr, "");
 #ifdef HAVE_IPV6
-      memset(&addr, 0, sizeof(addr));
-      addr.in6.sin6_family = AF_INET6;
-      addr.in6.sin6_addr = in6addr_any;
-      addr.in6.sin6_port = htons(daemon->query_port);
+    memset(&addr, 0, sizeof(addr));
+    addr.in6.sin6_family = AF_INET6;
+    addr.in6.sin6_addr = in6addr_any;
+    addr.in6.sin6_port = htons(daemon->query_port);
 #ifdef HAVE_SOCKADDR_SA_LEN
-      addr.in6.sin6_len = sizeof(struct sockaddr_in6);
+    addr.in6.sin6_len = sizeof(struct sockaddr_in6);
 #endif
-      allocate_sfd(&addr, "");
+    allocate_sfd(&addr, "");
 #endif
-    }
-  
+  }
+
   for (srv = daemon->servers; srv; srv = srv->next)
-    if (!(srv->flags & (SERV_LITERAL_ADDRESS | SERV_NO_ADDR | SERV_USE_RESOLV | SERV_NO_REBIND)) &&
-	!allocate_sfd(&srv->source_addr, srv->interface) &&
-	errno != 0 &&
-	option_bool(OPT_NOWILD))
-      {
-	prettyprint_addr(&srv->source_addr, daemon->namebuff);
-	if (srv->interface[0] != 0)
-	  {
-	    strcat(daemon->namebuff, " ");
-	    strcat(daemon->namebuff, srv->interface);
-	  }
-	die(_("failed to bind server socket for %s: %s"),
-	    daemon->namebuff, EC_BADNET);
-      }  
+    if (!
+        (srv->
+         flags & (SERV_LITERAL_ADDRESS | SERV_NO_ADDR | SERV_USE_RESOLV |
+                  SERV_NO_REBIND))
+        && !allocate_sfd(&srv->source_addr, srv->interface) && errno != 0
+        && option_bool(OPT_NOWILD)) {
+      prettyprint_addr(&srv->source_addr, daemon->namebuff);
+      if (srv->interface[0] != 0) {
+        strcat(daemon->namebuff, " ");
+        strcat(daemon->namebuff, srv->interface);
+      }
+      die(_("failed to bind server socket for %s: %s"),
+          daemon->namebuff, EC_BADNET);
+    }
 }
 
 void mark_servers(int flag)
@@ -1329,15 +1266,14 @@
   struct server *serv;
 
   /* mark everything with argument flag */
-  for (serv = daemon->servers; serv; serv = serv->next)
-    {
-      if (serv->flags & flag)
-	serv->flags |= SERV_MARK;
+  for (serv = daemon->servers; serv; serv = serv->next) {
+    if (serv->flags & flag)
+      serv->flags |= SERV_MARK;
 #ifdef HAVE_LOOP
-      /* Give looped servers another chance */
-      serv->flags &= ~SERV_LOOP;
+    /* Give looped servers another chance */
+    serv->flags &= ~SERV_LOOP;
 #endif
-    }
+  }
 }
 
 void cleanup_servers(void)
@@ -1345,20 +1281,17 @@
   struct server *serv, *tmp, **up;
 
   /* unlink and free anything still marked. */
-  for (serv = daemon->servers, up = &daemon->servers; serv; serv = tmp) 
-    {
-      tmp = serv->next;
-      if (serv->flags & SERV_MARK)
-       {
-         server_gone(serv);
-         *up = serv->next;
-         if (serv->domain)
-	   free(serv->domain);
-	 free(serv);
-       }
-      else 
-       up = &serv->next;
-    }
+  for (serv = daemon->servers, up = &daemon->servers; serv; serv = tmp) {
+    tmp = serv->next;
+    if (serv->flags & SERV_MARK) {
+      server_gone(serv);
+      *up = serv->next;
+      if (serv->domain)
+        free(serv->domain);
+      free(serv);
+    } else
+      up = &serv->next;
+  }
 
 #ifdef HAVE_LOOP
   /* Now we have a new set of servers, test for loops. */
@@ -1367,82 +1300,70 @@
 }
 
 void add_update_server(int flags,
-		       union mysockaddr *addr,
-		       union mysockaddr *source_addr,
-		       const char *interface,
-		       const char *domain)
+                       union mysockaddr *addr,
+                       union mysockaddr *source_addr,
+                       const char *interface, const char *domain)
 {
   struct server *serv, *next = NULL;
   char *domain_str = NULL;
-  
+
   /* See if there is a suitable candidate, and unmark */
   for (serv = daemon->servers; serv; serv = serv->next)
-    if (serv->flags & SERV_MARK)
-      {
-	if (domain)
-	  {
-	    if (!(serv->flags & SERV_HAS_DOMAIN) || !hostname_isequal(domain, serv->domain))
-	      continue;
-	  }
-	else
-	  {
-	    if (serv->flags & SERV_HAS_DOMAIN)
-	      continue;
-	  }
-	
-        break;
+    if (serv->flags & SERV_MARK) {
+      if (domain) {
+        if (!(serv->flags & SERV_HAS_DOMAIN)
+            || !hostname_isequal(domain, serv->domain))
+          continue;
+      } else {
+        if (serv->flags & SERV_HAS_DOMAIN)
+          continue;
       }
 
-  if (serv)
-    {
-      domain_str = serv->domain;
-      next = serv->next;
-    }
-  else if ((serv = whine_malloc(sizeof (struct server))))
-    {
-      /* Not found, create a new one. */
-      if (domain && !(domain_str = whine_malloc(strlen(domain)+1)))
-	{
-	  free(serv);
-          serv = NULL;
-        }
-      else
-        {
-	  struct server *s;
-	  /* Add to the end of the chain, for order */
-	  if (!daemon->servers)
-	    daemon->servers = serv;
-	  else
-	    {
-	      for (s = daemon->servers; s->next; s = s->next);
-	      s->next = serv;
-	    }
-	  if (domain)
-	    strcpy(domain_str, domain);
-	}
+      break;
     }
-  
-  if (serv)
-    {
-      memset(serv, 0, sizeof(struct server));
-      serv->flags = flags;
-      serv->domain = domain_str;
-      serv->next = next;
-      serv->queries = serv->failed_queries = 0;
-#ifdef HAVE_LOOP
-      serv->uid = rand32();
-#endif      
 
+  if (serv) {
+    domain_str = serv->domain;
+    next = serv->next;
+  } else if ((serv = whine_malloc(sizeof(struct server)))) {
+    /* Not found, create a new one. */
+    if (domain && !(domain_str = whine_malloc(strlen(domain) + 1))) {
+      free(serv);
+      serv = NULL;
+    } else {
+      struct server *s;
+      /* Add to the end of the chain, for order */
+      if (!daemon->servers)
+        daemon->servers = serv;
+      else {
+        for (s = daemon->servers; s->next; s = s->next);
+        s->next = serv;
+      }
       if (domain)
-	serv->flags |= SERV_HAS_DOMAIN;
-      
-      if (interface)
-	strcpy(serv->interface, interface);      
-      if (addr)
-	serv->addr = *addr;
-      if (source_addr)
-	serv->source_addr = *source_addr;
+        strcpy(domain_str, domain);
     }
+  }
+
+  if (serv) {
+    memset(serv, 0, sizeof(struct server));
+    serv->flags = flags;
+    serv->domain = domain_str;
+    serv->next = next;
+    serv->queries = serv->failed_queries = 0;
+#ifdef HAVE_LOOP
+    serv->uid = rand32();
+#endif
+
+    if (domain)
+      serv->flags |= SERV_HAS_DOMAIN;
+
+    if (interface)
+      strcpy(serv->interface, interface);
+    if (addr)
+      serv->addr = *addr;
+    if (source_addr)
+      serv->source_addr = *source_addr;
+  }
 }
 
 void check_servers(void)
@@ -1456,145 +1377,144 @@
   /* interface may be new since startup */
   if (!option_bool(OPT_NOWILD))
     enumerate_interfaces(0);
-  
+
   for (sfd = daemon->sfds; sfd; sfd = sfd->next)
     sfd->used = 0;
 
 #ifdef HAVE_DNSSEC
- /* Disable DNSSEC validation when using server=/domain/.... servers
-    unless there's a configured trust anchor. */
+  /* Disable DNSSEC validation when using server=/domain/.... servers
+     unless there's a configured trust anchor. */
   for (serv = daemon->servers; serv; serv = serv->next)
     serv->flags |= SERV_DO_DNSSEC;
 #endif
 
-  for (count = 0, serv = daemon->servers; serv; serv = serv->next)
-    {
-      if (!(serv->flags & (SERV_LITERAL_ADDRESS | SERV_NO_ADDR | SERV_USE_RESOLV | SERV_NO_REBIND)))
-	{
-	  /* Init edns_pktsz for newly created server records. */
-	  if (serv->edns_pktsz == 0)
-	    serv->edns_pktsz = daemon->edns_pktsz;
-	  
+  for (count = 0, serv = daemon->servers; serv; serv = serv->next) {
+    if (!
+        (serv->
+         flags & (SERV_LITERAL_ADDRESS | SERV_NO_ADDR | SERV_USE_RESOLV |
+                  SERV_NO_REBIND))) {
+      /* Init edns_pktsz for newly created server records. */
+      if (serv->edns_pktsz == 0)
+        serv->edns_pktsz = daemon->edns_pktsz;
+
 #ifdef HAVE_DNSSEC
-	  if (option_bool(OPT_DNSSEC_VALID))
-	    { 
-	      if (serv->flags & SERV_HAS_DOMAIN)
-		{
-		  struct ds_config *ds;
-		  char *domain = serv->domain;
-		  
-		  /* .example.com is valid */
-		  while (*domain == '.')
-		    domain++;
-		  
-		  for (ds = daemon->ds; ds; ds = ds->next)
-		    if (ds->name[0] != 0 && hostname_isequal(domain, ds->name))
-		      break;
-		  
-		  if (!ds)
-		    serv->flags &= ~SERV_DO_DNSSEC;
-		}
-	      else if (serv->flags & SERV_FOR_NODOTS) 
-		serv->flags &= ~SERV_DO_DNSSEC;
-	    }
-#endif
-
-	  port = prettyprint_addr(&serv->addr, daemon->namebuff);
-	  
-	  /* 0.0.0.0 is nothing, the stack treats it like 127.0.0.1 */
-	  if (serv->addr.sa.sa_family == AF_INET &&
-	      serv->addr.in.sin_addr.s_addr == 0)
-	    {
-	      serv->flags |= SERV_MARK;
-	      continue;
-	    }
-
-	  for (iface = daemon->interfaces; iface; iface = iface->next)
-	    if (sockaddr_isequal(&serv->addr, &iface->addr))
-	      break;
-	  if (iface)
-	    {
-	      my_syslog(LOG_WARNING, _("ignoring nameserver %s - local interface"), daemon->namebuff);
-	      serv->flags |= SERV_MARK;
-	      continue;
-	    }
-	  
-	  /* Do we need a socket set? */
-	  if (!serv->sfd && 
-	      !(serv->sfd = allocate_sfd(&serv->source_addr, serv->interface)) &&
-	      errno != 0)
-	    {
-	      my_syslog(LOG_WARNING, 
-			_("ignoring nameserver %s - cannot make/bind socket: %s"),
-			daemon->namebuff, strerror(errno));
-	      serv->flags |= SERV_MARK;
-	      continue;
-	    }
-	  
-	  if (serv->sfd)
-	    serv->sfd->used = 1;
-	}
-      
-      if (!(serv->flags & SERV_NO_REBIND) && !(serv->flags & SERV_LITERAL_ADDRESS))
-	{
-	  if (++count > SERVERS_LOGGED)
-	    continue;
-	  
-	  if (serv->flags & (SERV_HAS_DOMAIN | SERV_FOR_NODOTS | SERV_USE_RESOLV))
-	    {
-	      char *s1, *s2, *s3 = "";
+      if (option_bool(OPT_DNSSEC_VALID)) {
+        if (serv->flags & SERV_HAS_DOMAIN) {
+          struct ds_config *ds;
+          char *domain = serv->domain;
+
+          /* .example.com is valid */
+          while (*domain == '.')
+            domain++;
+
+          for (ds = daemon->ds; ds; ds = ds->next)
+            if (ds->name[0] != 0 && hostname_isequal(domain, ds->name))
+              break;
+
+          if (!ds)
+            serv->flags &= ~SERV_DO_DNSSEC;
+        } else if (serv->flags & SERV_FOR_NODOTS)
+          serv->flags &= ~SERV_DO_DNSSEC;
+      }
+#endif
+
+      port = prettyprint_addr(&serv->addr, daemon->namebuff);
+
+      /* 0.0.0.0 is nothing, the stack treats it like 127.0.0.1 */
+      if (serv->addr.sa.sa_family == AF_INET &&
+          serv->addr.in.sin_addr.s_addr == 0) {
+        serv->flags |= SERV_MARK;
+        continue;
+      }
+
+      for (iface = daemon->interfaces; iface; iface = iface->next)
+        if (sockaddr_isequal(&serv->addr, &iface->addr))
+          break;
+      if (iface) {
+        my_syslog(LOG_WARNING, _("ignoring nameserver %s - local interface"),
+                  daemon->namebuff);
+        serv->flags |= SERV_MARK;
+        continue;
+      }
+
+      /* Do we need a socket set? */
+      if (!serv->sfd &&
+          !(serv->sfd = allocate_sfd(&serv->source_addr, serv->interface)) &&
+          errno != 0) {
+        my_syslog(LOG_WARNING,
+                  _("ignoring nameserver %s - cannot make/bind socket: %s"),
+                  daemon->namebuff, strerror(errno));
+        serv->flags |= SERV_MARK;
+        continue;
+      }
+
+      if (serv->sfd)
+        serv->sfd->used = 1;
+    }
+
+    if (!(serv->flags & SERV_NO_REBIND)
+        && !(serv->flags & SERV_LITERAL_ADDRESS)) {
+      if (++count > SERVERS_LOGGED)
+        continue;
+
+      if (serv->flags & (SERV_HAS_DOMAIN | SERV_FOR_NODOTS | SERV_USE_RESOLV)) {
+        char *s1, *s2, *s3 = "";
 #ifdef HAVE_DNSSEC
-	      if (option_bool(OPT_DNSSEC_VALID) && !(serv->flags & SERV_DO_DNSSEC))
-		s3 = _("(no DNSSEC)");
+        if (option_bool(OPT_DNSSEC_VALID) && !(serv->flags & SERV_DO_DNSSEC))
+          s3 = _("(no DNSSEC)");
 #endif
-	      if (!(serv->flags & SERV_HAS_DOMAIN))
-		s1 = _("unqualified"), s2 = _("names");
-	      else if (strlen(serv->domain) == 0)
-		s1 = _("default"), s2 = "";
-	      else
-		s1 = _("domain"), s2 = serv->domain;
-	      
-	      if (serv->flags & SERV_NO_ADDR)
-		{
-		  count--;
-		  if (++locals <= LOCALS_LOGGED)
-			my_syslog(LOG_INFO, _("using local addresses only for %s %s"), s1, s2);
-	        }
-	      else if (serv->flags & SERV_USE_RESOLV)
-		my_syslog(LOG_INFO, _("using standard nameservers for %s %s"), s1, s2);
-	      else 
-		my_syslog(LOG_INFO, _("using nameserver %s#%d for %s %s %s"), daemon->namebuff, port, s1, s2, s3);
-	    }
+        if (!(serv->flags & SERV_HAS_DOMAIN))
+          s1 = _("unqualified"), s2 = _("names");
+        else if (strlen(serv->domain) == 0)
+          s1 = _("default"), s2 = "";
+        else
+          s1 = _("domain"), s2 = serv->domain;
+
+        if (serv->flags & SERV_NO_ADDR) {
+          count--;
+          if (++locals <= LOCALS_LOGGED)
+            my_syslog(LOG_INFO, _("using local addresses only for %s %s"), s1,
+                      s2);
+        } else if (serv->flags & SERV_USE_RESOLV)
+          my_syslog(LOG_INFO, _("using standard nameservers for %s %s"), s1,
+                    s2);
+        else
+          my_syslog(LOG_INFO, _("using nameserver %s#%d for %s %s %s"),
+                    daemon->namebuff, port, s1, s2, s3);
+      }
 #ifdef HAVE_LOOP
-	  else if (serv->flags & SERV_LOOP)
-	    my_syslog(LOG_INFO, _("NOT using nameserver %s#%d - query loop detected"), daemon->namebuff, port); 
-#endif
-	  else if (serv->interface[0] != 0)
-	    my_syslog(LOG_INFO, _("using nameserver %s#%d(via %s)"), daemon->namebuff, port, serv->interface); 
-	  else
-	    my_syslog(LOG_INFO, _("using nameserver %s#%d"), daemon->namebuff, port); 
-	}
+      else if (serv->flags & SERV_LOOP)
+        my_syslog(LOG_INFO,
+                  _("NOT using nameserver %s#%d - query loop detected"),
+                  daemon->namebuff, port);
+#endif
+      else if (serv->interface[0] != 0)
+        my_syslog(LOG_INFO, _("using nameserver %s#%d(via %s)"),
+                  daemon->namebuff, port, serv->interface);
+      else
+        my_syslog(LOG_INFO, _("using nameserver %s#%d"), daemon->namebuff,
+                  port);
     }
-  
+  }
+
   if (locals > LOCALS_LOGGED)
-    my_syslog(LOG_INFO, _("using %d more local addresses"), locals - LOCALS_LOGGED);
+    my_syslog(LOG_INFO, _("using %d more local addresses"),
+              locals - LOCALS_LOGGED);
   if (count - 1 > SERVERS_LOGGED)
-    my_syslog(LOG_INFO, _("using %d more nameservers"), count - SERVERS_LOGGED - 1);
+    my_syslog(LOG_INFO, _("using %d more nameservers"),
+              count - SERVERS_LOGGED - 1);
 
   /* Remove unused sfds */
-  for (sfd = daemon->sfds, up = &daemon->sfds; sfd; sfd = tmp)
-    {
-       tmp = sfd->next;
-       if (!sfd->used) 
-	{
-	  *up = sfd->next;
-	  close(sfd->fd);
-	  free(sfd);
-	} 
-      else
-	up = &sfd->next;
-    }
-  
+  for (sfd = daemon->sfds, up = &daemon->sfds; sfd; sfd = tmp) {
+    tmp = sfd->next;
+    if (!sfd->used) {
+      *up = sfd->next;
+      close(sfd->fd);
+      free(sfd);
+    } else
+      up = &sfd->next;
+  }
+
   cleanup_servers();
 }
 
@@ -1607,76 +1527,69 @@
   int gotone = 0;
 
   /* buff happens to be MAXDNAME long... */
-  if (!(f = fopen(fname, "r")))
-    {
-      my_syslog(LOG_ERR, _("failed to read %s: %s"), fname, strerror(errno));
-      return 0;
-    }
-   
+  if (!(f = fopen(fname, "r"))) {
+    my_syslog(LOG_ERR, _("failed to read %s: %s"), fname, strerror(errno));
+    return 0;
+  }
+
   mark_servers(SERV_FROM_RESOLV);
-    
-  while ((line = fgets(daemon->namebuff, MAXDNAME, f)))
-    {
-      union mysockaddr addr, source_addr;
-      char *token = strtok(line, " \t\n\r");
-      
-      if (!token)
-	continue;
-      if (strcmp(token, "nameserver") != 0 && strcmp(token, "server") != 0)
-	continue;
-      if (!(token = strtok(NULL, " \t\n\r")))
-	continue;
-      
-      memset(&addr, 0, sizeof(addr));
-      memset(&source_addr, 0, sizeof(source_addr));
-      
-      if ((addr.in.sin_addr.s_addr = inet_addr(token)) != (in_addr_t) -1)
-	{
+
+  while ((line = fgets(daemon->namebuff, MAXDNAME, f))) {
+    union mysockaddr addr, source_addr;
+    char *token = strtok(line, " \t\n\r");
+
+    if (!token)
+      continue;
+    if (strcmp(token, "nameserver") != 0 && strcmp(token, "server") != 0)
+      continue;
+    if (!(token = strtok(NULL, " \t\n\r")))
+      continue;
+
+    memset(&addr, 0, sizeof(addr));
+    memset(&source_addr, 0, sizeof(source_addr));
+
+    if ((addr.in.sin_addr.s_addr = inet_addr(token)) != (in_addr_t) - 1) {
 #ifdef HAVE_SOCKADDR_SA_LEN
-	  source_addr.in.sin_len = addr.in.sin_len = sizeof(source_addr.in);
+      source_addr.in.sin_len = addr.in.sin_len = sizeof(source_addr.in);
 #endif
-	  source_addr.in.sin_family = addr.in.sin_family = AF_INET;
-	  addr.in.sin_port = htons(NAMESERVER_PORT);
-	  source_addr.in.sin_addr.s_addr = INADDR_ANY;
-	  source_addr.in.sin_port = htons(daemon->query_port);
-	}
-#ifdef HAVE_IPV6
-      else 
-	{	
-	  int scope_index = 0;
-	  char *scope_id = strchr(token, '%');
-	  
-	  if (scope_id)
-	    {
-	      *(scope_id++) = 0;
-	      scope_index = if_nametoindex(scope_id);
-	    }
-	  
-	  if (inet_pton(AF_INET6, token, &addr.in6.sin6_addr) > 0)
-	    {
+      source_addr.in.sin_family = addr.in.sin_family = AF_INET;
+      addr.in.sin_port = htons(NAMESERVER_PORT);
+      source_addr.in.sin_addr.s_addr = INADDR_ANY;
+      source_addr.in.sin_port = htons(daemon->query_port);
+    }
+#ifdef HAVE_IPV6
+    else {
+      int scope_index = 0;
+      char *scope_id = strchr(token, '%');
+
+      if (scope_id) {
+        *(scope_id++) = 0;
+        scope_index = if_nametoindex(scope_id);
+      }
+
+      if (inet_pton(AF_INET6, token, &addr.in6.sin6_addr) > 0) {
 #ifdef HAVE_SOCKADDR_SA_LEN
-	      source_addr.in6.sin6_len = addr.in6.sin6_len = sizeof(source_addr.in6);
+        source_addr.in6.sin6_len = addr.in6.sin6_len = sizeof(source_addr.in6);
 #endif
-	      source_addr.in6.sin6_family = addr.in6.sin6_family = AF_INET6;
-	      source_addr.in6.sin6_flowinfo = addr.in6.sin6_flowinfo = 0;
-	      addr.in6.sin6_port = htons(NAMESERVER_PORT);
-	      addr.in6.sin6_scope_id = scope_index;
-	      source_addr.in6.sin6_addr = in6addr_any;
-	      source_addr.in6.sin6_port = htons(daemon->query_port);
-	      source_addr.in6.sin6_scope_id = 0;
-	    }
-	  else
-	    continue;
-	}
-#else /* IPV6 */
-      else
-	continue;
-#endif 
+        source_addr.in6.sin6_family = addr.in6.sin6_family = AF_INET6;
+        source_addr.in6.sin6_flowinfo = addr.in6.sin6_flowinfo = 0;
+        addr.in6.sin6_port = htons(NAMESERVER_PORT);
+        addr.in6.sin6_scope_id = scope_index;
+        source_addr.in6.sin6_addr = in6addr_any;
+        source_addr.in6.sin6_port = htons(daemon->query_port);
+        source_addr.in6.sin6_scope_id = 0;
+      } else
+        continue;
+    }
+#else                           /* IPV6 */
+    else
+      continue;
+#endif
+
+    add_update_server(SERV_FROM_RESOLV, &addr, &source_addr, NULL, NULL);
+    gotone = 1;
+  }
 
-      add_update_server(SERV_FROM_RESOLV, &addr, &source_addr, NULL, NULL);
-      gotone = 1;
-    }
-  
   fclose(f);
   cleanup_servers();
 
@@ -1686,28 +1599,23 @@
 /* Called when addresses are added or deleted from an interface */
 void newaddress(time_t now)
 {
-  (void)now;
-  
+  (void) now;
+
   if (option_bool(OPT_CLEVERBIND) || option_bool(OPT_LOCAL_SERVICE) ||
       daemon->doing_dhcp6 || daemon->relay6 || daemon->doing_ra)
     enumerate_interfaces(0);
-  
+
   if (option_bool(OPT_CLEVERBIND))
     create_bound_listeners(0);
-  
+
 #ifdef HAVE_DHCP6
   if (daemon->doing_dhcp6 || daemon->relay6 || daemon->doing_ra)
     join_multicast(0);
-  
+
   if (daemon->doing_dhcp6 || daemon->doing_ra)
     dhcp_construct_contexts(now);
-  
+
   if (daemon->doing_dhcp6)
     lease_find_interfaces(now);
 #endif
 }
-
-
-
-
-
Index: dnsmasq-2.78/src/option.c
===================================================================
--- dnsmasq-2.78.orig/src/option.c	2017-10-02 21:13:51.000000000 +0800
+++ dnsmasq-2.78/src/option.c	2018-10-29 16:14:19.461440026 +0800
@@ -28,27 +28,28 @@
 static const struct {
   char *c_name;
   unsigned int c_val;
-}  facilitynames[] = {
-  { "kern",   LOG_KERN },
-  { "user",   LOG_USER },
-  { "mail",   LOG_MAIL },
-  { "daemon", LOG_DAEMON },
-  { "auth",   LOG_AUTH },
-  { "syslog", LOG_SYSLOG },
-  { "lpr",    LOG_LPR },
-  { "news",   LOG_NEWS },
-  { "uucp",   LOG_UUCP },
-  { "audit",  LOG_AUDIT },
-  { "cron",   LOG_CRON },
-  { "local0", LOG_LOCAL0 },
-  { "local1", LOG_LOCAL1 },
-  { "local2", LOG_LOCAL2 },
-  { "local3", LOG_LOCAL3 },
-  { "local4", LOG_LOCAL4 },
-  { "local5", LOG_LOCAL5 },
-  { "local6", LOG_LOCAL6 },
-  { "local7", LOG_LOCAL7 },
-  { NULL, 0 }
+} facilitynames[] = {
+  {
+  "kern", LOG_KERN}, {
+  "user", LOG_USER}, {
+  "mail", LOG_MAIL}, {
+  "daemon", LOG_DAEMON}, {
+  "auth", LOG_AUTH}, {
+  "syslog", LOG_SYSLOG}, {
+  "lpr", LOG_LPR}, {
+  "news", LOG_NEWS}, {
+  "uucp", LOG_UUCP}, {
+  "audit", LOG_AUDIT}, {
+  "cron", LOG_CRON}, {
+  "local0", LOG_LOCAL0}, {
+  "local1", LOG_LOCAL1}, {
+  "local2", LOG_LOCAL2}, {
+  "local3", LOG_LOCAL3}, {
+  "local4", LOG_LOCAL4}, {
+  "local5", LOG_LOCAL5}, {
+  "local6", LOG_LOCAL6}, {
+  "local7", LOG_LOCAL7}, {
+  NULL, 0}
 };
 #endif
 
@@ -129,7 +130,7 @@
 #define LOPT_AUTHPEER      318
 #define LOPT_IPSET         319
 #define LOPT_SYNTH         320
-#ifdef OPTION6_PREFIX_CLASS 
+#ifdef OPTION6_PREFIX_CLASS
 #define LOPT_PREF_CLSS     321
 #endif
 #define LOPT_RELAY         323
@@ -160,173 +161,173 @@
 #define LOPT_DHCPTTL       348
 #define LOPT_TFTP_MTU      349
 #define LOPT_REPLY_DELAY   350
- 
+
 #ifdef HAVE_GETOPT_LONG
-static const struct option opts[] =  
+static const struct option opts[] =
 #else
-static const struct myoption opts[] = 
+static const struct myoption opts[] =
 #endif
-  { 
-    { "version", 0, 0, 'v' },
-    { "no-hosts", 0, 0, 'h' },
-    { "no-poll", 0, 0, 'n' },
-    { "help", 0, 0, 'w' },
-    { "no-daemon", 0, 0, 'd' },
-    { "log-queries", 2, 0, 'q' },
-    { "user", 2, 0, 'u' },
-    { "group", 2, 0, 'g' },
-    { "resolv-file", 2, 0, 'r' },
-    { "servers-file", 1, 0, LOPT_SERVERS_FILE },
-    { "mx-host", 1, 0, 'm' },
-    { "mx-target", 1, 0, 't' },
-    { "cache-size", 2, 0, 'c' },
-    { "port", 1, 0, 'p' },
-    { "dhcp-leasefile", 2, 0, 'l' },
-    { "dhcp-lease", 1, 0, 'l' },
-    { "dhcp-host", 1, 0, 'G' },
-    { "dhcp-range", 1, 0, 'F' },
-    { "dhcp-option", 1, 0, 'O' },
-    { "dhcp-boot", 1, 0, 'M' },
-    { "domain", 1, 0, 's' },
-    { "domain-suffix", 1, 0, 's' },
-    { "interface", 1, 0, 'i' },
-    { "listen-address", 1, 0, 'a' },
-    { "local-service", 0, 0, LOPT_LOCAL_SERVICE },
-    { "bogus-priv", 0, 0, 'b' },
-    { "bogus-nxdomain", 1, 0, 'B' },
-    { "ignore-address", 1, 0, LOPT_IGNORE_ADDR },
-    { "selfmx", 0, 0, 'e' },
-    { "filterwin2k", 0, 0, 'f' },
-    { "pid-file", 2, 0, 'x' },
-    { "strict-order", 0, 0, 'o' },
-    { "server", 1, 0, 'S' },
-    { "rev-server", 1, 0, LOPT_REV_SERV },
-    { "local", 1, 0, LOPT_LOCAL },
-    { "address", 1, 0, 'A' },
-    { "conf-file", 2, 0, 'C' },
-    { "no-resolv", 0, 0, 'R' },
-    { "expand-hosts", 0, 0, 'E' },
-    { "localmx", 0, 0, 'L' },
-    { "local-ttl", 1, 0, 'T' },
-    { "no-negcache", 0, 0, 'N' },
-    { "addn-hosts", 1, 0, 'H' },
-    { "hostsdir", 1, 0, LOPT_HOST_INOTIFY },
-    { "query-port", 1, 0, 'Q' },
-    { "except-interface", 1, 0, 'I' },
-    { "no-dhcp-interface", 1, 0, '2' },
-    { "domain-needed", 0, 0, 'D' },
-    { "dhcp-lease-max", 1, 0, 'X' },
-    { "bind-interfaces", 0, 0, 'z' },
-    { "read-ethers", 0, 0, 'Z' },
-    { "alias", 1, 0, 'V' },
-    { "dhcp-vendorclass", 1, 0, 'U' },
-    { "dhcp-userclass", 1, 0, 'j' },
-    { "dhcp-ignore", 1, 0, 'J' },
-    { "edns-packet-max", 1, 0, 'P' },
-    { "keep-in-foreground", 0, 0, 'k' },
-    { "dhcp-authoritative", 0, 0, 'K' },
-    { "srv-host", 1, 0, 'W' },
-    { "localise-queries", 0, 0, 'y' },
-    { "txt-record", 1, 0, 'Y' },
-    { "dns-rr", 1, 0, LOPT_RR },
-    { "enable-dbus", 2, 0, '1' },
-    { "bootp-dynamic", 2, 0, '3' },
-    { "dhcp-mac", 1, 0, '4' },
-    { "no-ping", 0, 0, '5' },
-    { "dhcp-script", 1, 0, '6' },
-    { "conf-dir", 1, 0, '7' },
-    { "log-facility", 1, 0 ,'8' },
-    { "leasefile-ro", 0, 0, '9' },
-    { "dns-forward-max", 1, 0, '0' },
-    { "clear-on-reload", 0, 0, LOPT_RELOAD },
-    { "dhcp-ignore-names", 2, 0, LOPT_NO_NAMES },
-    { "enable-tftp", 2, 0, LOPT_TFTP },
-    { "tftp-secure", 0, 0, LOPT_SECURE },
-    { "tftp-no-fail", 0, 0, LOPT_TFTP_NO_FAIL },
-    { "tftp-unique-root", 2, 0, LOPT_APREF },
-    { "tftp-root", 1, 0, LOPT_PREFIX },
-    { "tftp-max", 1, 0, LOPT_TFTP_MAX },
-    { "tftp-mtu", 1, 0, LOPT_TFTP_MTU },
-    { "tftp-lowercase", 0, 0, LOPT_TFTP_LC },
-    { "ptr-record", 1, 0, LOPT_PTR },
-    { "naptr-record", 1, 0, LOPT_NAPTR },
-    { "bridge-interface", 1, 0 , LOPT_BRIDGE },
-    { "dhcp-option-force", 1, 0, LOPT_FORCE },
-    { "tftp-no-blocksize", 0, 0, LOPT_NOBLOCK },
-    { "log-dhcp", 0, 0, LOPT_LOG_OPTS },
-    { "log-async", 2, 0, LOPT_MAX_LOGS },
-    { "dhcp-circuitid", 1, 0, LOPT_CIRCUIT },
-    { "dhcp-remoteid", 1, 0, LOPT_REMOTE },
-    { "dhcp-subscrid", 1, 0, LOPT_SUBSCR },
-    { "interface-name", 1, 0, LOPT_INTNAME },
-    { "dhcp-hostsfile", 1, 0, LOPT_DHCP_HOST },
-    { "dhcp-optsfile", 1, 0, LOPT_DHCP_OPTS },
-    { "dhcp-hostsdir", 1, 0, LOPT_DHCP_INOTIFY },
-    { "dhcp-optsdir", 1, 0, LOPT_DHOPT_INOTIFY },
-    { "dhcp-no-override", 0, 0, LOPT_OVERRIDE },
-    { "tftp-port-range", 1, 0, LOPT_TFTPPORTS },
-    { "stop-dns-rebind", 0, 0, LOPT_REBIND },
-    { "rebind-domain-ok", 1, 0, LOPT_NO_REBIND },
-    { "all-servers", 0, 0, LOPT_NOLAST }, 
-    { "dhcp-match", 1, 0, LOPT_MATCH }, 
-    { "dhcp-broadcast", 2, 0, LOPT_BROADCAST },
-    { "neg-ttl", 1, 0, LOPT_NEGTTL },
-    { "max-ttl", 1, 0, LOPT_MAXTTL },
-    { "min-cache-ttl", 1, 0, LOPT_MINCTTL },
-    { "max-cache-ttl", 1, 0, LOPT_MAXCTTL },
-    { "dhcp-alternate-port", 2, 0, LOPT_ALTPORT },
-    { "dhcp-scriptuser", 1, 0, LOPT_SCRIPTUSR },
-    { "min-port", 1, 0, LOPT_MINPORT },
-    { "max-port", 1, 0, LOPT_MAXPORT },
-    { "dhcp-fqdn", 0, 0, LOPT_DHCP_FQDN },
-    { "cname", 1, 0, LOPT_CNAME },
-    { "pxe-prompt", 1, 0, LOPT_PXE_PROMT },
-    { "pxe-service", 1, 0, LOPT_PXE_SERV },
-    { "test", 0, 0, LOPT_TEST },
-    { "tag-if", 1, 0, LOPT_TAG_IF },
-    { "dhcp-proxy", 2, 0, LOPT_PROXY },
-    { "dhcp-generate-names", 2, 0, LOPT_GEN_NAMES },
-    { "rebind-localhost-ok", 0, 0,  LOPT_LOC_REBND },
-    { "add-mac", 2, 0, LOPT_ADD_MAC },
-    { "add-subnet", 2, 0, LOPT_ADD_SBNET },
-    { "add-cpe-id", 1, 0 , LOPT_CPE_ID },
-    { "proxy-dnssec", 0, 0, LOPT_DNSSEC },
-    { "dhcp-sequential-ip", 0, 0,  LOPT_INCR_ADDR },
-    { "conntrack", 0, 0, LOPT_CONNTRACK },
-    { "dhcp-client-update", 0, 0, LOPT_FQDN },
-    { "dhcp-luascript", 1, 0, LOPT_LUASCRIPT },
-    { "enable-ra", 0, 0, LOPT_RA },
-    { "dhcp-duid", 1, 0, LOPT_DUID },
-    { "host-record", 1, 0, LOPT_HOST_REC },
-    { "bind-dynamic", 0, 0, LOPT_CLVERBIND },
-    { "auth-zone", 1, 0, LOPT_AUTHZONE },
-    { "auth-server", 1, 0, LOPT_AUTHSERV },
-    { "auth-ttl", 1, 0, LOPT_AUTHTTL },
-    { "auth-soa", 1, 0, LOPT_AUTHSOA },
-    { "auth-sec-servers", 1, 0, LOPT_AUTHSFS },
-    { "auth-peer", 1, 0, LOPT_AUTHPEER }, 
-    { "ipset", 1, 0, LOPT_IPSET },
-    { "synth-domain", 1, 0, LOPT_SYNTH },
-    { "dnssec", 0, 0, LOPT_SEC_VALID },
-    { "trust-anchor", 1, 0, LOPT_TRUST_ANCHOR },
-    { "dnssec-debug", 0, 0, LOPT_DNSSEC_DEBUG },
-    { "dnssec-check-unsigned", 0, 0, LOPT_DNSSEC_CHECK },
-    { "dnssec-no-timecheck", 0, 0, LOPT_DNSSEC_TIME },
-    { "dnssec-timestamp", 1, 0, LOPT_DNSSEC_STAMP },
-#ifdef OPTION6_PREFIX_CLASS 
-    { "dhcp-prefix-class", 1, 0, LOPT_PREF_CLSS },
-#endif
-    { "dhcp-relay", 1, 0, LOPT_RELAY },
-    { "ra-param", 1, 0, LOPT_RA_PARAM },
-    { "quiet-dhcp", 0, 0, LOPT_QUIET_DHCP },
-    { "quiet-dhcp6", 0, 0, LOPT_QUIET_DHCP6 },
-    { "quiet-ra", 0, 0, LOPT_QUIET_RA },
-    { "dns-loop-detect", 0, 0, LOPT_LOOP_DETECT },
-    { "script-arp", 0, 0, LOPT_SCRIPT_ARP },
-    { "dhcp-ttl", 1, 0 , LOPT_DHCPTTL },
-    { "dhcp-reply-delay", 1, 0, LOPT_REPLY_DELAY },
-    { NULL, 0, 0, 0 }
-  };
+{
+  {"version", 0, 0, 'v'},
+  {"no-hosts", 0, 0, 'h'},
+  {"no-poll", 0, 0, 'n'},
+  {"help", 0, 0, 'w'},
+  {"no-daemon", 0, 0, 'd'},
+  {"log-queries", 2, 0, 'q'},
+  {"user", 2, 0, 'u'},
+  {"group", 2, 0, 'g'},
+  {"resolv-file", 2, 0, 'r'},
+  {"servers-file", 1, 0, LOPT_SERVERS_FILE},
+  {"mx-host", 1, 0, 'm'},
+  {"mx-target", 1, 0, 't'},
+  {"cache-size", 2, 0, 'c'},
+  {"port", 1, 0, 'p'},
+  {"dhcp-leasefile", 2, 0, 'l'},
+  {"dhcp-lease", 1, 0, 'l'},
+  {"dhcp-host", 1, 0, 'G'},
+  {"dhcp-range", 1, 0, 'F'},
+  {"dhcp-option", 1, 0, 'O'},
+  {"dhcp-boot", 1, 0, 'M'},
+  {"domain", 1, 0, 's'},
+  {"domain-suffix", 1, 0, 's'},
+  {"interface", 1, 0, 'i'},
+  {"listen-address", 1, 0, 'a'},
+  {"local-service", 0, 0, LOPT_LOCAL_SERVICE},
+  {"bogus-priv", 0, 0, 'b'},
+  {"bogus-nxdomain", 1, 0, 'B'},
+  {"ignore-address", 1, 0, LOPT_IGNORE_ADDR},
+  {"selfmx", 0, 0, 'e'},
+  {"filterwin2k", 0, 0, 'f'},
+  {"pid-file", 2, 0, 'x'},
+  {"strict-order", 0, 0, 'o'},
+  {"server", 1, 0, 'S'},
+  {"rev-server", 1, 0, LOPT_REV_SERV},
+  {"local", 1, 0, LOPT_LOCAL},
+  {"address", 1, 0, 'A'},
+  {"conf-file", 2, 0, 'C'},
+  {"no-resolv", 0, 0, 'R'},
+  {"expand-hosts", 0, 0, 'E'},
+  {"localmx", 0, 0, 'L'},
+  {"local-ttl", 1, 0, 'T'},
+  {"no-negcache", 0, 0, 'N'},
+  {"addn-hosts", 1, 0, 'H'},
+  {"hostsdir", 1, 0, LOPT_HOST_INOTIFY},
+  {"query-port", 1, 0, 'Q'},
+  {"except-interface", 1, 0, 'I'},
+  {"no-dhcp-interface", 1, 0, '2'},
+  {"domain-needed", 0, 0, 'D'},
+  {"dhcp-lease-max", 1, 0, 'X'},
+  {"bind-interfaces", 0, 0, 'z'},
+  {"read-ethers", 0, 0, 'Z'},
+  {"alias", 1, 0, 'V'},
+  {"dhcp-vendorclass", 1, 0, 'U'},
+  {"dhcp-userclass", 1, 0, 'j'},
+  {"dhcp-ignore", 1, 0, 'J'},
+  {"edns-packet-max", 1, 0, 'P'},
+  {"keep-in-foreground", 0, 0, 'k'},
+  {"dhcp-authoritative", 0, 0, 'K'},
+  {"srv-host", 1, 0, 'W'},
+  {"localise-queries", 0, 0, 'y'},
+  {"txt-record", 1, 0, 'Y'},
+  {"dns-rr", 1, 0, LOPT_RR},
+  {"enable-dbus", 2, 0, '1'},
+  {"bootp-dynamic", 2, 0, '3'},
+  {"dhcp-mac", 1, 0, '4'},
+  {"no-ping", 0, 0, '5'},
+  {"dhcp-script", 1, 0, '6'},
+  {"conf-dir", 1, 0, '7'},
+  {"log-facility", 1, 0, '8'},
+  {"leasefile-ro", 0, 0, '9'},
+  {"dns-forward-max", 1, 0, '0'},
+  {"clear-on-reload", 0, 0, LOPT_RELOAD},
+  {"dhcp-ignore-names", 2, 0, LOPT_NO_NAMES},
+  {"enable-tftp", 2, 0, LOPT_TFTP},
+  {"tftp-secure", 0, 0, LOPT_SECURE},
+  {"tftp-no-fail", 0, 0, LOPT_TFTP_NO_FAIL},
+  {"tftp-unique-root", 2, 0, LOPT_APREF},
+  {"tftp-root", 1, 0, LOPT_PREFIX},
+  {"tftp-max", 1, 0, LOPT_TFTP_MAX},
+  {"tftp-mtu", 1, 0, LOPT_TFTP_MTU},
+  {"tftp-lowercase", 0, 0, LOPT_TFTP_LC},
+  {"ptr-record", 1, 0, LOPT_PTR},
+  {"naptr-record", 1, 0, LOPT_NAPTR},
+  {"bridge-interface", 1, 0, LOPT_BRIDGE},
+  {"dhcp-option-force", 1, 0, LOPT_FORCE},
+  {"tftp-no-blocksize", 0, 0, LOPT_NOBLOCK},
+  {"log-dhcp", 0, 0, LOPT_LOG_OPTS},
+  {"log-async", 2, 0, LOPT_MAX_LOGS},
+  {"dhcp-circuitid", 1, 0, LOPT_CIRCUIT},
+  {"dhcp-remoteid", 1, 0, LOPT_REMOTE},
+  {"dhcp-subscrid", 1, 0, LOPT_SUBSCR},
+  {"interface-name", 1, 0, LOPT_INTNAME},
+  {"dhcp-hostsfile", 1, 0, LOPT_DHCP_HOST},
+  {"dhcp-optsfile", 1, 0, LOPT_DHCP_OPTS},
+  {"dhcp-hostsdir", 1, 0, LOPT_DHCP_INOTIFY},
+  {"dhcp-optsdir", 1, 0, LOPT_DHOPT_INOTIFY},
+  {"dhcp-no-override", 0, 0, LOPT_OVERRIDE},
+  {"tftp-port-range", 1, 0, LOPT_TFTPPORTS},
+  {"stop-dns-rebind", 0, 0, LOPT_REBIND},
+  {"rebind-domain-ok", 1, 0, LOPT_NO_REBIND},
+  {"all-servers", 0, 0, LOPT_NOLAST},
+  {"dhcp-match", 1, 0, LOPT_MATCH},
+  {"dhcp-broadcast", 2, 0, LOPT_BROADCAST},
+  {"neg-ttl", 1, 0, LOPT_NEGTTL},
+  {"max-ttl", 1, 0, LOPT_MAXTTL},
+  {"min-cache-ttl", 1, 0, LOPT_MINCTTL},
+  {"max-cache-ttl", 1, 0, LOPT_MAXCTTL},
+  {"dhcp-alternate-port", 2, 0, LOPT_ALTPORT},
+  {"dhcp-scriptuser", 1, 0, LOPT_SCRIPTUSR},
+  {"min-port", 1, 0, LOPT_MINPORT},
+  {"max-port", 1, 0, LOPT_MAXPORT},
+  {"dhcp-fqdn", 0, 0, LOPT_DHCP_FQDN},
+  {"cname", 1, 0, LOPT_CNAME},
+  {"pxe-prompt", 1, 0, LOPT_PXE_PROMT},
+  {"pxe-service", 1, 0, LOPT_PXE_SERV},
+  {"test", 0, 0, LOPT_TEST},
+  {"tag-if", 1, 0, LOPT_TAG_IF},
+  {"dhcp-proxy", 2, 0, LOPT_PROXY},
+  {"dhcp-generate-names", 2, 0, LOPT_GEN_NAMES},
+  {"rebind-localhost-ok", 0, 0, LOPT_LOC_REBND},
+  {"add-mac", 2, 0, LOPT_ADD_MAC},
+  {"add-subnet", 2, 0, LOPT_ADD_SBNET},
+  {"add-cpe-id", 1, 0, LOPT_CPE_ID},
+  {"proxy-dnssec", 0, 0, LOPT_DNSSEC},
+  {"dhcp-sequential-ip", 0, 0, LOPT_INCR_ADDR},
+  {"conntrack", 0, 0, LOPT_CONNTRACK},
+  {"dhcp-client-update", 0, 0, LOPT_FQDN},
+  {"dhcp-luascript", 1, 0, LOPT_LUASCRIPT},
+  {"enable-ra", 0, 0, LOPT_RA},
+  {"dhcp-duid", 1, 0, LOPT_DUID},
+  {"host-record", 1, 0, LOPT_HOST_REC},
+  {"bind-dynamic", 0, 0, LOPT_CLVERBIND},
+  {"auth-zone", 1, 0, LOPT_AUTHZONE},
+  {"auth-server", 1, 0, LOPT_AUTHSERV},
+  {"auth-ttl", 1, 0, LOPT_AUTHTTL},
+  {"auth-soa", 1, 0, LOPT_AUTHSOA},
+  {"auth-sec-servers", 1, 0, LOPT_AUTHSFS},
+  {"auth-peer", 1, 0, LOPT_AUTHPEER},
+  {"ipset", 1, 0, LOPT_IPSET},
+  {"synth-domain", 1, 0, LOPT_SYNTH},
+  {"dnssec", 0, 0, LOPT_SEC_VALID},
+  {"trust-anchor", 1, 0, LOPT_TRUST_ANCHOR},
+  {"dnssec-debug", 0, 0, LOPT_DNSSEC_DEBUG},
+  {"dnssec-check-unsigned", 0, 0, LOPT_DNSSEC_CHECK},
+  {"dnssec-no-timecheck", 0, 0, LOPT_DNSSEC_TIME},
+  {"dnssec-timestamp", 1, 0, LOPT_DNSSEC_STAMP},
+#ifdef OPTION6_PREFIX_CLASS
+  {"dhcp-prefix-class", 1, 0, LOPT_PREF_CLSS},
+#endif
+  {"dhcp-relay", 1, 0, LOPT_RELAY},
+  {"ra-param", 1, 0, LOPT_RA_PARAM},
+  {"quiet-dhcp", 0, 0, LOPT_QUIET_DHCP},
+  {"quiet-dhcp6", 0, 0, LOPT_QUIET_DHCP6},
+  {"quiet-ra", 0, 0, LOPT_QUIET_RA},
+  {"dns-loop-detect", 0, 0, LOPT_LOOP_DETECT},
+  {"script-arp", 0, 0, LOPT_SCRIPT_ARP},
+  {"dhcp-ttl", 1, 0, LOPT_DHCPTTL},
+  {"dhcp-reply-delay", 1, 0, LOPT_REPLY_DELAY},
+  {NULL, 0, 0, 0}
+};
 
 
 #define ARG_DUP       OPT_LAST
@@ -337,168 +338,420 @@
 static struct {
   int opt;
   unsigned int rept;
-  char * const flagdesc;
-  char * const desc;
-  char * const arg;
+  char *const flagdesc;
+  char *const desc;
+  char *const arg;
 } usage[] = {
-  { 'a', ARG_DUP, "<ipaddr>",  gettext_noop("Specify local address(es) to listen on."), NULL },
-  { 'A', ARG_DUP, "/<domain>/<ipaddr>", gettext_noop("Return ipaddr for all hosts in specified domains."), NULL },
-  { 'b', OPT_BOGUSPRIV, NULL, gettext_noop("Fake reverse lookups for RFC1918 private address ranges."), NULL },
-  { 'B', ARG_DUP, "<ipaddr>", gettext_noop("Treat ipaddr as NXDOMAIN (defeats Verisign wildcard)."), NULL }, 
-  { 'c', ARG_ONE, "<integer>", gettext_noop("Specify the size of the cache in entries (defaults to %s)."), "$" },
-  { 'C', ARG_DUP, "<path>", gettext_noop("Specify configuration file (defaults to %s)."), CONFFILE },
-  { 'd', OPT_DEBUG, NULL, gettext_noop("Do NOT fork into the background: run in debug mode."), NULL },
-  { 'D', OPT_NODOTS_LOCAL, NULL, gettext_noop("Do NOT forward queries with no domain part."), NULL }, 
-  { 'e', OPT_SELFMX, NULL, gettext_noop("Return self-pointing MX records for local hosts."), NULL },
-  { 'E', OPT_EXPAND, NULL, gettext_noop("Expand simple names in /etc/hosts with domain-suffix."), NULL },
-  { 'f', OPT_FILTER, NULL, gettext_noop("Don't forward spurious DNS requests from Windows hosts."), NULL },
-  { 'F', ARG_DUP, "<ipaddr>,...", gettext_noop("Enable DHCP in the range given with lease duration."), NULL },
-  { 'g', ARG_ONE, "<groupname>", gettext_noop("Change to this group after startup (defaults to %s)."), CHGRP },
-  { 'G', ARG_DUP, "<hostspec>", gettext_noop("Set address or hostname for a specified machine."), NULL },
-  { LOPT_DHCP_HOST, ARG_DUP, "<path>", gettext_noop("Read DHCP host specs from file."), NULL },
-  { LOPT_DHCP_OPTS, ARG_DUP, "<path>", gettext_noop("Read DHCP option specs from file."), NULL },
-  { LOPT_DHCP_INOTIFY, ARG_DUP, "<path>", gettext_noop("Read DHCP host specs from a directory."), NULL }, 
-  { LOPT_DHOPT_INOTIFY, ARG_DUP, "<path>", gettext_noop("Read DHCP options from a directory."), NULL }, 
-  { LOPT_TAG_IF, ARG_DUP, "tag-expression", gettext_noop("Evaluate conditional tag expression."), NULL },
-  { 'h', OPT_NO_HOSTS, NULL, gettext_noop("Do NOT load %s file."), HOSTSFILE },
-  { 'H', ARG_DUP, "<path>", gettext_noop("Specify a hosts file to be read in addition to %s."), HOSTSFILE },
-  { LOPT_HOST_INOTIFY, ARG_DUP, "<path>", gettext_noop("Read hosts files from a directory."), NULL },
-  { 'i', ARG_DUP, "<interface>", gettext_noop("Specify interface(s) to listen on."), NULL },
-  { 'I', ARG_DUP, "<interface>", gettext_noop("Specify interface(s) NOT to listen on.") , NULL },
-  { 'j', ARG_DUP, "set:<tag>,<class>", gettext_noop("Map DHCP user class to tag."), NULL },
-  { LOPT_CIRCUIT, ARG_DUP, "set:<tag>,<circuit>", gettext_noop("Map RFC3046 circuit-id to tag."), NULL },
-  { LOPT_REMOTE, ARG_DUP, "set:<tag>,<remote>", gettext_noop("Map RFC3046 remote-id to tag."), NULL },
-  { LOPT_SUBSCR, ARG_DUP, "set:<tag>,<remote>", gettext_noop("Map RFC3993 subscriber-id to tag."), NULL },
-  { 'J', ARG_DUP, "tag:<tag>...", gettext_noop("Don't do DHCP for hosts with tag set."), NULL },
-  { LOPT_BROADCAST, ARG_DUP, "[=tag:<tag>...]", gettext_noop("Force broadcast replies for hosts with tag set."), NULL }, 
-  { 'k', OPT_NO_FORK, NULL, gettext_noop("Do NOT fork into the background, do NOT run in debug mode."), NULL },
-  { 'K', OPT_AUTHORITATIVE, NULL, gettext_noop("Assume we are the only DHCP server on the local network."), NULL },
-  { 'l', ARG_ONE, "<path>", gettext_noop("Specify where to store DHCP leases (defaults to %s)."), LEASEFILE },
-  { 'L', OPT_LOCALMX, NULL, gettext_noop("Return MX records for local hosts."), NULL },
-  { 'm', ARG_DUP, "<host_name>,<target>,<pref>", gettext_noop("Specify an MX record."), NULL },
-  { 'M', ARG_DUP, "<bootp opts>", gettext_noop("Specify BOOTP options to DHCP server."), NULL },
-  { 'n', OPT_NO_POLL, NULL, gettext_noop("Do NOT poll %s file, reload only on SIGHUP."), RESOLVFILE }, 
-  { 'N', OPT_NO_NEG, NULL, gettext_noop("Do NOT cache failed search results."), NULL },
-  { 'o', OPT_ORDER, NULL, gettext_noop("Use nameservers strictly in the order given in %s."), RESOLVFILE },
-  { 'O', ARG_DUP, "<optspec>", gettext_noop("Specify options to be sent to DHCP clients."), NULL },
-  { LOPT_FORCE, ARG_DUP, "<optspec>", gettext_noop("DHCP option sent even if the client does not request it."), NULL},
-  { 'p', ARG_ONE, "<integer>", gettext_noop("Specify port to listen for DNS requests on (defaults to 53)."), NULL },
-  { 'P', ARG_ONE, "<integer>", gettext_noop("Maximum supported UDP packet size for EDNS.0 (defaults to %s)."), "*" },
-  { 'q', ARG_DUP, NULL, gettext_noop("Log DNS queries."), NULL },
-  { 'Q', ARG_ONE, "<integer>", gettext_noop("Force the originating port for upstream DNS queries."), NULL },
-  { 'R', OPT_NO_RESOLV, NULL, gettext_noop("Do NOT read resolv.conf."), NULL },
-  { 'r', ARG_DUP, "<path>", gettext_noop("Specify path to resolv.conf (defaults to %s)."), RESOLVFILE }, 
-  { LOPT_SERVERS_FILE, ARG_ONE, "<path>", gettext_noop("Specify path to file with server= options"), NULL },
-  { 'S', ARG_DUP, "/<domain>/<ipaddr>", gettext_noop("Specify address(es) of upstream servers with optional domains."), NULL },
-  { LOPT_REV_SERV, ARG_DUP, "<addr>/<prefix>,<ipaddr>", gettext_noop("Specify address of upstream servers for reverse address queries"), NULL },
-  { LOPT_LOCAL, ARG_DUP, "/<domain>/", gettext_noop("Never forward queries to specified domains."), NULL },
-  { 's', ARG_DUP, "<domain>[,<range>]", gettext_noop("Specify the domain to be assigned in DHCP leases."), NULL },
-  { 't', ARG_ONE, "<host_name>", gettext_noop("Specify default target in an MX record."), NULL },
-  { 'T', ARG_ONE, "<integer>", gettext_noop("Specify time-to-live in seconds for replies from /etc/hosts."), NULL },
-  { LOPT_NEGTTL, ARG_ONE, "<integer>", gettext_noop("Specify time-to-live in seconds for negative caching."), NULL },
-  { LOPT_MAXTTL, ARG_ONE, "<integer>", gettext_noop("Specify time-to-live in seconds for maximum TTL to send to clients."), NULL },
-  { LOPT_MAXCTTL, ARG_ONE, "<integer>", gettext_noop("Specify time-to-live ceiling for cache."), NULL },
-  { LOPT_MINCTTL, ARG_ONE, "<integer>", gettext_noop("Specify time-to-live floor for cache."), NULL },
-  { 'u', ARG_ONE, "<username>", gettext_noop("Change to this user after startup. (defaults to %s)."), CHUSER }, 
-  { 'U', ARG_DUP, "set:<tag>,<class>", gettext_noop("Map DHCP vendor class to tag."), NULL },
-  { 'v', 0, NULL, gettext_noop("Display dnsmasq version and copyright information."), NULL },
-  { 'V', ARG_DUP, "<ipaddr>,<ipaddr>,<netmask>", gettext_noop("Translate IPv4 addresses from upstream servers."), NULL },
-  { 'W', ARG_DUP, "<name>,<target>,...", gettext_noop("Specify a SRV record."), NULL },
-  { 'w', 0, NULL, gettext_noop("Display this message. Use --help dhcp or --help dhcp6 for known DHCP options."), NULL },
-  { 'x', ARG_ONE, "<path>", gettext_noop("Specify path of PID file (defaults to %s)."), RUNFILE },
-  { 'X', ARG_ONE, "<integer>", gettext_noop("Specify maximum number of DHCP leases (defaults to %s)."), "&" },
-  { 'y', OPT_LOCALISE, NULL, gettext_noop("Answer DNS queries based on the interface a query was sent to."), NULL },
-  { 'Y', ARG_DUP, "<name>,<txt>[,<txt]", gettext_noop("Specify TXT DNS record."), NULL },
-  { LOPT_PTR, ARG_DUP, "<name>,<target>", gettext_noop("Specify PTR DNS record."), NULL },
-  { LOPT_INTNAME, ARG_DUP, "<name>,<interface>", gettext_noop("Give DNS name to IPv4 address of interface."), NULL },
-  { 'z', OPT_NOWILD, NULL, gettext_noop("Bind only to interfaces in use."), NULL },
-  { 'Z', OPT_ETHERS, NULL, gettext_noop("Read DHCP static host information from %s."), ETHERSFILE },
-  { '1', ARG_ONE, "[=<busname>]", gettext_noop("Enable the DBus interface for setting upstream servers, etc."), NULL },
-  { '2', ARG_DUP, "<interface>", gettext_noop("Do not provide DHCP on this interface, only provide DNS."), NULL },
-  { '3', ARG_DUP, "[=tag:<tag>]...", gettext_noop("Enable dynamic address allocation for bootp."), NULL },
-  { '4', ARG_DUP, "set:<tag>,<mac address>", gettext_noop("Map MAC address (with wildcards) to option set."), NULL },
-  { LOPT_BRIDGE, ARG_DUP, "<iface>,<alias>..", gettext_noop("Treat DHCP requests on aliases as arriving from interface."), NULL },
-  { '5', OPT_NO_PING, NULL, gettext_noop("Disable ICMP echo address checking in the DHCP server."), NULL },
-  { '6', ARG_ONE, "<path>", gettext_noop("Shell script to run on DHCP lease creation and destruction."), NULL },
-  { LOPT_LUASCRIPT, ARG_DUP, "path", gettext_noop("Lua script to run on DHCP lease creation and destruction."), NULL },
-  { LOPT_SCRIPTUSR, ARG_ONE, "<username>", gettext_noop("Run lease-change scripts as this user."), NULL },
-  { LOPT_SCRIPT_ARP, OPT_SCRIPT_ARP, NULL, gettext_noop("Call dhcp-script with changes to local ARP table."), NULL },
-  { '7', ARG_DUP, "<path>", gettext_noop("Read configuration from all the files in this directory."), NULL },
-  { '8', ARG_ONE, "<facility>|<file>", gettext_noop("Log to this syslog facility or file. (defaults to DAEMON)"), NULL },
-  { '9', OPT_LEASE_RO, NULL, gettext_noop("Do not use leasefile."), NULL },
-  { '0', ARG_ONE, "<integer>", gettext_noop("Maximum number of concurrent DNS queries. (defaults to %s)"), "!" }, 
-  { LOPT_RELOAD, OPT_RELOAD, NULL, gettext_noop("Clear DNS cache when reloading %s."), RESOLVFILE },
-  { LOPT_NO_NAMES, ARG_DUP, "[=tag:<tag>]...", gettext_noop("Ignore hostnames provided by DHCP clients."), NULL },
-  { LOPT_OVERRIDE, OPT_NO_OVERRIDE, NULL, gettext_noop("Do NOT reuse filename and server fields for extra DHCP options."), NULL },
-  { LOPT_TFTP, ARG_DUP, "[=<intr>[,<intr>]]", gettext_noop("Enable integrated read-only TFTP server."), NULL },
-  { LOPT_PREFIX, ARG_DUP, "<dir>[,<iface>]", gettext_noop("Export files by TFTP only from the specified subtree."), NULL },
-  { LOPT_APREF, ARG_DUP, "[=ip|mac]", gettext_noop("Add client IP or hardware address to tftp-root."), NULL },
-  { LOPT_SECURE, OPT_TFTP_SECURE, NULL, gettext_noop("Allow access only to files owned by the user running dnsmasq."), NULL },
-  { LOPT_TFTP_NO_FAIL, OPT_TFTP_NO_FAIL, NULL, gettext_noop("Do not terminate the service if TFTP directories are inaccessible."), NULL },
-  { LOPT_TFTP_MAX, ARG_ONE, "<integer>", gettext_noop("Maximum number of concurrent TFTP transfers (defaults to %s)."), "#" },
-  { LOPT_TFTP_MTU, ARG_ONE, "<integer>", gettext_noop("Maximum MTU to use for TFTP transfers."), NULL },
-  { LOPT_NOBLOCK, OPT_TFTP_NOBLOCK, NULL, gettext_noop("Disable the TFTP blocksize extension."), NULL },
-  { LOPT_TFTP_LC, OPT_TFTP_LC, NULL, gettext_noop("Convert TFTP filenames to lowercase"), NULL },
-  { LOPT_TFTPPORTS, ARG_ONE, "<start>,<end>", gettext_noop("Ephemeral port range for use by TFTP transfers."), NULL },
-  { LOPT_LOG_OPTS, OPT_LOG_OPTS, NULL, gettext_noop("Extra logging for DHCP."), NULL },
-  { LOPT_MAX_LOGS, ARG_ONE, "[=<integer>]", gettext_noop("Enable async. logging; optionally set queue length."), NULL },
-  { LOPT_REBIND, OPT_NO_REBIND, NULL, gettext_noop("Stop DNS rebinding. Filter private IP ranges when resolving."), NULL },
-  { LOPT_LOC_REBND, OPT_LOCAL_REBIND, NULL, gettext_noop("Allow rebinding of 127.0.0.0/8, for RBL servers."), NULL },
-  { LOPT_NO_REBIND, ARG_DUP, "/<domain>/", gettext_noop("Inhibit DNS-rebind protection on this domain."), NULL },
-  { LOPT_NOLAST, OPT_ALL_SERVERS, NULL, gettext_noop("Always perform DNS queries to all servers."), NULL },
-  { LOPT_MATCH, ARG_DUP, "set:<tag>,<optspec>", gettext_noop("Set tag if client includes matching option in request."), NULL },
-  { LOPT_ALTPORT, ARG_ONE, "[=<ports>]", gettext_noop("Use alternative ports for DHCP."), NULL },
-  { LOPT_NAPTR, ARG_DUP, "<name>,<naptr>", gettext_noop("Specify NAPTR DNS record."), NULL },
-  { LOPT_MINPORT, ARG_ONE, "<port>", gettext_noop("Specify lowest port available for DNS query transmission."), NULL },
-  { LOPT_MAXPORT, ARG_ONE, "<port>", gettext_noop("Specify highest port available for DNS query transmission."), NULL },
-  { LOPT_DHCP_FQDN, OPT_DHCP_FQDN, NULL, gettext_noop("Use only fully qualified domain names for DHCP clients."), NULL },
-  { LOPT_GEN_NAMES, ARG_DUP, "[=tag:<tag>]", gettext_noop("Generate hostnames based on MAC address for nameless clients."), NULL},
-  { LOPT_PROXY, ARG_DUP, "[=<ipaddr>]...", gettext_noop("Use these DHCP relays as full proxies."), NULL },
-  { LOPT_RELAY, ARG_DUP, "<local-addr>,<server>[,<iface>]", gettext_noop("Relay DHCP requests to a remote server"), NULL},
-  { LOPT_CNAME, ARG_DUP, "<alias>,<target>[,<ttl>]", gettext_noop("Specify alias name for LOCAL DNS name."), NULL },
-  { LOPT_PXE_PROMT, ARG_DUP, "<prompt>,[<timeout>]", gettext_noop("Prompt to send to PXE clients."), NULL },
-  { LOPT_PXE_SERV, ARG_DUP, "<service>", gettext_noop("Boot service for PXE menu."), NULL },
-  { LOPT_TEST, 0, NULL, gettext_noop("Check configuration syntax."), NULL },
-  { LOPT_ADD_MAC, ARG_DUP, "[=base64|text]", gettext_noop("Add requestor's MAC address to forwarded DNS queries."), NULL },
-  { LOPT_ADD_SBNET, ARG_ONE, "<v4 pref>[,<v6 pref>]", gettext_noop("Add specified IP subnet to forwarded DNS queries."), NULL },
-  { LOPT_CPE_ID, ARG_ONE, "<text>", gettext_noop("Add client identification to forwarded DNS queries."), NULL },
-  { LOPT_DNSSEC, OPT_DNSSEC_PROXY, NULL, gettext_noop("Proxy DNSSEC validation results from upstream nameservers."), NULL },
-  { LOPT_INCR_ADDR, OPT_CONSEC_ADDR, NULL, gettext_noop("Attempt to allocate sequential IP addresses to DHCP clients."), NULL },
-  { LOPT_CONNTRACK, OPT_CONNTRACK, NULL, gettext_noop("Copy connection-track mark from queries to upstream connections."), NULL },
-  { LOPT_FQDN, OPT_FQDN_UPDATE, NULL, gettext_noop("Allow DHCP clients to do their own DDNS updates."), NULL },
-  { LOPT_RA, OPT_RA, NULL, gettext_noop("Send router-advertisements for interfaces doing DHCPv6"), NULL },
-  { LOPT_DUID, ARG_ONE, "<enterprise>,<duid>", gettext_noop("Specify DUID_EN-type DHCPv6 server DUID"), NULL },
-  { LOPT_HOST_REC, ARG_DUP, "<name>,<address>[,<ttl>]", gettext_noop("Specify host (A/AAAA and PTR) records"), NULL },
-  { LOPT_RR, ARG_DUP, "<name>,<RR-number>,[<data>]", gettext_noop("Specify arbitrary DNS resource record"), NULL },
-  { LOPT_CLVERBIND, OPT_CLEVERBIND, NULL, gettext_noop("Bind to interfaces in use - check for new interfaces"), NULL },
-  { LOPT_AUTHSERV, ARG_ONE, "<NS>,<interface>", gettext_noop("Export local names to global DNS"), NULL },
-  { LOPT_AUTHZONE, ARG_DUP, "<domain>,[<subnet>...]", gettext_noop("Domain to export to global DNS"), NULL },
-  { LOPT_AUTHTTL, ARG_ONE, "<integer>", gettext_noop("Set TTL for authoritative replies"), NULL },
-  { LOPT_AUTHSOA, ARG_ONE, "<serial>[,...]", gettext_noop("Set authoritative zone information"), NULL },
-  { LOPT_AUTHSFS, ARG_DUP, "<NS>[,<NS>...]", gettext_noop("Secondary authoritative nameservers for forward domains"), NULL },
-  { LOPT_AUTHPEER, ARG_DUP, "<ipaddr>[,<ipaddr>...]", gettext_noop("Peers which are allowed to do zone transfer"), NULL },
-  { LOPT_IPSET, ARG_DUP, "/<domain>[/<domain>...]/<ipset>...", gettext_noop("Specify ipsets to which matching domains should be added"), NULL },
-  { LOPT_SYNTH, ARG_DUP, "<domain>,<range>,[<prefix>]", gettext_noop("Specify a domain and address range for synthesised names"), NULL },
-  { LOPT_SEC_VALID, OPT_DNSSEC_VALID, NULL, gettext_noop("Activate DNSSEC validation"), NULL },
-  { LOPT_TRUST_ANCHOR, ARG_DUP, "<domain>,[<class>],...", gettext_noop("Specify trust anchor key digest."), NULL },
-  { LOPT_DNSSEC_DEBUG, OPT_DNSSEC_DEBUG, NULL, gettext_noop("Disable upstream checking for DNSSEC debugging."), NULL },
-  { LOPT_DNSSEC_CHECK, OPT_DNSSEC_NO_SIGN, NULL, gettext_noop("Ensure answers without DNSSEC are in unsigned zones."), NULL },
-  { LOPT_DNSSEC_TIME, OPT_DNSSEC_TIME, NULL, gettext_noop("Don't check DNSSEC signature timestamps until first cache-reload"), NULL },
-  { LOPT_DNSSEC_STAMP, ARG_ONE, "<path>", gettext_noop("Timestamp file to verify system clock for DNSSEC"), NULL },
-#ifdef OPTION6_PREFIX_CLASS 
-  { LOPT_PREF_CLSS, ARG_DUP, "set:tag,<class>", gettext_noop("Specify DHCPv6 prefix class"), NULL },
-#endif
-  { LOPT_RA_PARAM, ARG_DUP, "<iface>,[mtu:<value>|<interface>|off,][<prio>,]<intval>[,<lifetime>]", gettext_noop("Set MTU, priority, resend-interval and router-lifetime"), NULL },
-  { LOPT_QUIET_DHCP, OPT_QUIET_DHCP, NULL, gettext_noop("Do not log routine DHCP."), NULL },
-  { LOPT_QUIET_DHCP6, OPT_QUIET_DHCP6, NULL, gettext_noop("Do not log routine DHCPv6."), NULL },
-  { LOPT_QUIET_RA, OPT_QUIET_RA, NULL, gettext_noop("Do not log RA."), NULL },
-  { LOPT_LOCAL_SERVICE, OPT_LOCAL_SERVICE, NULL, gettext_noop("Accept queries only from directly-connected networks."), NULL },
-  { LOPT_LOOP_DETECT, OPT_LOOP_DETECT, NULL, gettext_noop("Detect and remove DNS forwarding loops."), NULL },
-  { LOPT_IGNORE_ADDR, ARG_DUP, "<ipaddr>", gettext_noop("Ignore DNS responses containing ipaddr."), NULL }, 
-  { LOPT_DHCPTTL, ARG_ONE, "<ttl>", gettext_noop("Set TTL in DNS responses with DHCP-derived addresses."), NULL }, 
-  { LOPT_REPLY_DELAY, ARG_ONE, "<integer>", gettext_noop("Delay DHCP replies for at least number of seconds."), NULL },
-  { 0, 0, NULL, NULL, NULL }
-}; 
+  {
+  'a', ARG_DUP, "<ipaddr>",
+        gettext_noop("Specify local address(es) to listen on."), NULL}, {
+  'A', ARG_DUP, "/<domain>/<ipaddr>",
+        gettext_noop("Return ipaddr for all hosts in specified domains."),
+        NULL}, {
+  'b', OPT_BOGUSPRIV, NULL,
+        gettext_noop
+        ("Fake reverse lookups for RFC1918 private address ranges."), NULL}, {
+  'B', ARG_DUP, "<ipaddr>",
+        gettext_noop("Treat ipaddr as NXDOMAIN (defeats Verisign wildcard)."),
+        NULL}, {
+  'c', ARG_ONE, "<integer>",
+        gettext_noop
+        ("Specify the size of the cache in entries (defaults to %s)."), "$"}, {
+  'C', ARG_DUP, "<path>",
+        gettext_noop("Specify configuration file (defaults to %s)."), CONFFILE},
+  {
+  'd', OPT_DEBUG, NULL,
+        gettext_noop("Do NOT fork into the background: run in debug mode."),
+        NULL}, {
+  'D', OPT_NODOTS_LOCAL, NULL,
+        gettext_noop("Do NOT forward queries with no domain part."), NULL}, {
+  'e', OPT_SELFMX, NULL,
+        gettext_noop("Return self-pointing MX records for local hosts."), NULL},
+  {
+  'E', OPT_EXPAND, NULL,
+        gettext_noop("Expand simple names in /etc/hosts with domain-suffix."),
+        NULL}, {
+  'f', OPT_FILTER, NULL,
+        gettext_noop
+        ("Don't forward spurious DNS requests from Windows hosts."), NULL}, {
+  'F', ARG_DUP, "<ipaddr>,...",
+        gettext_noop("Enable DHCP in the range given with lease duration."),
+        NULL}, {
+  'g', ARG_ONE, "<groupname>",
+        gettext_noop("Change to this group after startup (defaults to %s)."),
+        CHGRP}, {
+  'G', ARG_DUP, "<hostspec>",
+        gettext_noop("Set address or hostname for a specified machine."), NULL},
+  {
+  LOPT_DHCP_HOST, ARG_DUP, "<path>",
+        gettext_noop("Read DHCP host specs from file."), NULL}, {
+  LOPT_DHCP_OPTS, ARG_DUP, "<path>",
+        gettext_noop("Read DHCP option specs from file."), NULL}, {
+  LOPT_DHCP_INOTIFY, ARG_DUP, "<path>",
+        gettext_noop("Read DHCP host specs from a directory."), NULL}, {
+  LOPT_DHOPT_INOTIFY, ARG_DUP, "<path>",
+        gettext_noop("Read DHCP options from a directory."), NULL}, {
+  LOPT_TAG_IF, ARG_DUP, "tag-expression",
+        gettext_noop("Evaluate conditional tag expression."), NULL}, {
+  'h', OPT_NO_HOSTS, NULL, gettext_noop("Do NOT load %s file."), HOSTSFILE}, {
+  'H', ARG_DUP, "<path>",
+        gettext_noop("Specify a hosts file to be read in addition to %s."),
+        HOSTSFILE}, {
+  LOPT_HOST_INOTIFY, ARG_DUP, "<path>",
+        gettext_noop("Read hosts files from a directory."), NULL}, {
+  'i', ARG_DUP, "<interface>",
+        gettext_noop("Specify interface(s) to listen on."), NULL}, {
+  'I', ARG_DUP, "<interface>",
+        gettext_noop("Specify interface(s) NOT to listen on."), NULL}, {
+  'j', ARG_DUP, "set:<tag>,<class>",
+        gettext_noop("Map DHCP user class to tag."), NULL}, {
+  LOPT_CIRCUIT, ARG_DUP, "set:<tag>,<circuit>",
+        gettext_noop("Map RFC3046 circuit-id to tag."), NULL}, {
+  LOPT_REMOTE, ARG_DUP, "set:<tag>,<remote>",
+        gettext_noop("Map RFC3046 remote-id to tag."), NULL}, {
+  LOPT_SUBSCR, ARG_DUP, "set:<tag>,<remote>",
+        gettext_noop("Map RFC3993 subscriber-id to tag."), NULL}, {
+  'J', ARG_DUP, "tag:<tag>...",
+        gettext_noop("Don't do DHCP for hosts with tag set."), NULL}, {
+  LOPT_BROADCAST, ARG_DUP, "[=tag:<tag>...]",
+        gettext_noop("Force broadcast replies for hosts with tag set."), NULL},
+  {
+  'k', OPT_NO_FORK, NULL,
+        gettext_noop
+        ("Do NOT fork into the background, do NOT run in debug mode."), NULL}, {
+  'K', OPT_AUTHORITATIVE, NULL,
+        gettext_noop
+        ("Assume we are the only DHCP server on the local network."), NULL}, {
+  'l', ARG_ONE, "<path>",
+        gettext_noop("Specify where to store DHCP leases (defaults to %s)."),
+        LEASEFILE}, {
+  'L', OPT_LOCALMX, NULL, gettext_noop("Return MX records for local hosts."),
+        NULL}, {
+  'm', ARG_DUP, "<host_name>,<target>,<pref>",
+        gettext_noop("Specify an MX record."), NULL}, {
+  'M', ARG_DUP, "<bootp opts>",
+        gettext_noop("Specify BOOTP options to DHCP server."), NULL}, {
+  'n', OPT_NO_POLL, NULL,
+        gettext_noop("Do NOT poll %s file, reload only on SIGHUP."),
+        RESOLVFILE}, {
+  'N', OPT_NO_NEG, NULL, gettext_noop("Do NOT cache failed search results."),
+        NULL}, {
+  'o', OPT_ORDER, NULL,
+        gettext_noop("Use nameservers strictly in the order given in %s."),
+        RESOLVFILE}, {
+  'O', ARG_DUP, "<optspec>",
+        gettext_noop("Specify options to be sent to DHCP clients."), NULL}, {
+  LOPT_FORCE, ARG_DUP, "<optspec>",
+        gettext_noop
+        ("DHCP option sent even if the client does not request it."), NULL}, {
+  'p', ARG_ONE, "<integer>",
+        gettext_noop
+        ("Specify port to listen for DNS requests on (defaults to 53)."), NULL},
+  {
+  'P', ARG_ONE, "<integer>",
+        gettext_noop
+        ("Maximum supported UDP packet size for EDNS.0 (defaults to %s)."),
+        "*"}, {
+  'q', ARG_DUP, NULL, gettext_noop("Log DNS queries."), NULL}, {
+  'Q', ARG_ONE, "<integer>",
+        gettext_noop("Force the originating port for upstream DNS queries."),
+        NULL}, {
+  'R', OPT_NO_RESOLV, NULL, gettext_noop("Do NOT read resolv.conf."), NULL}, {
+  'r', ARG_DUP, "<path>",
+        gettext_noop("Specify path to resolv.conf (defaults to %s)."),
+        RESOLVFILE}, {
+  LOPT_SERVERS_FILE, ARG_ONE, "<path>",
+        gettext_noop("Specify path to file with server= options"), NULL}, {
+  'S', ARG_DUP, "/<domain>/<ipaddr>",
+        gettext_noop
+        ("Specify address(es) of upstream servers with optional domains."),
+        NULL}, {
+  LOPT_REV_SERV, ARG_DUP, "<addr>/<prefix>,<ipaddr>",
+        gettext_noop
+        ("Specify address of upstream servers for reverse address queries"),
+        NULL}, {
+  LOPT_LOCAL, ARG_DUP, "/<domain>/",
+        gettext_noop("Never forward queries to specified domains."), NULL}, {
+  's', ARG_DUP, "<domain>[,<range>]",
+        gettext_noop("Specify the domain to be assigned in DHCP leases."),
+        NULL}, {
+  't', ARG_ONE, "<host_name>",
+        gettext_noop("Specify default target in an MX record."), NULL}, {
+  'T', ARG_ONE, "<integer>",
+        gettext_noop
+        ("Specify time-to-live in seconds for replies from /etc/hosts."), NULL},
+  {
+  LOPT_NEGTTL, ARG_ONE, "<integer>",
+        gettext_noop("Specify time-to-live in seconds for negative caching."),
+        NULL}, {
+  LOPT_MAXTTL, ARG_ONE, "<integer>",
+        gettext_noop
+        ("Specify time-to-live in seconds for maximum TTL to send to clients."),
+        NULL}, {
+  LOPT_MAXCTTL, ARG_ONE, "<integer>",
+        gettext_noop("Specify time-to-live ceiling for cache."), NULL}, {
+  LOPT_MINCTTL, ARG_ONE, "<integer>",
+        gettext_noop("Specify time-to-live floor for cache."), NULL}, {
+  'u', ARG_ONE, "<username>",
+        gettext_noop("Change to this user after startup. (defaults to %s)."),
+        CHUSER}, {
+  'U', ARG_DUP, "set:<tag>,<class>",
+        gettext_noop("Map DHCP vendor class to tag."), NULL}, {
+  'v', 0, NULL,
+        gettext_noop("Display dnsmasq version and copyright information."),
+        NULL}, {
+  'V', ARG_DUP, "<ipaddr>,<ipaddr>,<netmask>",
+        gettext_noop("Translate IPv4 addresses from upstream servers."), NULL},
+  {
+  'W', ARG_DUP, "<name>,<target>,...", gettext_noop("Specify a SRV record."),
+        NULL}, {
+  'w', 0, NULL,
+        gettext_noop
+        ("Display this message. Use --help dhcp or --help dhcp6 for known DHCP options."),
+        NULL}, {
+  'x', ARG_ONE, "<path>",
+        gettext_noop("Specify path of PID file (defaults to %s)."), RUNFILE}, {
+  'X', ARG_ONE, "<integer>",
+        gettext_noop
+        ("Specify maximum number of DHCP leases (defaults to %s)."), "&"}, {
+  'y', OPT_LOCALISE, NULL,
+        gettext_noop
+        ("Answer DNS queries based on the interface a query was sent to."),
+        NULL}, {
+  'Y', ARG_DUP, "<name>,<txt>[,<txt]",
+        gettext_noop("Specify TXT DNS record."), NULL}, {
+  LOPT_PTR, ARG_DUP, "<name>,<target>",
+        gettext_noop("Specify PTR DNS record."), NULL}, {
+  LOPT_INTNAME, ARG_DUP, "<name>,<interface>",
+        gettext_noop("Give DNS name to IPv4 address of interface."), NULL}, {
+  'z', OPT_NOWILD, NULL, gettext_noop("Bind only to interfaces in use."), NULL}, {
+  'Z', OPT_ETHERS, NULL,
+        gettext_noop("Read DHCP static host information from %s."), ETHERSFILE},
+  {
+  '1', ARG_ONE, "[=<busname>]",
+        gettext_noop
+        ("Enable the DBus interface for setting upstream servers, etc."), NULL},
+  {
+  '2', ARG_DUP, "<interface>",
+        gettext_noop
+        ("Do not provide DHCP on this interface, only provide DNS."), NULL}, {
+  '3', ARG_DUP, "[=tag:<tag>]...",
+        gettext_noop("Enable dynamic address allocation for bootp."), NULL}, {
+  '4', ARG_DUP, "set:<tag>,<mac address>",
+        gettext_noop("Map MAC address (with wildcards) to option set."), NULL},
+  {
+  LOPT_BRIDGE, ARG_DUP, "<iface>,<alias>..",
+        gettext_noop
+        ("Treat DHCP requests on aliases as arriving from interface."), NULL}, {
+  '5', OPT_NO_PING, NULL,
+        gettext_noop
+        ("Disable ICMP echo address checking in the DHCP server."), NULL}, {
+  '6', ARG_ONE, "<path>",
+        gettext_noop
+        ("Shell script to run on DHCP lease creation and destruction."), NULL},
+  {
+  LOPT_LUASCRIPT, ARG_DUP, "path",
+        gettext_noop
+        ("Lua script to run on DHCP lease creation and destruction."), NULL}, {
+  LOPT_SCRIPTUSR, ARG_ONE, "<username>",
+        gettext_noop("Run lease-change scripts as this user."), NULL}, {
+  LOPT_SCRIPT_ARP, OPT_SCRIPT_ARP, NULL,
+        gettext_noop("Call dhcp-script with changes to local ARP table."),
+        NULL}, {
+  '7', ARG_DUP, "<path>",
+        gettext_noop
+        ("Read configuration from all the files in this directory."), NULL}, {
+  '8', ARG_ONE, "<facility>|<file>",
+        gettext_noop
+        ("Log to this syslog facility or file. (defaults to DAEMON)"), NULL}, {
+  '9', OPT_LEASE_RO, NULL, gettext_noop("Do not use leasefile."), NULL}, {
+  '0', ARG_ONE, "<integer>",
+        gettext_noop
+        ("Maximum number of concurrent DNS queries. (defaults to %s)"), "!"}, {
+  LOPT_RELOAD, OPT_RELOAD, NULL,
+        gettext_noop("Clear DNS cache when reloading %s."), RESOLVFILE}, {
+  LOPT_NO_NAMES, ARG_DUP, "[=tag:<tag>]...",
+        gettext_noop("Ignore hostnames provided by DHCP clients."), NULL}, {
+  LOPT_OVERRIDE, OPT_NO_OVERRIDE, NULL,
+        gettext_noop
+        ("Do NOT reuse filename and server fields for extra DHCP options."),
+        NULL}, {
+  LOPT_TFTP, ARG_DUP, "[=<intr>[,<intr>]]",
+        gettext_noop("Enable integrated read-only TFTP server."), NULL}, {
+  LOPT_PREFIX, ARG_DUP, "<dir>[,<iface>]",
+        gettext_noop("Export files by TFTP only from the specified subtree."),
+        NULL}, {
+  LOPT_APREF, ARG_DUP, "[=ip|mac]",
+        gettext_noop("Add client IP or hardware address to tftp-root."), NULL},
+  {
+  LOPT_SECURE, OPT_TFTP_SECURE, NULL,
+        gettext_noop
+        ("Allow access only to files owned by the user running dnsmasq."),
+        NULL}, {
+  LOPT_TFTP_NO_FAIL, OPT_TFTP_NO_FAIL, NULL,
+        gettext_noop
+        ("Do not terminate the service if TFTP directories are inaccessible."),
+        NULL}, {
+  LOPT_TFTP_MAX, ARG_ONE, "<integer>",
+        gettext_noop
+        ("Maximum number of concurrent TFTP transfers (defaults to %s)."), "#"},
+  {
+  LOPT_TFTP_MTU, ARG_ONE, "<integer>",
+        gettext_noop("Maximum MTU to use for TFTP transfers."), NULL}, {
+  LOPT_NOBLOCK, OPT_TFTP_NOBLOCK, NULL,
+        gettext_noop("Disable the TFTP blocksize extension."), NULL}, {
+  LOPT_TFTP_LC, OPT_TFTP_LC, NULL,
+        gettext_noop("Convert TFTP filenames to lowercase"), NULL}, {
+  LOPT_TFTPPORTS, ARG_ONE, "<start>,<end>",
+        gettext_noop("Ephemeral port range for use by TFTP transfers."), NULL},
+  {
+  LOPT_LOG_OPTS, OPT_LOG_OPTS, NULL, gettext_noop("Extra logging for DHCP."),
+        NULL}, {
+  LOPT_MAX_LOGS, ARG_ONE, "[=<integer>]",
+        gettext_noop("Enable async. logging; optionally set queue length."),
+        NULL}, {
+  LOPT_REBIND, OPT_NO_REBIND, NULL,
+        gettext_noop
+        ("Stop DNS rebinding. Filter private IP ranges when resolving."), NULL},
+  {
+  LOPT_LOC_REBND, OPT_LOCAL_REBIND, NULL,
+        gettext_noop("Allow rebinding of 127.0.0.0/8, for RBL servers."), NULL},
+  {
+  LOPT_NO_REBIND, ARG_DUP, "/<domain>/",
+        gettext_noop("Inhibit DNS-rebind protection on this domain."), NULL}, {
+  LOPT_NOLAST, OPT_ALL_SERVERS, NULL,
+        gettext_noop("Always perform DNS queries to all servers."), NULL}, {
+  LOPT_MATCH, ARG_DUP, "set:<tag>,<optspec>",
+        gettext_noop
+        ("Set tag if client includes matching option in request."), NULL}, {
+  LOPT_ALTPORT, ARG_ONE, "[=<ports>]",
+        gettext_noop("Use alternative ports for DHCP."), NULL}, {
+  LOPT_NAPTR, ARG_DUP, "<name>,<naptr>",
+        gettext_noop("Specify NAPTR DNS record."), NULL}, {
+  LOPT_MINPORT, ARG_ONE, "<port>",
+        gettext_noop
+        ("Specify lowest port available for DNS query transmission."), NULL}, {
+  LOPT_MAXPORT, ARG_ONE, "<port>",
+        gettext_noop
+        ("Specify highest port available for DNS query transmission."), NULL}, {
+  LOPT_DHCP_FQDN, OPT_DHCP_FQDN, NULL,
+        gettext_noop
+        ("Use only fully qualified domain names for DHCP clients."), NULL}, {
+  LOPT_GEN_NAMES, ARG_DUP, "[=tag:<tag>]",
+        gettext_noop
+        ("Generate hostnames based on MAC address for nameless clients."),
+        NULL}, {
+  LOPT_PROXY, ARG_DUP, "[=<ipaddr>]...",
+        gettext_noop("Use these DHCP relays as full proxies."), NULL}, {
+  LOPT_RELAY, ARG_DUP, "<local-addr>,<server>[,<iface>]",
+        gettext_noop("Relay DHCP requests to a remote server"), NULL}, {
+  LOPT_CNAME, ARG_DUP, "<alias>,<target>[,<ttl>]",
+        gettext_noop("Specify alias name for LOCAL DNS name."), NULL}, {
+  LOPT_PXE_PROMT, ARG_DUP, "<prompt>,[<timeout>]",
+        gettext_noop("Prompt to send to PXE clients."), NULL}, {
+  LOPT_PXE_SERV, ARG_DUP, "<service>",
+        gettext_noop("Boot service for PXE menu."), NULL}, {
+  LOPT_TEST, 0, NULL, gettext_noop("Check configuration syntax."), NULL}, {
+  LOPT_ADD_MAC, ARG_DUP, "[=base64|text]",
+        gettext_noop("Add requestor's MAC address to forwarded DNS queries."),
+        NULL}, {
+  LOPT_ADD_SBNET, ARG_ONE, "<v4 pref>[,<v6 pref>]",
+        gettext_noop("Add specified IP subnet to forwarded DNS queries."),
+        NULL}, {
+  LOPT_CPE_ID, ARG_ONE, "<text>",
+        gettext_noop("Add client identification to forwarded DNS queries."),
+        NULL}, {
+  LOPT_DNSSEC, OPT_DNSSEC_PROXY, NULL,
+        gettext_noop
+        ("Proxy DNSSEC validation results from upstream nameservers."), NULL}, {
+  LOPT_INCR_ADDR, OPT_CONSEC_ADDR, NULL,
+        gettext_noop
+        ("Attempt to allocate sequential IP addresses to DHCP clients."), NULL},
+  {
+  LOPT_CONNTRACK, OPT_CONNTRACK, NULL,
+        gettext_noop
+        ("Copy connection-track mark from queries to upstream connections."),
+        NULL}, {
+  LOPT_FQDN, OPT_FQDN_UPDATE, NULL,
+        gettext_noop("Allow DHCP clients to do their own DDNS updates."), NULL},
+  {
+  LOPT_RA, OPT_RA, NULL,
+        gettext_noop
+        ("Send router-advertisements for interfaces doing DHCPv6"), NULL}, {
+  LOPT_DUID, ARG_ONE, "<enterprise>,<duid>",
+        gettext_noop("Specify DUID_EN-type DHCPv6 server DUID"), NULL}, {
+  LOPT_HOST_REC, ARG_DUP, "<name>,<address>[,<ttl>]",
+        gettext_noop("Specify host (A/AAAA and PTR) records"), NULL}, {
+  LOPT_RR, ARG_DUP, "<name>,<RR-number>,[<data>]",
+        gettext_noop("Specify arbitrary DNS resource record"), NULL}, {
+  LOPT_CLVERBIND, OPT_CLEVERBIND, NULL,
+        gettext_noop("Bind to interfaces in use - check for new interfaces"),
+        NULL}, {
+  LOPT_AUTHSERV, ARG_ONE, "<NS>,<interface>",
+        gettext_noop("Export local names to global DNS"), NULL}, {
+  LOPT_AUTHZONE, ARG_DUP, "<domain>,[<subnet>...]",
+        gettext_noop("Domain to export to global DNS"), NULL}, {
+  LOPT_AUTHTTL, ARG_ONE, "<integer>",
+        gettext_noop("Set TTL for authoritative replies"), NULL}, {
+  LOPT_AUTHSOA, ARG_ONE, "<serial>[,...]",
+        gettext_noop("Set authoritative zone information"), NULL}, {
+  LOPT_AUTHSFS, ARG_DUP, "<NS>[,<NS>...]",
+        gettext_noop
+        ("Secondary authoritative nameservers for forward domains"), NULL}, {
+  LOPT_AUTHPEER, ARG_DUP, "<ipaddr>[,<ipaddr>...]",
+        gettext_noop("Peers which are allowed to do zone transfer"), NULL}, {
+  LOPT_IPSET, ARG_DUP, "/<domain>[/<domain>...]/<ipset>...",
+        gettext_noop
+        ("Specify ipsets to which matching domains should be added"), NULL}, {
+  LOPT_SYNTH, ARG_DUP, "<domain>,<range>,[<prefix>]",
+        gettext_noop
+        ("Specify a domain and address range for synthesised names"), NULL}, {
+  LOPT_SEC_VALID, OPT_DNSSEC_VALID, NULL,
+        gettext_noop("Activate DNSSEC validation"), NULL}, {
+  LOPT_TRUST_ANCHOR, ARG_DUP, "<domain>,[<class>],...",
+        gettext_noop("Specify trust anchor key digest."), NULL}, {
+  LOPT_DNSSEC_DEBUG, OPT_DNSSEC_DEBUG, NULL,
+        gettext_noop("Disable upstream checking for DNSSEC debugging."), NULL},
+  {
+  LOPT_DNSSEC_CHECK, OPT_DNSSEC_NO_SIGN, NULL,
+        gettext_noop("Ensure answers without DNSSEC are in unsigned zones."),
+        NULL}, {
+  LOPT_DNSSEC_TIME, OPT_DNSSEC_TIME, NULL,
+        gettext_noop
+        ("Don't check DNSSEC signature timestamps until first cache-reload"),
+        NULL}, {
+  LOPT_DNSSEC_STAMP, ARG_ONE, "<path>",
+        gettext_noop("Timestamp file to verify system clock for DNSSEC"), NULL},
+#ifdef OPTION6_PREFIX_CLASS
+  {
+  LOPT_PREF_CLSS, ARG_DUP, "set:tag,<class>",
+        gettext_noop("Specify DHCPv6 prefix class"), NULL},
+#endif
+  {
+  LOPT_RA_PARAM, ARG_DUP,
+        "<iface>,[mtu:<value>|<interface>|off,][<prio>,]<intval>[,<lifetime>]",
+        gettext_noop
+        ("Set MTU, priority, resend-interval and router-lifetime"), NULL}, {
+  LOPT_QUIET_DHCP, OPT_QUIET_DHCP, NULL,
+        gettext_noop("Do not log routine DHCP."), NULL}, {
+  LOPT_QUIET_DHCP6, OPT_QUIET_DHCP6, NULL,
+        gettext_noop("Do not log routine DHCPv6."), NULL}, {
+  LOPT_QUIET_RA, OPT_QUIET_RA, NULL, gettext_noop("Do not log RA."), NULL}, {
+  LOPT_LOCAL_SERVICE, OPT_LOCAL_SERVICE, NULL,
+        gettext_noop("Accept queries only from directly-connected networks."),
+        NULL}, {
+  LOPT_LOOP_DETECT, OPT_LOOP_DETECT, NULL,
+        gettext_noop("Detect and remove DNS forwarding loops."), NULL}, {
+  LOPT_IGNORE_ADDR, ARG_DUP, "<ipaddr>",
+        gettext_noop("Ignore DNS responses containing ipaddr."), NULL}, {
+  LOPT_DHCPTTL, ARG_ONE, "<ttl>",
+        gettext_noop("Set TTL in DNS responses with DHCP-derived addresses."),
+        NULL}, {
+  LOPT_REPLY_DELAY, ARG_ONE, "<integer>",
+        gettext_noop("Delay DHCP replies for at least number of seconds."),
+        NULL}, {
+  0, 0, NULL, NULL, NULL}
+};
 
 /* We hide metacharacters in quoted strings by mapping them into the ASCII control
    character space. Note that the \0, \t \b \r \033 and \n characters are carefully placed in the
@@ -521,25 +774,25 @@
 
   for (i = 0; i < (sizeof(meta) - 1); i++)
     if (c == meta[i])
-      return (char)i;
-  
+      return (char) i;
+
   return c;
 }
 
 static char unhide_meta(char cr)
-{ 
+{
   unsigned int c = cr;
-  
+
   if (c < (sizeof(meta) - 1))
     cr = meta[c];
-  
+
   return cr;
 }
 
 static void unhide_metas(char *cp)
 {
   if (cp)
-    for(; *cp; cp++)
+    for (; *cp; cp++)
       *cp = unhide_meta(*cp);
 }
 
@@ -547,31 +800,28 @@
 {
   void *ret;
 
-  if (mem_recover)
-    {
-      ret = whine_malloc(size);
-      if (!ret)
-	longjmp(mem_jmp, 1);
-    }
-  else
+  if (mem_recover) {
+    ret = whine_malloc(size);
+    if (!ret)
+      longjmp(mem_jmp, 1);
+  } else
     ret = safe_malloc(size);
-  
+
   return ret;
 }
 
 static char *opt_string_alloc(char *cp)
 {
   char *ret = NULL;
-  
-  if (cp && strlen(cp) != 0)
-    {
-      ret = opt_malloc(strlen(cp)+1);
-      strcpy(ret, cp); 
-      
-      /* restore hidden metachars */
-      unhide_metas(ret);
-    }
-    
+
+  if (cp && strlen(cp) != 0) {
+    ret = opt_malloc(strlen(cp) + 1);
+    strcpy(ret, cp);
+
+    /* restore hidden metachars */
+    unhide_metas(ret);
+  }
+
   return ret;
 }
 
@@ -585,15 +835,15 @@
 
   if (!s || !(comma = strchr(s, c)))
     return NULL;
-  
+
   p = comma;
   *comma = ' ';
-  
+
   for (; *comma == ' '; comma++);
- 
+
   for (; (p >= s) && *p == ' '; p--)
     *p = 0;
-    
+
   return comma;
 }
 
@@ -611,13 +861,12 @@
     return 0;
 
   unhide_metas(s);
-  if (!(ret = canonicalise(s, &nomem)) && nomem)
-    {
-      if (mem_recover)
-	longjmp(mem_jmp, 1);
-      else
-	die(_("could not get memory"), NULL, EC_NOMEM);
-    }
+  if (!(ret = canonicalise(s, &nomem)) && nomem) {
+    if (mem_recover)
+      longjmp(mem_jmp, 1);
+    else
+      die(_("could not get memory"), NULL, EC_NOMEM);
+  }
 
   return ret;
 }
@@ -630,10 +879,10 @@
     return 0;
 
   unhide_metas(a);
-  
+
   for (p = a; *p; p++)
-     if (*p < '0' || *p > '9')
-       return 0;
+    if (*p < '0' || *p > '9')
+      return 0;
 
   *res = atoi(a);
   return 1;
@@ -641,9 +890,7 @@
 
 static int atoi_check16(char *a, int *res)
 {
-  if (!(atoi_check(a, res)) ||
-      *res < 0 ||
-      *res > 0xffff)
+  if (!(atoi_check(a, res)) || *res < 0 || *res > 0xffff)
     return 0;
 
   return 1;
@@ -652,9 +899,7 @@
 #ifdef HAVE_DNSSEC
 static int atoi_check8(char *a, int *res)
 {
-  if (!(atoi_check(a, res)) ||
-      *res < 0 ||
-      *res > 0xff)
+  if (!(atoi_check(a, res)) || *res < 0 || *res > 0xff)
     return 0;
 
   return 1;
@@ -666,14 +911,13 @@
 {
   struct txt_record *r = opt_malloc(sizeof(struct txt_record));
 
-  if (txt)
-    {
-      size_t len = strlen(txt);
-      r->txt = opt_malloc(len+1);
-      r->len = len+1;
-      *(r->txt) = len;
-      memcpy((r->txt)+1, txt, len);
-    }
+  if (txt) {
+    size_t len = strlen(txt);
+    r->txt = opt_malloc(len + 1);
+    r->len = len + 1;
+    *(r->txt) = len;
+    memcpy((r->txt) + 1, txt, len);
+  }
 
   r->stat = stat;
   r->name = opt_string_alloc(name);
@@ -692,12 +936,13 @@
     char handle;
     int val;
   } tab[] = {
-    { '$', CACHESIZ },
-    { '*', EDNS_PKTSZ },
-    { '&', MAXLEASES },
-    { '!', FTABSIZ },
-    { '#', TFTP_MAX_CONNECTIONS },
-    { '\0', 0 }
+    {
+    '$', CACHESIZ}, {
+    '*', EDNS_PKTSZ}, {
+    '&', MAXLEASES}, {
+    '!', FTABSIZ}, {
+    '#', TFTP_MAX_CONNECTIONS}, {
+    '\0', 0}
   };
 
   printf(_("Usage: dnsmasq [options]\n\n"));
@@ -705,44 +950,42 @@
   printf(_("Use short options only on the command line.\n"));
 #endif
   printf(_("Valid options are:\n"));
-  
-  for (i = 0; usage[i].opt != 0; i++)
-    {
-      char *desc = usage[i].flagdesc; 
-      char *eq = "=";
-      
-      if (!desc || *desc == '[')
-	eq = "";
-      
-      if (!desc)
-	desc = "";
-
-      for ( j = 0; opts[j].name; j++)
-	if (opts[j].val == usage[i].opt)
-	  break;
-      if (usage[i].opt < 256)
-	sprintf(buff, "-%c, ", usage[i].opt);
-      else
-	sprintf(buff, "    ");
-      
-      sprintf(buff+4, "--%s%s%s", opts[j].name, eq, desc);
-      printf("%-55.55s", buff);
-	     
-      if (usage[i].arg)
-	{
-	  strcpy(buff, usage[i].arg);
-	  for (j = 0; tab[j].handle; j++)
-	    if (tab[j].handle == *(usage[i].arg))
-	      sprintf(buff, "%d", tab[j].val);
-	}
-      printf(_(usage[i].desc), buff);
-      printf("\n");
+
+  for (i = 0; usage[i].opt != 0; i++) {
+    char *desc = usage[i].flagdesc;
+    char *eq = "=";
+
+    if (!desc || *desc == '[')
+      eq = "";
+
+    if (!desc)
+      desc = "";
+
+    for (j = 0; opts[j].name; j++)
+      if (opts[j].val == usage[i].opt)
+        break;
+    if (usage[i].opt < 256)
+      sprintf(buff, "-%c, ", usage[i].opt);
+    else
+      sprintf(buff, "    ");
+
+    sprintf(buff + 4, "--%s%s%s", opts[j].name, eq, desc);
+    printf("%-55.55s", buff);
+
+    if (usage[i].arg) {
+      strcpy(buff, usage[i].arg);
+      for (j = 0; tab[j].handle; j++)
+        if (tab[j].handle == *(usage[i].arg))
+          sprintf(buff, "%d", tab[j].val);
     }
+    printf(_(usage[i].desc), buff);
+    printf("\n");
+  }
 }
 
 #define ret_err(x) do { strcpy(errstr, (x)); return 0; } while (0)
 
-static char *parse_mysockaddr(char *arg, union mysockaddr *addr) 
+static char *parse_mysockaddr(char *arg, union mysockaddr *addr)
 {
   if (inet_pton(AF_INET, arg, &addr->in.sin_addr) > 0)
     addr->sa.sa_family = AF_INET;
@@ -752,11 +995,12 @@
 #endif
   else
     return _("bad address");
-   
+
   return NULL;
 }
 
-char *parse_server(char *arg, union mysockaddr *addr, union mysockaddr *source_addr, char *interface, int *flags)
+char *parse_server(char *arg, union mysockaddr *addr,
+                   union mysockaddr *source_addr, char *interface, int *flags)
 {
   int source_port = 0, serv_port = NAMESERVER_PORT;
   char *portno, *source;
@@ -765,104 +1009,95 @@
   int scope_index = 0;
   char *scope_id;
 #endif
-  
-  if (!arg || strlen(arg) == 0)
-    {
-      *flags |= SERV_NO_ADDR;
-      *interface = 0;
-      return NULL;
-    }
+
+  if (!arg || strlen(arg) == 0) {
+    *flags |= SERV_NO_ADDR;
+    *interface = 0;
+    return NULL;
+  }
 
   if ((source = split_chr(arg, '@')) && /* is there a source. */
-      (portno = split_chr(source, '#')) &&
-      !atoi_check16(portno, &source_port))
+      (portno = split_chr(source, '#')) && !atoi_check16(portno, &source_port))
     return _("bad port");
-  
+
   if ((portno = split_chr(arg, '#')) && /* is there a port no. */
       !atoi_check16(portno, &serv_port))
     return _("bad port");
-  
+
 #ifdef HAVE_IPV6
   scope_id = split_chr(arg, '%');
 #endif
-  
+
   if (source) {
     interface_opt = split_chr(source, '@');
 
-    if (interface_opt)
-      {
+    if (interface_opt) {
 #if defined(SO_BINDTODEVICE)
-	strncpy(interface, interface_opt, IF_NAMESIZE - 1);
+      strncpy(interface, interface_opt, IF_NAMESIZE - 1);
 #else
-	return _("interface binding not supported");
+      return _("interface binding not supported");
 #endif
-      }
+    }
   }
 
-  if (inet_pton(AF_INET, arg, &addr->in.sin_addr) > 0)
-    {
-      addr->in.sin_port = htons(serv_port);	
-      addr->sa.sa_family = source_addr->sa.sa_family = AF_INET;
+  if (inet_pton(AF_INET, arg, &addr->in.sin_addr) > 0) {
+    addr->in.sin_port = htons(serv_port);
+    addr->sa.sa_family = source_addr->sa.sa_family = AF_INET;
 #ifdef HAVE_SOCKADDR_SA_LEN
-      source_addr->in.sin_len = addr->in.sin_len = sizeof(struct sockaddr_in);
+    source_addr->in.sin_len = addr->in.sin_len = sizeof(struct sockaddr_in);
 #endif
-      source_addr->in.sin_addr.s_addr = INADDR_ANY;
-      source_addr->in.sin_port = htons(daemon->query_port);
-      
-      if (source)
-	{
-	  if (flags)
-	    *flags |= SERV_HAS_SOURCE;
-	  source_addr->in.sin_port = htons(source_port);
-	  if (!(inet_pton(AF_INET, source, &source_addr->in.sin_addr) > 0))
-	    {
+    source_addr->in.sin_addr.s_addr = INADDR_ANY;
+    source_addr->in.sin_port = htons(daemon->query_port);
+
+    if (source) {
+      if (flags)
+        *flags |= SERV_HAS_SOURCE;
+      source_addr->in.sin_port = htons(source_port);
+      if (!(inet_pton(AF_INET, source, &source_addr->in.sin_addr) > 0)) {
 #if defined(SO_BINDTODEVICE)
-	      if (interface_opt)
-		return _("interface can only be specified once");
-	      
-	      source_addr->in.sin_addr.s_addr = INADDR_ANY;
-	      strncpy(interface, source, IF_NAMESIZE - 1);
+        if (interface_opt)
+          return _("interface can only be specified once");
+
+        source_addr->in.sin_addr.s_addr = INADDR_ANY;
+        strncpy(interface, source, IF_NAMESIZE - 1);
 #else
-	      return _("interface binding not supported");
+        return _("interface binding not supported");
 #endif
-	    }
-	}
+      }
     }
+  }
 #ifdef HAVE_IPV6
-  else if (inet_pton(AF_INET6, arg, &addr->in6.sin6_addr) > 0)
-    {
-      if (scope_id && (scope_index = if_nametoindex(scope_id)) == 0)
-	return _("bad interface name");
-      
-      addr->in6.sin6_port = htons(serv_port);
-      addr->in6.sin6_scope_id = scope_index;
-      source_addr->in6.sin6_addr = in6addr_any; 
-      source_addr->in6.sin6_port = htons(daemon->query_port);
-      source_addr->in6.sin6_scope_id = 0;
-      addr->sa.sa_family = source_addr->sa.sa_family = AF_INET6;
-      addr->in6.sin6_flowinfo = source_addr->in6.sin6_flowinfo = 0;
+  else if (inet_pton(AF_INET6, arg, &addr->in6.sin6_addr) > 0) {
+    if (scope_id && (scope_index = if_nametoindex(scope_id)) == 0)
+      return _("bad interface name");
+
+    addr->in6.sin6_port = htons(serv_port);
+    addr->in6.sin6_scope_id = scope_index;
+    source_addr->in6.sin6_addr = in6addr_any;
+    source_addr->in6.sin6_port = htons(daemon->query_port);
+    source_addr->in6.sin6_scope_id = 0;
+    addr->sa.sa_family = source_addr->sa.sa_family = AF_INET6;
+    addr->in6.sin6_flowinfo = source_addr->in6.sin6_flowinfo = 0;
 #ifdef HAVE_SOCKADDR_SA_LEN
-      addr->in6.sin6_len = source_addr->in6.sin6_len = sizeof(addr->in6);
+    addr->in6.sin6_len = source_addr->in6.sin6_len = sizeof(addr->in6);
 #endif
-      if (source)
-	{
-	  if (flags)
-	    *flags |= SERV_HAS_SOURCE;
-	  source_addr->in6.sin6_port = htons(source_port);
-	  if (inet_pton(AF_INET6, source, &source_addr->in6.sin6_addr) == 0)
-	    {
+    if (source) {
+      if (flags)
+        *flags |= SERV_HAS_SOURCE;
+      source_addr->in6.sin6_port = htons(source_port);
+      if (inet_pton(AF_INET6, source, &source_addr->in6.sin6_addr) == 0) {
 #if defined(SO_BINDTODEVICE)
-	      if (interface_opt)
-		return _("interface can only be specified once");
-	      
-	      source_addr->in6.sin6_addr = in6addr_any;
-	      strncpy(interface, source, IF_NAMESIZE - 1);
+        if (interface_opt)
+          return _("interface can only be specified once");
+
+        source_addr->in6.sin6_addr = in6addr_any;
+        strncpy(interface, source, IF_NAMESIZE - 1);
 #else
-	      return _("interface binding not supported");
+        return _("interface binding not supported");
 #endif
-	    }
-	}
+      }
     }
+  }
 #endif
   else
     return _("bad address");
@@ -873,32 +1108,31 @@
 static struct server *add_rev4(struct in_addr addr, int msize)
 {
   struct server *serv = opt_malloc(sizeof(struct server));
-  in_addr_t  a = ntohl(addr.s_addr);
+  in_addr_t a = ntohl(addr.s_addr);
   char *p;
 
   memset(serv, 0, sizeof(struct server));
-  p = serv->domain = opt_malloc(29); /* strlen("xxx.yyy.zzz.ttt.in-addr.arpa")+1 */
+  p = serv->domain = opt_malloc(29);    /* strlen("xxx.yyy.zzz.ttt.in-addr.arpa")+1 */
 
-  switch (msize)
-    {
-    case 32:
-      p += sprintf(p, "%u.", a & 0xff);
-      /* fall through */
-    case 24:
-      p += sprintf(p, "%d.", (a >> 8) & 0xff);
-      /* fall through */
-    case 16:
-      p += sprintf(p, "%d.", (a >> 16) & 0xff);
-      /* fall through */
-    case 8:
-      p += sprintf(p, "%d.", (a >> 24) & 0xff);
-      break;
-    default:
-      return NULL;
-    }
+  switch (msize) {
+  case 32:
+    p += sprintf(p, "%u.", a & 0xff);
+    /* fall through */
+  case 24:
+    p += sprintf(p, "%d.", (a >> 8) & 0xff);
+    /* fall through */
+  case 16:
+    p += sprintf(p, "%d.", (a >> 16) & 0xff);
+    /* fall through */
+  case 8:
+    p += sprintf(p, "%d.", (a >> 24) & 0xff);
+    break;
+  default:
+    return NULL;
+  }
 
   p += sprintf(p, "in-addr.arpa");
-  
+
   serv->flags = SERV_HAS_DOMAIN;
   serv->next = daemon->servers;
   daemon->servers = serv;
@@ -912,21 +1146,20 @@
   struct server *serv = opt_malloc(sizeof(struct server));
   char *p;
   int i;
-				  
+
   memset(serv, 0, sizeof(struct server));
-  p = serv->domain = opt_malloc(73); /* strlen("32*<n.>ip6.arpa")+1 */
-  
-  for (i = msize-1; i >= 0; i -= 4)
-    { 
-      int dig = ((unsigned char *)addr)[i>>3];
-      p += sprintf(p, "%.1x.", (i>>2) & 1 ? dig & 15 : dig >> 4);
-    }
+  p = serv->domain = opt_malloc(73);    /* strlen("32*<n.>ip6.arpa")+1 */
+
+  for (i = msize - 1; i >= 0; i -= 4) {
+    int dig = ((unsigned char *) addr)[i >> 3];
+    p += sprintf(p, "%.1x.", (i >> 2) & 1 ? dig & 15 : dig >> 4);
+  }
   p += sprintf(p, "ip6.arpa");
-  
+
   serv->flags = SERV_HAS_DOMAIN;
   serv->next = daemon->servers;
   daemon->servers = serv;
-  
+
   return serv;
 }
 
@@ -936,16 +1169,16 @@
 {
   if (arg && (strstr(arg, "net:") == arg || strstr(arg, "tag:") == arg))
     return 1;
-  
+
   return 0;
 }
 
 static char *set_prefix(char *arg)
 {
-   if (strstr(arg, "set:") == arg)
-     return arg+4;
-   
-   return arg;
+  if (strstr(arg, "set:") == arg)
+    return arg + 4;
+
+  return arg;
 }
 
 /* This is too insanely large to keep in-line in the switch */
@@ -965,514 +1198,439 @@
   new->netid = NULL;
   new->val = NULL;
   new->opt = 0;
-  
-  while (arg)
-    {
-      comma = split(arg);      
 
-      for (cp = arg; *cp; cp++)
-	if (*cp < '0' || *cp > '9')
-	  break;
-      
-      if (!*cp)
-	{
-	  new->opt = atoi(arg);
-	  opt_len = 0;
-	  option_ok = 1;
-	  break;
-	}
-      
-      if (strstr(arg, "option:") == arg)
-	{
-	  if ((new->opt = lookup_dhcp_opt(AF_INET, arg+7)) != -1)
-	    {
-	      opt_len = lookup_dhcp_len(AF_INET, new->opt);
-	      /* option:<optname> must follow tag and vendor string. */
-	      if (!(opt_len & OT_INTERNAL) || flags == DHOPT_MATCH)
-		option_ok = 1;
-	    }
-	  break;
-	}
-#ifdef HAVE_DHCP6
-      else if (strstr(arg, "option6:") == arg)
-	{
-	  for (cp = arg+8; *cp; cp++)
-	    if (*cp < '0' || *cp > '9')
-	      break;
-	 
-	  if (!*cp)
-	    {
-	      new->opt = atoi(arg+8);
-	      opt_len = 0;
-	      option_ok = 1;
-	    }
-	  else
-	    {
-	      if ((new->opt = lookup_dhcp_opt(AF_INET6, arg+8)) != -1)
-		{
-		  opt_len = lookup_dhcp_len(AF_INET6, new->opt);
-		  if (!(opt_len & OT_INTERNAL) || flags == DHOPT_MATCH)
-		    option_ok = 1;
-		}
-	    }
-	  /* option6:<opt>|<optname> must follow tag and vendor string. */
-	  is6 = 1;
-	  break;
-	}
-#endif
-      else if (strstr(arg, "vendor:") == arg)
-	{
-	  new->u.vendor_class = (unsigned char *)opt_string_alloc(arg+7);
-	  new->flags |= DHOPT_VENDOR;
-	}
-      else if (strstr(arg, "encap:") == arg)
-	{
-	  new->u.encap = atoi(arg+6);
-	  new->flags |= DHOPT_ENCAPSULATE;
-	}
-      else if (strstr(arg, "vi-encap:") == arg)
-	{
-	  new->u.encap = atoi(arg+9);
-	  new->flags |= DHOPT_RFC3925;
-	  if (flags == DHOPT_MATCH)
-	    {
-	      option_ok = 1;
-	      break;
-	    }
-	}
-      else
-	{
-	  new->netid = opt_malloc(sizeof (struct dhcp_netid));
-	  /* allow optional "net:" or "tag:" for consistency */
-	  if (is_tag_prefix(arg))
-	    new->netid->net = opt_string_alloc(arg+4);
-	  else
-	    new->netid->net = opt_string_alloc(set_prefix(arg));
-	  new->netid->next = np;
-	  np = new->netid;
-	}
-      
-      arg = comma; 
+  while (arg) {
+    comma = split(arg);
+
+    for (cp = arg; *cp; cp++)
+      if (*cp < '0' || *cp > '9')
+        break;
+
+    if (!*cp) {
+      new->opt = atoi(arg);
+      opt_len = 0;
+      option_ok = 1;
+      break;
     }
 
+    if (strstr(arg, "option:") == arg) {
+      if ((new->opt = lookup_dhcp_opt(AF_INET, arg + 7)) != -1) {
+        opt_len = lookup_dhcp_len(AF_INET, new->opt);
+        /* option:<optname> must follow tag and vendor string. */
+        if (!(opt_len & OT_INTERNAL) || flags == DHOPT_MATCH)
+          option_ok = 1;
+      }
+      break;
+    }
 #ifdef HAVE_DHCP6
-  if (is6)
-    {
-      if (new->flags & (DHOPT_VENDOR | DHOPT_ENCAPSULATE))
-	ret_err(_("unsupported encapsulation for IPv6 option"));
-      
-      if (opt_len == 0 &&
-	  !(new->flags & DHOPT_RFC3925))
-	opt_len = lookup_dhcp_len(AF_INET6, new->opt);
+    else if (strstr(arg, "option6:") == arg) {
+      for (cp = arg + 8; *cp; cp++)
+        if (*cp < '0' || *cp > '9')
+          break;
+
+      if (!*cp) {
+        new->opt = atoi(arg + 8);
+        opt_len = 0;
+        option_ok = 1;
+      } else {
+        if ((new->opt = lookup_dhcp_opt(AF_INET6, arg + 8)) != -1) {
+          opt_len = lookup_dhcp_len(AF_INET6, new->opt);
+          if (!(opt_len & OT_INTERNAL) || flags == DHOPT_MATCH)
+            option_ok = 1;
+        }
+      }
+      /* option6:<opt>|<optname> must follow tag and vendor string. */
+      is6 = 1;
+      break;
     }
-  else
 #endif
-    if (opt_len == 0 &&
-	!(new->flags & (DHOPT_VENDOR | DHOPT_ENCAPSULATE | DHOPT_RFC3925)))
-      opt_len = lookup_dhcp_len(AF_INET, new->opt);
-  
+    else if (strstr(arg, "vendor:") == arg) {
+      new->u.vendor_class = (unsigned char *) opt_string_alloc(arg + 7);
+      new->flags |= DHOPT_VENDOR;
+    } else if (strstr(arg, "encap:") == arg) {
+      new->u.encap = atoi(arg + 6);
+      new->flags |= DHOPT_ENCAPSULATE;
+    } else if (strstr(arg, "vi-encap:") == arg) {
+      new->u.encap = atoi(arg + 9);
+      new->flags |= DHOPT_RFC3925;
+      if (flags == DHOPT_MATCH) {
+        option_ok = 1;
+        break;
+      }
+    } else {
+      new->netid = opt_malloc(sizeof(struct dhcp_netid));
+      /* allow optional "net:" or "tag:" for consistency */
+      if (is_tag_prefix(arg))
+        new->netid->net = opt_string_alloc(arg + 4);
+      else
+        new->netid->net = opt_string_alloc(set_prefix(arg));
+      new->netid->next = np;
+      np = new->netid;
+    }
+
+    arg = comma;
+  }
+
+#ifdef HAVE_DHCP6
+  if (is6) {
+    if (new->flags & (DHOPT_VENDOR | DHOPT_ENCAPSULATE))
+      ret_err(_("unsupported encapsulation for IPv6 option"));
+
+    if (opt_len == 0 && !(new->flags & DHOPT_RFC3925))
+      opt_len = lookup_dhcp_len(AF_INET6, new->opt);
+  } else
+#endif
+  if (opt_len == 0 &&
+        !(new->flags & (DHOPT_VENDOR | DHOPT_ENCAPSULATE | DHOPT_RFC3925)))
+    opt_len = lookup_dhcp_len(AF_INET, new->opt);
+
   /* option may be missing with rfc3925 match */
   if (!option_ok)
     ret_err(_("bad dhcp-option"));
-  
-  if (comma)
-    {
-      /* characterise the value */
-      char c;
-      int found_dig = 0;
-      is_addr = is_addr6 = is_hex = is_dec = is_string = 1;
-      addrs = digs = 1;
-      dots = 0;
-      for (cp = comma; (c = *cp); cp++)
-	if (c == ',')
-	  {
-	    addrs++;
-	    is_dec = is_hex = 0;
-	  }
-	else if (c == ':')
-	  {
-	    digs++;
-	    is_dec = is_addr = 0;
-	  }
-	else if (c == '/') 
-	  {
-	    is_addr6 = is_dec = is_hex = 0;
-	    if (cp == comma) /* leading / means a pathname */
-	      is_addr = 0;
-	  } 
-	else if (c == '.')	
-	  {
-	    is_addr6 = is_dec = is_hex = 0;
-	    dots++;
-	  }
-	else if (c == '-')
-	  is_hex = is_addr = is_addr6 = 0;
-	else if (c == ' ')
-	  is_dec = is_hex = 0;
-	else if (!(c >='0' && c <= '9'))
-	  {
-	    is_addr = 0;
-	    if (cp[1] == 0 && is_dec &&
-		(c == 'b' || c == 's' || c == 'i'))
-	      {
-		lenchar = c;
-		*cp = 0;
-	      }
-	    else
-	      is_dec = 0;
-	    if (!((c >='A' && c <= 'F') ||
-		  (c >='a' && c <= 'f') || 
-		  (c == '*' && (flags & DHOPT_MATCH))))
-	      {
-		is_hex = 0;
-		if (c != '[' && c != ']')
-		  is_addr6 = 0;
-	      }
-	  }
-	else
-	  found_dig = 1;
-     
-      if (!found_dig)
-	is_dec = is_addr = 0;
-     
-      /* We know that some options take addresses */
-      if (opt_len & OT_ADDR_LIST)
-	{
-	  is_string = is_dec = is_hex = 0;
-	  
-	  if (!is6 && (!is_addr || dots == 0))
-	    ret_err(_("bad IP address"));
-
-	   if (is6 && !is_addr6)
-	     ret_err(_("bad IPv6 address"));
-	}
-      /* or names */
-      else if (opt_len & (OT_NAME | OT_RFC1035_NAME | OT_CSTRING))
-	is_addr6 = is_addr = is_dec = is_hex = 0;
-      
-      if (found_dig && (opt_len & OT_TIME) && strlen(comma) > 0)
-	{
-	  int val, fac = 1;
-
-	  switch (comma[strlen(comma) - 1])
-	    {
-	    case 'w':
-	    case 'W':
-	      fac *= 7;
-	      /* fall through */
-	    case 'd':
-	    case 'D':
-	      fac *= 24;
-	      /* fall though */
-	    case 'h':
-	    case 'H':
-	      fac *= 60;
-	      /* fall through */
-	    case 'm':
-	    case 'M':
-	      fac *= 60;
-	      /* fall through */
-	    case 's':
-	    case 'S':
-	      comma[strlen(comma) - 1] = 0;
-	    }
-	  
-	  new->len = 4;
-	  new->val = opt_malloc(4);
-	  val = atoi(comma);
-	  *((int *)new->val) = htonl(val * fac);	  
-	}  
-      else if (is_hex && digs > 1)
-	{
-	  new->len = digs;
-	  new->val = opt_malloc(new->len);
-	  parse_hex(comma, new->val, digs, (flags & DHOPT_MATCH) ? &new->u.wildcard_mask : NULL, NULL);
-	  new->flags |= DHOPT_HEX;
-	}
-      else if (is_dec)
-	{
-	  int i, val = atoi(comma);
-	  /* assume numeric arg is 1 byte except for
-	     options where it is known otherwise.
-	     For vendor class option, we have to hack. */
-	  if (opt_len != 0)
-	    new->len = opt_len;
-	  else if (val & 0xffff0000)
-	    new->len = 4;
-	  else if (val & 0xff00)
-	    new->len = 2;
-	  else
-	    new->len = 1;
-
-	  if (lenchar == 'b')
-	    new->len = 1;
-	  else if (lenchar == 's')
-	    new->len = 2;
-	  else if (lenchar == 'i')
-	    new->len = 4;
-	  
-	  new->val = opt_malloc(new->len);
-	  for (i=0; i<new->len; i++)
-	    new->val[i] = val>>((new->len - i - 1)*8);
-	}
-      else if (is_addr && !is6)	
-	{
-	  struct in_addr in;
-	  unsigned char *op;
-	  char *slash;
-	  /* max length of address/subnet descriptor is five bytes,
-	     add one for the option 120 enc byte too */
-	  new->val = op = opt_malloc((5 * addrs) + 1);
-	  new->flags |= DHOPT_ADDR;
-
-	  if (!(new->flags & (DHOPT_ENCAPSULATE | DHOPT_VENDOR | DHOPT_RFC3925)) && 
-	      new->opt == OPTION_SIP_SERVER)
-	    {
-	      *(op++) = 1; /* RFC 3361 "enc byte" */
-	      new->flags &= ~DHOPT_ADDR;
-	    }
-	  while (addrs--) 
-	    {
-	      cp = comma;
-	      comma = split(cp);
-	      slash = split_chr(cp, '/');
-	      if (!inet_pton(AF_INET, cp, &in))
-		ret_err(_("bad IPv4 address"));
-	      if (!slash)
-		{
-		  memcpy(op, &in, INADDRSZ);
-		  op += INADDRSZ;
-		}
-	      else
-		{
-		  unsigned char *p = (unsigned char *)&in;
-		  int netsize = atoi(slash);
-		  *op++ = netsize;
-		  if (netsize > 0)
-		    *op++ = *p++;
-		  if (netsize > 8)
-		    *op++ = *p++;
-		  if (netsize > 16)
-		    *op++ = *p++;
-		  if (netsize > 24)
-		    *op++ = *p++;
-		  new->flags &= ~DHOPT_ADDR; /* cannot re-write descriptor format */
-		} 
-	    }
-	  new->len = op - new->val;
-	}
-      else if (is_addr6 && is6)
-	{
-	  unsigned char *op;
-	  new->val = op = opt_malloc(16 * addrs);
-	  new->flags |= DHOPT_ADDR6;
-	  while (addrs--) 
-	    {
-	      cp = comma;
-	      comma = split(cp);
-	      
-	      /* check for [1234::7] */
-	      if (*cp == '[')
-		cp++;
-	      if (strlen(cp) > 1 && cp[strlen(cp)-1] == ']')
-		cp[strlen(cp)-1] = 0;
-	      
-	      if (inet_pton(AF_INET6, cp, op))
-		{
-		  op += IN6ADDRSZ;
-		  continue;
-		}
-	  
-	      ret_err(_("bad IPv6 address"));
-	    } 
-	  new->len = op - new->val;
-	}
-      else if (is_string)
-	{
- 	  /* text arg */
-	  if ((new->opt == OPTION_DOMAIN_SEARCH || new->opt == OPTION_SIP_SERVER) &&
-	      !is6 && !(new->flags & (DHOPT_ENCAPSULATE | DHOPT_VENDOR | DHOPT_RFC3925)))
-	    {
-	      /* dns search, RFC 3397, or SIP, RFC 3361 */
-	      unsigned char *q, *r, *tail;
-	      unsigned char *p, *m = NULL, *newp;
-	      size_t newlen, len = 0;
-	      int header_size = (new->opt == OPTION_DOMAIN_SEARCH) ? 0 : 1;
-	      
-	      arg = comma;
-	      comma = split(arg);
-	      
-	      while (arg && *arg)
-		{
-		  char *in, *dom = NULL;
-		  size_t domlen = 1;
-		  /* Allow "." as an empty domain */
-		  if (strcmp (arg, ".") != 0)
-		    {
-		      if (!(dom = canonicalise_opt(arg)))
-			ret_err(_("bad domain in dhcp-option"));
-			
-		      domlen = strlen(dom) + 2;
-		    }
-		      
-		  newp = opt_malloc(len + domlen + header_size);
-		  if (m)
-		    {
-		      memcpy(newp, m, header_size + len);
-		      free(m);
-		    }
-		  m = newp;
-		  p = m + header_size;
-		  q = p + len;
-		  
-		  /* add string on the end in RFC1035 format */
-		  for (in = dom; in && *in;) 
-		    {
-		      unsigned char *cp = q++;
-		      int j;
-		      for (j = 0; *in && (*in != '.'); in++, j++)
-			*q++ = *in;
-		      *cp = j;
-		      if (*in)
-			in++;
-		    }
-		  *q++ = 0;
-		  free(dom);
-		  
-		  /* Now tail-compress using earlier names. */
-		  newlen = q - p;
-		  for (tail = p + len; *tail; tail += (*tail) + 1)
-		    for (r = p; r - p < (int)len; r += (*r) + 1)
-		      if (strcmp((char *)r, (char *)tail) == 0)
-			{
-			  PUTSHORT((r - p) | 0xc000, tail); 
-			  newlen = tail - p;
-			  goto end;
-			}
-		end:
-		  len = newlen;
-		  
-		  arg = comma;
-		  comma = split(arg);
-		}
-      
-	      /* RFC 3361, enc byte is zero for names */
-	      if (new->opt == OPTION_SIP_SERVER)
-		m[0] = 0;
-	      new->len = (int) len + header_size;
-	      new->val = m;
-	    }
+
+  if (comma) {
+    /* characterise the value */
+    char c;
+    int found_dig = 0;
+    is_addr = is_addr6 = is_hex = is_dec = is_string = 1;
+    addrs = digs = 1;
+    dots = 0;
+    for (cp = comma; (c = *cp); cp++)
+      if (c == ',') {
+        addrs++;
+        is_dec = is_hex = 0;
+      } else if (c == ':') {
+        digs++;
+        is_dec = is_addr = 0;
+      } else if (c == '/') {
+        is_addr6 = is_dec = is_hex = 0;
+        if (cp == comma)        /* leading / means a pathname */
+          is_addr = 0;
+      } else if (c == '.') {
+        is_addr6 = is_dec = is_hex = 0;
+        dots++;
+      } else if (c == '-')
+        is_hex = is_addr = is_addr6 = 0;
+      else if (c == ' ')
+        is_dec = is_hex = 0;
+      else if (!(c >= '0' && c <= '9')) {
+        is_addr = 0;
+        if (cp[1] == 0 && is_dec && (c == 'b' || c == 's' || c == 'i')) {
+          lenchar = c;
+          *cp = 0;
+        } else
+          is_dec = 0;
+        if (!((c >= 'A' && c <= 'F') ||
+              (c >= 'a' && c <= 'f') || (c == '*' && (flags & DHOPT_MATCH)))) {
+          is_hex = 0;
+          if (c != '[' && c != ']')
+            is_addr6 = 0;
+        }
+      } else
+        found_dig = 1;
+
+    if (!found_dig)
+      is_dec = is_addr = 0;
+
+    /* We know that some options take addresses */
+    if (opt_len & OT_ADDR_LIST) {
+      is_string = is_dec = is_hex = 0;
+
+      if (!is6 && (!is_addr || dots == 0))
+        ret_err(_("bad IP address"));
+
+      if (is6 && !is_addr6)
+        ret_err(_("bad IPv6 address"));
+    }
+    /* or names */
+    else if (opt_len & (OT_NAME | OT_RFC1035_NAME | OT_CSTRING))
+      is_addr6 = is_addr = is_dec = is_hex = 0;
+
+    if (found_dig && (opt_len & OT_TIME) && strlen(comma) > 0) {
+      int val, fac = 1;
+
+      switch (comma[strlen(comma) - 1]) {
+      case 'w':
+      case 'W':
+        fac *= 7;
+        /* fall through */
+      case 'd':
+      case 'D':
+        fac *= 24;
+        /* fall though */
+      case 'h':
+      case 'H':
+        fac *= 60;
+        /* fall through */
+      case 'm':
+      case 'M':
+        fac *= 60;
+        /* fall through */
+      case 's':
+      case 'S':
+        comma[strlen(comma) - 1] = 0;
+      }
+
+      new->len = 4;
+      new->val = opt_malloc(4);
+      val = atoi(comma);
+      *((int *) new->val) = htonl(val * fac);
+    } else if (is_hex && digs > 1) {
+      new->len = digs;
+      new->val = opt_malloc(new->len);
+      parse_hex(comma, new->val, digs,
+                (flags & DHOPT_MATCH) ? &new->u.wildcard_mask : NULL, NULL);
+      new->flags |= DHOPT_HEX;
+    } else if (is_dec) {
+      int i, val = atoi(comma);
+      /* assume numeric arg is 1 byte except for
+         options where it is known otherwise.
+         For vendor class option, we have to hack. */
+      if (opt_len != 0)
+        new->len = opt_len;
+      else if (val & 0xffff0000)
+        new->len = 4;
+      else if (val & 0xff00)
+        new->len = 2;
+      else
+        new->len = 1;
+
+      if (lenchar == 'b')
+        new->len = 1;
+      else if (lenchar == 's')
+        new->len = 2;
+      else if (lenchar == 'i')
+        new->len = 4;
+
+      new->val = opt_malloc(new->len);
+      for (i = 0; i < new->len; i++)
+        new->val[i] = val >> ((new->len - i - 1) * 8);
+    } else if (is_addr && !is6) {
+      struct in_addr in;
+      unsigned char *op;
+      char *slash;
+      /* max length of address/subnet descriptor is five bytes,
+         add one for the option 120 enc byte too */
+      new->val = op = opt_malloc((5 * addrs) + 1);
+      new->flags |= DHOPT_ADDR;
+
+      if (!(new->flags & (DHOPT_ENCAPSULATE | DHOPT_VENDOR | DHOPT_RFC3925)) &&
+          new->opt == OPTION_SIP_SERVER) {
+        *(op++) = 1;            /* RFC 3361 "enc byte" */
+        new->flags &= ~DHOPT_ADDR;
+      }
+      while (addrs--) {
+        cp = comma;
+        comma = split(cp);
+        slash = split_chr(cp, '/');
+        if (!inet_pton(AF_INET, cp, &in))
+          ret_err(_("bad IPv4 address"));
+        if (!slash) {
+          memcpy(op, &in, INADDRSZ);
+          op += INADDRSZ;
+        } else {
+          unsigned char *p = (unsigned char *) &in;
+          int netsize = atoi(slash);
+          *op++ = netsize;
+          if (netsize > 0)
+            *op++ = *p++;
+          if (netsize > 8)
+            *op++ = *p++;
+          if (netsize > 16)
+            *op++ = *p++;
+          if (netsize > 24)
+            *op++ = *p++;
+          new->flags &= ~DHOPT_ADDR;    /* cannot re-write descriptor format */
+        }
+      }
+      new->len = op - new->val;
+    } else if (is_addr6 && is6) {
+      unsigned char *op;
+      new->val = op = opt_malloc(16 * addrs);
+      new->flags |= DHOPT_ADDR6;
+      while (addrs--) {
+        cp = comma;
+        comma = split(cp);
+
+        /* check for [1234::7] */
+        if (*cp == '[')
+          cp++;
+        if (strlen(cp) > 1 && cp[strlen(cp) - 1] == ']')
+          cp[strlen(cp) - 1] = 0;
+
+        if (inet_pton(AF_INET6, cp, op)) {
+          op += IN6ADDRSZ;
+          continue;
+        }
+
+        ret_err(_("bad IPv6 address"));
+      }
+      new->len = op - new->val;
+    } else if (is_string) {
+      /* text arg */
+      if ((new->opt == OPTION_DOMAIN_SEARCH || new->opt == OPTION_SIP_SERVER) &&
+          !is6
+          && !(new->
+               flags & (DHOPT_ENCAPSULATE | DHOPT_VENDOR | DHOPT_RFC3925))) {
+        /* dns search, RFC 3397, or SIP, RFC 3361 */
+        unsigned char *q, *r, *tail;
+        unsigned char *p, *m = NULL, *newp;
+        size_t newlen, len = 0;
+        int header_size = (new->opt == OPTION_DOMAIN_SEARCH) ? 0 : 1;
+
+        arg = comma;
+        comma = split(arg);
+
+        while (arg && *arg) {
+          char *in, *dom = NULL;
+          size_t domlen = 1;
+          /* Allow "." as an empty domain */
+          if (strcmp(arg, ".") != 0) {
+            if (!(dom = canonicalise_opt(arg)))
+              ret_err(_("bad domain in dhcp-option"));
+
+            domlen = strlen(dom) + 2;
+          }
+
+          newp = opt_malloc(len + domlen + header_size);
+          if (m) {
+            memcpy(newp, m, header_size + len);
+            free(m);
+          }
+          m = newp;
+          p = m + header_size;
+          q = p + len;
+
+          /* add string on the end in RFC1035 format */
+          for (in = dom; in && *in;) {
+            unsigned char *cp = q++;
+            int j;
+            for (j = 0; *in && (*in != '.'); in++, j++)
+              *q++ = *in;
+            *cp = j;
+            if (*in)
+              in++;
+          }
+          *q++ = 0;
+          free(dom);
+
+          /* Now tail-compress using earlier names. */
+          newlen = q - p;
+          for (tail = p + len; *tail; tail += (*tail) + 1)
+            for (r = p; r - p < (int) len; r += (*r) + 1)
+              if (strcmp((char *) r, (char *) tail) == 0) {
+                PUTSHORT((r - p) | 0xc000, tail);
+                newlen = tail - p;
+                goto end;
+              }
+        end:
+          len = newlen;
+
+          arg = comma;
+          comma = split(arg);
+        }
+
+        /* RFC 3361, enc byte is zero for names */
+        if (new->opt == OPTION_SIP_SERVER)
+          m[0] = 0;
+        new->len = (int) len + header_size;
+        new->val = m;
+      }
 #ifdef HAVE_DHCP6
-	  else if (comma && (opt_len & OT_CSTRING))
-	    {
-	      /* length fields are two bytes so need 16 bits for each string */
-	      int i, commas = 1;
-	      unsigned char *p, *newp;
-
-	      for (i = 0; comma[i]; i++)
-		if (comma[i] == ',')
-		  commas++;
-	      
-	      newp = opt_malloc(strlen(comma)+(2*commas));	  
-	      p = newp;
-	      arg = comma;
-	      comma = split(arg);
-	      
-	      while (arg && *arg)
-		{
-		  u16 len = strlen(arg);
-		  unhide_metas(arg);
-		  PUTSHORT(len, p);
-		  memcpy(p, arg, len);
-		  p += len; 
-
-		  arg = comma;
-		  comma = split(arg);
-		}
-
-	      new->val = newp;
-	      new->len = p - newp;
-	    }
-	  else if (comma && (opt_len & OT_RFC1035_NAME))
-	    {
-	      unsigned char *p = NULL, *newp, *end;
-	      int len = 0;
-	      arg = comma;
-	      comma = split(arg);
-	      
-	      while (arg && *arg)
-		{
-		  char *dom = canonicalise_opt(arg);
-		  if (!dom)
-		    ret_err(_("bad domain in dhcp-option"));
-		    		  
-		  newp = opt_malloc(len + strlen(dom) + 2);
-		  
-		  if (p)
-		    {
-		      memcpy(newp, p, len);
-		      free(p);
-		    }
-		  
-		  p = newp;
-		  end = do_rfc1035_name(p + len, dom, NULL);
-		  *end++ = 0;
-		  len = end - p;
-		  free(dom);
-
-		  arg = comma;
-		  comma = split(arg);
-		}
-	      
-	      new->val = p;
-	      new->len = len;
-	    }
-#endif
-	  else
-	    {
-	      new->len = strlen(comma);
-	      /* keep terminating zero on string */
-	      new->val = (unsigned char *)opt_string_alloc(comma);
-	      new->flags |= DHOPT_STRING;
-	    }
-	}
-    }
-
-  if (!is6 && 
-      ((new->len > 255) || 
-      (new->len > 253 && (new->flags & (DHOPT_VENDOR | DHOPT_ENCAPSULATE))) ||
+      else if (comma && (opt_len & OT_CSTRING)) {
+        /* length fields are two bytes so need 16 bits for each string */
+        int i, commas = 1;
+        unsigned char *p, *newp;
+
+        for (i = 0; comma[i]; i++)
+          if (comma[i] == ',')
+            commas++;
+
+        newp = opt_malloc(strlen(comma) + (2 * commas));
+        p = newp;
+        arg = comma;
+        comma = split(arg);
+
+        while (arg && *arg) {
+          u16 len = strlen(arg);
+          unhide_metas(arg);
+          PUTSHORT(len, p);
+          memcpy(p, arg, len);
+          p += len;
+
+          arg = comma;
+          comma = split(arg);
+        }
+
+        new->val = newp;
+        new->len = p - newp;
+      } else if (comma && (opt_len & OT_RFC1035_NAME)) {
+        unsigned char *p = NULL, *newp, *end;
+        int len = 0;
+        arg = comma;
+        comma = split(arg);
+
+        while (arg && *arg) {
+          char *dom = canonicalise_opt(arg);
+          if (!dom)
+            ret_err(_("bad domain in dhcp-option"));
+
+          newp = opt_malloc(len + strlen(dom) + 2);
+
+          if (p) {
+            memcpy(newp, p, len);
+            free(p);
+          }
+
+          p = newp;
+          end = do_rfc1035_name(p + len, dom, NULL);
+          *end++ = 0;
+          len = end - p;
+          free(dom);
+
+          arg = comma;
+          comma = split(arg);
+        }
+
+        new->val = p;
+        new->len = len;
+      }
+#endif
+      else {
+        new->len = strlen(comma);
+        /* keep terminating zero on string */
+        new->val = (unsigned char *) opt_string_alloc(comma);
+        new->flags |= DHOPT_STRING;
+      }
+    }
+  }
+
+  if (!is6 &&
+      ((new->len > 255) ||
+       (new->len > 253 && (new->flags & (DHOPT_VENDOR | DHOPT_ENCAPSULATE))) ||
        (new->len > 250 && (new->flags & DHOPT_RFC3925))))
     ret_err(_("dhcp-option too long"));
-  
-  if (flags == DHOPT_MATCH)
-    {
-      if ((new->flags & (DHOPT_ENCAPSULATE | DHOPT_VENDOR)) ||
-	  !new->netid ||
-	  new->netid->next)
-	ret_err(_("illegal dhcp-match"));
-       
-      if (is6)
-	{
-	  new->next = daemon->dhcp_match6;
-	  daemon->dhcp_match6 = new;
-	}
-      else
-	{
-	  new->next = daemon->dhcp_match;
-	  daemon->dhcp_match = new;
-	}
-    }
-  else if (is6)
-    {
-      new->next = daemon->dhcp_opts6;
-      daemon->dhcp_opts6 = new;
-    }
-  else
-    {
-      new->next = daemon->dhcp_opts;
-      daemon->dhcp_opts = new;
+
+  if (flags == DHOPT_MATCH) {
+    if ((new->flags & (DHOPT_ENCAPSULATE | DHOPT_VENDOR)) ||
+        !new->netid || new->netid->next)
+      ret_err(_("illegal dhcp-match"));
+
+    if (is6) {
+      new->next = daemon->dhcp_match6;
+      daemon->dhcp_match6 = new;
+    } else {
+      new->next = daemon->dhcp_match;
+      daemon->dhcp_match = new;
     }
-    
+  } else if (is6) {
+    new->next = daemon->dhcp_opts6;
+    daemon->dhcp_opts6 = new;
+  } else {
+    new->next = daemon->dhcp_opts;
+    daemon->dhcp_opts = new;
+  }
+
   return 1;
 }
 
@@ -1494,2825 +1652,2601 @@
     daemon->options2 &= ~(1u << (opt - 32));
 }
 
-static int one_opt(int option, char *arg, char *errstr, char *gen_err, int command_line, int servers_only)
-{      
+static int one_opt(int option, char *arg, char *errstr, char *gen_err,
+                   int command_line, int servers_only)
+{
   int i;
   char *comma;
 
   if (option == '?')
     ret_err(gen_err);
-  
-  for (i=0; usage[i].opt != 0; i++)
-    if (usage[i].opt == option)
-      {
-	 int rept = usage[i].rept;
-	 
-	 if (command_line)
-	   {
-	     /* command line */
-	     if (rept == ARG_USED_CL)
-	       ret_err(_("illegal repeated flag"));
-	     if (rept == ARG_ONE)
-	       usage[i].rept = ARG_USED_CL;
-	   }
-	 else
-	   {
-	     /* allow file to override command line */
-	     if (rept == ARG_USED_FILE)
-	       ret_err(_("illegal repeated keyword"));
-	     if (rept == ARG_USED_CL || rept == ARG_ONE)
-	       usage[i].rept = ARG_USED_FILE;
-	   }
-
-	 if (rept != ARG_DUP && rept != ARG_ONE && rept != ARG_USED_CL) 
-	   {
-	     set_option_bool(rept);
-	     return 1;
-	   }
-       
-	 break;
-      }
-  
-  switch (option)
-    { 
-    case 'C': /* --conf-file */
-      {
-	char *file = opt_string_alloc(arg);
-	if (file)
-	  {
-	    one_file(file, 0);
-	    free(file);
-	  }
-	break;
-      }
-
-    case '7': /* --conf-dir */	      
-      {
-	DIR *dir_stream;
-	struct dirent *ent;
-	char *directory, *path;
-	struct list {
-	  char *suffix;
-	  struct list *next;
-	} *ignore_suffix = NULL, *match_suffix = NULL, *li;
-	
-	comma = split(arg);
-	if (!(directory = opt_string_alloc(arg)))
-	  break;
-	
-	for (arg = comma; arg; arg = comma) 
-	  {
-	    comma = split(arg);
-	    if (strlen(arg) != 0)
-	      {
-		li = opt_malloc(sizeof(struct list));
-		if (*arg == '*')
-		  {
-		    /* "*" with no suffix is a no-op */
-		    if (arg[1] == 0)
-		      free(li);
-		    else
-		      {
-			li->next = match_suffix;
-			match_suffix = li;
-			/* Have to copy: buffer is overwritten */
-			li->suffix = opt_string_alloc(arg+1);
-		      }
-		  }
-		else
-		  {
-		    li->next = ignore_suffix;
-		    ignore_suffix = li;
-		    /* Have to copy: buffer is overwritten */
-		    li->suffix = opt_string_alloc(arg);
-		  }
-	      }
-	  }
-	
-	if (!(dir_stream = opendir(directory)))
-	  die(_("cannot access directory %s: %s"), directory, EC_FILE);
-	
-	while ((ent = readdir(dir_stream)))
-	  {
-	    size_t len = strlen(ent->d_name);
-	    struct stat buf;
-	    
-	    /* ignore emacs backups and dotfiles */
-	    if (len == 0 ||
-		ent->d_name[len - 1] == '~' ||
-		(ent->d_name[0] == '#' && ent->d_name[len - 1] == '#') ||
-		ent->d_name[0] == '.')
-	      continue;
-
-	    if (match_suffix)
-	      {
-		for (li = match_suffix; li; li = li->next)
-		  {
-		    /* check for required suffices */
-		    size_t ls = strlen(li->suffix);
-		    if (len > ls &&
-			strcmp(li->suffix, &ent->d_name[len - ls]) == 0)
-		      break;
-		  }
-		if (!li)
-		  continue;
-	      }
-	    
-	    for (li = ignore_suffix; li; li = li->next)
-	      {
-		/* check for proscribed suffices */
-		size_t ls = strlen(li->suffix);
-		if (len > ls &&
-		    strcmp(li->suffix, &ent->d_name[len - ls]) == 0)
-		  break;
-	      }
-	    if (li)
-	      continue;
-	    
-	    path = opt_malloc(strlen(directory) + len + 2);
-	    strcpy(path, directory);
-	    strcat(path, "/");
-	    strcat(path, ent->d_name);
-
-	    /* files must be readable */
-	    if (stat(path, &buf) == -1)
-	      die(_("cannot access %s: %s"), path, EC_FILE);
-	    
-	    /* only reg files allowed. */
-	    if (S_ISREG(buf.st_mode))
-	      one_file(path, 0);
-	    
-	    free(path);
-	  }
-     
-	closedir(dir_stream);
-	free(directory);
-	for(; ignore_suffix; ignore_suffix = li)
-	  {
-	    li = ignore_suffix->next;
-	    free(ignore_suffix->suffix);
-	    free(ignore_suffix);
-	  }
-	for(; match_suffix; match_suffix = li)
-	  {
-	    li = match_suffix->next;
-	    free(match_suffix->suffix);
-	    free(match_suffix);
-	  }
-	break;
-      }
-
-    case LOPT_ADD_SBNET: /* --add-subnet */
-      set_option_bool(OPT_CLIENT_SUBNET);
-      if (arg)
-	{
-          char *err, *end;
-	  comma = split(arg);
-
-          struct mysubnet* new = opt_malloc(sizeof(struct mysubnet));
-          if ((end = split_chr(arg, '/')))
-	    {
-	      /* has subnet+len */
-	      err = parse_mysockaddr(arg, &new->addr);
-	      if (err)
-		ret_err(err);
-	      if (!atoi_check(end, &new->mask))
-		ret_err(gen_err);
-	      new->addr_used = 1;
-	    } 
-	  else if (!atoi_check(arg, &new->mask))
-	    ret_err(gen_err);
-	    
-          daemon->add_subnet4 = new;
 
-          if (comma)
-            {
-	      new = opt_malloc(sizeof(struct mysubnet));
-	      if ((end = split_chr(comma, '/')))
-		{
-		  /* has subnet+len */
-                  err = parse_mysockaddr(comma, &new->addr);
-                  if (err)
-                    ret_err(err);
-                  if (!atoi_check(end, &new->mask))
-                    ret_err(gen_err);
-                  new->addr_used = 1;
-                }
-              else
-                {
-                  if (!atoi_check(comma, &new->mask))
-                    ret_err(gen_err);
-                }
-          
-	      daemon->add_subnet6 = new;
-	    }
-	}
-      break;
+  for (i = 0; usage[i].opt != 0; i++)
+    if (usage[i].opt == option) {
+      int rept = usage[i].rept;
 
-    case '1': /* --enable-dbus */
-      set_option_bool(OPT_DBUS);
-      if (arg)
-	daemon->dbus_name = opt_string_alloc(arg);
-      else
-	daemon->dbus_name = DNSMASQ_SERVICE;
-      break;
-      
-    case '8': /* --log-facility */
-      /* may be a filename */
-      if (strchr(arg, '/') || strcmp (arg, "-") == 0)
-	daemon->log_file = opt_string_alloc(arg);
-      else
-	{	  
-#ifdef __ANDROID__
-	  ret_err(_("setting log facility is not possible under Android"));
-#else
-	  for (i = 0; facilitynames[i].c_name; i++)
-	    if (hostname_isequal((char *)facilitynames[i].c_name, arg))
-	      break;
-	  
-	  if (facilitynames[i].c_name)
-	    daemon->log_fac = facilitynames[i].c_val;
-	  else
-	    ret_err(_("bad log facility"));
-#endif
-	}
-      break;
-      
-    case 'x': /* --pid-file */
-      daemon->runfile = opt_string_alloc(arg);
-      break;
-
-    case 'r': /* --resolv-file */
-      {
-	char *name = opt_string_alloc(arg);
-	struct resolvc *new, *list = daemon->resolv_files;
-	
-	if (list && list->is_default)
-	  {
-	    /* replace default resolv file - possibly with nothing */
-	    if (name)
-	      {
-		list->is_default = 0;
-		list->name = name;
-	      }
-	    else
-	      list = NULL;
-	  }
-	else if (name)
-	  {
-	    new = opt_malloc(sizeof(struct resolvc));
-	    new->next = list;
-	    new->name = name;
-	    new->is_default = 0;
-	    new->mtime = 0;
-	    new->logged = 0;
-	    list = new;
-	  }
-	daemon->resolv_files = list;
-	break;
-      }
-
-    case LOPT_SERVERS_FILE:
-      daemon->servers_file = opt_string_alloc(arg);
-      break;
-      
-    case 'm':  /* --mx-host */
-      {
-	int pref = 1;
-	struct mx_srv_record *new;
-	char *name, *target = NULL;
-
-	if ((comma = split(arg)))
-	  {
-	    char *prefstr;
-	    if ((prefstr = split(comma)) && !atoi_check16(prefstr, &pref))
-	      ret_err(_("bad MX preference"));
-	  }
-	
-	if (!(name = canonicalise_opt(arg)) || 
-	    (comma && !(target = canonicalise_opt(comma))))
-	  ret_err(_("bad MX name"));
-	
-	new = opt_malloc(sizeof(struct mx_srv_record));
-	new->next = daemon->mxnames;
-	daemon->mxnames = new;
-	new->issrv = 0;
-	new->name = name;
-	new->target = target; /* may be NULL */
-	new->weight = pref;
-	break;
-      }
-      
-    case 't': /*  --mx-target */
-      if (!(daemon->mxtarget = canonicalise_opt(arg)))
-	ret_err(_("bad MX target"));
-      break;
-
-#ifdef HAVE_DHCP      
-    case 'l':  /* --dhcp-leasefile */
-      daemon->lease_file = opt_string_alloc(arg);
-      break;
-      
-      /* Sorry about the gross pre-processor abuse */
-    case '6':             /* --dhcp-script */
-    case LOPT_LUASCRIPT:  /* --dhcp-luascript */
-#  if defined(NO_FORK)
-      ret_err(_("cannot run scripts under uClinux"));
-#  elif !defined(HAVE_SCRIPT)
-      ret_err(_("recompile with HAVE_SCRIPT defined to enable lease-change scripts"));
-#  else
-      if (option == LOPT_LUASCRIPT)
-#    if !defined(HAVE_LUASCRIPT)
-	ret_err(_("recompile with HAVE_LUASCRIPT defined to enable Lua scripts"));
-#    else
-        daemon->luascript = opt_string_alloc(arg);
-#    endif
-      else
-        daemon->lease_change_command = opt_string_alloc(arg);
-#  endif
-      break;
-#endif /* HAVE_DHCP */
+      if (command_line) {
+        /* command line */
+        if (rept == ARG_USED_CL)
+          ret_err(_("illegal repeated flag"));
+        if (rept == ARG_ONE)
+          usage[i].rept = ARG_USED_CL;
+      } else {
+        /* allow file to override command line */
+        if (rept == ARG_USED_FILE)
+          ret_err(_("illegal repeated keyword"));
+        if (rept == ARG_USED_CL || rept == ARG_ONE)
+          usage[i].rept = ARG_USED_FILE;
+      }
 
-    case LOPT_DHCP_HOST:     /* --dhcp-hostsfile */
-    case LOPT_DHCP_OPTS:     /* --dhcp-optsfile */
-    case LOPT_DHCP_INOTIFY:  /* --dhcp-hostsdir */
-    case LOPT_DHOPT_INOTIFY: /* --dhcp-optsdir */
-    case LOPT_HOST_INOTIFY:  /* --hostsdir */
-    case 'H':                /* --addn-hosts */
-      {
-	struct hostsfile *new = opt_malloc(sizeof(struct hostsfile));
-	static unsigned int hosts_index = SRC_AH;
-	new->fname = opt_string_alloc(arg);
-	new->index = hosts_index++;
-	new->flags = 0;
-	if (option == 'H')
-	  {
-	    new->next = daemon->addn_hosts;
-	    daemon->addn_hosts = new;
-	  }
-	else if (option == LOPT_DHCP_HOST)
-	  {
-	    new->next = daemon->dhcp_hosts_file;
-	    daemon->dhcp_hosts_file = new;
-	  }
-	else if (option == LOPT_DHCP_OPTS)
-	  {
-	    new->next = daemon->dhcp_opts_file;
-	    daemon->dhcp_opts_file = new;
-	  } 	  
-	else 
-	  {
-	    new->next = daemon->dynamic_dirs;
-	    daemon->dynamic_dirs = new; 
-	    if (option == LOPT_DHCP_INOTIFY)
-	      new->flags |= AH_DHCP_HST;
-	    else if (option == LOPT_DHOPT_INOTIFY)
-	      new->flags |= AH_DHCP_OPT;
-	    else if (option == LOPT_HOST_INOTIFY)
-	      new->flags |= AH_HOSTS;
-	  }
-	
-	break;
+      if (rept != ARG_DUP && rept != ARG_ONE && rept != ARG_USED_CL) {
+        set_option_bool(rept);
+        return 1;
       }
-      
 
-#ifdef HAVE_AUTH
-    case LOPT_AUTHSERV: /* --auth-server */
-      if (!(comma = split(arg)))
-	ret_err(gen_err);
-      
-      daemon->authserver = opt_string_alloc(arg);
-      arg = comma;
-      do {
-	struct iname *new = opt_malloc(sizeof(struct iname));
-	comma = split(arg);
-	new->name = NULL;
-	unhide_metas(arg);
-	if (inet_pton(AF_INET, arg, &new->addr.in.sin_addr) > 0)
-	  new->addr.sa.sa_family = AF_INET;
-#ifdef HAVE_IPV6
-	else if (inet_pton(AF_INET6, arg, &new->addr.in6.sin6_addr) > 0)
-	  new->addr.sa.sa_family = AF_INET6;
-#endif
-	else
-	  {
-	    char *fam = split_chr(arg, '/');
-	    new->name = opt_string_alloc(arg);
-	    new->addr.sa.sa_family = 0;
-	    if (fam)
-	      {
-		if (strcmp(fam, "4") == 0)
-		  new->addr.sa.sa_family = AF_INET;
-#ifdef HAVE_IPV6
-		else if (strcmp(fam, "6") == 0)
-		  new->addr.sa.sa_family = AF_INET6;
-#endif
-		else
-		  ret_err(gen_err);
-	      } 
-	  }
-	new->next = daemon->authinterface;
-	daemon->authinterface = new;
-	
-	arg = comma;
-      } while (arg);
-            
       break;
+    }
 
-    case LOPT_AUTHSFS: /* --auth-sec-servers */
-      {
-	struct name_list *new;
-
-	do {
-	  comma = split(arg);
-	  new = opt_malloc(sizeof(struct name_list));
-	  new->name = opt_string_alloc(arg);
-	  new->next = daemon->secondary_forward_server;
-	  daemon->secondary_forward_server = new;
-	  arg = comma;
-	} while (arg);
-	break;
-      }
-	
-    case LOPT_AUTHZONE: /* --auth-zone */
-      {
-	struct auth_zone *new;
-	
-	comma = split(arg);
-		
-	new = opt_malloc(sizeof(struct auth_zone));
-	new->domain = opt_string_alloc(arg);
-	new->subnet = NULL;
-	new->exclude = NULL;
-	new->interface_names = NULL;
-	new->next = daemon->auth_zones;
-	daemon->auth_zones = new;
-
-	while ((arg = comma))
-	  {
-	    int prefixlen = 0;
-	    int is_exclude = 0;
-	    char *prefix;
-	    struct addrlist *subnet =  NULL;
-	    struct all_addr addr;
-
-	    comma = split(arg);
-	    prefix = split_chr(arg, '/');
-	    
-	    if (prefix && !atoi_check(prefix, &prefixlen))
-	      ret_err(gen_err);
-	    
-	    if (strstr(arg, "exclude:") == arg)
-	      {
-		    is_exclude = 1;
-		    arg = arg+8;
-	      }
-
-	    if (inet_pton(AF_INET, arg, &addr.addr.addr4))
-	      {
-		subnet = opt_malloc(sizeof(struct addrlist));
-		subnet->prefixlen = (prefixlen == 0) ? 24 : prefixlen;
-		subnet->flags = ADDRLIST_LITERAL;
-	      }
-#ifdef HAVE_IPV6
-	    else if (inet_pton(AF_INET6, arg, &addr.addr.addr6))
-	      {
-		subnet = opt_malloc(sizeof(struct addrlist));
-		subnet->prefixlen = (prefixlen == 0) ? 64 : prefixlen;
-		subnet->flags = ADDRLIST_LITERAL | ADDRLIST_IPV6;
-	      }
-#endif
-	    else 
-	      {
-		struct auth_name_list *name =  opt_malloc(sizeof(struct auth_name_list));
-		name->name = opt_string_alloc(arg);
-		name->flags = AUTH4 | AUTH6;
-		name->next = new->interface_names;
-		new->interface_names = name;
-		if (prefix)
-		  {
-		    if (prefixlen == 4)
-		      name->flags &= ~AUTH6;
-#ifdef HAVE_IPV6
-		    else if (prefixlen == 6)
-		      name->flags &= ~AUTH4;
-#endif
-		    else
-		      ret_err(gen_err);
-		  }
-	      }
-	    
-	    if (subnet)
-	      {
-		subnet->addr = addr;
-
-		if (is_exclude)
-		  {
-		    subnet->next = new->exclude;
-		    new->exclude = subnet;
-		  }
-		else
-		  {
-		    subnet->next = new->subnet;
-		    new->subnet = subnet;
-		  }
-	      }
-	  }
-	break;
+  switch (option) {
+  case 'C':                    /* --conf-file */
+    {
+      char *file = opt_string_alloc(arg);
+      if (file) {
+        one_file(file, 0);
+        free(file);
       }
-      
-    case  LOPT_AUTHSOA: /* --auth-soa */
+      break;
+    }
+
+  case '7':                    /* --conf-dir */
+    {
+      DIR *dir_stream;
+      struct dirent *ent;
+      char *directory, *path;
+      struct list {
+        char *suffix;
+        struct list *next;
+      } *ignore_suffix = NULL, *match_suffix = NULL, *li;
+
       comma = split(arg);
-      daemon->soa_sn = (u32)atoi(arg);
-      if (comma)
-	{
-	  char *cp;
-	  arg = comma;
-	  comma = split(arg);
-	  daemon->hostmaster = opt_string_alloc(arg);
-	  for (cp = daemon->hostmaster; *cp; cp++)
-	    if (*cp == '@')
-	      *cp = '.';
-
-	  if (comma)
-	    {
-	      arg = comma;
-	      comma = split(arg); 
-	      daemon->soa_refresh = (u32)atoi(arg);
-	      if (comma)
-		{
-		  arg = comma;
-		  comma = split(arg); 
-		  daemon->soa_retry = (u32)atoi(arg);
-		  if (comma)
-		    daemon->soa_expiry = (u32)atoi(comma);
-		}
-	    }
-	}
+      if (!(directory = opt_string_alloc(arg)))
+        break;
 
-      break;
-#endif
+      for (arg = comma; arg; arg = comma) {
+        comma = split(arg);
+        if (strlen(arg) != 0) {
+          li = opt_malloc(sizeof(struct list));
+          if (*arg == '*') {
+            /* "*" with no suffix is a no-op */
+            if (arg[1] == 0)
+              free(li);
+            else {
+              li->next = match_suffix;
+              match_suffix = li;
+              /* Have to copy: buffer is overwritten */
+              li->suffix = opt_string_alloc(arg + 1);
+            }
+          } else {
+            li->next = ignore_suffix;
+            ignore_suffix = li;
+            /* Have to copy: buffer is overwritten */
+            li->suffix = opt_string_alloc(arg);
+          }
+        }
+      }
 
-    case 's':         /* --domain */
-    case LOPT_SYNTH:  /* --synth-domain */
-      if (strcmp (arg, "#") == 0)
-	set_option_bool(OPT_RESOLV_DOMAIN);
-      else
-	{
-	  char *d;
-	  comma = split(arg);
-	  if (!(d = canonicalise_opt(arg)))
-	    ret_err(gen_err);
-	  else
-	    {
-	      if (comma)
-		{
-		  struct cond_domain *new = opt_malloc(sizeof(struct cond_domain));
-		  char *netpart;
-		  
-		  new->prefix = NULL;
-
-		  unhide_metas(comma);
-		  if ((netpart = split_chr(comma, '/')))
-		    {
-		      int msize;
-
-		      arg = split(netpart);
-		      if (!atoi_check(netpart, &msize))
-			ret_err(gen_err);
-		      else if (inet_pton(AF_INET, comma, &new->start))
-			{
-			  int mask = (1 << (32 - msize)) - 1;
-			  new->is6 = 0; 			  
-			  new->start.s_addr = ntohl(htonl(new->start.s_addr) & ~mask);
-			  new->end.s_addr = new->start.s_addr | htonl(mask);
-			  if (arg)
-			    {
-			      if (option != 's')
-				{
-				  if (!(new->prefix = canonicalise_opt(arg)) ||
-				      strlen(new->prefix) > MAXLABEL - INET_ADDRSTRLEN)
-				    ret_err(_("bad prefix"));
-				}
-			      else if (strcmp(arg, "local") != 0 ||
-				       (msize != 8 && msize != 16 && msize != 24))
-				ret_err(gen_err);
-			      else
-				{
-				   /* generate the equivalent of
-				      local=/xxx.yyy.zzz.in-addr.arpa/ */
-				  struct server *serv = add_rev4(new->start, msize);
-				  if (!serv)
-				    ret_err(_("bad prefix"));
-
-				  serv->flags |= SERV_NO_ADDR;
-
-				  /* local=/<domain>/ */
-				  serv = opt_malloc(sizeof(struct server));
-				  memset(serv, 0, sizeof(struct server));
-				  serv->domain = d;
-				  serv->flags = SERV_HAS_DOMAIN | SERV_NO_ADDR;
-				  serv->next = daemon->servers;
-				  daemon->servers = serv;
-				}
-			    }
-			}
-#ifdef HAVE_IPV6
-		      else if (inet_pton(AF_INET6, comma, &new->start6))
-			{
-			  u64 mask = (1LLU << (128 - msize)) - 1LLU;
-			  u64 addrpart = addr6part(&new->start6);
-			  new->is6 = 1;
-			  
-			  /* prefix==64 overflows the mask calculation above */
-			  if (msize == 64)
-			    mask = (u64)-1LL;
-			  
-			  new->end6 = new->start6;
-			  setaddr6part(&new->start6, addrpart & ~mask);
-			  setaddr6part(&new->end6, addrpart | mask);
-			  
-			  if (msize < 64)
-			    ret_err(gen_err);
-			  else if (arg)
-			    {
-			      if (option != 's')
-				{
-				  if (!(new->prefix = canonicalise_opt(arg)) ||
-				      strlen(new->prefix) > MAXLABEL - INET6_ADDRSTRLEN)
-				    ret_err(_("bad prefix"));
-				}	
-			      else if (strcmp(arg, "local") != 0 || ((msize & 4) != 0))
-				ret_err(gen_err);
-			      else 
-				{
-				  /* generate the equivalent of
-				     local=/xxx.yyy.zzz.ip6.arpa/ */
-				  struct server *serv = add_rev6(&new->start6, msize);
-				  serv->flags |= SERV_NO_ADDR;
-				  
-				  /* local=/<domain>/ */
-				  serv = opt_malloc(sizeof(struct server));
-				  memset(serv, 0, sizeof(struct server));
-				  serv->domain = d;
-				  serv->flags = SERV_HAS_DOMAIN | SERV_NO_ADDR;
-				  serv->next = daemon->servers;
-				  daemon->servers = serv;
-				}
-			    }
-			}
-#endif
-		      else
-			ret_err(gen_err);
-		    }
-		  else
-		    {
-		      char *prefstr;
-		      arg = split(comma);
-		      prefstr = split(arg);
-
-		      if (inet_pton(AF_INET, comma, &new->start))
-			{
-			  new->is6 = 0;
-			  if (!arg)
-			    new->end.s_addr = new->start.s_addr;
-			  else if (!inet_pton(AF_INET, arg, &new->end))
-			    ret_err(gen_err);
-			}
-#ifdef HAVE_IPV6
-		      else if (inet_pton(AF_INET6, comma, &new->start6))
-			{
-			  new->is6 = 1;
-			  if (!arg)
-			    memcpy(&new->end6, &new->start6, IN6ADDRSZ);
-			  else if (!inet_pton(AF_INET6, arg, &new->end6))
-			    ret_err(gen_err);
-			}
-#endif
-		      else 
-			ret_err(gen_err);
-
-		      if (option != 's' && prefstr)
-			{
-			  if (!(new->prefix = canonicalise_opt(prefstr)) ||
-			      strlen(new->prefix) > MAXLABEL - INET_ADDRSTRLEN)
-			    ret_err(_("bad prefix"));
-			}
-		    }
-
-		  new->domain = d;
-		  if (option  == 's')
-		    {
-		      new->next = daemon->cond_domain;
-		      daemon->cond_domain = new;
-		    }
-		  else
-		    {
-		      new->next = daemon->synth_domains;
-		      daemon->synth_domains = new;
-		    }
-		}
-	      else if (option == 's')
-		daemon->domain_suffix = d;
-	      else 
-		ret_err(gen_err);
-	    }
-	}
-      break;
-      
-    case LOPT_CPE_ID: /* --add-dns-client */
-      if (arg)
-	daemon->dns_client_id = opt_string_alloc(arg);
-      break;
+      if (!(dir_stream = opendir(directory)))
+        die(_("cannot access directory %s: %s"), directory, EC_FILE);
 
-    case LOPT_ADD_MAC: /* --add-mac */
-      if (!arg)
-	set_option_bool(OPT_ADD_MAC);
-      else
-	{
-	  unhide_metas(arg);
-	  if (strcmp(arg, "base64") == 0)
-	    set_option_bool(OPT_MAC_B64);
-	  else if (strcmp(arg, "text") == 0)
-	    set_option_bool(OPT_MAC_HEX);
-	  else
-	    ret_err(gen_err);
-	}
-      break;
-
-    case 'u':  /* --user */
-      daemon->username = opt_string_alloc(arg);
-      break;
-      
-    case 'g':  /* --group */
-      daemon->groupname = opt_string_alloc(arg);
-      daemon->group_set = 1;
-      break;
+      while ((ent = readdir(dir_stream))) {
+        size_t len = strlen(ent->d_name);
+        struct stat buf;
+
+        /* ignore emacs backups and dotfiles */
+        if (len == 0 ||
+            ent->d_name[len - 1] == '~' ||
+            (ent->d_name[0] == '#' && ent->d_name[len - 1] == '#') ||
+            ent->d_name[0] == '.')
+          continue;
+
+        if (match_suffix) {
+          for (li = match_suffix; li; li = li->next) {
+            /* check for required suffices */
+            size_t ls = strlen(li->suffix);
+            if (len > ls && strcmp(li->suffix, &ent->d_name[len - ls]) == 0)
+              break;
+          }
+          if (!li)
+            continue;
+        }
 
-#ifdef HAVE_DHCP
-    case LOPT_SCRIPTUSR: /* --scriptuser */
-      daemon->scriptuser = opt_string_alloc(arg);
-      break;
-#endif
-      
-    case 'i':  /* --interface */
-      do {
-	struct iname *new = opt_malloc(sizeof(struct iname));
-	comma = split(arg);
-	new->next = daemon->if_names;
-	daemon->if_names = new;
-	/* new->name may be NULL if someone does
-	   "interface=" to disable all interfaces except loop. */
-	new->name = opt_string_alloc(arg);
-	new->used = 0;
-	arg = comma;
-      } while (arg);
-      break;
-      
-    case LOPT_TFTP: /* --enable-tftp */
-      set_option_bool(OPT_TFTP);
-      if (!arg)
-	break;
-      /* fall through */
+        for (li = ignore_suffix; li; li = li->next) {
+          /* check for proscribed suffices */
+          size_t ls = strlen(li->suffix);
+          if (len > ls && strcmp(li->suffix, &ent->d_name[len - ls]) == 0)
+            break;
+        }
+        if (li)
+          continue;
 
-    case 'I':  /* --except-interface */
-    case '2':  /* --no-dhcp-interface */
-      do {
-	struct iname *new = opt_malloc(sizeof(struct iname));
-	comma = split(arg);
-	new->name = opt_string_alloc(arg);
-	if (option == 'I')
-	  {
-	    new->next = daemon->if_except;
-	    daemon->if_except = new;
-	  }
-	else if (option == LOPT_TFTP)
-	   {
-	    new->next = daemon->tftp_interfaces;
-	    daemon->tftp_interfaces = new;
-	  }
-	else
-	  {
-	    new->next = daemon->dhcp_except;
-	    daemon->dhcp_except = new;
-	  }
-	arg = comma;
-      } while (arg);
-      break;
-      
-    case 'B':  /* --bogus-nxdomain */
-    case LOPT_IGNORE_ADDR: /* --ignore-address */
-     {
-	struct in_addr addr;
-	unhide_metas(arg);
-	if (arg && (inet_pton(AF_INET, arg, &addr) > 0))
-	  {
-	    struct bogus_addr *baddr = opt_malloc(sizeof(struct bogus_addr));
-	    if (option == 'B')
-	      {
-		baddr->next = daemon->bogus_addr;
-		daemon->bogus_addr = baddr;
-	      }
-	    else
-	      {
-		baddr->next = daemon->ignore_addr;
-		daemon->ignore_addr = baddr;
-	      }
-	    baddr->addr = addr;
-	  }
-	else
-	  ret_err(gen_err); /* error */
-	break;	
-      }
-      
-    case 'a':  /* --listen-address */
-    case LOPT_AUTHPEER: /* --auth-peer */
-      do {
-	struct iname *new = opt_malloc(sizeof(struct iname));
-	comma = split(arg);
-	unhide_metas(arg);
-	if (arg && (inet_pton(AF_INET, arg, &new->addr.in.sin_addr) > 0))
-	  {
-	    new->addr.sa.sa_family = AF_INET;
-	    new->addr.in.sin_port = 0;
-#ifdef HAVE_SOCKADDR_SA_LEN
-	    new->addr.in.sin_len = sizeof(new->addr.in);
-#endif
-	  }
-#ifdef HAVE_IPV6
-	else if (arg && inet_pton(AF_INET6, arg, &new->addr.in6.sin6_addr) > 0)
-	  {
-	    new->addr.sa.sa_family = AF_INET6;
-	    new->addr.in6.sin6_flowinfo = 0;
-	    new->addr.in6.sin6_scope_id = 0;
-	    new->addr.in6.sin6_port = 0;
-#ifdef HAVE_SOCKADDR_SA_LEN
-	    new->addr.in6.sin6_len = sizeof(new->addr.in6);
-#endif
-	  }
-#endif
-	else
-	  ret_err(gen_err);
+        path = opt_malloc(strlen(directory) + len + 2);
+        strcpy(path, directory);
+        strcat(path, "/");
+        strcat(path, ent->d_name);
+
+        /* files must be readable */
+        if (stat(path, &buf) == -1)
+          die(_("cannot access %s: %s"), path, EC_FILE);
+
+        /* only reg files allowed. */
+        if (S_ISREG(buf.st_mode))
+          one_file(path, 0);
 
-	new->used = 0;
-	if (option == 'a')
-	  {
-	    new->next = daemon->if_addrs;
-	    daemon->if_addrs = new;
-	  }
-	else
-	  {
-	    new->next = daemon->auth_peers;
-	    daemon->auth_peers = new;
-	  } 
-	arg = comma;
-      } while (arg);
-      break;
-      
-    case 'S':            /*  --server */
-    case LOPT_LOCAL:     /*  --local */
-    case 'A':            /*  --address */
-    case LOPT_NO_REBIND: /*  --rebind-domain-ok */
-      {
-	struct server *serv, *newlist = NULL;
-	
-	unhide_metas(arg);
-	
-	if (arg && (*arg == '/' || option == LOPT_NO_REBIND))
-	  {
-	    int rebind = !(*arg == '/');
-	    char *end = NULL;
-	    if (!rebind)
-	      arg++;
-	    while (rebind || (end = split_chr(arg, '/')))
-	      {
-		char *domain = NULL;
-		/* elide leading dots - they are implied in the search algorithm */
-		while (*arg == '.') arg++;
-		/* # matches everything and becomes a zero length domain string */
-		if (strcmp(arg, "#") == 0)
-		  domain = "";
-		else if (strlen (arg) != 0 && !(domain = canonicalise_opt(arg)))
-		  option = '?';
-		serv = opt_malloc(sizeof(struct server));
-		memset(serv, 0, sizeof(struct server));
-		serv->next = newlist;
-		newlist = serv;
-		serv->domain = domain;
-		serv->flags = domain ? SERV_HAS_DOMAIN : SERV_FOR_NODOTS;
-		arg = end;
-		if (rebind)
-		  break;
-	      }
-	    if (!newlist)
-	      ret_err(gen_err);
-	  }
-	else
-	  {
-	    newlist = opt_malloc(sizeof(struct server));
-	    memset(newlist, 0, sizeof(struct server));
-#ifdef HAVE_LOOP
-	    newlist->uid = rand32();
-#endif
-	  }
-	
-	if (servers_only && option == 'S')
-	  newlist->flags |= SERV_FROM_FILE;
-	
-	if (option == 'A')
-	  {
-	    newlist->flags |= SERV_LITERAL_ADDRESS;
-	    if (!(newlist->flags & SERV_TYPE))
-	      ret_err(gen_err);
-	  }
-	else if (option == LOPT_NO_REBIND)
-	  newlist->flags |= SERV_NO_REBIND;
-	
-	if (!arg || !*arg)
-	  {
-	    if (!(newlist->flags & SERV_NO_REBIND))
-	      newlist->flags |= SERV_NO_ADDR; /* no server */
-	  }
-
-	else if (strcmp(arg, "#") == 0)
-	  {
-	    newlist->flags |= SERV_USE_RESOLV; /* treat in ordinary way */
-	    if (newlist->flags & SERV_LITERAL_ADDRESS)
-	      ret_err(gen_err);
-	  }
-	else
-	  {
-	    char *err = parse_server(arg, &newlist->addr, &newlist->source_addr, newlist->interface, &newlist->flags);
-	    if (err)
-	      ret_err(err);
-	  }
-	
-	serv = newlist;
-	while (serv->next)
-	  {
-	    serv->next->flags = serv->flags;
-	    serv->next->addr = serv->addr;
-	    serv->next->source_addr = serv->source_addr;
-	    strcpy(serv->next->interface, serv->interface);
-	    serv = serv->next;
-	  }
-	serv->next = daemon->servers;
-	daemon->servers = newlist;
-	break;
-      }
-
-    case LOPT_REV_SERV: /* --rev-server */
-      {
-	char *string;
-	int size;
-	struct server *serv;
-	struct in_addr addr4;
-#ifdef HAVE_IPV6
-	struct in6_addr addr6;
-#endif
- 
-	unhide_metas(arg);
-	if (!arg || !(comma=split(arg)) || !(string = split_chr(arg, '/')) || !atoi_check(string, &size))
-	  ret_err(gen_err);
-
-	if (inet_pton(AF_INET, arg, &addr4))
-	  {
-	    serv = add_rev4(addr4, size);
-	    if (!serv)
-	      ret_err(_("bad prefix"));
-	  }
-#ifdef HAVE_IPV6
-	else if (inet_pton(AF_INET6, arg, &addr6))
-	  serv = add_rev6(&addr6, size);
-#endif
-	else
-	  ret_err(gen_err);
- 
-	string = parse_server(comma, &serv->addr, &serv->source_addr, serv->interface, &serv->flags);
-	
-	if (string)
-	  ret_err(string);
-	
-	if (servers_only)
-	  serv->flags |= SERV_FROM_FILE;
-	
-	break;
+        free(path);
       }
 
-    case LOPT_IPSET: /* --ipset */
-#ifndef HAVE_IPSET
-      ret_err(_("recompile with HAVE_IPSET defined to enable ipset directives"));
-      break;
-#else
-      {
-	 struct ipsets ipsets_head;
-	 struct ipsets *ipsets = &ipsets_head;
-	 int size;
-	 char *end;
-	 char **sets, **sets_pos;
-	 memset(ipsets, 0, sizeof(struct ipsets));
-	 unhide_metas(arg);
-	 if (arg && *arg == '/') 
-	   {
-	     arg++;
-	     while ((end = split_chr(arg, '/'))) 
-	       {
-		 char *domain = NULL;
-		 /* elide leading dots - they are implied in the search algorithm */
-		 while (*arg == '.')
-		   arg++;
-		 /* # matches everything and becomes a zero length domain string */
-		 if (strcmp(arg, "#") == 0 || !*arg)
-		   domain = "";
-		 else if (strlen(arg) != 0 && !(domain = canonicalise_opt(arg)))
-		   option = '?';
-		 ipsets->next = opt_malloc(sizeof(struct ipsets));
-		 ipsets = ipsets->next;
-		 memset(ipsets, 0, sizeof(struct ipsets));
-		 ipsets->domain = domain;
-		 arg = end;
-	       }
-	   } 
-	 else 
-	   {
-	     ipsets->next = opt_malloc(sizeof(struct ipsets));
-	     ipsets = ipsets->next;
-	     memset(ipsets, 0, sizeof(struct ipsets));
-	     ipsets->domain = "";
-	   }
-	 if (!arg || !*arg)
-	   {
-	     option = '?';
-	     break;
-	   }
-	 size = 2;
-	 for (end = arg; *end; ++end) 
-	   if (*end == ',')
-	       ++size;
-     
-	 sets = sets_pos = opt_malloc(sizeof(char *) * size);
-	 
-	 do {
-	   end = split(arg);
-	   *sets_pos++ = opt_string_alloc(arg);
-	   arg = end;
-	 } while (end);
-	 *sets_pos = 0;
-	 for (ipsets = &ipsets_head; ipsets->next; ipsets = ipsets->next)
-	   ipsets->next->sets = sets;
-	 ipsets->next = daemon->ipsets;
-	 daemon->ipsets = ipsets_head.next;
-	 
-	 break;
-      }
-#endif
-      
-    case 'c':  /* --cache-size */
-      {
-	int size;
-	
-	if (!atoi_check(arg, &size))
-	  ret_err(gen_err);
-	else
-	  {
-	    /* zero is OK, and means no caching. */
-	    
-	    if (size < 0)
-	      size = 0;
-	    else if (size > 10000)
-	      size = 10000;
-	    
-	    daemon->cachesize = size;
-	  }
-	break;
-      }
-      
-    case 'p':  /* --port */
-      if (!atoi_check16(arg, &daemon->port))
-	ret_err(gen_err);
-      break;
-    
-    case LOPT_MINPORT:  /* --min-port */
-      if (!atoi_check16(arg, &daemon->min_port))
-	ret_err(gen_err);
-      break;
-
-    case LOPT_MAXPORT:  /* --max-port */
-      if (!atoi_check16(arg, &daemon->max_port))
-	ret_err(gen_err);
-      break;
-
-    case '0':  /* --dns-forward-max */
-      if (!atoi_check(arg, &daemon->ftabsize))
-	ret_err(gen_err);
-      break;  
-    
-    case 'q': /* --log-queries */
-      set_option_bool(OPT_LOG);
-      if (arg && strcmp(arg, "extra") == 0)
-	set_option_bool(OPT_EXTRALOG);
-      break;
-
-    case LOPT_MAX_LOGS:  /* --log-async */
-      daemon->max_logs = LOG_MAX; /* default */
-      if (arg && !atoi_check(arg, &daemon->max_logs))
-	ret_err(gen_err);
-      else if (daemon->max_logs > 100)
-	daemon->max_logs = 100;
-      break;  
-
-    case 'P': /* --edns-packet-max */
-      {
-	int i;
-	if (!atoi_check(arg, &i))
-	  ret_err(gen_err);
-	daemon->edns_pktsz = (unsigned short)i;	
-	break;
-      }
-      
-    case 'Q':  /* --query-port */
-      if (!atoi_check16(arg, &daemon->query_port))
-	ret_err(gen_err);
-      /* if explicitly set to zero, use single OS ephemeral port
-	 and disable random ports */
-      if (daemon->query_port == 0)
-	daemon->osport = 1;
-      break;
-      
-    case 'T':         /* --local-ttl */
-    case LOPT_NEGTTL: /* --neg-ttl */
-    case LOPT_MAXTTL: /* --max-ttl */
-    case LOPT_MINCTTL: /* --min-cache-ttl */
-    case LOPT_MAXCTTL: /* --max-cache-ttl */
-    case LOPT_AUTHTTL: /* --auth-ttl */
-    case LOPT_DHCPTTL: /* --dhcp-ttl */
-      {
-	int ttl;
-	if (!atoi_check(arg, &ttl))
-	  ret_err(gen_err);
-	else if (option == LOPT_NEGTTL)
-	  daemon->neg_ttl = (unsigned long)ttl;
-	else if (option == LOPT_MAXTTL)
-	  daemon->max_ttl = (unsigned long)ttl;
-	else if (option == LOPT_MINCTTL)
-	  {
-	    if (ttl > TTL_FLOOR_LIMIT)
-	      ttl = TTL_FLOOR_LIMIT;
-	    daemon->min_cache_ttl = (unsigned long)ttl;
-	  }
-	else if (option == LOPT_MAXCTTL)
-	  daemon->max_cache_ttl = (unsigned long)ttl;
-	else if (option == LOPT_AUTHTTL)
-	  daemon->auth_ttl = (unsigned long)ttl;
-	else if (option == LOPT_DHCPTTL)
-	  {
-	    daemon->dhcp_ttl = (unsigned long)ttl;
-	    daemon->use_dhcp_ttl = 1;
-	  }
-	else
-	  daemon->local_ttl = (unsigned long)ttl;
-	break;
+      closedir(dir_stream);
+      free(directory);
+      for (; ignore_suffix; ignore_suffix = li) {
+        li = ignore_suffix->next;
+        free(ignore_suffix->suffix);
+        free(ignore_suffix);
+      }
+      for (; match_suffix; match_suffix = li) {
+        li = match_suffix->next;
+        free(match_suffix->suffix);
+        free(match_suffix);
       }
-      
-#ifdef HAVE_DHCP
-    case 'X': /* --dhcp-lease-max */
-      if (!atoi_check(arg, &daemon->dhcp_max))
-	ret_err(gen_err);
-      break;
-#endif
-      
-#ifdef HAVE_TFTP
-    case LOPT_TFTP_MAX:  /*  --tftp-max */
-      if (!atoi_check(arg, &daemon->tftp_max))
-	ret_err(gen_err);
-      break;  
-
-    case LOPT_TFTP_MTU:  /*  --tftp-mtu */
-      if (!atoi_check(arg, &daemon->tftp_mtu))
-	ret_err(gen_err);
       break;
+    }
 
-    case LOPT_PREFIX: /* --tftp-prefix */
+  case LOPT_ADD_SBNET:         /* --add-subnet */
+    set_option_bool(OPT_CLIENT_SUBNET);
+    if (arg) {
+      char *err, *end;
       comma = split(arg);
-      if (comma)
-	{
-	  struct tftp_prefix *new = opt_malloc(sizeof(struct tftp_prefix));
-	  new->interface = opt_string_alloc(comma);
-	  new->prefix = opt_string_alloc(arg);
-	  new->next = daemon->if_prefix;
-	  daemon->if_prefix = new;
-	}
-      else
-	daemon->tftp_prefix = opt_string_alloc(arg);
-      break;
 
-    case LOPT_TFTPPORTS: /* --tftp-port-range */
-      if (!(comma = split(arg)) || 
-	  !atoi_check16(arg, &daemon->start_tftp_port) ||
-	  !atoi_check16(comma, &daemon->end_tftp_port))
-	ret_err(_("bad port range"));
-      
-      if (daemon->start_tftp_port > daemon->end_tftp_port)
-	{
-	  int tmp = daemon->start_tftp_port;
-	  daemon->start_tftp_port = daemon->end_tftp_port;
-	  daemon->end_tftp_port = tmp;
-	} 
-      
-      break;
-
-    case LOPT_APREF: /* --tftp-unique-root */
-      if (!arg || strcasecmp(arg, "ip") == 0)
-        set_option_bool(OPT_TFTP_APREF_IP);
-      else if (strcasecmp(arg, "mac") == 0)
-        set_option_bool(OPT_TFTP_APREF_MAC);
-      else
+      struct mysubnet *new = opt_malloc(sizeof(struct mysubnet));
+      if ((end = split_chr(arg, '/'))) {
+        /* has subnet+len */
+        err = parse_mysockaddr(arg, &new->addr);
+        if (err)
+          ret_err(err);
+        if (!atoi_check(end, &new->mask))
+          ret_err(gen_err);
+        new->addr_used = 1;
+      } else if (!atoi_check(arg, &new->mask))
         ret_err(gen_err);
-      break;
-#endif
-	      
-    case LOPT_BRIDGE:   /* --bridge-interface */
-      {
-	struct dhcp_bridge *new = opt_malloc(sizeof(struct dhcp_bridge));
-	if (!(comma = split(arg)) || strlen(arg) > IF_NAMESIZE - 1 )
-	  ret_err(_("bad bridge-interface"));
-	
-	strcpy(new->iface, arg);
-	new->alias = NULL;
-	new->next = daemon->bridges;
-	daemon->bridges = new;
-
-	do {
-	  arg = comma;
-	  comma = split(arg);
-	  if (strlen(arg) != 0 && strlen(arg) <= IF_NAMESIZE - 1)
-	    {
-	      struct dhcp_bridge *b = opt_malloc(sizeof(struct dhcp_bridge)); 
-	      b->next = new->alias;
-	      new->alias = b;
-	      strcpy(b->iface, arg);
-	    }
-	} while (comma);
-	
-	break;
-      }
 
-#ifdef HAVE_DHCP
-    case 'F':  /* --dhcp-range */
-      {
-	int k, leasepos = 2;
-	char *cp, *a[8] = { NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL };
-	struct dhcp_context *new = opt_malloc(sizeof(struct dhcp_context));
-	
-	memset (new, 0, sizeof(*new));
-	new->lease_time = DEFLEASE;
-	
-	if (!arg)
-	  {
-	    option = '?';
-	    break;
-	  }
-	
-	while(1)
-	  {
-	    for (cp = arg; *cp; cp++)
-	      if (!(*cp == ' ' || *cp == '.' || *cp == ':' || 
-		    (*cp >= 'a' && *cp <= 'f') || (*cp >= 'A' && *cp <= 'F') ||
-		    (*cp >='0' && *cp <= '9')))
-		break;
-	    
-	    if (*cp != ',' && (comma = split(arg)))
-	      {
-		if (is_tag_prefix(arg))
-		  {
-		    struct dhcp_netid *tt = opt_malloc(sizeof (struct dhcp_netid));
-		    tt->net = opt_string_alloc(arg+4);
-		    tt->next = new->filter;
-		    /* ignore empty tag */
-		    if (tt->net)
-		      new->filter = tt;
-		  }
-		else
-		  {
-		    if (new->netid.net)
-		      ret_err(_("only one tag allowed"));
-		    else if (strstr(arg, "set:") == arg)
-		      new->netid.net = opt_string_alloc(arg+4);
-		    else
-		      new->netid.net = opt_string_alloc(arg);
-		  }
-		arg = comma;
-	      }
-	    else
-	      {
-		a[0] = arg;
-		break;
-	      }
-	  }
-	
-	for (k = 1; k < 8; k++)
-	  if (!(a[k] = split(a[k-1])))
-	    break;
-	
-	if (k < 2)
-	  ret_err(_("bad dhcp-range"));
-	
-	if (inet_pton(AF_INET, a[0], &new->start))
-	  {
-	    new->next = daemon->dhcp;
-	    daemon->dhcp = new;
-	    new->end = new->start;
-	    if (strcmp(a[1], "static") == 0)
-	      new->flags |= CONTEXT_STATIC;
-	    else if (strcmp(a[1], "proxy") == 0)
-	      new->flags |= CONTEXT_PROXY;
-	    else if (!inet_pton(AF_INET, a[1], &new->end))
-	      ret_err(_("bad dhcp-range"));
-	    
-	    if (ntohl(new->start.s_addr) > ntohl(new->end.s_addr))
-	      {
-		struct in_addr tmp = new->start;
-		new->start = new->end;
-		new->end = tmp;
-	      }
-	    
-	    if (k >= 3 && strchr(a[2], '.') &&  
-		(inet_pton(AF_INET, a[2], &new->netmask) > 0))
-	      {
-		new->flags |= CONTEXT_NETMASK;
-		leasepos = 3;
-		if (!is_same_net(new->start, new->end, new->netmask))
-		  ret_err(_("inconsistent DHCP range"));
-		
-	    
-		if (k >= 4 && strchr(a[3], '.') &&  
-		    (inet_pton(AF_INET, a[3], &new->broadcast) > 0))
-		  {
-		    new->flags |= CONTEXT_BRDCAST;
-		    leasepos = 4;
-		  }
-	      }
-	  }
-#ifdef HAVE_DHCP6
-	else if (inet_pton(AF_INET6, a[0], &new->start6))
-	  {
-	    new->flags |= CONTEXT_V6; 
-	    new->prefix = 64; /* default */
-	    new->end6 = new->start6;
-	    new->next = daemon->dhcp6;
-	    daemon->dhcp6 = new;
-
-	    for (leasepos = 1; leasepos < k; leasepos++)
-	      {
-		if (strcmp(a[leasepos], "static") == 0)
-		  new->flags |= CONTEXT_STATIC | CONTEXT_DHCP;
-		else if (strcmp(a[leasepos], "ra-only") == 0 || strcmp(a[leasepos], "slaac") == 0 )
-		  new->flags |= CONTEXT_RA;
-		else if (strcmp(a[leasepos], "ra-names") == 0)
-		  new->flags |= CONTEXT_RA_NAME | CONTEXT_RA;
-		else if (strcmp(a[leasepos], "ra-advrouter") == 0)
-		  new->flags |= CONTEXT_RA_ROUTER | CONTEXT_RA;
-		else if (strcmp(a[leasepos], "ra-stateless") == 0)
-		  new->flags |= CONTEXT_RA_STATELESS | CONTEXT_DHCP | CONTEXT_RA;
-		else if (strcmp(a[leasepos], "off-link") == 0)
-		  new->flags |= CONTEXT_RA_OFF_LINK;
-		else if (leasepos == 1 && inet_pton(AF_INET6, a[leasepos], &new->end6))
-		  new->flags |= CONTEXT_DHCP; 
-		else if (strstr(a[leasepos], "constructor:") == a[leasepos])
-		  {
-		    new->template_interface = opt_string_alloc(a[leasepos] + 12);
-		    new->flags |= CONTEXT_TEMPLATE;
-		  }
-		else  
-		  break;
-	      }
-	   	    	     
-	    /* bare integer < 128 is prefix value */
-	    if (leasepos < k)
-	      {
-		int pref;
-		for (cp = a[leasepos]; *cp; cp++)
-		  if (!(*cp >= '0' && *cp <= '9'))
-		    break;
-		if (!*cp && (pref = atoi(a[leasepos])) <= 128)
-		  {
-		    new->prefix = pref;
-		    leasepos++;
-		  }
-	      }
-	    
-	    if (new->prefix != 64)
-	      {
-		if (new->flags & CONTEXT_RA)
-		  ret_err(_("prefix length must be exactly 64 for RA subnets"));
-		else if (new->flags & CONTEXT_TEMPLATE)
-		  ret_err(_("prefix length must be exactly 64 for subnet constructors"));
-	      }
-
-	    if (new->prefix < 64)
-	      ret_err(_("prefix length must be at least 64"));
-	    
-	    if (!is_same_net6(&new->start6, &new->end6, new->prefix))
-	      ret_err(_("inconsistent DHCPv6 range"));
-
-	    /* dhcp-range=:: enables DHCP stateless on any interface */
-	    if (IN6_IS_ADDR_UNSPECIFIED(&new->start6) && !(new->flags & CONTEXT_TEMPLATE))
-	      new->prefix = 0;
-	    
-	    if (new->flags & CONTEXT_TEMPLATE)
-	      {
-		struct in6_addr zero;
-		memset(&zero, 0, sizeof(zero));
-		if (!is_same_net6(&zero, &new->start6, new->prefix))
-		  ret_err(_("prefix must be zero with \"constructor:\" argument"));
-	      }
-	    
-	    if (addr6part(&new->start6) > addr6part(&new->end6))
-	      {
-		struct in6_addr tmp = new->start6;
-		new->start6 = new->end6;
-		new->end6 = tmp;
-	      }
-	  }
-#endif
-	else
-	  ret_err(_("bad dhcp-range"));
-	
-	if (leasepos < k)
-	  {
-	    if (leasepos != k-1)
-	      ret_err(_("bad dhcp-range"));
-	    
-	    if (strcmp(a[leasepos], "infinite") == 0)
-	      new->lease_time = 0xffffffff;
-	    else if (strcmp(a[leasepos], "deprecated") == 0)
-	      new->flags |= CONTEXT_DEPRECATE;
-	    else
-	      {
-		int fac = 1;
-		if (strlen(a[leasepos]) > 0)
-		  {
-		    switch (a[leasepos][strlen(a[leasepos]) - 1])
-		      {
-		      case 'w':
-		      case 'W':
-			fac *= 7;
-			/* fall through */
-		      case 'd':
-		      case 'D':
-			fac *= 24;
-			/* fall though */
-		      case 'h':
-		      case 'H':
-			fac *= 60;
-			/* fall through */
-		      case 'm':
-		      case 'M':
-			fac *= 60;
-			/* fall through */
-		      case 's':
-		      case 'S':
-			a[leasepos][strlen(a[leasepos]) - 1] = 0;
-		      }
-		    
-		    for (cp = a[leasepos]; *cp; cp++)
-		      if (!(*cp >= '0' && *cp <= '9'))
-			break;
-
-		    if (*cp || (leasepos+1 < k))
-		      ret_err(_("bad dhcp-range"));
-		    
-		    new->lease_time = atoi(a[leasepos]) * fac;
-		    /* Leases of a minute or less confuse
-		       some clients, notably Apple's */
-		    if (new->lease_time < 120)
-		      new->lease_time = 120;
-		  }
-	      }
-	  }
-	break;
-      }
-
-    case LOPT_BANK:
-    case 'G':  /* --dhcp-host */
-      {
-	int j, k = 0;
-	char *a[7] = { NULL, NULL, NULL, NULL, NULL, NULL, NULL };
-	struct dhcp_config *new;
-	struct in_addr in;
-	
-	new = opt_malloc(sizeof(struct dhcp_config));
-	
-	new->next = daemon->dhcp_conf;
-	new->flags = (option == LOPT_BANK) ? CONFIG_BANK : 0;
-	new->hwaddr = NULL;
-	new->netid = NULL;
-
-	if ((a[0] = arg))
-	  for (k = 1; k < 7; k++)
-	    if (!(a[k] = split(a[k-1])))
-	      break;
-	
-	for (j = 0; j < k; j++)
-	  if (strchr(a[j], ':')) /* ethernet address, netid or binary CLID */
-	    {
-	      char *arg = a[j];
-	      
-	      if ((arg[0] == 'i' || arg[0] == 'I') &&
-		  (arg[1] == 'd' || arg[1] == 'D') &&
-		  arg[2] == ':')
-		{
-		  if (arg[3] == '*')
-		    new->flags |= CONFIG_NOCLID;
-		  else
-		    {
-		      int len;
-		      arg += 3; /* dump id: */
-		      if (strchr(arg, ':'))
-			len = parse_hex(arg, (unsigned char *)arg, -1, NULL, NULL);
-		      else
-			{
-			  unhide_metas(arg);
-			  len = (int) strlen(arg);
-			}
-
-		      if (len == -1)
-			ret_err(_("bad hex constant"));
-		      else if ((new->clid = opt_malloc(len)))
-			{
-			  new->flags |= CONFIG_CLID;
-			  new->clid_len = len;
-			  memcpy(new->clid, arg, len);
-			}
-		    }
-		}
-	      /* dhcp-host has strange backwards-compat needs. */
-	      else if (strstr(arg, "net:") == arg || strstr(arg, "set:") == arg)
-		{
-		  struct dhcp_netid *newtag = opt_malloc(sizeof(struct dhcp_netid));
-		  struct dhcp_netid_list *newlist = opt_malloc(sizeof(struct dhcp_netid_list));
-		  newtag->net = opt_malloc(strlen(arg + 4) + 1);
-		  newlist->next = new->netid;
-		  new->netid = newlist;
-		  newlist->list = newtag;
-		  strcpy(newtag->net, arg+4);
-		  unhide_metas(newtag->net);
-		}
-	      else if (strstr(arg, "tag:") == arg)
-		ret_err(_("cannot match tags in --dhcp-host"));
-#ifdef HAVE_DHCP6
-	      else if (arg[0] == '[' && arg[strlen(arg)-1] == ']')
-		{
-		  arg[strlen(arg)-1] = 0;
-		  arg++;
-		  
-		  if (!inet_pton(AF_INET6, arg, &new->addr6))
-		    ret_err(_("bad IPv6 address"));
-
-		  for (i= 0; i < 8; i++)
-		    if (new->addr6.s6_addr[i] != 0)
-		      break;
-
-		  /* set WILDCARD if network part all zeros */
-		  if (i == 8)
-		    new->flags |= CONFIG_WILDCARD;
-		  
-		  new->flags |= CONFIG_ADDR6;
-		}
-#endif
-	      else
-		{
-		  struct hwaddr_config *newhw = opt_malloc(sizeof(struct hwaddr_config));
-		  if ((newhw->hwaddr_len = parse_hex(a[j], newhw->hwaddr, DHCP_CHADDR_MAX, 
-						     &newhw->wildcard_mask, &newhw->hwaddr_type)) == -1)
-		    ret_err(_("bad hex constant"));
-		  else
-		    {
-		      
-		      newhw->next = new->hwaddr;
-		      new->hwaddr = newhw;
-		    }		    
-		}
-	    }
-	  else if (strchr(a[j], '.') && (inet_pton(AF_INET, a[j], &in) > 0))
-	    {
-	      struct dhcp_config *configs;
-	      
-	      new->addr = in;
-	      new->flags |= CONFIG_ADDR;
-
-	      /* If the same IP appears in more than one host config, then DISCOVER
-		 for one of the hosts will get the address, but REQUEST will be NAKed,
-		 since the address is reserved by the other one -> protocol loop. */
-	      for (configs = daemon->dhcp_conf; configs; configs = configs->next) 
-		if ((configs->flags & CONFIG_ADDR) && configs->addr.s_addr == in.s_addr)
-		  {
-		    sprintf(errstr, _("duplicate dhcp-host IP address %s"),  inet_ntoa(in));
-		    return 0;
-		  }	      
-	    }
-	  else
-	    {
-	      char *cp, *lastp = NULL, last = 0;
-	      int fac = 1, isdig = 0;
-	      
-	      if (strlen(a[j]) > 1)
-		{
-		  lastp = a[j] + strlen(a[j]) - 1;
-		  last = *lastp;
-		  switch (last)
-		    {
-		    case 'w':
-		    case 'W':
-		      fac *= 7;
-		      /* fall through */
-		    case 'd':
-		    case 'D':
-		      fac *= 24;
-		      /* fall through */
-		    case 'h':
-		    case 'H':
-		      fac *= 60;
-		      /* fall through */
-		    case 'm':
-		    case 'M':
-		      fac *= 60;
-		      /* fall through */
-		    case 's':
-		    case 'S':
-		      *lastp = 0;
-		    }
-		}
-	      
-	      for (cp = a[j]; *cp; cp++)
-		if (isdigit((unsigned char)*cp))
-		  isdig = 1;
-		else if (*cp != ' ')
-		  break;
-
-	      if (*cp)
-		{
-		  if (lastp)
-		    *lastp = last;
-		  if (strcmp(a[j], "infinite") == 0)
-		    {
-		      new->lease_time = 0xffffffff;
-		      new->flags |= CONFIG_TIME;
-		    }
-		  else if (strcmp(a[j], "ignore") == 0)
-		    new->flags |= CONFIG_DISABLE;
-		  else
-		    {
-		      if (!(new->hostname = canonicalise_opt(a[j])) ||
-			  !legal_hostname(new->hostname))
-			ret_err(_("bad DHCP host name"));
-		     
-		      new->flags |= CONFIG_NAME;
-		      new->domain = strip_hostname(new->hostname);			
-		    }
-		}
-	      else if (isdig)
-		{
-		  new->lease_time = atoi(a[j]) * fac; 
-		  /* Leases of a minute or less confuse
-		     some clients, notably Apple's */
-		  if (new->lease_time < 120)
-		    new->lease_time = 120;
-		  new->flags |= CONFIG_TIME;
-		}
-	    }
-	
-	daemon->dhcp_conf = new;
-	break;
-      }
-
-    case LOPT_TAG_IF:  /* --tag-if */
-      {
-	struct tag_if *new = opt_malloc(sizeof(struct tag_if));
-		
-	new->tag = NULL;
-	new->set = NULL;
-	new->next = NULL;
-	
-	/* preserve order */
-	if (!daemon->tag_if)
-	  daemon->tag_if = new;
-	else
-	  {
-	    struct tag_if *tmp;
-	    for (tmp = daemon->tag_if; tmp->next; tmp = tmp->next);
-	    tmp->next = new;
-	  }
-
-	while (arg)
-	  {
-	    size_t len;
-
-	    comma = split(arg);
-	    len = strlen(arg);
-
-	    if (len < 5)
-	      {
-		new->set = NULL;
-		break;
-	      }
-	    else
-	      {
-		struct dhcp_netid *newtag = opt_malloc(sizeof(struct dhcp_netid));
-		newtag->net = opt_malloc(len - 3);
-		strcpy(newtag->net, arg+4);
-		unhide_metas(newtag->net);
-
-		if (strstr(arg, "set:") == arg)
-		  {
-		    struct dhcp_netid_list *newlist = opt_malloc(sizeof(struct dhcp_netid_list));
-		    newlist->next = new->set;
-		    new->set = newlist;
-		    newlist->list = newtag;
-		  }
-		else if (strstr(arg, "tag:") == arg)
-		  {
-		    newtag->next = new->tag;
-		    new->tag = newtag;
-		  }
-		else 
-		  {
-		    new->set = NULL;
-		    free(newtag);
-		    break;
-		  }
-	      }
-	    
-	    arg = comma;
-	  }
-
-	if (!new->set)
-	  ret_err(_("bad tag-if"));
-	  
-	break;
-      }
-
-      
-    case 'O':           /* --dhcp-option */
-    case LOPT_FORCE:    /* --dhcp-option-force */
-    case LOPT_OPTS:
-    case LOPT_MATCH:    /* --dhcp-match */
-      return parse_dhcp_opt(errstr, arg, 
-			    option == LOPT_FORCE ? DHOPT_FORCE : 
-			    (option == LOPT_MATCH ? DHOPT_MATCH :
-			     (option == LOPT_OPTS ? DHOPT_BANK : 0)));
-     
-    case 'M': /* --dhcp-boot */
-      {
-	struct dhcp_netid *id = NULL;
-	while (is_tag_prefix(arg))
-	  {
-	    struct dhcp_netid *newid = opt_malloc(sizeof(struct dhcp_netid));
-	    newid->next = id;
-	    id = newid;
-	    comma = split(arg);
-	    newid->net = opt_string_alloc(arg+4);
-	    arg = comma;
-	  };
-	
-	if (!arg)
-	  ret_err(gen_err);
-	else 
-	  {
-	    char *dhcp_file, *dhcp_sname = NULL, *tftp_sname = NULL;
-	    struct in_addr dhcp_next_server;
-	    struct dhcp_boot *new;
-	    comma = split(arg);
-	    dhcp_file = opt_string_alloc(arg);
-	    dhcp_next_server.s_addr = 0;
-	    if (comma)
-	      {
-		arg = comma;
-		comma = split(arg);
-		dhcp_sname = opt_string_alloc(arg);
-		if (comma)
-		  {
-		    unhide_metas(comma);
-		    if (!(inet_pton(AF_INET, comma, &dhcp_next_server) > 0))
-		      {
-			/*
-			 * The user may have specified the tftp hostname here.
-			 * save it so that it can be resolved/looked up during
-			 * actual dhcp_reply().
-			 */	
-			
-			tftp_sname = opt_string_alloc(comma);
-			dhcp_next_server.s_addr = 0;
-		      }
-		  }
-	      }
-	    
-	    new = opt_malloc(sizeof(struct dhcp_boot));
-	    new->file = dhcp_file;
-	    new->sname = dhcp_sname;
-	    new->tftp_sname = tftp_sname;
-	    new->next_server = dhcp_next_server;
-	    new->netid = id;
-	    new->next = daemon->boot_config;
-	    daemon->boot_config = new;
-	  }
-      
-	break;
-      }
-
-    case LOPT_REPLY_DELAY: /* --dhcp-reply-delay */
-      {
-	struct dhcp_netid *id = NULL;
-	while (is_tag_prefix(arg))
-	  {
-	    struct dhcp_netid *newid = opt_malloc(sizeof(struct dhcp_netid));
-	    newid->next = id;
-	    id = newid;
-	    comma = split(arg);
-	    newid->net = opt_string_alloc(arg+4);
-	    arg = comma;
-	  };
-	
-	if (!arg)
-	  ret_err(gen_err);
-	else
-	  {
-	    struct delay_config *new;
-	    int delay;
-	    if (!atoi_check(arg, &delay))
-              ret_err(gen_err);
-	    
-	    new = opt_malloc(sizeof(struct delay_config));
-	    new->delay = delay;
-	    new->netid = id;
-            new->next = daemon->delay_conf;
-            daemon->delay_conf = new;
-	  }
-	
-	break;
-      }
-      
-    case LOPT_PXE_PROMT:  /* --pxe-prompt */
-       {
-	 struct dhcp_opt *new = opt_malloc(sizeof(struct dhcp_opt));
-	 int timeout;
-	 
-	 new->netid = NULL;
-	 new->opt = 10; /* PXE_MENU_PROMPT */
-
-	 while (is_tag_prefix(arg))
-	  {
-	     struct dhcp_netid *nn = opt_malloc(sizeof (struct dhcp_netid));
-	     comma = split(arg);
-	     nn->next = new->netid;
-	     new->netid = nn;
-	     nn->net = opt_string_alloc(arg+4);
-	     arg = comma;
-	   }
-	 
-	 if (!arg)
-	   ret_err(gen_err);
-	 else
-	   {
-	     comma = split(arg);
-	     unhide_metas(arg);
-	     new->len = strlen(arg) + 1;
-	     new->val = opt_malloc(new->len);
-	     memcpy(new->val + 1, arg, new->len - 1);
-	     
-	     new->u.vendor_class = (unsigned char *)"PXEClient";
-	     new->flags = DHOPT_VENDOR;
-	     
-	     if (comma && atoi_check(comma, &timeout))
-	       *(new->val) = timeout;
-	     else
-	       *(new->val) = 255;
-
-	     new->next = daemon->dhcp_opts;
-	     daemon->dhcp_opts = new;
-	     daemon->enable_pxe = 1;
-	   }
-	 
-	 break;
-       }
-       
-    case LOPT_PXE_SERV:  /* --pxe-service */
-       {
-	 struct pxe_service *new = opt_malloc(sizeof(struct pxe_service));
-	 char *CSA[] = { "x86PC", "PC98", "IA64_EFI", "Alpha", "Arc_x86", "Intel_Lean_Client",
-			 "IA32_EFI", "x86-64_EFI", "Xscale_EFI", "BC_EFI",
-			 "ARM32_EFI", "ARM64_EFI", NULL };  
-	 static int boottype = 32768;
-	 
-	 new->netid = NULL;
-	 new->sname = NULL;
-	 new->server.s_addr = 0;
-
-	 while (is_tag_prefix(arg))
-	   {
-	     struct dhcp_netid *nn = opt_malloc(sizeof (struct dhcp_netid));
-	     comma = split(arg);
-	     nn->next = new->netid;
-	     new->netid = nn;
-	     nn->net = opt_string_alloc(arg+4);
-	     arg = comma;
-	   }
-       
-	 if (arg && (comma = split(arg)))
-	   {
-	     for (i = 0; CSA[i]; i++)
-	       if (strcasecmp(CSA[i], arg) == 0)
-		 break;
-	     
-	     if (CSA[i] || atoi_check(arg, &i))
-	       {
-		 arg = comma;
-		 comma = split(arg);
-		 
-		 new->CSA = i;
-		 new->menu = opt_string_alloc(arg);
-		 
-		 if (!comma)
-		   {
-		     new->type = 0; /* local boot */
-		     new->basename = NULL;
-		   }
-		 else
-		   {
-		     arg = comma;
-		     comma = split(arg);
-		     if (atoi_check(arg, &i))
-		       {
-			 new->type = i;
-			 new->basename = NULL;
-		       }
-		     else
-		       {
-			 new->type = boottype++;
-			 new->basename = opt_string_alloc(arg);
-		       }
-		     
-		     if (comma)
-		       {
-			 if (!inet_pton(AF_INET, comma, &new->server))
-			   {
-			     new->server.s_addr = 0;
-			     new->sname = opt_string_alloc(comma);
-			   }
-		       
-		       }
-		   }
-		 
-		 /* Order matters */
-		 new->next = NULL;
-		 if (!daemon->pxe_services)
-		   daemon->pxe_services = new; 
-		 else
-		   {
-		     struct pxe_service *s;
-		     for (s = daemon->pxe_services; s->next; s = s->next);
-		     s->next = new;
-		   }
-		 
-		 daemon->enable_pxe = 1;
-		 break;
-		
-	       }
-	   }
-	 
-	 ret_err(gen_err);
-       }
-	 
-    case '4':  /* --dhcp-mac */
-      {
-	if (!(comma = split(arg)))
-	  ret_err(gen_err);
-	else
-	  {
-	    struct dhcp_mac *new = opt_malloc(sizeof(struct dhcp_mac));
-	    new->netid.net = opt_string_alloc(set_prefix(arg));
-	    unhide_metas(comma);
-	    new->hwaddr_len = parse_hex(comma, new->hwaddr, DHCP_CHADDR_MAX, &new->mask, &new->hwaddr_type);
-	    if (new->hwaddr_len == -1)
-	      ret_err(gen_err);
-	    else
-	      {
-		new->next = daemon->dhcp_macs;
-		daemon->dhcp_macs = new;
-	      }
-	  }
-      }
-      break;
-
-#ifdef OPTION6_PREFIX_CLASS 
-    case LOPT_PREF_CLSS: /* --dhcp-prefix-class */
-      {
-	struct prefix_class *new = opt_malloc(sizeof(struct prefix_class));
-	
-	if (!(comma = split(arg)) ||
-	    !atoi_check16(comma, &new->class))
-	  ret_err(gen_err);
-	
-	new->tag.net = opt_string_alloc(set_prefix(arg));
-	new->next = daemon->prefix_classes;
-	daemon->prefix_classes = new;
-	
-	break;
-      }
-#endif
-			      
-
-    case 'U':           /* --dhcp-vendorclass */
-    case 'j':           /* --dhcp-userclass */
-    case LOPT_CIRCUIT:  /* --dhcp-circuitid */
-    case LOPT_REMOTE:   /* --dhcp-remoteid */
-    case LOPT_SUBSCR:   /* --dhcp-subscrid */
-      {
-	 unsigned char *p;
-	 int dig = 0;
-	 struct dhcp_vendor *new = opt_malloc(sizeof(struct dhcp_vendor));
-	 
-	 if (!(comma = split(arg)))
-	   ret_err(gen_err);
-	
-	 new->netid.net = opt_string_alloc(set_prefix(arg));
-	 /* check for hex string - must digits may include : must not have nothing else, 
-	    only allowed for agent-options. */
-	 
-	 arg = comma;
-	 if ((comma = split(arg)))
-	   {
-	     if (option  != 'U' || strstr(arg, "enterprise:") != arg)
-	       ret_err(gen_err);
-	     else
-	       new->enterprise = atoi(arg+11);
-	   }
-	 else
-	   comma = arg;
-	 
-	 for (p = (unsigned char *)comma; *p; p++)
-	   if (isxdigit(*p))
-	     dig = 1;
-	   else if (*p != ':')
-	     break;
-	 unhide_metas(comma);
-	 if (option == 'U' || option == 'j' || *p || !dig)
-	   {
-	     new->len = strlen(comma);  
-	     new->data = opt_malloc(new->len);
-	     memcpy(new->data, comma, new->len);
-	   }
-	 else
-	   {
-	     new->len = parse_hex(comma, (unsigned char *)comma, strlen(comma), NULL, NULL);
-	     new->data = opt_malloc(new->len);
-	     memcpy(new->data, comma, new->len);
-	   }
-	 
-	 switch (option)
-	   {
-	   case 'j':
-	     new->match_type = MATCH_USER;
-	     break;
-	   case 'U':
-	     new->match_type = MATCH_VENDOR;
-	     break; 
-	   case LOPT_CIRCUIT:
-	     new->match_type = MATCH_CIRCUIT;
-	     break;
-	   case LOPT_REMOTE:
-	     new->match_type = MATCH_REMOTE;
-	     break;
-	   case LOPT_SUBSCR:
-	     new->match_type = MATCH_SUBSCRIBER;
-	     break;
-	   }
-	 new->next = daemon->dhcp_vendors;
-	 daemon->dhcp_vendors = new;
+      daemon->add_subnet4 = new;
 
-	 break;
-      }
-      
-    case LOPT_ALTPORT:   /* --dhcp-alternate-port */
-      if (!arg)
-	{
-	  daemon->dhcp_server_port = DHCP_SERVER_ALTPORT;
-	  daemon->dhcp_client_port = DHCP_CLIENT_ALTPORT;
-	}
-      else
-	{
-	  comma = split(arg);
-	  if (!atoi_check16(arg, &daemon->dhcp_server_port) || 
-	      (comma && !atoi_check16(comma, &daemon->dhcp_client_port)))
-	    ret_err(_("invalid port number"));
-	  if (!comma)
-	    daemon->dhcp_client_port = daemon->dhcp_server_port+1; 
-	}
-      break;
-
-    case 'J':            /* --dhcp-ignore */
-    case LOPT_NO_NAMES:  /* --dhcp-ignore-names */
-    case LOPT_BROADCAST: /* --dhcp-broadcast */
-    case '3':            /* --bootp-dynamic */
-    case LOPT_GEN_NAMES: /* --dhcp-generate-names */
-      {
-	struct dhcp_netid_list *new = opt_malloc(sizeof(struct dhcp_netid_list));
-	struct dhcp_netid *list = NULL;
-	if (option == 'J')
-	  {
-	    new->next = daemon->dhcp_ignore;
-	    daemon->dhcp_ignore = new;
-	  }
-	else if (option == LOPT_BROADCAST)
-	  {
-	    new->next = daemon->force_broadcast;
-	    daemon->force_broadcast = new;
-	  }
-	else if (option == '3')
-	  {
-	    new->next = daemon->bootp_dynamic;
-	    daemon->bootp_dynamic = new;
-	  }
-	else if (option == LOPT_GEN_NAMES)
-	  {
-	    new->next = daemon->dhcp_gen_names;
-	    daemon->dhcp_gen_names = new;
-	  }
-	else
-	  {
-	    new->next = daemon->dhcp_ignore_names;
-	    daemon->dhcp_ignore_names = new;
-	  }
-	
-	while (arg) {
-	  struct dhcp_netid *member = opt_malloc(sizeof(struct dhcp_netid));
-	  comma = split(arg);
-	  member->next = list;
-	  list = member;
-	  if (is_tag_prefix(arg))
-	    member->net = opt_string_alloc(arg+4);
-	  else
-	    member->net = opt_string_alloc(arg);
-	  arg = comma;
-	}
-	
-	new->list = list;
-	break;
-      }
+      if (comma) {
+        new = opt_malloc(sizeof(struct mysubnet));
+        if ((end = split_chr(comma, '/'))) {
+          /* has subnet+len */
+          err = parse_mysockaddr(comma, &new->addr);
+          if (err)
+            ret_err(err);
+          if (!atoi_check(end, &new->mask))
+            ret_err(gen_err);
+          new->addr_used = 1;
+        } else {
+          if (!atoi_check(comma, &new->mask))
+            ret_err(gen_err);
+        }
 
-    case LOPT_PROXY: /* --dhcp-proxy */
-      daemon->override = 1;
-      while (arg) {
-	struct addr_list *new = opt_malloc(sizeof(struct addr_list));
-	comma = split(arg);
-	if (!(inet_pton(AF_INET, arg, &new->addr) > 0))
-	  ret_err(_("bad dhcp-proxy address"));
-	new->next = daemon->override_relays;
-	daemon->override_relays = new;
-	arg = comma;
+        daemon->add_subnet6 = new;
       }
-      break;
+    }
+    break;
 
-    case LOPT_RELAY: /* --dhcp-relay */
-      {
-	struct dhcp_relay *new = opt_malloc(sizeof(struct dhcp_relay));
-	comma = split(arg);
-	new->interface = opt_string_alloc(split(comma));
-	new->iface_index = 0;
-	if (inet_pton(AF_INET, arg, &new->local) && inet_pton(AF_INET, comma, &new->server))
-	  {
-	    new->next = daemon->relay4;
-	    daemon->relay4 = new;
-	  }
-#ifdef HAVE_DHCP6
-	else if (inet_pton(AF_INET6, arg, &new->local) && inet_pton(AF_INET6, comma, &new->server))
-	  {
-	    new->next = daemon->relay6;
-	    daemon->relay6 = new;
-	  }
-#endif
-	else
-	  ret_err(_("Bad dhcp-relay"));
-	
-	break;
-      }
+  case '1':                    /* --enable-dbus */
+    set_option_bool(OPT_DBUS);
+    if (arg)
+      daemon->dbus_name = opt_string_alloc(arg);
+    else
+      daemon->dbus_name = DNSMASQ_SERVICE;
+    break;
+
+  case '8':                    /* --log-facility */
+    /* may be a filename */
+    if (strchr(arg, '/') || strcmp(arg, "-") == 0)
+      daemon->log_file = opt_string_alloc(arg);
+    else {
+#ifdef __ANDROID__
+      ret_err(_("setting log facility is not possible under Android"));
+#else
+      for (i = 0; facilitynames[i].c_name; i++)
+        if (hostname_isequal((char *) facilitynames[i].c_name, arg))
+          break;
 
-#endif
-      
-#ifdef HAVE_DHCP6
-    case LOPT_RA_PARAM: /* --ra-param */
-      if ((comma = split(arg)))
-	{
-	  struct ra_interface *new = opt_malloc(sizeof(struct ra_interface));
-	  new->lifetime = -1;
-	  new->prio = 0;
-	  new->mtu = 0;
-	  new->mtu_name = NULL;
-	  new->name = opt_string_alloc(arg);
-	  if (strcasestr(comma, "mtu:") == comma)
-	    {
-	      arg = comma + 4;
-	      if (!(comma = split(comma)))
-	        goto err;
-	      if (!strcasecmp(arg, "off"))
-	        new->mtu = -1;
-	      else if (!atoi_check(arg, &new->mtu))
-	        new->mtu_name = opt_string_alloc(arg);
-	      else if (new->mtu < 1280)
-	        goto err;
-	    }
-	  if (strcasestr(comma, "high") == comma || strcasestr(comma, "low") == comma)
-	    {
-	      if (*comma == 'l' || *comma == 'L')
-		new->prio = 0x18;
-	      else
-		new->prio = 0x08;
-	      comma = split(comma);
-	    }
-	   arg = split(comma);
-	   if (!atoi_check(comma, &new->interval) || 
-	      (arg && !atoi_check(arg, &new->lifetime)))
-err:
-	    ret_err(_("bad RA-params"));
-	  
-	  new->next = daemon->ra_interfaces;
-	  daemon->ra_interfaces = new;
-	}
-      break;
-      
-    case LOPT_DUID: /* --dhcp-duid */
-      if (!(comma = split(arg)) || !atoi_check(arg, (int *)&daemon->duid_enterprise))
-	ret_err(_("bad DUID"));
+      if (facilitynames[i].c_name)
+        daemon->log_fac = facilitynames[i].c_val;
       else
-	{
-	  daemon->duid_config_len = parse_hex(comma,(unsigned char *)comma, strlen(comma), NULL, NULL);
-	  daemon->duid_config = opt_malloc(daemon->duid_config_len);
-	  memcpy(daemon->duid_config, comma, daemon->duid_config_len);
-	}
-      break;
-#endif
-
-    case 'V':  /* --alias */
-      {
-	char *dash, *a[3] = { NULL, NULL, NULL };
-	int k = 0;
-	struct doctor *new = opt_malloc(sizeof(struct doctor));
-	new->next = daemon->doctors;
-	daemon->doctors = new;
-	new->mask.s_addr = 0xffffffff;
-	new->end.s_addr = 0;
-
-	if ((a[0] = arg))
-	  for (k = 1; k < 3; k++)
-	    {
-	      if (!(a[k] = split(a[k-1])))
-		break;
-	      unhide_metas(a[k]);
-	    }
-	
-	dash = split_chr(a[0], '-');
-
-	if ((k < 2) || 
-	    (!(inet_pton(AF_INET, a[0], &new->in) > 0)) ||
-	    (!(inet_pton(AF_INET, a[1], &new->out) > 0)))
-	  option = '?';
-	
-	if (k == 3 && !inet_pton(AF_INET, a[2], &new->mask))
-	  option = '?';
-	
-	if (dash && 
-	    (!(inet_pton(AF_INET, dash, &new->end) > 0) ||
-	     !is_same_net(new->in, new->end, new->mask) ||
-	     ntohl(new->in.s_addr) > ntohl(new->end.s_addr)))
-	  ret_err(_("invalid alias range"));
-	
-	break;
-      }
-      
-    case LOPT_INTNAME:  /* --interface-name */
-      {
-	struct interface_name *new, **up;
-	char *domain = NULL;
-
-	comma = split(arg);
-	
-	if (!comma || !(domain = canonicalise_opt(arg)))
-	  ret_err(_("bad interface name"));
-	
-	new = opt_malloc(sizeof(struct interface_name));
-	new->next = NULL;
-	new->addr = NULL;
-	
-	/* Add to the end of the list, so that first name
-	   of an interface is used for PTR lookups. */
-	for (up = &daemon->int_names; *up; up = &((*up)->next));
-	*up = new;
-	new->name = domain;
-	new->family = 0;
-	arg = split_chr(comma, '/');
-	if (arg)
-	  {
-	    if (strcmp(arg, "4") == 0)
-	      new->family = AF_INET;
-#ifdef HAVE_IPV6
-	    else if (strcmp(arg, "6") == 0)
-	      new->family = AF_INET6;
-#endif
-	    else
-	      ret_err(gen_err);
-	  } 
-	new->intr = opt_string_alloc(comma);
-	break;
-      }
-      
-    case LOPT_CNAME: /* --cname */
-      {
-	struct cname *new;
-	char *alias, *target, *last, *pen;
-	int ttl = -1;
-
-	for (last = pen = NULL, comma = arg; comma; comma = split(comma))
-	  {
-	    pen = last;
-	    last = comma;
-	  }
-
-	if (!pen)
-	  ret_err(_("bad CNAME"));
-	
-	if (pen != arg && atoi_check(last, &ttl))
-	  last = pen;
-	  	
-    	target = canonicalise_opt(last);
-
-	while (arg != last)
-	  {
-	    alias = canonicalise_opt(arg);
-
-	    if (!alias || !target)
-	      ret_err(_("bad CNAME"));
-	    
-	    for (new = daemon->cnames; new; new = new->next)
-	      if (hostname_isequal(new->alias, alias))
-		ret_err(_("duplicate CNAME"));
-	    new = opt_malloc(sizeof(struct cname));
-	    new->next = daemon->cnames;
-	    daemon->cnames = new;
-	    new->alias = alias;
-	    new->target = target;
-	    new->ttl = ttl;
-
-	    arg += strlen(arg)+1;
-	  }
-      
-	break;
-      }
-
-    case LOPT_PTR:  /* --ptr-record */
-      {
-	struct ptr_record *new;
-	char *dom, *target = NULL;
-
-	comma = split(arg);
-	
-	if (!(dom = canonicalise_opt(arg)) ||
-	    (comma && !(target = canonicalise_opt(comma))))
-	  ret_err(_("bad PTR record"));
-	else
-	  {
-	    new = opt_malloc(sizeof(struct ptr_record));
-	    new->next = daemon->ptr;
-	    daemon->ptr = new;
-	    new->name = dom;
-	    new->ptr = target;
-	  }
-	break;
-      }
-
-    case LOPT_NAPTR: /* --naptr-record */
-      {
-	char *a[7] = { NULL, NULL, NULL, NULL, NULL, NULL, NULL };
-	int k = 0;
-	struct naptr *new;
-	int order, pref;
-	char *name, *replace = NULL;
-
-	if ((a[0] = arg))
-	  for (k = 1; k < 7; k++)
-	    if (!(a[k] = split(a[k-1])))
-	      break;
-	
-	
-	if (k < 6 || 
-	    !(name = canonicalise_opt(a[0])) ||
-	    !atoi_check16(a[1], &order) || 
-	    !atoi_check16(a[2], &pref) ||
-	    (k == 7 && !(replace = canonicalise_opt(a[6]))))
-	  ret_err(_("bad NAPTR record"));
-	else
-	  {
-	    new = opt_malloc(sizeof(struct naptr));
-	    new->next = daemon->naptr;
-	    daemon->naptr = new;
-	    new->name = name;
-	    new->flags = opt_string_alloc(a[3]);
-	    new->services = opt_string_alloc(a[4]);
-	    new->regexp = opt_string_alloc(a[5]);
-	    new->replace = replace;
-	    new->order = order;
-	    new->pref = pref;
-	  }
-	break;
-      }
-
-    case LOPT_RR: /* dns-rr */
-      {
-       	struct txt_record *new;
-	size_t len = 0;
-	char *data;
-	int val;
-
-	comma = split(arg);
-	data = split(comma);
-		
-	new = opt_malloc(sizeof(struct txt_record));
-	new->next = daemon->rr;
-	daemon->rr = new;
-	
-	if (!atoi_check(comma, &val) || 
-	    !(new->name = canonicalise_opt(arg)) ||
-	    (data && (len = parse_hex(data, (unsigned char *)data, -1, NULL, NULL)) == -1U))
-	  ret_err(_("bad RR record"));
-	   	
-	new->class = val;
-	new->len = 0;
-	
-	if (data)
-	  {
-	    new->txt=opt_malloc(len);
-	    new->len = len;
-	    memcpy(new->txt, data, len);
-	  }
-	
-	break;
-      }
-
-    case 'Y':  /* --txt-record */
-      {
-	struct txt_record *new;
-	unsigned char *p, *cnt;
-	size_t len;
-
-	comma = split(arg);
-		
-	new = opt_malloc(sizeof(struct txt_record));
-	new->next = daemon->txt;
-	daemon->txt = new;
-	new->class = C_IN;
-	new->stat = 0;
-
-	if (!(new->name = canonicalise_opt(arg)))
-	  ret_err(_("bad TXT record"));
-	
-	len = comma ? strlen(comma) : 0;
-	len += (len/255) + 1; /* room for extra counts */
-	new->txt = p = opt_malloc(len);
-
-	cnt = p++;
-	*cnt = 0;
-	
-	while (comma && *comma)
-	  {
-	    unsigned char c = (unsigned char)*comma++;
-
-	    if (c == ',' || *cnt == 255)
-	      {
-		if (c != ',')
-		  comma--;
-		cnt = p++;
-		*cnt = 0;
-	      }
-	    else
-	      {
-		*p++ = unhide_meta(c);
-		(*cnt)++;
-	      }
-	  }
-
-	new->len = p - new->txt;
-
-	break;
-      }
-      
-    case 'W':  /* --srv-host */
-      {
-	int port = 1, priority = 0, weight = 0;
-	char *name, *target = NULL;
-	struct mx_srv_record *new;
-	
-	comma = split(arg);
-	
-	if (!(name = canonicalise_opt(arg)))
-	  ret_err(_("bad SRV record"));
-	
-	if (comma)
-	  {
-	    arg = comma;
-	    comma = split(arg);
-	    if (!(target = canonicalise_opt(arg)))
-	      ret_err(_("bad SRV target"));
-		
-	    if (comma)
-	      {
-		arg = comma;
-		comma = split(arg);
-		if (!atoi_check16(arg, &port))
-		  ret_err(_("invalid port number"));
-		
-		if (comma)
-		  {
-		    arg = comma;
-		    comma = split(arg);
-		    if (!atoi_check16(arg, &priority))
-		      ret_err(_("invalid priority"));
-			
-		    if (comma && !atoi_check16(comma, &weight))
-		      ret_err(_("invalid weight"));
-		  }
-	      }
-	  }
-	
-	new = opt_malloc(sizeof(struct mx_srv_record));
-	new->next = daemon->mxnames;
-	daemon->mxnames = new;
-	new->issrv = 1;
-	new->name = name;
-	new->target = target;
-	new->srvport = port;
-	new->priority = priority;
-	new->weight = weight;
-	break;
-      }
-      
-    case LOPT_HOST_REC: /* --host-record */
-      {
-	struct host_record *new = opt_malloc(sizeof(struct host_record));
-	memset(new, 0, sizeof(struct host_record));
-	new->ttl = -1;
-
-	if (!arg || !(comma = split(arg)))
-	  ret_err(_("Bad host-record"));
-	
-	while (arg)
-	  {
-	    struct all_addr addr;
-	    char *dig;
-
-	    for (dig = arg; *dig != 0; dig++)
-	      if (*dig < '0' || *dig > '9')
-		break;
-	    if (*dig == 0)
-	      new->ttl = atoi(arg);
-	    else if (inet_pton(AF_INET, arg, &addr))
-	      new->addr = addr.addr.addr4;
-#ifdef HAVE_IPV6
-	    else if (inet_pton(AF_INET6, arg, &addr))
-	      new->addr6 = addr.addr.addr6;
+        ret_err(_("bad log facility"));
 #endif
-	    else
-	      {
-		int nomem;
-		char *canon = canonicalise(arg, &nomem);
-		struct name_list *nl = opt_malloc(sizeof(struct name_list));
-		if (!canon)
-		  ret_err(_("Bad name in host-record"));
-
-		nl->name = canon;
-		/* keep order, so that PTR record goes to first name */
-		nl->next = NULL;
-		if (!new->names)
-		  new->names = nl;
-		else
-		  { 
-		    struct name_list *tmp;
-		    for (tmp = new->names; tmp->next; tmp = tmp->next);
-		    tmp->next = nl;
-		  }
-	      }
-	    
-	    arg = comma;
-	    comma = split(arg);
-	  }
-
-	/* Keep list order */
-	if (!daemon->host_records_tail)
-	  daemon->host_records = new;
-	else
-	  daemon->host_records_tail->next = new;
-	new->next = NULL;
-	daemon->host_records_tail = new;
-	break;
-      }
+    }
+    break;
 
-#ifdef HAVE_DNSSEC
-    case LOPT_DNSSEC_STAMP:
-      daemon->timestamp_file = opt_string_alloc(arg); 
-      break;
+  case 'x':                    /* --pid-file */
+    daemon->runfile = opt_string_alloc(arg);
+    break;
 
-    case LOPT_TRUST_ANCHOR:
-      {
-	struct ds_config *new = opt_malloc(sizeof(struct ds_config));
-      	char *cp, *cp1, *keyhex, *digest, *algo = NULL;
-	int len;
-	
-	new->class = C_IN;
-
-	if ((comma = split(arg)) && (algo = split(comma)))
-	  {
-	    int class = 0;
-	    if (strcmp(comma, "IN") == 0)
-	      class = C_IN;
-	    else if (strcmp(comma, "CH") == 0)
-	      class = C_CHAOS;
-	    else if (strcmp(comma, "HS") == 0)
-	      class = C_HESIOD;
-	    
-	    if (class != 0)
-	      {
-		new->class = class;
-		comma = algo;
-		algo = split(comma);
-	      }
-	  }
-		  
-       	if (!comma || !algo || !(digest = split(algo)) || !(keyhex = split(digest)) ||
-	    !atoi_check16(comma, &new->keytag) || 
-	    !atoi_check8(algo, &new->algo) ||
-	    !atoi_check8(digest, &new->digest_type) ||
-	    !(new->name = canonicalise_opt(arg)))
-	  ret_err(_("bad trust anchor"));
-	    
-	/* Upper bound on length */
-	len = (2*strlen(keyhex))+1;
-	new->digest = opt_malloc(len);
-	unhide_metas(keyhex);
-	/* 4034: "Whitespace is allowed within digits" */
-	for (cp = keyhex; *cp; )
-	  if (isspace(*cp))
-	    for (cp1 = cp; *cp1; cp1++)
-	      *cp1 = *(cp1+1);
-	  else
-	    cp++;
-	if ((new->digestlen = parse_hex(keyhex, (unsigned char *)new->digest, len, NULL, NULL)) == -1)
-	  ret_err(_("bad HEX in trust anchor"));
-	
-	new->next = daemon->ds;
-	daemon->ds = new;
-	
-	break;
-      }
-#endif
-		
-    default:
-      ret_err(_("unsupported option (check that dnsmasq was compiled with DHCP/TFTP/DNSSEC/DBus support)"));
-      
-    }
-  
-  return 1;
-}
+  case 'r':                    /* --resolv-file */
+    {
+      char *name = opt_string_alloc(arg);
+      struct resolvc *new, *list = daemon->resolv_files;
 
-static void read_file(char *file, FILE *f, int hard_opt)	
-{
-  volatile int lineno = 0;
-  char *buff = daemon->namebuff;
-  
-  while (fgets(buff, MAXDNAME, f))
+      if (list && list->is_default) {
+        /* replace default resolv file - possibly with nothing */
+        if (name) {
+          list->is_default = 0;
+          list->name = name;
+        } else
+          list = NULL;
+      } else if (name) {
+        new = opt_malloc(sizeof(struct resolvc));
+        new->next = list;
+        new->name = name;
+        new->is_default = 0;
+        new->mtime = 0;
+        new->logged = 0;
+        list = new;
+      }
+      daemon->resolv_files = list;
+      break;
+    }
+
+  case LOPT_SERVERS_FILE:
+    daemon->servers_file = opt_string_alloc(arg);
+    break;
+
+  case 'm':                    /* --mx-host */
+    {
+      int pref = 1;
+      struct mx_srv_record *new;
+      char *name, *target = NULL;
+
+      if ((comma = split(arg))) {
+        char *prefstr;
+        if ((prefstr = split(comma)) && !atoi_check16(prefstr, &pref))
+          ret_err(_("bad MX preference"));
+      }
+
+      if (!(name = canonicalise_opt(arg)) ||
+          (comma && !(target = canonicalise_opt(comma))))
+        ret_err(_("bad MX name"));
+
+      new = opt_malloc(sizeof(struct mx_srv_record));
+      new->next = daemon->mxnames;
+      daemon->mxnames = new;
+      new->issrv = 0;
+      new->name = name;
+      new->target = target;     /* may be NULL */
+      new->weight = pref;
+      break;
+    }
+
+  case 't':                    /*  --mx-target */
+    if (!(daemon->mxtarget = canonicalise_opt(arg)))
+      ret_err(_("bad MX target"));
+    break;
+
+#ifdef HAVE_DHCP
+  case 'l':                    /* --dhcp-leasefile */
+    daemon->lease_file = opt_string_alloc(arg);
+    break;
+
+    /* Sorry about the gross pre-processor abuse */
+  case '6':                    /* --dhcp-script */
+  case LOPT_LUASCRIPT:         /* --dhcp-luascript */
+#if defined(NO_FORK)
+    ret_err(_("cannot run scripts under uClinux"));
+#elif !defined(HAVE_SCRIPT)
+    ret_err(_
+            ("recompile with HAVE_SCRIPT defined to enable lease-change scripts"));
+#else
+    if (option == LOPT_LUASCRIPT)
+#if !defined(HAVE_LUASCRIPT)
+      ret_err(_("recompile with HAVE_LUASCRIPT defined to enable Lua scripts"));
+#else
+      daemon->luascript = opt_string_alloc(arg);
+#endif
+    else
+      daemon->lease_change_command = opt_string_alloc(arg);
+#endif
+    break;
+#endif                          /* HAVE_DHCP */
+
+  case LOPT_DHCP_HOST:         /* --dhcp-hostsfile */
+  case LOPT_DHCP_OPTS:         /* --dhcp-optsfile */
+  case LOPT_DHCP_INOTIFY:      /* --dhcp-hostsdir */
+  case LOPT_DHOPT_INOTIFY:     /* --dhcp-optsdir */
+  case LOPT_HOST_INOTIFY:      /* --hostsdir */
+  case 'H':                    /* --addn-hosts */
+    {
+      struct hostsfile *new = opt_malloc(sizeof(struct hostsfile));
+      static unsigned int hosts_index = SRC_AH;
+      new->fname = opt_string_alloc(arg);
+      new->index = hosts_index++;
+      new->flags = 0;
+      if (option == 'H') {
+        new->next = daemon->addn_hosts;
+        daemon->addn_hosts = new;
+      } else if (option == LOPT_DHCP_HOST) {
+        new->next = daemon->dhcp_hosts_file;
+        daemon->dhcp_hosts_file = new;
+      } else if (option == LOPT_DHCP_OPTS) {
+        new->next = daemon->dhcp_opts_file;
+        daemon->dhcp_opts_file = new;
+      } else {
+        new->next = daemon->dynamic_dirs;
+        daemon->dynamic_dirs = new;
+        if (option == LOPT_DHCP_INOTIFY)
+          new->flags |= AH_DHCP_HST;
+        else if (option == LOPT_DHOPT_INOTIFY)
+          new->flags |= AH_DHCP_OPT;
+        else if (option == LOPT_HOST_INOTIFY)
+          new->flags |= AH_HOSTS;
+      }
+
+      break;
+    }
+
+
+#ifdef HAVE_AUTH
+  case LOPT_AUTHSERV:          /* --auth-server */
+    if (!(comma = split(arg)))
+      ret_err(gen_err);
+
+    daemon->authserver = opt_string_alloc(arg);
+    arg = comma;
+    do {
+      struct iname *new = opt_malloc(sizeof(struct iname));
+      comma = split(arg);
+      new->name = NULL;
+      unhide_metas(arg);
+      if (inet_pton(AF_INET, arg, &new->addr.in.sin_addr) > 0)
+        new->addr.sa.sa_family = AF_INET;
+#ifdef HAVE_IPV6
+      else if (inet_pton(AF_INET6, arg, &new->addr.in6.sin6_addr) > 0)
+        new->addr.sa.sa_family = AF_INET6;
+#endif
+      else {
+        char *fam = split_chr(arg, '/');
+        new->name = opt_string_alloc(arg);
+        new->addr.sa.sa_family = 0;
+        if (fam) {
+          if (strcmp(fam, "4") == 0)
+            new->addr.sa.sa_family = AF_INET;
+#ifdef HAVE_IPV6
+          else if (strcmp(fam, "6") == 0)
+            new->addr.sa.sa_family = AF_INET6;
+#endif
+          else
+            ret_err(gen_err);
+        }
+      }
+      new->next = daemon->authinterface;
+      daemon->authinterface = new;
+
+      arg = comma;
+    } while (arg);
+
+    break;
+
+  case LOPT_AUTHSFS:           /* --auth-sec-servers */
+    {
+      struct name_list *new;
+
+      do {
+        comma = split(arg);
+        new = opt_malloc(sizeof(struct name_list));
+        new->name = opt_string_alloc(arg);
+        new->next = daemon->secondary_forward_server;
+        daemon->secondary_forward_server = new;
+        arg = comma;
+      } while (arg);
+      break;
+    }
+
+  case LOPT_AUTHZONE:          /* --auth-zone */
+    {
+      struct auth_zone *new;
+
+      comma = split(arg);
+
+      new = opt_malloc(sizeof(struct auth_zone));
+      new->domain = opt_string_alloc(arg);
+      new->subnet = NULL;
+      new->exclude = NULL;
+      new->interface_names = NULL;
+      new->next = daemon->auth_zones;
+      daemon->auth_zones = new;
+
+      while ((arg = comma)) {
+        int prefixlen = 0;
+        int is_exclude = 0;
+        char *prefix;
+        struct addrlist *subnet = NULL;
+        struct all_addr addr;
+
+        comma = split(arg);
+        prefix = split_chr(arg, '/');
+
+        if (prefix && !atoi_check(prefix, &prefixlen))
+          ret_err(gen_err);
+
+        if (strstr(arg, "exclude:") == arg) {
+          is_exclude = 1;
+          arg = arg + 8;
+        }
+
+        if (inet_pton(AF_INET, arg, &addr.addr.addr4)) {
+          subnet = opt_malloc(sizeof(struct addrlist));
+          subnet->prefixlen = (prefixlen == 0) ? 24 : prefixlen;
+          subnet->flags = ADDRLIST_LITERAL;
+        }
+#ifdef HAVE_IPV6
+        else if (inet_pton(AF_INET6, arg, &addr.addr.addr6)) {
+          subnet = opt_malloc(sizeof(struct addrlist));
+          subnet->prefixlen = (prefixlen == 0) ? 64 : prefixlen;
+          subnet->flags = ADDRLIST_LITERAL | ADDRLIST_IPV6;
+        }
+#endif
+        else {
+          struct auth_name_list *name =
+              opt_malloc(sizeof(struct auth_name_list));
+          name->name = opt_string_alloc(arg);
+          name->flags = AUTH4 | AUTH6;
+          name->next = new->interface_names;
+          new->interface_names = name;
+          if (prefix) {
+            if (prefixlen == 4)
+              name->flags &= ~AUTH6;
+#ifdef HAVE_IPV6
+            else if (prefixlen == 6)
+              name->flags &= ~AUTH4;
+#endif
+            else
+              ret_err(gen_err);
+          }
+        }
+
+        if (subnet) {
+          subnet->addr = addr;
+
+          if (is_exclude) {
+            subnet->next = new->exclude;
+            new->exclude = subnet;
+          } else {
+            subnet->next = new->subnet;
+            new->subnet = subnet;
+          }
+        }
+      }
+      break;
+    }
+
+  case LOPT_AUTHSOA:           /* --auth-soa */
+    comma = split(arg);
+    daemon->soa_sn = (u32) atoi(arg);
+    if (comma) {
+      char *cp;
+      arg = comma;
+      comma = split(arg);
+      daemon->hostmaster = opt_string_alloc(arg);
+      for (cp = daemon->hostmaster; *cp; cp++)
+        if (*cp == '@')
+          *cp = '.';
+
+      if (comma) {
+        arg = comma;
+        comma = split(arg);
+        daemon->soa_refresh = (u32) atoi(arg);
+        if (comma) {
+          arg = comma;
+          comma = split(arg);
+          daemon->soa_retry = (u32) atoi(arg);
+          if (comma)
+            daemon->soa_expiry = (u32) atoi(comma);
+        }
+      }
+    }
+
+    break;
+#endif
+
+  case 's':                    /* --domain */
+  case LOPT_SYNTH:             /* --synth-domain */
+    if (strcmp(arg, "#") == 0)
+      set_option_bool(OPT_RESOLV_DOMAIN);
+    else {
+      char *d;
+      comma = split(arg);
+      if (!(d = canonicalise_opt(arg)))
+        ret_err(gen_err);
+      else {
+        if (comma) {
+          struct cond_domain *new = opt_malloc(sizeof(struct cond_domain));
+          char *netpart;
+
+          new->prefix = NULL;
+
+          unhide_metas(comma);
+          if ((netpart = split_chr(comma, '/'))) {
+            int msize;
+
+            arg = split(netpart);
+            if (!atoi_check(netpart, &msize))
+              ret_err(gen_err);
+            else if (inet_pton(AF_INET, comma, &new->start)) {
+              int mask = (1 << (32 - msize)) - 1;
+              new->is6 = 0;
+              new->start.s_addr = ntohl(htonl(new->start.s_addr) & ~mask);
+              new->end.s_addr = new->start.s_addr | htonl(mask);
+              if (arg) {
+                if (option != 's') {
+                  if (!(new->prefix = canonicalise_opt(arg)) ||
+                      strlen(new->prefix) > MAXLABEL - INET_ADDRSTRLEN)
+                    ret_err(_("bad prefix"));
+                } else if (strcmp(arg, "local") != 0 ||
+                           (msize != 8 && msize != 16 && msize != 24))
+                  ret_err(gen_err);
+                else {
+                  /* generate the equivalent of
+                     local=/xxx.yyy.zzz.in-addr.arpa/ */
+                  struct server *serv = add_rev4(new->start, msize);
+                  if (!serv)
+                    ret_err(_("bad prefix"));
+
+                  serv->flags |= SERV_NO_ADDR;
+
+                  /* local=/<domain>/ */
+                  serv = opt_malloc(sizeof(struct server));
+                  memset(serv, 0, sizeof(struct server));
+                  serv->domain = d;
+                  serv->flags = SERV_HAS_DOMAIN | SERV_NO_ADDR;
+                  serv->next = daemon->servers;
+                  daemon->servers = serv;
+                }
+              }
+            }
+#ifdef HAVE_IPV6
+            else if (inet_pton(AF_INET6, comma, &new->start6)) {
+              u64 mask = (1LLU << (128 - msize)) - 1LLU;
+              u64 addrpart = addr6part(&new->start6);
+              new->is6 = 1;
+
+              /* prefix==64 overflows the mask calculation above */
+              if (msize == 64)
+                mask = (u64) - 1LL;
+
+              new->end6 = new->start6;
+              setaddr6part(&new->start6, addrpart & ~mask);
+              setaddr6part(&new->end6, addrpart | mask);
+
+              if (msize < 64)
+                ret_err(gen_err);
+              else if (arg) {
+                if (option != 's') {
+                  if (!(new->prefix = canonicalise_opt(arg)) ||
+                      strlen(new->prefix) > MAXLABEL - INET6_ADDRSTRLEN)
+                    ret_err(_("bad prefix"));
+                } else if (strcmp(arg, "local") != 0 || ((msize & 4) != 0))
+                  ret_err(gen_err);
+                else {
+                  /* generate the equivalent of
+                     local=/xxx.yyy.zzz.ip6.arpa/ */
+                  struct server *serv = add_rev6(&new->start6, msize);
+                  serv->flags |= SERV_NO_ADDR;
+
+                  /* local=/<domain>/ */
+                  serv = opt_malloc(sizeof(struct server));
+                  memset(serv, 0, sizeof(struct server));
+                  serv->domain = d;
+                  serv->flags = SERV_HAS_DOMAIN | SERV_NO_ADDR;
+                  serv->next = daemon->servers;
+                  daemon->servers = serv;
+                }
+              }
+            }
+#endif
+            else
+              ret_err(gen_err);
+          } else {
+            char *prefstr;
+            arg = split(comma);
+            prefstr = split(arg);
+
+            if (inet_pton(AF_INET, comma, &new->start)) {
+              new->is6 = 0;
+              if (!arg)
+                new->end.s_addr = new->start.s_addr;
+              else if (!inet_pton(AF_INET, arg, &new->end))
+                ret_err(gen_err);
+            }
+#ifdef HAVE_IPV6
+            else if (inet_pton(AF_INET6, comma, &new->start6)) {
+              new->is6 = 1;
+              if (!arg)
+                memcpy(&new->end6, &new->start6, IN6ADDRSZ);
+              else if (!inet_pton(AF_INET6, arg, &new->end6))
+                ret_err(gen_err);
+            }
+#endif
+            else
+              ret_err(gen_err);
+
+            if (option != 's' && prefstr) {
+              if (!(new->prefix = canonicalise_opt(prefstr)) ||
+                  strlen(new->prefix) > MAXLABEL - INET_ADDRSTRLEN)
+                ret_err(_("bad prefix"));
+            }
+          }
+
+          new->domain = d;
+          if (option == 's') {
+            new->next = daemon->cond_domain;
+            daemon->cond_domain = new;
+          } else {
+            new->next = daemon->synth_domains;
+            daemon->synth_domains = new;
+          }
+        } else if (option == 's')
+          daemon->domain_suffix = d;
+        else
+          ret_err(gen_err);
+      }
+    }
+    break;
+
+  case LOPT_CPE_ID:            /* --add-dns-client */
+    if (arg)
+      daemon->dns_client_id = opt_string_alloc(arg);
+    break;
+
+  case LOPT_ADD_MAC:           /* --add-mac */
+    if (!arg)
+      set_option_bool(OPT_ADD_MAC);
+    else {
+      unhide_metas(arg);
+      if (strcmp(arg, "base64") == 0)
+        set_option_bool(OPT_MAC_B64);
+      else if (strcmp(arg, "text") == 0)
+        set_option_bool(OPT_MAC_HEX);
+      else
+        ret_err(gen_err);
+    }
+    break;
+
+  case 'u':                    /* --user */
+    daemon->username = opt_string_alloc(arg);
+    break;
+
+  case 'g':                    /* --group */
+    daemon->groupname = opt_string_alloc(arg);
+    daemon->group_set = 1;
+    break;
+
+#ifdef HAVE_DHCP
+  case LOPT_SCRIPTUSR:         /* --scriptuser */
+    daemon->scriptuser = opt_string_alloc(arg);
+    break;
+#endif
+
+  case 'i':                    /* --interface */
+    do {
+      struct iname *new = opt_malloc(sizeof(struct iname));
+      comma = split(arg);
+      new->next = daemon->if_names;
+      daemon->if_names = new;
+      /* new->name may be NULL if someone does
+         "interface=" to disable all interfaces except loop. */
+      new->name = opt_string_alloc(arg);
+      new->used = 0;
+      arg = comma;
+    } while (arg);
+    break;
+
+  case LOPT_TFTP:              /* --enable-tftp */
+    set_option_bool(OPT_TFTP);
+    if (!arg)
+      break;
+    /* fall through */
+
+  case 'I':                    /* --except-interface */
+  case '2':                    /* --no-dhcp-interface */
+    do {
+      struct iname *new = opt_malloc(sizeof(struct iname));
+      comma = split(arg);
+      new->name = opt_string_alloc(arg);
+      if (option == 'I') {
+        new->next = daemon->if_except;
+        daemon->if_except = new;
+      } else if (option == LOPT_TFTP) {
+        new->next = daemon->tftp_interfaces;
+        daemon->tftp_interfaces = new;
+      } else {
+        new->next = daemon->dhcp_except;
+        daemon->dhcp_except = new;
+      }
+      arg = comma;
+    } while (arg);
+    break;
+
+  case 'B':                    /* --bogus-nxdomain */
+  case LOPT_IGNORE_ADDR:       /* --ignore-address */
+    {
+      struct in_addr addr;
+      unhide_metas(arg);
+      if (arg && (inet_pton(AF_INET, arg, &addr) > 0)) {
+        struct bogus_addr *baddr = opt_malloc(sizeof(struct bogus_addr));
+        if (option == 'B') {
+          baddr->next = daemon->bogus_addr;
+          daemon->bogus_addr = baddr;
+        } else {
+          baddr->next = daemon->ignore_addr;
+          daemon->ignore_addr = baddr;
+        }
+        baddr->addr = addr;
+      } else
+        ret_err(gen_err);       /* error */
+      break;
+    }
+
+  case 'a':                    /* --listen-address */
+  case LOPT_AUTHPEER:          /* --auth-peer */
+    do {
+      struct iname *new = opt_malloc(sizeof(struct iname));
+      comma = split(arg);
+      unhide_metas(arg);
+      if (arg && (inet_pton(AF_INET, arg, &new->addr.in.sin_addr) > 0)) {
+        new->addr.sa.sa_family = AF_INET;
+        new->addr.in.sin_port = 0;
+#ifdef HAVE_SOCKADDR_SA_LEN
+        new->addr.in.sin_len = sizeof(new->addr.in);
+#endif
+      }
+#ifdef HAVE_IPV6
+      else if (arg && inet_pton(AF_INET6, arg, &new->addr.in6.sin6_addr) > 0) {
+        new->addr.sa.sa_family = AF_INET6;
+        new->addr.in6.sin6_flowinfo = 0;
+        new->addr.in6.sin6_scope_id = 0;
+        new->addr.in6.sin6_port = 0;
+#ifdef HAVE_SOCKADDR_SA_LEN
+        new->addr.in6.sin6_len = sizeof(new->addr.in6);
+#endif
+      }
+#endif
+      else
+        ret_err(gen_err);
+
+      new->used = 0;
+      if (option == 'a') {
+        new->next = daemon->if_addrs;
+        daemon->if_addrs = new;
+      } else {
+        new->next = daemon->auth_peers;
+        daemon->auth_peers = new;
+      }
+      arg = comma;
+    } while (arg);
+    break;
+
+  case 'S':                    /*  --server */
+  case LOPT_LOCAL:             /*  --local */
+  case 'A':                    /*  --address */
+  case LOPT_NO_REBIND:         /*  --rebind-domain-ok */
+    {
+      struct server *serv, *newlist = NULL;
+
+      unhide_metas(arg);
+
+      if (arg && (*arg == '/' || option == LOPT_NO_REBIND)) {
+        int rebind = !(*arg == '/');
+        char *end = NULL;
+        if (!rebind)
+          arg++;
+        while (rebind || (end = split_chr(arg, '/'))) {
+          char *domain = NULL;
+          /* elide leading dots - they are implied in the search algorithm */
+          while (*arg == '.')
+            arg++;
+          /* # matches everything and becomes a zero length domain string */
+          if (strcmp(arg, "#") == 0)
+            domain = "";
+          else if (strlen(arg) != 0 && !(domain = canonicalise_opt(arg)))
+            option = '?';
+          serv = opt_malloc(sizeof(struct server));
+          memset(serv, 0, sizeof(struct server));
+          serv->next = newlist;
+          newlist = serv;
+          serv->domain = domain;
+          serv->flags = domain ? SERV_HAS_DOMAIN : SERV_FOR_NODOTS;
+          arg = end;
+          if (rebind)
+            break;
+        }
+        if (!newlist)
+          ret_err(gen_err);
+      } else {
+        newlist = opt_malloc(sizeof(struct server));
+        memset(newlist, 0, sizeof(struct server));
+#ifdef HAVE_LOOP
+        newlist->uid = rand32();
+#endif
+      }
+
+      if (servers_only && option == 'S')
+        newlist->flags |= SERV_FROM_FILE;
+
+      if (option == 'A') {
+        newlist->flags |= SERV_LITERAL_ADDRESS;
+        if (!(newlist->flags & SERV_TYPE))
+          ret_err(gen_err);
+      } else if (option == LOPT_NO_REBIND)
+        newlist->flags |= SERV_NO_REBIND;
+
+      if (!arg || !*arg) {
+        if (!(newlist->flags & SERV_NO_REBIND))
+          newlist->flags |= SERV_NO_ADDR;       /* no server */
+      }
+
+      else if (strcmp(arg, "#") == 0) {
+        newlist->flags |= SERV_USE_RESOLV;      /* treat in ordinary way */
+        if (newlist->flags & SERV_LITERAL_ADDRESS)
+          ret_err(gen_err);
+      } else {
+        char *err =
+            parse_server(arg, &newlist->addr, &newlist->source_addr,
+                         newlist->interface, &newlist->flags);
+        if (err)
+          ret_err(err);
+      }
+
+      serv = newlist;
+      while (serv->next) {
+        serv->next->flags = serv->flags;
+        serv->next->addr = serv->addr;
+        serv->next->source_addr = serv->source_addr;
+        strcpy(serv->next->interface, serv->interface);
+        serv = serv->next;
+      }
+      serv->next = daemon->servers;
+      daemon->servers = newlist;
+      break;
+    }
+
+  case LOPT_REV_SERV:          /* --rev-server */
+    {
+      char *string;
+      int size;
+      struct server *serv;
+      struct in_addr addr4;
+#ifdef HAVE_IPV6
+      struct in6_addr addr6;
+#endif
+
+      unhide_metas(arg);
+      if (!arg || !(comma = split(arg)) || !(string = split_chr(arg, '/'))
+          || !atoi_check(string, &size))
+        ret_err(gen_err);
+
+      if (inet_pton(AF_INET, arg, &addr4)) {
+        serv = add_rev4(addr4, size);
+        if (!serv)
+          ret_err(_("bad prefix"));
+      }
+#ifdef HAVE_IPV6
+      else if (inet_pton(AF_INET6, arg, &addr6))
+        serv = add_rev6(&addr6, size);
+#endif
+      else
+        ret_err(gen_err);
+
+      string =
+          parse_server(comma, &serv->addr, &serv->source_addr, serv->interface,
+                       &serv->flags);
+
+      if (string)
+        ret_err(string);
+
+      if (servers_only)
+        serv->flags |= SERV_FROM_FILE;
+
+      break;
+    }
+
+  case LOPT_IPSET:             /* --ipset */
+#ifndef HAVE_IPSET
+    ret_err(_("recompile with HAVE_IPSET defined to enable ipset directives"));
+    break;
+#else
+    {
+      struct ipsets ipsets_head;
+      struct ipsets *ipsets = &ipsets_head;
+      int size;
+      char *end;
+      char **sets, **sets_pos;
+      memset(ipsets, 0, sizeof(struct ipsets));
+      unhide_metas(arg);
+      if (arg && *arg == '/') {
+        arg++;
+        while ((end = split_chr(arg, '/'))) {
+          char *domain = NULL;
+          /* elide leading dots - they are implied in the search algorithm */
+          while (*arg == '.')
+            arg++;
+          /* # matches everything and becomes a zero length domain string */
+          if (strcmp(arg, "#") == 0 || !*arg)
+            domain = "";
+          else if (strlen(arg) != 0 && !(domain = canonicalise_opt(arg)))
+            option = '?';
+          ipsets->next = opt_malloc(sizeof(struct ipsets));
+          ipsets = ipsets->next;
+          memset(ipsets, 0, sizeof(struct ipsets));
+          ipsets->domain = domain;
+          arg = end;
+        }
+      } else {
+        ipsets->next = opt_malloc(sizeof(struct ipsets));
+        ipsets = ipsets->next;
+        memset(ipsets, 0, sizeof(struct ipsets));
+        ipsets->domain = "";
+      }
+      if (!arg || !*arg) {
+        option = '?';
+        break;
+      }
+      size = 2;
+      for (end = arg; *end; ++end)
+        if (*end == ',')
+          ++size;
+
+      sets = sets_pos = opt_malloc(sizeof(char *) * size);
+
+      do {
+        end = split(arg);
+        *sets_pos++ = opt_string_alloc(arg);
+        arg = end;
+      } while (end);
+      *sets_pos = 0;
+      for (ipsets = &ipsets_head; ipsets->next; ipsets = ipsets->next)
+        ipsets->next->sets = sets;
+      ipsets->next = daemon->ipsets;
+      daemon->ipsets = ipsets_head.next;
+
+      break;
+    }
+#endif
+
+  case 'c':                    /* --cache-size */
+    {
+      int size;
+
+      if (!atoi_check(arg, &size))
+        ret_err(gen_err);
+      else {
+        /* zero is OK, and means no caching. */
+
+        if (size < 0)
+          size = 0;
+        else if (size > 10000)
+          size = 10000;
+
+        daemon->cachesize = size;
+      }
+      break;
+    }
+
+  case 'p':                    /* --port */
+    if (!atoi_check16(arg, &daemon->port))
+      ret_err(gen_err);
+    break;
+
+  case LOPT_MINPORT:           /* --min-port */
+    if (!atoi_check16(arg, &daemon->min_port))
+      ret_err(gen_err);
+    break;
+
+  case LOPT_MAXPORT:           /* --max-port */
+    if (!atoi_check16(arg, &daemon->max_port))
+      ret_err(gen_err);
+    break;
+
+  case '0':                    /* --dns-forward-max */
+    if (!atoi_check(arg, &daemon->ftabsize))
+      ret_err(gen_err);
+    break;
+
+  case 'q':                    /* --log-queries */
+    set_option_bool(OPT_LOG);
+    if (arg && strcmp(arg, "extra") == 0)
+      set_option_bool(OPT_EXTRALOG);
+    break;
+
+  case LOPT_MAX_LOGS:          /* --log-async */
+    daemon->max_logs = LOG_MAX; /* default */
+    if (arg && !atoi_check(arg, &daemon->max_logs))
+      ret_err(gen_err);
+    else if (daemon->max_logs > 100)
+      daemon->max_logs = 100;
+    break;
+
+  case 'P':                    /* --edns-packet-max */
+    {
+      int i;
+      if (!atoi_check(arg, &i))
+        ret_err(gen_err);
+      daemon->edns_pktsz = (unsigned short) i;
+      break;
+    }
+
+  case 'Q':                    /* --query-port */
+    if (!atoi_check16(arg, &daemon->query_port))
+      ret_err(gen_err);
+    /* if explicitly set to zero, use single OS ephemeral port
+       and disable random ports */
+    if (daemon->query_port == 0)
+      daemon->osport = 1;
+    break;
+
+  case 'T':                    /* --local-ttl */
+  case LOPT_NEGTTL:            /* --neg-ttl */
+  case LOPT_MAXTTL:            /* --max-ttl */
+  case LOPT_MINCTTL:           /* --min-cache-ttl */
+  case LOPT_MAXCTTL:           /* --max-cache-ttl */
+  case LOPT_AUTHTTL:           /* --auth-ttl */
+  case LOPT_DHCPTTL:           /* --dhcp-ttl */
+    {
+      int ttl;
+      if (!atoi_check(arg, &ttl))
+        ret_err(gen_err);
+      else if (option == LOPT_NEGTTL)
+        daemon->neg_ttl = (unsigned long) ttl;
+      else if (option == LOPT_MAXTTL)
+        daemon->max_ttl = (unsigned long) ttl;
+      else if (option == LOPT_MINCTTL) {
+        if (ttl > TTL_FLOOR_LIMIT)
+          ttl = TTL_FLOOR_LIMIT;
+        daemon->min_cache_ttl = (unsigned long) ttl;
+      } else if (option == LOPT_MAXCTTL)
+        daemon->max_cache_ttl = (unsigned long) ttl;
+      else if (option == LOPT_AUTHTTL)
+        daemon->auth_ttl = (unsigned long) ttl;
+      else if (option == LOPT_DHCPTTL) {
+        daemon->dhcp_ttl = (unsigned long) ttl;
+        daemon->use_dhcp_ttl = 1;
+      } else
+        daemon->local_ttl = (unsigned long) ttl;
+      break;
+    }
+
+#ifdef HAVE_DHCP
+  case 'X':                    /* --dhcp-lease-max */
+    if (!atoi_check(arg, &daemon->dhcp_max))
+      ret_err(gen_err);
+    break;
+#endif
+
+#ifdef HAVE_TFTP
+  case LOPT_TFTP_MAX:          /*  --tftp-max */
+    if (!atoi_check(arg, &daemon->tftp_max))
+      ret_err(gen_err);
+    break;
+
+  case LOPT_TFTP_MTU:          /*  --tftp-mtu */
+    if (!atoi_check(arg, &daemon->tftp_mtu))
+      ret_err(gen_err);
+    break;
+
+  case LOPT_PREFIX:            /* --tftp-prefix */
+    comma = split(arg);
+    if (comma) {
+      struct tftp_prefix *new = opt_malloc(sizeof(struct tftp_prefix));
+      new->interface = opt_string_alloc(comma);
+      new->prefix = opt_string_alloc(arg);
+      new->next = daemon->if_prefix;
+      daemon->if_prefix = new;
+    } else
+      daemon->tftp_prefix = opt_string_alloc(arg);
+    break;
+
+  case LOPT_TFTPPORTS:         /* --tftp-port-range */
+    if (!(comma = split(arg)) ||
+        !atoi_check16(arg, &daemon->start_tftp_port) ||
+        !atoi_check16(comma, &daemon->end_tftp_port))
+      ret_err(_("bad port range"));
+
+    if (daemon->start_tftp_port > daemon->end_tftp_port) {
+      int tmp = daemon->start_tftp_port;
+      daemon->start_tftp_port = daemon->end_tftp_port;
+      daemon->end_tftp_port = tmp;
+    }
+
+    break;
+
+  case LOPT_APREF:             /* --tftp-unique-root */
+    if (!arg || strcasecmp(arg, "ip") == 0)
+      set_option_bool(OPT_TFTP_APREF_IP);
+    else if (strcasecmp(arg, "mac") == 0)
+      set_option_bool(OPT_TFTP_APREF_MAC);
+    else
+      ret_err(gen_err);
+    break;
+#endif
+
+  case LOPT_BRIDGE:            /* --bridge-interface */
+    {
+      struct dhcp_bridge *new = opt_malloc(sizeof(struct dhcp_bridge));
+      if (!(comma = split(arg)) || strlen(arg) > IF_NAMESIZE - 1)
+        ret_err(_("bad bridge-interface"));
+
+      strcpy(new->iface, arg);
+      new->alias = NULL;
+      new->next = daemon->bridges;
+      daemon->bridges = new;
+
+      do {
+        arg = comma;
+        comma = split(arg);
+        if (strlen(arg) != 0 && strlen(arg) <= IF_NAMESIZE - 1) {
+          struct dhcp_bridge *b = opt_malloc(sizeof(struct dhcp_bridge));
+          b->next = new->alias;
+          new->alias = b;
+          strcpy(b->iface, arg);
+        }
+      } while (comma);
+
+      break;
+    }
+
+#ifdef HAVE_DHCP
+  case 'F':                    /* --dhcp-range */
+    {
+      int k, leasepos = 2;
+      char *cp, *a[8] = { NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL };
+      struct dhcp_context *new = opt_malloc(sizeof(struct dhcp_context));
+
+      memset(new, 0, sizeof(*new));
+      new->lease_time = DEFLEASE;
+
+      if (!arg) {
+        option = '?';
+        break;
+      }
+
+      while (1) {
+        for (cp = arg; *cp; cp++)
+          if (!(*cp == ' ' || *cp == '.' || *cp == ':' ||
+                (*cp >= 'a' && *cp <= 'f') || (*cp >= 'A' && *cp <= 'F') ||
+                (*cp >= '0' && *cp <= '9')))
+            break;
+
+        if (*cp != ',' && (comma = split(arg))) {
+          if (is_tag_prefix(arg)) {
+            struct dhcp_netid *tt = opt_malloc(sizeof(struct dhcp_netid));
+            tt->net = opt_string_alloc(arg + 4);
+            tt->next = new->filter;
+            /* ignore empty tag */
+            if (tt->net)
+              new->filter = tt;
+          } else {
+            if (new->netid.net)
+              ret_err(_("only one tag allowed"));
+            else if (strstr(arg, "set:") == arg)
+              new->netid.net = opt_string_alloc(arg + 4);
+            else
+              new->netid.net = opt_string_alloc(arg);
+          }
+          arg = comma;
+        } else {
+          a[0] = arg;
+          break;
+        }
+      }
+
+      for (k = 1; k < 8; k++)
+        if (!(a[k] = split(a[k - 1])))
+          break;
+
+      if (k < 2)
+        ret_err(_("bad dhcp-range"));
+
+      if (inet_pton(AF_INET, a[0], &new->start)) {
+        new->next = daemon->dhcp;
+        daemon->dhcp = new;
+        new->end = new->start;
+        if (strcmp(a[1], "static") == 0)
+          new->flags |= CONTEXT_STATIC;
+        else if (strcmp(a[1], "proxy") == 0)
+          new->flags |= CONTEXT_PROXY;
+        else if (!inet_pton(AF_INET, a[1], &new->end))
+          ret_err(_("bad dhcp-range"));
+
+        if (ntohl(new->start.s_addr) > ntohl(new->end.s_addr)) {
+          struct in_addr tmp = new->start;
+          new->start = new->end;
+          new->end = tmp;
+        }
+
+        if (k >= 3 && strchr(a[2], '.') &&
+            (inet_pton(AF_INET, a[2], &new->netmask) > 0)) {
+          new->flags |= CONTEXT_NETMASK;
+          leasepos = 3;
+          if (!is_same_net(new->start, new->end, new->netmask))
+            ret_err(_("inconsistent DHCP range"));
+
+
+          if (k >= 4 && strchr(a[3], '.') &&
+              (inet_pton(AF_INET, a[3], &new->broadcast) > 0)) {
+            new->flags |= CONTEXT_BRDCAST;
+            leasepos = 4;
+          }
+        }
+      }
+#ifdef HAVE_DHCP6
+      else if (inet_pton(AF_INET6, a[0], &new->start6)) {
+        new->flags |= CONTEXT_V6;
+        new->prefix = 64;       /* default */
+        new->end6 = new->start6;
+        new->next = daemon->dhcp6;
+        daemon->dhcp6 = new;
+
+        for (leasepos = 1; leasepos < k; leasepos++) {
+          if (strcmp(a[leasepos], "static") == 0)
+            new->flags |= CONTEXT_STATIC | CONTEXT_DHCP;
+          else if (strcmp(a[leasepos], "ra-only") == 0
+                   || strcmp(a[leasepos], "slaac") == 0)
+            new->flags |= CONTEXT_RA;
+          else if (strcmp(a[leasepos], "ra-names") == 0)
+            new->flags |= CONTEXT_RA_NAME | CONTEXT_RA;
+          else if (strcmp(a[leasepos], "ra-advrouter") == 0)
+            new->flags |= CONTEXT_RA_ROUTER | CONTEXT_RA;
+          else if (strcmp(a[leasepos], "ra-stateless") == 0)
+            new->flags |= CONTEXT_RA_STATELESS | CONTEXT_DHCP | CONTEXT_RA;
+          else if (strcmp(a[leasepos], "off-link") == 0)
+            new->flags |= CONTEXT_RA_OFF_LINK;
+          else if (leasepos == 1
+                   && inet_pton(AF_INET6, a[leasepos], &new->end6))
+            new->flags |= CONTEXT_DHCP;
+          else if (strstr(a[leasepos], "constructor:") == a[leasepos]) {
+            new->template_interface = opt_string_alloc(a[leasepos] + 12);
+            new->flags |= CONTEXT_TEMPLATE;
+          } else
+            break;
+        }
+
+        /* bare integer < 128 is prefix value */
+        if (leasepos < k) {
+          int pref;
+          for (cp = a[leasepos]; *cp; cp++)
+            if (!(*cp >= '0' && *cp <= '9'))
+              break;
+          if (!*cp && (pref = atoi(a[leasepos])) <= 128) {
+            new->prefix = pref;
+            leasepos++;
+          }
+        }
+
+        if (new->prefix != 64) {
+          if (new->flags & CONTEXT_RA)
+            ret_err(_("prefix length must be exactly 64 for RA subnets"));
+          else if (new->flags & CONTEXT_TEMPLATE)
+            ret_err(_
+                    ("prefix length must be exactly 64 for subnet constructors"));
+        }
+
+        if (new->prefix < 64)
+          ret_err(_("prefix length must be at least 64"));
+
+        if (!is_same_net6(&new->start6, &new->end6, new->prefix))
+          ret_err(_("inconsistent DHCPv6 range"));
+
+        /* dhcp-range=:: enables DHCP stateless on any interface */
+        if (IN6_IS_ADDR_UNSPECIFIED(&new->start6)
+            && !(new->flags & CONTEXT_TEMPLATE))
+          new->prefix = 0;
+
+        if (new->flags & CONTEXT_TEMPLATE) {
+          struct in6_addr zero;
+          memset(&zero, 0, sizeof(zero));
+          if (!is_same_net6(&zero, &new->start6, new->prefix))
+            ret_err(_("prefix must be zero with \"constructor:\" argument"));
+        }
+
+        if (addr6part(&new->start6) > addr6part(&new->end6)) {
+          struct in6_addr tmp = new->start6;
+          new->start6 = new->end6;
+          new->end6 = tmp;
+        }
+      }
+#endif
+      else
+        ret_err(_("bad dhcp-range"));
+
+      if (leasepos < k) {
+        if (leasepos != k - 1)
+          ret_err(_("bad dhcp-range"));
+
+        if (strcmp(a[leasepos], "infinite") == 0)
+          new->lease_time = 0xffffffff;
+        else if (strcmp(a[leasepos], "deprecated") == 0)
+          new->flags |= CONTEXT_DEPRECATE;
+        else {
+          int fac = 1;
+          if (strlen(a[leasepos]) > 0) {
+            switch (a[leasepos][strlen(a[leasepos]) - 1]) {
+            case 'w':
+            case 'W':
+              fac *= 7;
+              /* fall through */
+            case 'd':
+            case 'D':
+              fac *= 24;
+              /* fall though */
+            case 'h':
+            case 'H':
+              fac *= 60;
+              /* fall through */
+            case 'm':
+            case 'M':
+              fac *= 60;
+              /* fall through */
+            case 's':
+            case 'S':
+              a[leasepos][strlen(a[leasepos]) - 1] = 0;
+            }
+
+            for (cp = a[leasepos]; *cp; cp++)
+              if (!(*cp >= '0' && *cp <= '9'))
+                break;
+
+            if (*cp || (leasepos + 1 < k))
+              ret_err(_("bad dhcp-range"));
+
+            new->lease_time = atoi(a[leasepos]) * fac;
+            /* Leases of a minute or less confuse
+               some clients, notably Apple's */
+            if (new->lease_time < 120)
+              new->lease_time = 120;
+          }
+        }
+      }
+      break;
+    }
+
+  case LOPT_BANK:
+  case 'G':                    /* --dhcp-host */
+    {
+      int j, k = 0;
+      char *a[7] = { NULL, NULL, NULL, NULL, NULL, NULL, NULL };
+      struct dhcp_config *new;
+      struct in_addr in;
+
+      new = opt_malloc(sizeof(struct dhcp_config));
+
+      new->next = daemon->dhcp_conf;
+      new->flags = (option == LOPT_BANK) ? CONFIG_BANK : 0;
+      new->hwaddr = NULL;
+      new->netid = NULL;
+
+      if ((a[0] = arg))
+        for (k = 1; k < 7; k++)
+          if (!(a[k] = split(a[k - 1])))
+            break;
+
+      for (j = 0; j < k; j++)
+        if (strchr(a[j], ':')) {        /* ethernet address, netid or binary CLID */
+          char *arg = a[j];
+
+          if ((arg[0] == 'i' || arg[0] == 'I') &&
+              (arg[1] == 'd' || arg[1] == 'D') && arg[2] == ':') {
+            if (arg[3] == '*')
+              new->flags |= CONFIG_NOCLID;
+            else {
+              int len;
+              arg += 3;         /* dump id: */
+              if (strchr(arg, ':'))
+                len = parse_hex(arg, (unsigned char *) arg, -1, NULL, NULL);
+              else {
+                unhide_metas(arg);
+                len = (int) strlen(arg);
+              }
+
+              if (len == -1)
+                ret_err(_("bad hex constant"));
+              else if ((new->clid = opt_malloc(len))) {
+                new->flags |= CONFIG_CLID;
+                new->clid_len = len;
+                memcpy(new->clid, arg, len);
+              }
+            }
+          }
+          /* dhcp-host has strange backwards-compat needs. */
+          else if (strstr(arg, "net:") == arg || strstr(arg, "set:") == arg) {
+            struct dhcp_netid *newtag = opt_malloc(sizeof(struct dhcp_netid));
+            struct dhcp_netid_list *newlist =
+                opt_malloc(sizeof(struct dhcp_netid_list));
+            newtag->net = opt_malloc(strlen(arg + 4) + 1);
+            newlist->next = new->netid;
+            new->netid = newlist;
+            newlist->list = newtag;
+            strcpy(newtag->net, arg + 4);
+            unhide_metas(newtag->net);
+          } else if (strstr(arg, "tag:") == arg)
+            ret_err(_("cannot match tags in --dhcp-host"));
+#ifdef HAVE_DHCP6
+          else if (arg[0] == '[' && arg[strlen(arg) - 1] == ']') {
+            arg[strlen(arg) - 1] = 0;
+            arg++;
+
+            if (!inet_pton(AF_INET6, arg, &new->addr6))
+              ret_err(_("bad IPv6 address"));
+
+            for (i = 0; i < 8; i++)
+              if (new->addr6.s6_addr[i] != 0)
+                break;
+
+            /* set WILDCARD if network part all zeros */
+            if (i == 8)
+              new->flags |= CONFIG_WILDCARD;
+
+            new->flags |= CONFIG_ADDR6;
+          }
+#endif
+          else {
+            struct hwaddr_config *newhw =
+                opt_malloc(sizeof(struct hwaddr_config));
+            if ((newhw->hwaddr_len =
+                 parse_hex(a[j], newhw->hwaddr, DHCP_CHADDR_MAX,
+                           &newhw->wildcard_mask, &newhw->hwaddr_type)) == -1)
+              ret_err(_("bad hex constant"));
+            else {
+
+              newhw->next = new->hwaddr;
+              new->hwaddr = newhw;
+            }
+          }
+        } else if (strchr(a[j], '.') && (inet_pton(AF_INET, a[j], &in) > 0)) {
+          struct dhcp_config *configs;
+
+          new->addr = in;
+          new->flags |= CONFIG_ADDR;
+
+          /* If the same IP appears in more than one host config, then DISCOVER
+             for one of the hosts will get the address, but REQUEST will be NAKed,
+             since the address is reserved by the other one -> protocol loop. */
+          for (configs = daemon->dhcp_conf; configs; configs = configs->next)
+            if ((configs->flags & CONFIG_ADDR)
+                && configs->addr.s_addr == in.s_addr) {
+              sprintf(errstr, _("duplicate dhcp-host IP address %s"),
+                      inet_ntoa(in));
+              return 0;
+            }
+        } else {
+          char *cp, *lastp = NULL, last = 0;
+          int fac = 1, isdig = 0;
+
+          if (strlen(a[j]) > 1) {
+            lastp = a[j] + strlen(a[j]) - 1;
+            last = *lastp;
+            switch (last) {
+            case 'w':
+            case 'W':
+              fac *= 7;
+              /* fall through */
+            case 'd':
+            case 'D':
+              fac *= 24;
+              /* fall through */
+            case 'h':
+            case 'H':
+              fac *= 60;
+              /* fall through */
+            case 'm':
+            case 'M':
+              fac *= 60;
+              /* fall through */
+            case 's':
+            case 'S':
+              *lastp = 0;
+            }
+          }
+
+          for (cp = a[j]; *cp; cp++)
+            if (isdigit((unsigned char) *cp))
+              isdig = 1;
+            else if (*cp != ' ')
+              break;
+
+          if (*cp) {
+            if (lastp)
+              *lastp = last;
+            if (strcmp(a[j], "infinite") == 0) {
+              new->lease_time = 0xffffffff;
+              new->flags |= CONFIG_TIME;
+            } else if (strcmp(a[j], "ignore") == 0)
+              new->flags |= CONFIG_DISABLE;
+            else {
+              if (!(new->hostname = canonicalise_opt(a[j])) ||
+                  !legal_hostname(new->hostname))
+                ret_err(_("bad DHCP host name"));
+
+              new->flags |= CONFIG_NAME;
+              new->domain = strip_hostname(new->hostname);
+            }
+          } else if (isdig) {
+            new->lease_time = atoi(a[j]) * fac;
+            /* Leases of a minute or less confuse
+               some clients, notably Apple's */
+            if (new->lease_time < 120)
+              new->lease_time = 120;
+            new->flags |= CONFIG_TIME;
+          }
+        }
+
+      daemon->dhcp_conf = new;
+      break;
+    }
+
+  case LOPT_TAG_IF:            /* --tag-if */
+    {
+      struct tag_if *new = opt_malloc(sizeof(struct tag_if));
+
+      new->tag = NULL;
+      new->set = NULL;
+      new->next = NULL;
+
+      /* preserve order */
+      if (!daemon->tag_if)
+        daemon->tag_if = new;
+      else {
+        struct tag_if *tmp;
+        for (tmp = daemon->tag_if; tmp->next; tmp = tmp->next);
+        tmp->next = new;
+      }
+
+      while (arg) {
+        size_t len;
+
+        comma = split(arg);
+        len = strlen(arg);
+
+        if (len < 5) {
+          new->set = NULL;
+          break;
+        } else {
+          struct dhcp_netid *newtag = opt_malloc(sizeof(struct dhcp_netid));
+          newtag->net = opt_malloc(len - 3);
+          strcpy(newtag->net, arg + 4);
+          unhide_metas(newtag->net);
+
+          if (strstr(arg, "set:") == arg) {
+            struct dhcp_netid_list *newlist =
+                opt_malloc(sizeof(struct dhcp_netid_list));
+            newlist->next = new->set;
+            new->set = newlist;
+            newlist->list = newtag;
+          } else if (strstr(arg, "tag:") == arg) {
+            newtag->next = new->tag;
+            new->tag = newtag;
+          } else {
+            new->set = NULL;
+            free(newtag);
+            break;
+          }
+        }
+
+        arg = comma;
+      }
+
+      if (!new->set)
+        ret_err(_("bad tag-if"));
+
+      break;
+    }
+
+
+  case 'O':                    /* --dhcp-option */
+  case LOPT_FORCE:             /* --dhcp-option-force */
+  case LOPT_OPTS:
+  case LOPT_MATCH:             /* --dhcp-match */
+    return parse_dhcp_opt(errstr, arg,
+                          option == LOPT_FORCE ? DHOPT_FORCE :
+                          (option == LOPT_MATCH ? DHOPT_MATCH :
+                           (option == LOPT_OPTS ? DHOPT_BANK : 0)));
+
+  case 'M':                    /* --dhcp-boot */
+    {
+      struct dhcp_netid *id = NULL;
+      while (is_tag_prefix(arg)) {
+        struct dhcp_netid *newid = opt_malloc(sizeof(struct dhcp_netid));
+        newid->next = id;
+        id = newid;
+        comma = split(arg);
+        newid->net = opt_string_alloc(arg + 4);
+        arg = comma;
+      };
+
+      if (!arg)
+        ret_err(gen_err);
+      else {
+        char *dhcp_file, *dhcp_sname = NULL, *tftp_sname = NULL;
+        struct in_addr dhcp_next_server;
+        struct dhcp_boot *new;
+        comma = split(arg);
+        dhcp_file = opt_string_alloc(arg);
+        dhcp_next_server.s_addr = 0;
+        if (comma) {
+          arg = comma;
+          comma = split(arg);
+          dhcp_sname = opt_string_alloc(arg);
+          if (comma) {
+            unhide_metas(comma);
+            if (!(inet_pton(AF_INET, comma, &dhcp_next_server) > 0)) {
+              /*
+               * The user may have specified the tftp hostname here.
+               * save it so that it can be resolved/looked up during
+               * actual dhcp_reply().
+               */
+
+              tftp_sname = opt_string_alloc(comma);
+              dhcp_next_server.s_addr = 0;
+            }
+          }
+        }
+
+        new = opt_malloc(sizeof(struct dhcp_boot));
+        new->file = dhcp_file;
+        new->sname = dhcp_sname;
+        new->tftp_sname = tftp_sname;
+        new->next_server = dhcp_next_server;
+        new->netid = id;
+        new->next = daemon->boot_config;
+        daemon->boot_config = new;
+      }
+
+      break;
+    }
+
+  case LOPT_REPLY_DELAY:       /* --dhcp-reply-delay */
+    {
+      struct dhcp_netid *id = NULL;
+      while (is_tag_prefix(arg)) {
+        struct dhcp_netid *newid = opt_malloc(sizeof(struct dhcp_netid));
+        newid->next = id;
+        id = newid;
+        comma = split(arg);
+        newid->net = opt_string_alloc(arg + 4);
+        arg = comma;
+      };
+
+      if (!arg)
+        ret_err(gen_err);
+      else {
+        struct delay_config *new;
+        int delay;
+        if (!atoi_check(arg, &delay))
+          ret_err(gen_err);
+
+        new = opt_malloc(sizeof(struct delay_config));
+        new->delay = delay;
+        new->netid = id;
+        new->next = daemon->delay_conf;
+        daemon->delay_conf = new;
+      }
+
+      break;
+    }
+
+  case LOPT_PXE_PROMT:         /* --pxe-prompt */
+    {
+      struct dhcp_opt *new = opt_malloc(sizeof(struct dhcp_opt));
+      int timeout;
+
+      new->netid = NULL;
+      new->opt = 10;            /* PXE_MENU_PROMPT */
+
+      while (is_tag_prefix(arg)) {
+        struct dhcp_netid *nn = opt_malloc(sizeof(struct dhcp_netid));
+        comma = split(arg);
+        nn->next = new->netid;
+        new->netid = nn;
+        nn->net = opt_string_alloc(arg + 4);
+        arg = comma;
+      }
+
+      if (!arg)
+        ret_err(gen_err);
+      else {
+        comma = split(arg);
+        unhide_metas(arg);
+        new->len = strlen(arg) + 1;
+        new->val = opt_malloc(new->len);
+        memcpy(new->val + 1, arg, new->len - 1);
+
+        new->u.vendor_class = (unsigned char *) "PXEClient";
+        new->flags = DHOPT_VENDOR;
+
+        if (comma && atoi_check(comma, &timeout))
+          *(new->val) = timeout;
+        else
+          *(new->val) = 255;
+
+        new->next = daemon->dhcp_opts;
+        daemon->dhcp_opts = new;
+        daemon->enable_pxe = 1;
+      }
+
+      break;
+    }
+
+  case LOPT_PXE_SERV:          /* --pxe-service */
+    {
+      struct pxe_service *new = opt_malloc(sizeof(struct pxe_service));
+      char *CSA[] =
+          { "x86PC", "PC98", "IA64_EFI", "Alpha", "Arc_x86",
+  "Intel_Lean_Client",
+        "IA32_EFI", "x86-64_EFI", "Xscale_EFI", "BC_EFI",
+        "ARM32_EFI", "ARM64_EFI", NULL
+      };
+      static int boottype = 32768;
+
+      new->netid = NULL;
+      new->sname = NULL;
+      new->server.s_addr = 0;
+
+      while (is_tag_prefix(arg)) {
+        struct dhcp_netid *nn = opt_malloc(sizeof(struct dhcp_netid));
+        comma = split(arg);
+        nn->next = new->netid;
+        new->netid = nn;
+        nn->net = opt_string_alloc(arg + 4);
+        arg = comma;
+      }
+
+      if (arg && (comma = split(arg))) {
+        for (i = 0; CSA[i]; i++)
+          if (strcasecmp(CSA[i], arg) == 0)
+            break;
+
+        if (CSA[i] || atoi_check(arg, &i)) {
+          arg = comma;
+          comma = split(arg);
+
+          new->CSA = i;
+          new->menu = opt_string_alloc(arg);
+
+          if (!comma) {
+            new->type = 0;      /* local boot */
+            new->basename = NULL;
+          } else {
+            arg = comma;
+            comma = split(arg);
+            if (atoi_check(arg, &i)) {
+              new->type = i;
+              new->basename = NULL;
+            } else {
+              new->type = boottype++;
+              new->basename = opt_string_alloc(arg);
+            }
+
+            if (comma) {
+              if (!inet_pton(AF_INET, comma, &new->server)) {
+                new->server.s_addr = 0;
+                new->sname = opt_string_alloc(comma);
+              }
+
+            }
+          }
+
+          /* Order matters */
+          new->next = NULL;
+          if (!daemon->pxe_services)
+            daemon->pxe_services = new;
+          else {
+            struct pxe_service *s;
+            for (s = daemon->pxe_services; s->next; s = s->next);
+            s->next = new;
+          }
+
+          daemon->enable_pxe = 1;
+          break;
+
+        }
+      }
+
+      ret_err(gen_err);
+    }
+
+  case '4':                    /* --dhcp-mac */
+    {
+      if (!(comma = split(arg)))
+        ret_err(gen_err);
+      else {
+        struct dhcp_mac *new = opt_malloc(sizeof(struct dhcp_mac));
+        new->netid.net = opt_string_alloc(set_prefix(arg));
+        unhide_metas(comma);
+        new->hwaddr_len =
+            parse_hex(comma, new->hwaddr, DHCP_CHADDR_MAX, &new->mask,
+                      &new->hwaddr_type);
+        if (new->hwaddr_len == -1)
+          ret_err(gen_err);
+        else {
+          new->next = daemon->dhcp_macs;
+          daemon->dhcp_macs = new;
+        }
+      }
+    }
+    break;
+
+#ifdef OPTION6_PREFIX_CLASS
+  case LOPT_PREF_CLSS:         /* --dhcp-prefix-class */
+    {
+      struct prefix_class *new = opt_malloc(sizeof(struct prefix_class));
+
+      if (!(comma = split(arg)) || !atoi_check16(comma, &new->class))
+        ret_err(gen_err);
+
+      new->tag.net = opt_string_alloc(set_prefix(arg));
+      new->next = daemon->prefix_classes;
+      daemon->prefix_classes = new;
+
+      break;
+    }
+#endif
+
+
+  case 'U':                    /* --dhcp-vendorclass */
+  case 'j':                    /* --dhcp-userclass */
+  case LOPT_CIRCUIT:           /* --dhcp-circuitid */
+  case LOPT_REMOTE:            /* --dhcp-remoteid */
+  case LOPT_SUBSCR:            /* --dhcp-subscrid */
+    {
+      unsigned char *p;
+      int dig = 0;
+      struct dhcp_vendor *new = opt_malloc(sizeof(struct dhcp_vendor));
+
+      if (!(comma = split(arg)))
+        ret_err(gen_err);
+
+      new->netid.net = opt_string_alloc(set_prefix(arg));
+      /* check for hex string - must digits may include : must not have nothing else,
+         only allowed for agent-options. */
+
+      arg = comma;
+      if ((comma = split(arg))) {
+        if (option != 'U' || strstr(arg, "enterprise:") != arg)
+          ret_err(gen_err);
+        else
+          new->enterprise = atoi(arg + 11);
+      } else
+        comma = arg;
+
+      for (p = (unsigned char *) comma; *p; p++)
+        if (isxdigit(*p))
+          dig = 1;
+        else if (*p != ':')
+          break;
+      unhide_metas(comma);
+      if (option == 'U' || option == 'j' || *p || !dig) {
+        new->len = strlen(comma);
+        new->data = opt_malloc(new->len);
+        memcpy(new->data, comma, new->len);
+      } else {
+        new->len =
+            parse_hex(comma, (unsigned char *) comma, strlen(comma), NULL,
+                      NULL);
+        new->data = opt_malloc(new->len);
+        memcpy(new->data, comma, new->len);
+      }
+
+      switch (option) {
+      case 'j':
+        new->match_type = MATCH_USER;
+        break;
+      case 'U':
+        new->match_type = MATCH_VENDOR;
+        break;
+      case LOPT_CIRCUIT:
+        new->match_type = MATCH_CIRCUIT;
+        break;
+      case LOPT_REMOTE:
+        new->match_type = MATCH_REMOTE;
+        break;
+      case LOPT_SUBSCR:
+        new->match_type = MATCH_SUBSCRIBER;
+        break;
+      }
+      new->next = daemon->dhcp_vendors;
+      daemon->dhcp_vendors = new;
+
+      break;
+    }
+
+  case LOPT_ALTPORT:           /* --dhcp-alternate-port */
+    if (!arg) {
+      daemon->dhcp_server_port = DHCP_SERVER_ALTPORT;
+      daemon->dhcp_client_port = DHCP_CLIENT_ALTPORT;
+    } else {
+      comma = split(arg);
+      if (!atoi_check16(arg, &daemon->dhcp_server_port) ||
+          (comma && !atoi_check16(comma, &daemon->dhcp_client_port)))
+        ret_err(_("invalid port number"));
+      if (!comma)
+        daemon->dhcp_client_port = daemon->dhcp_server_port + 1;
+    }
+    break;
+
+  case 'J':                    /* --dhcp-ignore */
+  case LOPT_NO_NAMES:          /* --dhcp-ignore-names */
+  case LOPT_BROADCAST:         /* --dhcp-broadcast */
+  case '3':                    /* --bootp-dynamic */
+  case LOPT_GEN_NAMES:         /* --dhcp-generate-names */
+    {
+      struct dhcp_netid_list *new = opt_malloc(sizeof(struct dhcp_netid_list));
+      struct dhcp_netid *list = NULL;
+      if (option == 'J') {
+        new->next = daemon->dhcp_ignore;
+        daemon->dhcp_ignore = new;
+      } else if (option == LOPT_BROADCAST) {
+        new->next = daemon->force_broadcast;
+        daemon->force_broadcast = new;
+      } else if (option == '3') {
+        new->next = daemon->bootp_dynamic;
+        daemon->bootp_dynamic = new;
+      } else if (option == LOPT_GEN_NAMES) {
+        new->next = daemon->dhcp_gen_names;
+        daemon->dhcp_gen_names = new;
+      } else {
+        new->next = daemon->dhcp_ignore_names;
+        daemon->dhcp_ignore_names = new;
+      }
+
+      while (arg) {
+        struct dhcp_netid *member = opt_malloc(sizeof(struct dhcp_netid));
+        comma = split(arg);
+        member->next = list;
+        list = member;
+        if (is_tag_prefix(arg))
+          member->net = opt_string_alloc(arg + 4);
+        else
+          member->net = opt_string_alloc(arg);
+        arg = comma;
+      }
+
+      new->list = list;
+      break;
+    }
+
+  case LOPT_PROXY:             /* --dhcp-proxy */
+    daemon->override = 1;
+    while (arg) {
+      struct addr_list *new = opt_malloc(sizeof(struct addr_list));
+      comma = split(arg);
+      if (!(inet_pton(AF_INET, arg, &new->addr) > 0))
+        ret_err(_("bad dhcp-proxy address"));
+      new->next = daemon->override_relays;
+      daemon->override_relays = new;
+      arg = comma;
+    }
+    break;
+
+  case LOPT_RELAY:             /* --dhcp-relay */
+    {
+      struct dhcp_relay *new = opt_malloc(sizeof(struct dhcp_relay));
+      comma = split(arg);
+      new->interface = opt_string_alloc(split(comma));
+      new->iface_index = 0;
+      if (inet_pton(AF_INET, arg, &new->local)
+          && inet_pton(AF_INET, comma, &new->server)) {
+        new->next = daemon->relay4;
+        daemon->relay4 = new;
+      }
+#ifdef HAVE_DHCP6
+      else if (inet_pton(AF_INET6, arg, &new->local)
+               && inet_pton(AF_INET6, comma, &new->server)) {
+        new->next = daemon->relay6;
+        daemon->relay6 = new;
+      }
+#endif
+      else
+        ret_err(_("Bad dhcp-relay"));
+
+      break;
+    }
+
+#endif
+
+#ifdef HAVE_DHCP6
+  case LOPT_RA_PARAM:          /* --ra-param */
+    if ((comma = split(arg))) {
+      struct ra_interface *new = opt_malloc(sizeof(struct ra_interface));
+      new->lifetime = -1;
+      new->prio = 0;
+      new->mtu = 0;
+      new->mtu_name = NULL;
+      new->name = opt_string_alloc(arg);
+      if (strcasestr(comma, "mtu:") == comma) {
+        arg = comma + 4;
+        if (!(comma = split(comma)))
+          goto err;
+        if (!strcasecmp(arg, "off"))
+          new->mtu = -1;
+        else if (!atoi_check(arg, &new->mtu))
+          new->mtu_name = opt_string_alloc(arg);
+        else if (new->mtu < 1280)
+          goto err;
+      }
+      if (strcasestr(comma, "high") == comma
+          || strcasestr(comma, "low") == comma) {
+        if (*comma == 'l' || *comma == 'L')
+          new->prio = 0x18;
+        else
+          new->prio = 0x08;
+        comma = split(comma);
+      }
+      arg = split(comma);
+      if (!atoi_check(comma, &new->interval) ||
+          (arg && !atoi_check(arg, &new->lifetime)))
+      err:
+        ret_err(_("bad RA-params"));
+
+      new->next = daemon->ra_interfaces;
+      daemon->ra_interfaces = new;
+    }
+    break;
+
+  case LOPT_DUID:              /* --dhcp-duid */
+    if (!(comma = split(arg))
+        || !atoi_check(arg, (int *) &daemon->duid_enterprise))
+      ret_err(_("bad DUID"));
+    else {
+      daemon->duid_config_len =
+          parse_hex(comma, (unsigned char *) comma, strlen(comma), NULL, NULL);
+      daemon->duid_config = opt_malloc(daemon->duid_config_len);
+      memcpy(daemon->duid_config, comma, daemon->duid_config_len);
+    }
+    break;
+#endif
+
+  case 'V':                    /* --alias */
+    {
+      char *dash, *a[3] = { NULL, NULL, NULL };
+      int k = 0;
+      struct doctor *new = opt_malloc(sizeof(struct doctor));
+      new->next = daemon->doctors;
+      daemon->doctors = new;
+      new->mask.s_addr = 0xffffffff;
+      new->end.s_addr = 0;
+
+      if ((a[0] = arg))
+        for (k = 1; k < 3; k++) {
+          if (!(a[k] = split(a[k - 1])))
+            break;
+          unhide_metas(a[k]);
+        }
+
+      dash = split_chr(a[0], '-');
+
+      if ((k < 2) ||
+          (!(inet_pton(AF_INET, a[0], &new->in) > 0)) ||
+          (!(inet_pton(AF_INET, a[1], &new->out) > 0)))
+        option = '?';
+
+      if (k == 3 && !inet_pton(AF_INET, a[2], &new->mask))
+        option = '?';
+
+      if (dash &&
+          (!(inet_pton(AF_INET, dash, &new->end) > 0) ||
+           !is_same_net(new->in, new->end, new->mask) ||
+           ntohl(new->in.s_addr) > ntohl(new->end.s_addr)))
+        ret_err(_("invalid alias range"));
+
+      break;
+    }
+
+  case LOPT_INTNAME:           /* --interface-name */
+    {
+      struct interface_name *new, **up;
+      char *domain = NULL;
+
+      comma = split(arg);
+
+      if (!comma || !(domain = canonicalise_opt(arg)))
+        ret_err(_("bad interface name"));
+
+      new = opt_malloc(sizeof(struct interface_name));
+      new->next = NULL;
+      new->addr = NULL;
+
+      /* Add to the end of the list, so that first name
+         of an interface is used for PTR lookups. */
+      for (up = &daemon->int_names; *up; up = &((*up)->next));
+      *up = new;
+      new->name = domain;
+      new->family = 0;
+      arg = split_chr(comma, '/');
+      if (arg) {
+        if (strcmp(arg, "4") == 0)
+          new->family = AF_INET;
+#ifdef HAVE_IPV6
+        else if (strcmp(arg, "6") == 0)
+          new->family = AF_INET6;
+#endif
+        else
+          ret_err(gen_err);
+      }
+      new->intr = opt_string_alloc(comma);
+      break;
+    }
+
+  case LOPT_CNAME:             /* --cname */
+    {
+      struct cname *new;
+      char *alias, *target, *last, *pen;
+      int ttl = -1;
+
+      for (last = pen = NULL, comma = arg; comma; comma = split(comma)) {
+        pen = last;
+        last = comma;
+      }
+
+      if (!pen)
+        ret_err(_("bad CNAME"));
+
+      if (pen != arg && atoi_check(last, &ttl))
+        last = pen;
+
+      target = canonicalise_opt(last);
+
+      while (arg != last) {
+        alias = canonicalise_opt(arg);
+
+        if (!alias || !target)
+          ret_err(_("bad CNAME"));
+
+        for (new = daemon->cnames; new; new = new->next)
+          if (hostname_isequal(new->alias, alias))
+            ret_err(_("duplicate CNAME"));
+        new = opt_malloc(sizeof(struct cname));
+        new->next = daemon->cnames;
+        daemon->cnames = new;
+        new->alias = alias;
+        new->target = target;
+        new->ttl = ttl;
+
+        arg += strlen(arg) + 1;
+      }
+
+      break;
+    }
+
+  case LOPT_PTR:               /* --ptr-record */
+    {
+      struct ptr_record *new;
+      char *dom, *target = NULL;
+
+      comma = split(arg);
+
+      if (!(dom = canonicalise_opt(arg)) ||
+          (comma && !(target = canonicalise_opt(comma))))
+        ret_err(_("bad PTR record"));
+      else {
+        new = opt_malloc(sizeof(struct ptr_record));
+        new->next = daemon->ptr;
+        daemon->ptr = new;
+        new->name = dom;
+        new->ptr = target;
+      }
+      break;
+    }
+
+  case LOPT_NAPTR:             /* --naptr-record */
+    {
+      char *a[7] = { NULL, NULL, NULL, NULL, NULL, NULL, NULL };
+      int k = 0;
+      struct naptr *new;
+      int order, pref;
+      char *name, *replace = NULL;
+
+      if ((a[0] = arg))
+        for (k = 1; k < 7; k++)
+          if (!(a[k] = split(a[k - 1])))
+            break;
+
+
+      if (k < 6 ||
+          !(name = canonicalise_opt(a[0])) ||
+          !atoi_check16(a[1], &order) ||
+          !atoi_check16(a[2], &pref) ||
+          (k == 7 && !(replace = canonicalise_opt(a[6]))))
+        ret_err(_("bad NAPTR record"));
+      else {
+        new = opt_malloc(sizeof(struct naptr));
+        new->next = daemon->naptr;
+        daemon->naptr = new;
+        new->name = name;
+        new->flags = opt_string_alloc(a[3]);
+        new->services = opt_string_alloc(a[4]);
+        new->regexp = opt_string_alloc(a[5]);
+        new->replace = replace;
+        new->order = order;
+        new->pref = pref;
+      }
+      break;
+    }
+
+  case LOPT_RR:                /* dns-rr */
+    {
+      struct txt_record *new;
+      size_t len = 0;
+      char *data;
+      int val;
+
+      comma = split(arg);
+      data = split(comma);
+
+      new = opt_malloc(sizeof(struct txt_record));
+      new->next = daemon->rr;
+      daemon->rr = new;
+
+      if (!atoi_check(comma, &val) ||
+          !(new->name = canonicalise_opt(arg)) ||
+          (data
+           && (len =
+               parse_hex(data, (unsigned char *) data, -1, NULL, NULL)) == -1U))
+        ret_err(_("bad RR record"));
+
+      new->class = val;
+      new->len = 0;
+
+      if (data) {
+        new->txt = opt_malloc(len);
+        new->len = len;
+        memcpy(new->txt, data, len);
+      }
+
+      break;
+    }
+
+  case 'Y':                    /* --txt-record */
     {
-      int white, i;
-      volatile int option = (hard_opt == LOPT_REV_SERV) ? 0 : hard_opt;
-      char *errmess, *p, *arg, *start;
+      struct txt_record *new;
+      unsigned char *p, *cnt;
       size_t len;
 
-      /* Memory allocation failure longjmps here if mem_recover == 1 */ 
-      if (option != 0 || hard_opt == LOPT_REV_SERV)
-	{
-	  if (setjmp(mem_jmp))
-	    continue;
-	  mem_recover = 1;
-	}
-      
-      arg = NULL;
-      lineno++;
-      errmess = NULL;
-      
-      /* Implement quotes, inside quotes we allow \\ \" \n and \t 
-	 metacharacters get hidden also strip comments */
-      for (white = 1, p = buff; *p; p++)
-	{
-	  if (*p == '"')
-	    {
-	      memmove(p, p+1, strlen(p+1)+1);
-
-	      for(; *p && *p != '"'; p++)
-		{
-		  if (*p == '\\' && strchr("\"tnebr\\", p[1]))
-		    {
-		      if (p[1] == 't')
-			p[1] = '\t';
-		      else if (p[1] == 'n')
-			p[1] = '\n';
-		      else if (p[1] == 'b')
-			p[1] = '\b';
-		      else if (p[1] == 'r')
-			p[1] = '\r';
-		      else if (p[1] == 'e') /* escape */
-			p[1] = '\033';
-		      memmove(p, p+1, strlen(p+1)+1);
-		    }
-		  *p = hide_meta(*p);
-		}
-
-	      if (*p == 0) 
-		{
-		  errmess = _("missing \"");
-		  goto oops; 
-		}
-
-	      memmove(p, p+1, strlen(p+1)+1);
-	    }
-
-	  if (isspace(*p))
-	    {
-	      *p = ' ';
-	      white = 1;
-	    }
-	  else 
-	    {
-	      if (white && *p == '#')
-		{ 
-		  *p = 0;
-		  break;
-		}
-	      white = 0;
-	    } 
-	}
-
-      
-      /* strip leading spaces */
-      for (start = buff; *start && *start == ' '; start++);
-      
-      /* strip trailing spaces */
-      for (len = strlen(start); (len != 0) && (start[len-1] == ' '); len--);
-      
-      if (len == 0)
-	continue; 
-      else
-	start[len] = 0;
-      
-      if (option != 0)
-	arg = start;
-      else if ((p=strchr(start, '=')))
-	{
-	  /* allow spaces around "=" */
-	  for (arg = p+1; *arg == ' '; arg++);
-	  for (; p >= start && (*p == ' ' || *p == '='); p--)
-	    *p = 0;
-	}
+      comma = split(arg);
+
+      new = opt_malloc(sizeof(struct txt_record));
+      new->next = daemon->txt;
+      daemon->txt = new;
+      new->class = C_IN;
+      new->stat = 0;
+
+      if (!(new->name = canonicalise_opt(arg)))
+        ret_err(_("bad TXT record"));
+
+      len = comma ? strlen(comma) : 0;
+      len += (len / 255) + 1;   /* room for extra counts */
+      new->txt = p = opt_malloc(len);
+
+      cnt = p++;
+      *cnt = 0;
+
+      while (comma && *comma) {
+        unsigned char c = (unsigned char) *comma++;
+
+        if (c == ',' || *cnt == 255) {
+          if (c != ',')
+            comma--;
+          cnt = p++;
+          *cnt = 0;
+        } else {
+          *p++ = unhide_meta(c);
+          (*cnt)++;
+        }
+      }
+
+      new->len = p - new->txt;
+
+      break;
+    }
+
+  case 'W':                    /* --srv-host */
+    {
+      int port = 1, priority = 0, weight = 0;
+      char *name, *target = NULL;
+      struct mx_srv_record *new;
+
+      comma = split(arg);
+
+      if (!(name = canonicalise_opt(arg)))
+        ret_err(_("bad SRV record"));
+
+      if (comma) {
+        arg = comma;
+        comma = split(arg);
+        if (!(target = canonicalise_opt(arg)))
+          ret_err(_("bad SRV target"));
+
+        if (comma) {
+          arg = comma;
+          comma = split(arg);
+          if (!atoi_check16(arg, &port))
+            ret_err(_("invalid port number"));
+
+          if (comma) {
+            arg = comma;
+            comma = split(arg);
+            if (!atoi_check16(arg, &priority))
+              ret_err(_("invalid priority"));
+
+            if (comma && !atoi_check16(comma, &weight))
+              ret_err(_("invalid weight"));
+          }
+        }
+      }
+
+      new = opt_malloc(sizeof(struct mx_srv_record));
+      new->next = daemon->mxnames;
+      daemon->mxnames = new;
+      new->issrv = 1;
+      new->name = name;
+      new->target = target;
+      new->srvport = port;
+      new->priority = priority;
+      new->weight = weight;
+      break;
+    }
+
+  case LOPT_HOST_REC:          /* --host-record */
+    {
+      struct host_record *new = opt_malloc(sizeof(struct host_record));
+      memset(new, 0, sizeof(struct host_record));
+      new->ttl = -1;
+
+      if (!arg || !(comma = split(arg)))
+        ret_err(_("Bad host-record"));
+
+      while (arg) {
+        struct all_addr addr;
+        char *dig;
+
+        for (dig = arg; *dig != 0; dig++)
+          if (*dig < '0' || *dig > '9')
+            break;
+        if (*dig == 0)
+          new->ttl = atoi(arg);
+        else if (inet_pton(AF_INET, arg, &addr))
+          new->addr = addr.addr.addr4;
+#ifdef HAVE_IPV6
+        else if (inet_pton(AF_INET6, arg, &addr))
+          new->addr6 = addr.addr.addr6;
+#endif
+        else {
+          int nomem;
+          char *canon = canonicalise(arg, &nomem);
+          struct name_list *nl = opt_malloc(sizeof(struct name_list));
+          if (!canon)
+            ret_err(_("Bad name in host-record"));
+
+          nl->name = canon;
+          /* keep order, so that PTR record goes to first name */
+          nl->next = NULL;
+          if (!new->names)
+            new->names = nl;
+          else {
+            struct name_list *tmp;
+            for (tmp = new->names; tmp->next; tmp = tmp->next);
+            tmp->next = nl;
+          }
+        }
+
+        arg = comma;
+        comma = split(arg);
+      }
+
+      /* Keep list order */
+      if (!daemon->host_records_tail)
+        daemon->host_records = new;
       else
-	arg = NULL;
+        daemon->host_records_tail->next = new;
+      new->next = NULL;
+      daemon->host_records_tail = new;
+      break;
+    }
+
+#ifdef HAVE_DNSSEC
+  case LOPT_DNSSEC_STAMP:
+    daemon->timestamp_file = opt_string_alloc(arg);
+    break;
+
+  case LOPT_TRUST_ANCHOR:
+    {
+      struct ds_config *new = opt_malloc(sizeof(struct ds_config));
+      char *cp, *cp1, *keyhex, *digest, *algo = NULL;
+      int len;
+
+      new->class = C_IN;
+
+      if ((comma = split(arg)) && (algo = split(comma))) {
+        int class = 0;
+        if (strcmp(comma, "IN") == 0)
+          class = C_IN;
+        else if (strcmp(comma, "CH") == 0)
+          class = C_CHAOS;
+        else if (strcmp(comma, "HS") == 0)
+          class = C_HESIOD;
+
+        if (class != 0) {
+          new->class = class;
+          comma = algo;
+          algo = split(comma);
+        }
+      }
+
+      if (!comma || !algo || !(digest = split(algo))
+          || !(keyhex = split(digest)) || !atoi_check16(comma, &new->keytag)
+          || !atoi_check8(algo, &new->algo)
+          || !atoi_check8(digest, &new->digest_type)
+          || !(new->name = canonicalise_opt(arg)))
+        ret_err(_("bad trust anchor"));
+
+      /* Upper bound on length */
+      len = (2 * strlen(keyhex)) + 1;
+      new->digest = opt_malloc(len);
+      unhide_metas(keyhex);
+      /* 4034: "Whitespace is allowed within digits" */
+      for (cp = keyhex; *cp;)
+        if (isspace(*cp))
+          for (cp1 = cp; *cp1; cp1++)
+            *cp1 = *(cp1 + 1);
+        else
+          cp++;
+      if ((new->digestlen =
+           parse_hex(keyhex, (unsigned char *) new->digest, len, NULL,
+                     NULL)) == -1)
+        ret_err(_("bad HEX in trust anchor"));
+
+      new->next = daemon->ds;
+      daemon->ds = new;
+
+      break;
+    }
+#endif
+
+  default:
+    ret_err(_
+            ("unsupported option (check that dnsmasq was compiled with DHCP/TFTP/DNSSEC/DBus support)"));
+
+  }
+
+  return 1;
+}
+
+static void read_file(char *file, FILE * f, int hard_opt)
+{
+  volatile int lineno = 0;
+  char *buff = daemon->namebuff;
+
+  while (fgets(buff, MAXDNAME, f)) {
+    int white, i;
+    volatile int option = (hard_opt == LOPT_REV_SERV) ? 0 : hard_opt;
+    char *errmess, *p, *arg, *start;
+    size_t len;
+
+    /* Memory allocation failure longjmps here if mem_recover == 1 */
+    if (option != 0 || hard_opt == LOPT_REV_SERV) {
+      if (setjmp(mem_jmp))
+        continue;
+      mem_recover = 1;
+    }
+
+    arg = NULL;
+    lineno++;
+    errmess = NULL;
+
+    /* Implement quotes, inside quotes we allow \\ \" \n and \t
+       metacharacters get hidden also strip comments */
+    for (white = 1, p = buff; *p; p++) {
+      if (*p == '"') {
+        memmove(p, p + 1, strlen(p + 1) + 1);
+
+        for (; *p && *p != '"'; p++) {
+          if (*p == '\\' && strchr("\"tnebr\\", p[1])) {
+            if (p[1] == 't')
+              p[1] = '\t';
+            else if (p[1] == 'n')
+              p[1] = '\n';
+            else if (p[1] == 'b')
+              p[1] = '\b';
+            else if (p[1] == 'r')
+              p[1] = '\r';
+            else if (p[1] == 'e')       /* escape */
+              p[1] = '\033';
+            memmove(p, p + 1, strlen(p + 1) + 1);
+          }
+          *p = hide_meta(*p);
+        }
+
+        if (*p == 0) {
+          errmess = _("missing \"");
+          goto oops;
+        }
 
-      if (option == 0)
-	{
-	  for (option = 0, i = 0; opts[i].name; i++) 
-	    if (strcmp(opts[i].name, start) == 0)
-	      {
-		option = opts[i].val;
-		break;
-	      }
-	  
-	  if (!option)
-	    errmess = _("bad option");
-	  else if (opts[i].has_arg == 0 && arg)
-	    errmess = _("extraneous parameter");
-	  else if (opts[i].has_arg == 1 && !arg)
-	    errmess = _("missing parameter");
-	  else if (hard_opt == LOPT_REV_SERV && option != 'S' && option != LOPT_REV_SERV)
-	    errmess = _("illegal option");
-	}
-
-    oops:
-      if (errmess)
-	strcpy(daemon->namebuff, errmess);
-	  
-      if (errmess || !one_opt(option, arg, buff, _("error"), 0, hard_opt == LOPT_REV_SERV))
-	{
-	  sprintf(daemon->namebuff + strlen(daemon->namebuff), _(" at line %d of %s"), lineno, file);
-	  if (hard_opt != 0)
-	    my_syslog(LOG_ERR, "%s", daemon->namebuff);
-	  else
-	    die("%s", daemon->namebuff, EC_BADCONF);
-	}
+        memmove(p, p + 1, strlen(p + 1) + 1);
+      }
+
+      if (isspace(*p)) {
+        *p = ' ';
+        white = 1;
+      } else {
+        if (white && *p == '#') {
+          *p = 0;
+          break;
+        }
+        white = 0;
+      }
+    }
+
+
+    /* strip leading spaces */
+    for (start = buff; *start && *start == ' '; start++);
+
+    /* strip trailing spaces */
+    for (len = strlen(start); (len != 0) && (start[len - 1] == ' '); len--);
+
+    if (len == 0)
+      continue;
+    else
+      start[len] = 0;
+
+    if (option != 0)
+      arg = start;
+    else if ((p = strchr(start, '='))) {
+      /* allow spaces around "=" */
+      for (arg = p + 1; *arg == ' '; arg++);
+      for (; p >= start && (*p == ' ' || *p == '='); p--)
+        *p = 0;
+    } else
+      arg = NULL;
+
+    if (option == 0) {
+      for (option = 0, i = 0; opts[i].name; i++)
+        if (strcmp(opts[i].name, start) == 0) {
+          option = opts[i].val;
+          break;
+        }
+
+      if (!option)
+        errmess = _("bad option");
+      else if (opts[i].has_arg == 0 && arg)
+        errmess = _("extraneous parameter");
+      else if (opts[i].has_arg == 1 && !arg)
+        errmess = _("missing parameter");
+      else if (hard_opt == LOPT_REV_SERV && option != 'S'
+               && option != LOPT_REV_SERV)
+        errmess = _("illegal option");
+    }
+
+  oops:
+    if (errmess)
+      strcpy(daemon->namebuff, errmess);
+
+    if (errmess
+        || !one_opt(option, arg, buff, _("error"), 0,
+                    hard_opt == LOPT_REV_SERV)) {
+      sprintf(daemon->namebuff + strlen(daemon->namebuff),
+              _(" at line %d of %s"), lineno, file);
+      if (hard_opt != 0)
+        my_syslog(LOG_ERR, "%s", daemon->namebuff);
+      else
+        die("%s", daemon->namebuff, EC_BADCONF);
     }
+  }
 
   mem_recover = 0;
   fclose(f);
@@ -4322,12 +4256,12 @@
 int option_read_dynfile(char *file, int flags)
 {
   my_syslog(MS_DHCP | LOG_INFO, _("read %s"), file);
-  
+
   if (flags & AH_DHCP_HST)
     return one_file(file, LOPT_BANK);
   else if (flags & AH_DHCP_OPT)
     return one_file(file, LOPT_OPTS);
-  
+
   return 0;
 }
 #endif
@@ -4342,60 +4276,51 @@
     ino_t ino;
     struct fileread *next;
   } *filesread = NULL;
-  
-  if (hard_opt == '7')
-    {
-      /* default conf-file reading */
-      hard_opt = 0;
-      nofile_ok = 1;
-    }
 
-  if (hard_opt == 0 && strcmp(file, "-") == 0)
-    {
-      if (read_stdin == 1)
-	return 1;
-      read_stdin = 1;
-      file = "stdin";
-      f = stdin;
+  if (hard_opt == '7') {
+    /* default conf-file reading */
+    hard_opt = 0;
+    nofile_ok = 1;
+  }
+
+  if (hard_opt == 0 && strcmp(file, "-") == 0) {
+    if (read_stdin == 1)
+      return 1;
+    read_stdin = 1;
+    file = "stdin";
+    f = stdin;
+  } else {
+    /* ignore repeated files. */
+    struct stat statbuf;
+
+    if (hard_opt == 0 && stat(file, &statbuf) == 0) {
+      struct fileread *r;
+
+      for (r = filesread; r; r = r->next)
+        if (r->dev == statbuf.st_dev && r->ino == statbuf.st_ino)
+          return 1;
+
+      r = safe_malloc(sizeof(struct fileread));
+      r->next = filesread;
+      filesread = r;
+      r->dev = statbuf.st_dev;
+      r->ino = statbuf.st_ino;
     }
-  else
-    {
-      /* ignore repeated files. */
-      struct stat statbuf;
-    
-      if (hard_opt == 0 && stat(file, &statbuf) == 0)
-	{
-	  struct fileread *r;
-	  
-	  for (r = filesread; r; r = r->next)
-	    if (r->dev == statbuf.st_dev && r->ino == statbuf.st_ino)
-	      return 1;
-	  
-	  r = safe_malloc(sizeof(struct fileread));
-	  r->next = filesread;
-	  filesread = r;
-	  r->dev = statbuf.st_dev;
-	  r->ino = statbuf.st_ino;
-	}
-      
-      if (!(f = fopen(file, "r")))
-	{   
-	  if (errno == ENOENT && nofile_ok)
-	    return 1; /* No conffile, all done. */
-	  else
-	    {
-	      char *str = _("cannot read %s: %s");
-	      if (hard_opt != 0)
-		{
-		  my_syslog(LOG_ERR, str, file, strerror(errno));
-		  return 0;
-		}
-	      else
-		die(str, file, EC_FILE);
-	    }
-	} 
+
+    if (!(f = fopen(file, "r"))) {
+      if (errno == ENOENT && nofile_ok)
+        return 1;               /* No conffile, all done. */
+      else {
+        char *str = _("cannot read %s: %s");
+        if (hard_opt != 0) {
+          my_syslog(LOG_ERR, str, file, strerror(errno));
+          return 0;
+        } else
+          die(str, file, EC_FILE);
+      }
     }
-  
+  }
+
   read_file(file, f, hard_opt);
   return 1;
 }
@@ -4407,97 +4332,89 @@
   struct hostsfile *ah;
 
   /* find largest used index */
-  for (i = SRC_AH, ah = list; ah; ah = ah->next)
-    {
-      if (i <= ah->index)
-	i = ah->index + 1;
-
-      if (ah->flags & AH_DIR)
-	ah->flags |= AH_INACTIVE;
-      else
-	ah->flags &= ~AH_INACTIVE;
-    }
+  for (i = SRC_AH, ah = list; ah; ah = ah->next) {
+    if (i <= ah->index)
+      i = ah->index + 1;
+
+    if (ah->flags & AH_DIR)
+      ah->flags |= AH_INACTIVE;
+    else
+      ah->flags &= ~AH_INACTIVE;
+  }
 
   for (ah = list; ah; ah = ah->next)
-    if (!(ah->flags & AH_INACTIVE))
-      {
-	struct stat buf;
-	if (stat(ah->fname, &buf) != -1 && S_ISDIR(buf.st_mode))
-	  {
-	    DIR *dir_stream;
-	    struct dirent *ent;
-	    
-	    /* don't read this as a file */
-	    ah->flags |= AH_INACTIVE;
-	    
-	    if (!(dir_stream = opendir(ah->fname)))
-	      my_syslog(LOG_ERR, _("cannot access directory %s: %s"), 
-			ah->fname, strerror(errno));
-	    else
-	      {
-		while ((ent = readdir(dir_stream)))
-		  {
-		    size_t lendir = strlen(ah->fname);
-		    size_t lenfile = strlen(ent->d_name);
-		    struct hostsfile *ah1;
-		    char *path;
-		    
-		    /* ignore emacs backups and dotfiles */
-		    if (lenfile == 0 || 
-			ent->d_name[lenfile - 1] == '~' ||
-			(ent->d_name[0] == '#' && ent->d_name[lenfile - 1] == '#') ||
-			ent->d_name[0] == '.')
-		      continue;
-		    
-		    /* see if we have an existing record.
-		       dir is ah->fname 
-		       file is ent->d_name
-		       path to match is ah1->fname */
-		    
-		    for (ah1 = list; ah1; ah1 = ah1->next)
-		      {
-			if (lendir < strlen(ah1->fname) &&
-			    strstr(ah1->fname, ah->fname) == ah1->fname &&
-			    ah1->fname[lendir] == '/' &&
-			    strcmp(ah1->fname + lendir + 1, ent->d_name) == 0)
-			  {
-			    ah1->flags &= ~AH_INACTIVE;
-			    break;
-			  }
-		      }
-		    
-		    /* make new record */
-		    if (!ah1)
-		      {
-			if (!(ah1 = whine_malloc(sizeof(struct hostsfile))))
-			  continue;
-			
-			if (!(path = whine_malloc(lendir + lenfile + 2)))
-			  {
-			    free(ah1);
-			    continue;
-			  }
-		      	
-			strcpy(path, ah->fname);
-			strcat(path, "/");
-			strcat(path, ent->d_name);
-			ah1->fname = path;
-			ah1->index = i++;
-			ah1->flags = AH_DIR;
-			ah1->next = list;
-			list = ah1;
-		      }
-		    
-		    /* inactivate record if not regular file */
-		    if ((ah1->flags & AH_DIR) && stat(ah1->fname, &buf) != -1 && !S_ISREG(buf.st_mode))
-		      ah1->flags |= AH_INACTIVE; 
-		    
-		  }
-		closedir(dir_stream);
-	      }
-	  }
+    if (!(ah->flags & AH_INACTIVE)) {
+      struct stat buf;
+      if (stat(ah->fname, &buf) != -1 && S_ISDIR(buf.st_mode)) {
+        DIR *dir_stream;
+        struct dirent *ent;
+
+        /* don't read this as a file */
+        ah->flags |= AH_INACTIVE;
+
+        if (!(dir_stream = opendir(ah->fname)))
+          my_syslog(LOG_ERR, _("cannot access directory %s: %s"),
+                    ah->fname, strerror(errno));
+        else {
+          while ((ent = readdir(dir_stream))) {
+            size_t lendir = strlen(ah->fname);
+            size_t lenfile = strlen(ent->d_name);
+            struct hostsfile *ah1;
+            char *path;
+
+            /* ignore emacs backups and dotfiles */
+            if (lenfile == 0 ||
+                ent->d_name[lenfile - 1] == '~' ||
+                (ent->d_name[0] == '#' && ent->d_name[lenfile - 1] == '#') ||
+                ent->d_name[0] == '.')
+              continue;
+
+            /* see if we have an existing record.
+               dir is ah->fname
+               file is ent->d_name
+               path to match is ah1->fname */
+
+            for (ah1 = list; ah1; ah1 = ah1->next) {
+              if (lendir < strlen(ah1->fname) &&
+                  strstr(ah1->fname, ah->fname) == ah1->fname &&
+                  ah1->fname[lendir] == '/' &&
+                  strcmp(ah1->fname + lendir + 1, ent->d_name) == 0) {
+                ah1->flags &= ~AH_INACTIVE;
+                break;
+              }
+            }
+
+            /* make new record */
+            if (!ah1) {
+              if (!(ah1 = whine_malloc(sizeof(struct hostsfile))))
+                continue;
+
+              if (!(path = whine_malloc(lendir + lenfile + 2))) {
+                free(ah1);
+                continue;
+              }
+
+              strcpy(path, ah->fname);
+              strcat(path, "/");
+              strcat(path, ent->d_name);
+              ah1->fname = path;
+              ah1->index = i++;
+              ah1->flags = AH_DIR;
+              ah1->next = list;
+              list = ah1;
+            }
+
+            /* inactivate record if not regular file */
+            if ((ah1->flags & AH_DIR) && stat(ah1->fname, &buf) != -1
+                && !S_ISREG(buf.st_mode))
+              ah1->flags |= AH_INACTIVE;
+
+          }
+          closedir(dir_stream);
+        }
       }
-  
+    }
+
   return list;
 }
 
@@ -4505,117 +4422,105 @@
 {
   FILE *f;
 
-  if (!(f = fopen(daemon->servers_file, "r")))
-    {
-       my_syslog(LOG_ERR, _("cannot read %s: %s"), daemon->servers_file, strerror(errno));
-       return;
-    }
-  
+  if (!(f = fopen(daemon->servers_file, "r"))) {
+    my_syslog(LOG_ERR, _("cannot read %s: %s"), daemon->servers_file,
+              strerror(errno));
+    return;
+  }
+
   mark_servers(SERV_FROM_FILE);
   cleanup_servers();
-  
+
   read_file(daemon->servers_file, f, LOPT_REV_SERV);
 }
- 
+
 
 #ifdef HAVE_DHCP
 void reread_dhcp(void)
 {
   struct hostsfile *hf;
 
-  if (daemon->dhcp_hosts_file)
-    {
-      struct dhcp_config *configs, *cp, **up;
-  
-      /* remove existing... */
-      for (up = &daemon->dhcp_conf, configs = daemon->dhcp_conf; configs; configs = cp)
-	{
-	  cp = configs->next;
-	  
-	  if (configs->flags & CONFIG_BANK)
-	    {
-	      struct hwaddr_config *mac, *tmp;
-	      struct dhcp_netid_list *list, *tmplist;
-	      
-	      for (mac = configs->hwaddr; mac; mac = tmp)
-		{
-		  tmp = mac->next;
-		  free(mac);
-		}
-
-	      if (configs->flags & CONFIG_CLID)
-		free(configs->clid);
-
-	      for (list = configs->netid; list; list = tmplist)
-		{
-		  free(list->list);
-		  tmplist = list->next;
-		  free(list);
-		}
-	      
-	      if (configs->flags & CONFIG_NAME)
-		free(configs->hostname);
-	      
-	      *up = configs->next;
-	      free(configs);
-	    }
-	  else
-	    up = &configs->next;
-	}
-      
-      daemon->dhcp_hosts_file = expand_filelist(daemon->dhcp_hosts_file);
-      for (hf = daemon->dhcp_hosts_file; hf; hf = hf->next)
-	 if (!(hf->flags & AH_INACTIVE))
-	   {
-	     if (one_file(hf->fname, LOPT_BANK))  
-	       my_syslog(MS_DHCP | LOG_INFO, _("read %s"), hf->fname);
-	   }
+  if (daemon->dhcp_hosts_file) {
+    struct dhcp_config *configs, *cp, **up;
+
+    /* remove existing... */
+    for (up = &daemon->dhcp_conf, configs = daemon->dhcp_conf; configs;
+         configs = cp) {
+      cp = configs->next;
+
+      if (configs->flags & CONFIG_BANK) {
+        struct hwaddr_config *mac, *tmp;
+        struct dhcp_netid_list *list, *tmplist;
+
+        for (mac = configs->hwaddr; mac; mac = tmp) {
+          tmp = mac->next;
+          free(mac);
+        }
+
+        if (configs->flags & CONFIG_CLID)
+          free(configs->clid);
+
+        for (list = configs->netid; list; list = tmplist) {
+          free(list->list);
+          tmplist = list->next;
+          free(list);
+        }
+
+        if (configs->flags & CONFIG_NAME)
+          free(configs->hostname);
+
+        *up = configs->next;
+        free(configs);
+      } else
+        up = &configs->next;
     }
 
-  if (daemon->dhcp_opts_file)
-    {
-      struct dhcp_opt *opts, *cp, **up;
-      struct dhcp_netid *id, *next;
+    daemon->dhcp_hosts_file = expand_filelist(daemon->dhcp_hosts_file);
+    for (hf = daemon->dhcp_hosts_file; hf; hf = hf->next)
+      if (!(hf->flags & AH_INACTIVE)) {
+        if (one_file(hf->fname, LOPT_BANK))
+          my_syslog(MS_DHCP | LOG_INFO, _("read %s"), hf->fname);
+      }
+  }
 
-      for (up = &daemon->dhcp_opts, opts = daemon->dhcp_opts; opts; opts = cp)
-	{
-	  cp = opts->next;
-	  
-	  if (opts->flags & DHOPT_BANK)
-	    {
-	      if ((opts->flags & DHOPT_VENDOR))
-		free(opts->u.vendor_class);
-	      free(opts->val);
-	      for (id = opts->netid; id; id = next)
-		{
-		  next = id->next;
-		  free(id->net);
-		  free(id);
-		}
-	      *up = opts->next;
-	      free(opts);
-	    }
-	  else
-	    up = &opts->next;
-	}
-      
-      daemon->dhcp_opts_file = expand_filelist(daemon->dhcp_opts_file);
-      for (hf = daemon->dhcp_opts_file; hf; hf = hf->next)
-	if (!(hf->flags & AH_INACTIVE))
-	  {
-	    if (one_file(hf->fname, LOPT_OPTS))  
-	      my_syslog(MS_DHCP | LOG_INFO, _("read %s"), hf->fname);
-	  }
+  if (daemon->dhcp_opts_file) {
+    struct dhcp_opt *opts, *cp, **up;
+    struct dhcp_netid *id, *next;
+
+    for (up = &daemon->dhcp_opts, opts = daemon->dhcp_opts; opts; opts = cp) {
+      cp = opts->next;
+
+      if (opts->flags & DHOPT_BANK) {
+        if ((opts->flags & DHOPT_VENDOR))
+          free(opts->u.vendor_class);
+        free(opts->val);
+        for (id = opts->netid; id; id = next) {
+          next = id->next;
+          free(id->net);
+          free(id);
+        }
+        *up = opts->next;
+        free(opts);
+      } else
+        up = &opts->next;
     }
+
+    daemon->dhcp_opts_file = expand_filelist(daemon->dhcp_opts_file);
+    for (hf = daemon->dhcp_opts_file; hf; hf = hf->next)
+      if (!(hf->flags & AH_INACTIVE)) {
+        if (one_file(hf->fname, LOPT_OPTS))
+          my_syslog(MS_DHCP | LOG_INFO, _("read %s"), hf->fname);
+      }
+  }
 }
 #endif
-    
+
 void read_opts(int argc, char **argv, char *compile_opts)
 {
   char *buff = opt_malloc(MAXDNAME);
   int option, conffile_opt = '7', testmode = 0;
   char *arg, *conffile = CONFFILE;
-      
+
   opterr = 0;
 
   daemon = opt_malloc(sizeof(struct daemon));
@@ -4632,19 +4537,19 @@
   daemon->default_resolv.name = RESOLVFILE;
   daemon->resolv_files = &daemon->default_resolv;
   daemon->username = CHUSER;
-  daemon->runfile =  RUNFILE;
+  daemon->runfile = RUNFILE;
   daemon->dhcp_max = MAXLEASES;
   daemon->tftp_max = TFTP_MAX_CONNECTIONS;
   daemon->edns_pktsz = EDNS_PKTSZ;
   daemon->log_fac = -1;
-  daemon->auth_ttl = AUTH_TTL; 
+  daemon->auth_ttl = AUTH_TTL;
   daemon->soa_refresh = SOA_REFRESH;
   daemon->soa_retry = SOA_RETRY;
   daemon->soa_expiry = SOA_EXPIRY;
   daemon->max_port = MAX_PORT;
 
 #ifndef NO_ID
-  add_txt("version.bind", "dnsmasq-" VERSION, 0 );
+  add_txt("version.bind", "dnsmasq-" VERSION, 0);
   add_txt("authors.bind", "Simon Kelley", 0);
   add_txt("copyright.bind", COPYRIGHT, 0);
   add_txt("cachesize.bind", NULL, TXT_STAT_CACHESIZE);
@@ -4658,268 +4563,242 @@
   add_txt("servers.bind", NULL, TXT_STAT_SERVERS);
 #endif
 
-  while (1) 
-    {
+  while (1) {
 #ifdef HAVE_GETOPT_LONG
-      option = getopt_long(argc, argv, OPTSTRING, opts, NULL);
+    option = getopt_long(argc, argv, OPTSTRING, opts, NULL);
 #else
-      option = getopt(argc, argv, OPTSTRING);
+    option = getopt(argc, argv, OPTSTRING);
 #endif
-      
-      if (option == -1)
-	{
-	  for (; optind < argc; optind++)
-	    {
-	      unsigned char *c = (unsigned char *)argv[optind];
-	      for (; *c != 0; c++)
-		if (!isspace(*c))
-		  die(_("junk found in command line"), NULL, EC_BADCONF);
-	    }
-	  break;
-	}
-
-      /* Copy optarg so that argv doesn't get changed */
-      if (optarg)
-	{
-	  strncpy(buff, optarg, MAXDNAME);
-	  buff[MAXDNAME-1] = 0;
-	  arg = buff;
-	}
-      else
-	arg = NULL;
-      
-      /* command-line only stuff */
-      if (option == LOPT_TEST)
-	testmode = 1;
-      else if (option == 'w')
-	{
+
+    if (option == -1) {
+      for (; optind < argc; optind++) {
+        unsigned char *c = (unsigned char *) argv[optind];
+        for (; *c != 0; c++)
+          if (!isspace(*c))
+            die(_("junk found in command line"), NULL, EC_BADCONF);
+      }
+      break;
+    }
+
+    /* Copy optarg so that argv doesn't get changed */
+    if (optarg) {
+      strncpy(buff, optarg, MAXDNAME);
+      buff[MAXDNAME - 1] = 0;
+      arg = buff;
+    } else
+      arg = NULL;
+
+    /* command-line only stuff */
+    if (option == LOPT_TEST)
+      testmode = 1;
+    else if (option == 'w') {
 #ifdef HAVE_DHCP
-	  if (argc == 3 && strcmp(argv[2], "dhcp") == 0)
-	    display_opts();
+      if (argc == 3 && strcmp(argv[2], "dhcp") == 0)
+        display_opts();
 #ifdef HAVE_DHCP6
-	  else if (argc == 3 && strcmp(argv[2], "dhcp6") == 0)
-	    display_opts6();
+      else if (argc == 3 && strcmp(argv[2], "dhcp6") == 0)
+        display_opts6();
 #endif
-	  else
+      else
 #endif
-	    do_usage();
+        do_usage();
 
-	  exit(0);
-	}
-      else if (option == 'v')
-	{
-	  printf(_("Dnsmasq version %s  %s\n"), VERSION, COPYRIGHT);
-	  printf(_("Compile time options: %s\n\n"), compile_opts); 
-	  printf(_("This software comes with ABSOLUTELY NO WARRANTY.\n"));
-	  printf(_("Dnsmasq is free software, and you are welcome to redistribute it\n"));
-	  printf(_("under the terms of the GNU General Public License, version 2 or 3.\n"));
-          exit(0);
-        }
-      else if (option == 'C')
-	{
-	  conffile_opt = 0; /* file must exist */
-	  conffile = opt_string_alloc(arg);
-	}
-      else
-	{
+      exit(0);
+    } else if (option == 'v') {
+      printf(_("Dnsmasq version %s  %s\n"), VERSION, COPYRIGHT);
+      printf(_("Compile time options: %s\n\n"), compile_opts);
+      printf(_("This software comes with ABSOLUTELY NO WARRANTY.\n"));
+      printf(_
+             ("Dnsmasq is free software, and you are welcome to redistribute it\n"));
+      printf(_
+             ("under the terms of the GNU General Public License, version 2 or 3.\n"));
+      exit(0);
+    } else if (option == 'C') {
+      conffile_opt = 0;         /* file must exist */
+      conffile = opt_string_alloc(arg);
+    } else {
 #ifdef HAVE_GETOPT_LONG
-	  if (!one_opt(option, arg, daemon->namebuff, _("try --help"), 1, 0))
-#else 
-	    if (!one_opt(option, arg, daemon->namebuff, _("try -w"), 1, 0)) 
-#endif  
-	    die(_("bad command line options: %s"), daemon->namebuff, EC_BADCONF);
-	}
+      if (!one_opt(option, arg, daemon->namebuff, _("try --help"), 1, 0))
+#else
+      if (!one_opt(option, arg, daemon->namebuff, _("try -w"), 1, 0))
+#endif
+        die(_("bad command line options: %s"), daemon->namebuff, EC_BADCONF);
     }
+  }
 
-  if (conffile)
-    {
-      one_file(conffile, conffile_opt);
-      if (conffile_opt == 0)
-	free(conffile);
-    }
+  if (conffile) {
+    one_file(conffile, conffile_opt);
+    if (conffile_opt == 0)
+      free(conffile);
+  }
 
   /* port might not be known when the address is parsed - fill in here */
-  if (daemon->servers)
-    {
-      struct server *tmp;
-      for (tmp = daemon->servers; tmp; tmp = tmp->next)
-	if (!(tmp->flags & SERV_HAS_SOURCE))
-	  {
-	    if (tmp->source_addr.sa.sa_family == AF_INET)
-	      tmp->source_addr.in.sin_port = htons(daemon->query_port);
+  if (daemon->servers) {
+    struct server *tmp;
+    for (tmp = daemon->servers; tmp; tmp = tmp->next)
+      if (!(tmp->flags & SERV_HAS_SOURCE)) {
+        if (tmp->source_addr.sa.sa_family == AF_INET)
+          tmp->source_addr.in.sin_port = htons(daemon->query_port);
 #ifdef HAVE_IPV6
-	    else if (tmp->source_addr.sa.sa_family == AF_INET6)
-	      tmp->source_addr.in6.sin6_port = htons(daemon->query_port);
-#endif 
-	  }
-    } 
-  
-  if (daemon->host_records)
-    {
-      struct host_record *hr;
-      
-      for (hr = daemon->host_records; hr; hr = hr->next)
-	if (hr->ttl == -1)
-	  hr->ttl = daemon->local_ttl;
-    }
+        else if (tmp->source_addr.sa.sa_family == AF_INET6)
+          tmp->source_addr.in6.sin6_port = htons(daemon->query_port);
+#endif
+      }
+  }
 
-  if (daemon->cnames)
-    {
-      struct cname *cn, *cn2, *cn3;
+  if (daemon->host_records) {
+    struct host_record *hr;
+
+    for (hr = daemon->host_records; hr; hr = hr->next)
+      if (hr->ttl == -1)
+        hr->ttl = daemon->local_ttl;
+  }
+
+  if (daemon->cnames) {
+    struct cname *cn, *cn2, *cn3;
 
 #define NOLOOP 1
-#define TESTLOOP 2      
+#define TESTLOOP 2
 
-      /* Fill in TTL for CNAMES noe we have local_ttl.
-	 Also prepare to do loop detection. */
-      for (cn = daemon->cnames; cn; cn = cn->next)
-	{
-	  if (cn->ttl == -1)
-	    cn->ttl = daemon->local_ttl;
-	  cn->flag = 0;
-	  cn->targetp = NULL;
-	  for (cn2 = daemon->cnames; cn2; cn2 = cn2->next)
-	    if (hostname_isequal(cn->target, cn2->alias))
-	      {
-		cn->targetp = cn2;
-		break;
-	      }
-	}
-      
-      /* Find any CNAME loops.*/
-      for (cn = daemon->cnames; cn; cn = cn->next)
-	{
-	  for (cn2 = cn->targetp; cn2; cn2 = cn2->targetp)
-	    {
-	      if (cn2->flag == NOLOOP)
-		break;
-	      
-	      if (cn2->flag == TESTLOOP)
-		die(_("CNAME loop involving %s"), cn->alias, EC_BADCONF);
-	      
-	      cn2->flag = TESTLOOP;
-	    }
-	  
-	  for (cn3 = cn->targetp; cn3 != cn2; cn3 = cn3->targetp)
-	    cn3->flag = NOLOOP;
-	}
-    }
-
-  if (daemon->if_addrs)
-    {  
-      struct iname *tmp;
-      for(tmp = daemon->if_addrs; tmp; tmp = tmp->next)
-	if (tmp->addr.sa.sa_family == AF_INET)
-	  tmp->addr.in.sin_port = htons(daemon->port);
-#ifdef HAVE_IPV6
-	else if (tmp->addr.sa.sa_family == AF_INET6)
-	  tmp->addr.in6.sin6_port = htons(daemon->port);
-#endif /* IPv6 */
-    }
-	
-  /* create default, if not specified */
-  if (daemon->authserver && !daemon->hostmaster)
-    {
-      strcpy(buff, "hostmaster.");
-      strcat(buff, daemon->authserver);
-      daemon->hostmaster = opt_string_alloc(buff);
+    /* Fill in TTL for CNAMES noe we have local_ttl.
+       Also prepare to do loop detection. */
+    for (cn = daemon->cnames; cn; cn = cn->next) {
+      if (cn->ttl == -1)
+        cn->ttl = daemon->local_ttl;
+      cn->flag = 0;
+      cn->targetp = NULL;
+      for (cn2 = daemon->cnames; cn2; cn2 = cn2->next)
+        if (hostname_isequal(cn->target, cn2->alias)) {
+          cn->targetp = cn2;
+          break;
+        }
     }
-  
-  /* only one of these need be specified: the other defaults to the host-name */
-  if (option_bool(OPT_LOCALMX) || daemon->mxnames || daemon->mxtarget)
-    {
-      struct mx_srv_record *mx;
-      
-      if (gethostname(buff, MAXDNAME) == -1)
-	die(_("cannot get host-name: %s"), NULL, EC_MISC);
-      
-      for (mx = daemon->mxnames; mx; mx = mx->next)
-	if (!mx->issrv && hostname_isequal(mx->name, buff))
-	  break;
-      
-      if ((daemon->mxtarget || option_bool(OPT_LOCALMX)) && !mx)
-	{
-	  mx = opt_malloc(sizeof(struct mx_srv_record));
-	  mx->next = daemon->mxnames;
-	  mx->issrv = 0;
-	  mx->target = NULL;
-	  mx->name = opt_string_alloc(buff);
-	  daemon->mxnames = mx;
-	}
-      
-      if (!daemon->mxtarget)
-	daemon->mxtarget = opt_string_alloc(buff);
-
-      for (mx = daemon->mxnames; mx; mx = mx->next)
-	if (!mx->issrv && !mx->target)
-	  mx->target = daemon->mxtarget;
+
+    /* Find any CNAME loops. */
+    for (cn = daemon->cnames; cn; cn = cn->next) {
+      for (cn2 = cn->targetp; cn2; cn2 = cn2->targetp) {
+        if (cn2->flag == NOLOOP)
+          break;
+
+        if (cn2->flag == TESTLOOP)
+          die(_("CNAME loop involving %s"), cn->alias, EC_BADCONF);
+
+        cn2->flag = TESTLOOP;
+      }
+
+      for (cn3 = cn->targetp; cn3 != cn2; cn3 = cn3->targetp)
+        cn3->flag = NOLOOP;
     }
+  }
 
-  if (!option_bool(OPT_NO_RESOLV) &&
-      daemon->resolv_files && 
-      daemon->resolv_files->next && 
-      option_bool(OPT_NO_POLL))
-    die(_("only one resolv.conf file allowed in no-poll mode."), NULL, EC_BADCONF);
-  
-  if (option_bool(OPT_RESOLV_DOMAIN))
-    {
-      char *line;
-      FILE *f;
+  if (daemon->if_addrs) {
+    struct iname *tmp;
+    for (tmp = daemon->if_addrs; tmp; tmp = tmp->next)
+      if (tmp->addr.sa.sa_family == AF_INET)
+        tmp->addr.in.sin_port = htons(daemon->port);
+#ifdef HAVE_IPV6
+      else if (tmp->addr.sa.sa_family == AF_INET6)
+        tmp->addr.in6.sin6_port = htons(daemon->port);
+#endif                          /* IPv6 */
+  }
 
-      if (option_bool(OPT_NO_RESOLV) ||
-	  !daemon->resolv_files || 
-	  (daemon->resolv_files)->next)
-	die(_("must have exactly one resolv.conf to read domain from."), NULL, EC_BADCONF);
-      
-      if (!(f = fopen((daemon->resolv_files)->name, "r")))
-	die(_("failed to read %s: %s"), (daemon->resolv_files)->name, EC_FILE);
-      
-      while ((line = fgets(buff, MAXDNAME, f)))
-	{
-	  char *token = strtok(line, " \t\n\r");
-	  
-	  if (!token || strcmp(token, "search") != 0)
-	    continue;
-	  
-	  if ((token = strtok(NULL, " \t\n\r")) &&  
-	      (daemon->domain_suffix = canonicalise_opt(token)))
-	    break;
-	}
+  /* create default, if not specified */
+  if (daemon->authserver && !daemon->hostmaster) {
+    strcpy(buff, "hostmaster.");
+    strcat(buff, daemon->authserver);
+    daemon->hostmaster = opt_string_alloc(buff);
+  }
+
+  /* only one of these need be specified: the other defaults to the host-name */
+  if (option_bool(OPT_LOCALMX) || daemon->mxnames || daemon->mxtarget) {
+    struct mx_srv_record *mx;
 
-      fclose(f);
+    if (gethostname(buff, MAXDNAME) == -1)
+      die(_("cannot get host-name: %s"), NULL, EC_MISC);
 
-      if (!daemon->domain_suffix)
-	die(_("no search directive found in %s"), (daemon->resolv_files)->name, EC_MISC);
+    for (mx = daemon->mxnames; mx; mx = mx->next)
+      if (!mx->issrv && hostname_isequal(mx->name, buff))
+        break;
+
+    if ((daemon->mxtarget || option_bool(OPT_LOCALMX)) && !mx) {
+      mx = opt_malloc(sizeof(struct mx_srv_record));
+      mx->next = daemon->mxnames;
+      mx->issrv = 0;
+      mx->target = NULL;
+      mx->name = opt_string_alloc(buff);
+      daemon->mxnames = mx;
     }
 
-  if (daemon->domain_suffix)
-    {
-       /* add domain for any srv record without one. */
-      struct mx_srv_record *srv;
-      
-      for (srv = daemon->mxnames; srv; srv = srv->next)
-	if (srv->issrv &&
-	    strchr(srv->name, '.') && 
-	    strchr(srv->name, '.') == strrchr(srv->name, '.'))
-	  {
-	    strcpy(buff, srv->name);
-	    strcat(buff, ".");
-	    strcat(buff, daemon->domain_suffix);
-	    free(srv->name);
-	    srv->name = opt_string_alloc(buff);
-	  }
+    if (!daemon->mxtarget)
+      daemon->mxtarget = opt_string_alloc(buff);
+
+    for (mx = daemon->mxnames; mx; mx = mx->next)
+      if (!mx->issrv && !mx->target)
+        mx->target = daemon->mxtarget;
+  }
+
+  if (!option_bool(OPT_NO_RESOLV) &&
+      daemon->resolv_files &&
+      daemon->resolv_files->next && option_bool(OPT_NO_POLL))
+    die(_("only one resolv.conf file allowed in no-poll mode."), NULL,
+        EC_BADCONF);
+
+  if (option_bool(OPT_RESOLV_DOMAIN)) {
+    char *line;
+    FILE *f;
+
+    if (option_bool(OPT_NO_RESOLV) ||
+        !daemon->resolv_files || (daemon->resolv_files)->next)
+      die(_("must have exactly one resolv.conf to read domain from."), NULL,
+          EC_BADCONF);
+
+    if (!(f = fopen((daemon->resolv_files)->name, "r")))
+      die(_("failed to read %s: %s"), (daemon->resolv_files)->name, EC_FILE);
+
+    while ((line = fgets(buff, MAXDNAME, f))) {
+      char *token = strtok(line, " \t\n\r");
+
+      if (!token || strcmp(token, "search") != 0)
+        continue;
+
+      if ((token = strtok(NULL, " \t\n\r")) &&
+          (daemon->domain_suffix = canonicalise_opt(token)))
+        break;
     }
-  else if (option_bool(OPT_DHCP_FQDN))
-    die(_("there must be a default domain when --dhcp-fqdn is set"), NULL, EC_BADCONF);
+
+    fclose(f);
+
+    if (!daemon->domain_suffix)
+      die(_("no search directive found in %s"), (daemon->resolv_files)->name,
+          EC_MISC);
+  }
+
+  if (daemon->domain_suffix) {
+    /* add domain for any srv record without one. */
+    struct mx_srv_record *srv;
+
+    for (srv = daemon->mxnames; srv; srv = srv->next)
+      if (srv->issrv &&
+          strchr(srv->name, '.') &&
+          strchr(srv->name, '.') == strrchr(srv->name, '.')) {
+        strcpy(buff, srv->name);
+        strcat(buff, ".");
+        strcat(buff, daemon->domain_suffix);
+        free(srv->name);
+        srv->name = opt_string_alloc(buff);
+      }
+  } else if (option_bool(OPT_DHCP_FQDN))
+    die(_("there must be a default domain when --dhcp-fqdn is set"), NULL,
+        EC_BADCONF);
 
   /* If there's access-control config, then ignore --local-service, it's intended
      as a system default to keep otherwise unconfigured installations safe. */
-  if (daemon->if_names || daemon->if_except || daemon->if_addrs || daemon->authserver)
-    reset_option_bool(OPT_LOCAL_SERVICE); 
-
-  if (testmode)
-    {
-      fprintf(stderr, "dnsmasq: %s.\n", _("syntax check OK"));
-      exit(0);
-    }
-}  
+  if (daemon->if_names || daemon->if_except || daemon->if_addrs
+      || daemon->authserver)
+    reset_option_bool(OPT_LOCAL_SERVICE);
+
+  if (testmode) {
+    fprintf(stderr, "dnsmasq: %s.\n", _("syntax check OK"));
+    exit(0);
+  }
+}
Index: dnsmasq-2.78/src/outpacket.c
===================================================================
--- dnsmasq-2.78.orig/src/outpacket.c	2017-10-02 21:13:51.000000000 +0800
+++ dnsmasq-2.78/src/outpacket.c	2018-10-29 16:14:19.461440026 +0800
@@ -16,17 +16,17 @@
 
 
 #include "dnsmasq.h"
- 
+
 #ifdef HAVE_DHCP6
 
 static size_t outpacket_counter;
 
 void end_opt6(int container)
 {
-   void *p = daemon->outpacket.iov_base + container + 2;
-   u16 len = outpacket_counter - container - 4 ;
-   
-   PUTSHORT(len, p);
+  void *p = daemon->outpacket.iov_base + container + 2;
+  u16 len = outpacket_counter - container - 4;
+
+  PUTSHORT(len, p);
 }
 
 void reset_counter(void)
@@ -34,14 +34,14 @@
   /* Clear out buffer when starting from beginning */
   if (daemon->outpacket.iov_base)
     memset(daemon->outpacket.iov_base, 0, daemon->outpacket.iov_len);
- 
+
   save_counter(0);
 }
 
 int save_counter(int newval)
 {
   int ret = outpacket_counter;
-  
+
   if (newval != -1)
     outpacket_counter = newval;
 
@@ -52,26 +52,24 @@
 {
   void *ret;
 
-  if (expand_buf(&daemon->outpacket, outpacket_counter + headroom))
-    {
-      ret = daemon->outpacket.iov_base + outpacket_counter;
-      outpacket_counter += headroom;
-      return ret;
-    }
-  
+  if (expand_buf(&daemon->outpacket, outpacket_counter + headroom)) {
+    ret = daemon->outpacket.iov_base + outpacket_counter;
+    outpacket_counter += headroom;
+    return ret;
+  }
+
   return NULL;
 }
-    
+
 int new_opt6(int opt)
 {
   int ret = outpacket_counter;
   void *p;
 
-  if ((p = expand(4)))
-    {
-      PUTSHORT(opt, p);
-      PUTSHORT(0, p);
-    }
+  if ((p = expand(4))) {
+    PUTSHORT(opt, p);
+    PUTSHORT(0, p);
+  }
 
   return ret;
 }
@@ -81,16 +79,16 @@
   void *p;
 
   if ((p = expand(len)) && data)
-    memcpy(p, data, len);   
-  
+    memcpy(p, data, len);
+
   return p;
 }
-  
+
 void put_opt6_long(unsigned int val)
 {
   void *p;
-  
-  if ((p = expand(4)))  
+
+  if ((p = expand(4)))
     PUTLONG(val, p);
 }
 
@@ -99,7 +97,7 @@
   void *p;
 
   if ((p = expand(2)))
-    PUTSHORT(val, p);   
+    PUTSHORT(val, p);
 }
 
 void put_opt6_char(unsigned int val)
@@ -107,7 +105,7 @@
   unsigned char *p;
 
   if ((p = expand(1)))
-    *p = val;   
+    *p = val;
 }
 
 void put_opt6_string(char *s)
Index: dnsmasq-2.78/src/poll.c
===================================================================
--- dnsmasq-2.78.orig/src/poll.c	2017-10-02 21:13:51.000000000 +0800
+++ dnsmasq-2.78/src/poll.c	2018-10-29 16:14:19.461440026 +0800
@@ -48,24 +48,23 @@
 static nfds_t fd_search(int fd)
 {
   nfds_t left, right, mid;
-  
+
   if ((right = nfds) == 0)
     return 0;
-  
+
   left = 0;
-  
-  while (1)
-    {
-      if (right == left + 1)
-	return (pollfds[left].fd >= fd) ? left : right;
-      
-      mid = (left + right)/2;
-      
-      if (pollfds[mid].fd > fd)
-	right = mid;
-      else 
-	left = mid;
-    }
+
+  while (1) {
+    if (right == left + 1)
+      return (pollfds[left].fd >= fd) ? left : right;
+
+    mid = (left + right) / 2;
+
+    if (pollfds[mid].fd > fd)
+      right = mid;
+    else
+      left = mid;
+  }
 }
 
 void poll_reset(void)
@@ -81,7 +80,7 @@
 int poll_check(int fd, short event)
 {
   nfds_t i = fd_search(fd);
-  
+
   if (i < nfds && pollfds[i].fd == fd)
     return pollfds[i].revents & event;
 
@@ -90,36 +89,33 @@
 
 void poll_listen(int fd, short event)
 {
-   nfds_t i = fd_search(fd);
-  
-   if (i < nfds && pollfds[i].fd == fd)
-     pollfds[i].events |= event;
-   else
-     {
-       if (arrsize != nfds)
-	 memmove(&pollfds[i+1], &pollfds[i], (nfds - i) * sizeof(struct pollfd));
-       else
-	 {
-	   /* Array too small, extend. */
-	   struct pollfd *new;
-
-	   arrsize = (arrsize == 0) ? 64 : arrsize * 2;
-
-	   if (!(new = whine_malloc(arrsize * sizeof(struct pollfd))))
-	     return;
-
-	   if (pollfds)
-	     {
-	       memcpy(new, pollfds, i * sizeof(struct pollfd));
-	       memcpy(&new[i+1], &pollfds[i], (nfds - i) * sizeof(struct pollfd));
-	       free(pollfds);
-	     }
-	   
-	   pollfds = new;
-	 }
-       
-       pollfds[i].fd = fd;
-       pollfds[i].events = event;
-       nfds++;
-     }
+  nfds_t i = fd_search(fd);
+
+  if (i < nfds && pollfds[i].fd == fd)
+    pollfds[i].events |= event;
+  else {
+    if (arrsize != nfds)
+      memmove(&pollfds[i + 1], &pollfds[i], (nfds - i) * sizeof(struct pollfd));
+    else {
+      /* Array too small, extend. */
+      struct pollfd *new;
+
+      arrsize = (arrsize == 0) ? 64 : arrsize * 2;
+
+      if (!(new = whine_malloc(arrsize * sizeof(struct pollfd))))
+        return;
+
+      if (pollfds) {
+        memcpy(new, pollfds, i * sizeof(struct pollfd));
+        memcpy(&new[i + 1], &pollfds[i], (nfds - i) * sizeof(struct pollfd));
+        free(pollfds);
+      }
+
+      pollfds = new;
+    }
+
+    pollfds[i].fd = fd;
+    pollfds[i].events = event;
+    nfds++;
+  }
 }
Index: dnsmasq-2.78/src/radv-protocol.h
===================================================================
--- dnsmasq-2.78.orig/src/radv-protocol.h	2017-10-02 21:13:51.000000000 +0800
+++ dnsmasq-2.78/src/radv-protocol.h	2018-10-29 16:14:19.461440026 +0800
@@ -53,6 +53,3 @@
 #define ICMP6_OPT_RT_INFO     24
 #define ICMP6_OPT_RDNSS       25
 #define ICMP6_OPT_DNSSL       31
-
-
-
Index: dnsmasq-2.78/src/radv.c
===================================================================
--- dnsmasq-2.78.orig/src/radv.c	2017-10-02 21:13:51.000000000 +0800
+++ dnsmasq-2.78/src/radv.c	2018-10-29 16:14:19.465440027 +0800
@@ -32,13 +32,15 @@
   char *if_name;
   struct dhcp_netid *tags;
   struct in6_addr link_local, link_global, ula;
-  unsigned int glob_pref_time, link_pref_time, ula_pref_time, adv_interval, prio;
+  unsigned int glob_pref_time, link_pref_time, ula_pref_time, adv_interval,
+      prio;
   struct dhcp_context *found_context;
 };
 
 struct search_param {
-  time_t now; int iface;
-  char name[IF_NAMESIZE+1];
+  time_t now;
+  int iface;
+  char name[IF_NAMESIZE + 1];
 };
 
 struct alias_param {
@@ -49,18 +51,22 @@
   int *alias_ifs;
 };
 
-static void send_ra(time_t now, int iface, char *iface_name, struct in6_addr *dest);
-static void send_ra_alias(time_t now, int iface, char *iface_name, struct in6_addr *dest,
-                    int send_iface);
-static int send_ra_to_aliases(int index, unsigned int type, char *mac, size_t maclen, void *parm);
-static int add_prefixes(struct in6_addr *local,  int prefix,
-			int scope, int if_index, int flags, 
-			unsigned int preferred, unsigned int valid, void *vparam);
-static int iface_search(struct in6_addr *local,  int prefix,
-			int scope, int if_index, int flags, 
-			int prefered, int valid, void *vparam);
-static int add_lla(int index, unsigned int type, char *mac, size_t maclen, void *parm);
-static void new_timeout(struct dhcp_context *context, char *iface_name, time_t now);
+static void send_ra(time_t now, int iface, char *iface_name,
+                    struct in6_addr *dest);
+static void send_ra_alias(time_t now, int iface, char *iface_name,
+                          struct in6_addr *dest, int send_iface);
+static int send_ra_to_aliases(int index, unsigned int type, char *mac,
+                              size_t maclen, void *parm);
+static int add_prefixes(struct in6_addr *local, int prefix, int scope,
+                        int if_index, int flags, unsigned int preferred,
+                        unsigned int valid, void *vparam);
+static int iface_search(struct in6_addr *local, int prefix, int scope,
+                        int if_index, int flags, int prefered, int valid,
+                        void *vparam);
+static int add_lla(int index, unsigned int type, char *mac, size_t maclen,
+                   void *parm);
+static void new_timeout(struct dhcp_context *context, char *iface_name,
+                        time_t now);
 static unsigned int calc_lifetime(struct ra_interface *ra);
 static unsigned int calc_interval(struct ra_interface *ra);
 static unsigned int calc_prio(struct ra_interface *ra);
@@ -75,28 +81,27 @@
 #if defined(IPV6_TCLASS) && defined(IPTOS_CLASS_CS6)
   int class = IPTOS_CLASS_CS6;
 #endif
-  int val = 255; /* radvd uses this value */
+  int val = 255;                /* radvd uses this value */
   socklen_t len = sizeof(int);
   struct dhcp_context *context;
-  
+
   /* ensure this is around even if we're not doing DHCPv6 */
   expand_buf(&daemon->outpacket, sizeof(struct dhcp_packet));
- 
+
   /* See if we're guessing SLAAC addresses, if so we need to receive ping replies */
   for (context = daemon->dhcp6; context; context = context->next)
     if ((context->flags & CONTEXT_RA_NAME))
       break;
-  
+
   /* Need ICMP6 socket for transmission for DHCPv6 even when not doing RA. */
 
   ICMP6_FILTER_SETBLOCKALL(&filter);
-  if (daemon->doing_ra)
-    {
-      ICMP6_FILTER_SETPASS(ND_ROUTER_SOLICIT, &filter);
-      if (context)
-	ICMP6_FILTER_SETPASS(ICMP6_ECHO_REPLY, &filter);
-    }
-  
+  if (daemon->doing_ra) {
+    ICMP6_FILTER_SETPASS(ND_ROUTER_SOLICIT, &filter);
+    if (context)
+      ICMP6_FILTER_SETPASS(ICMP6_ECHO_REPLY, &filter);
+  }
+
   if ((fd = socket(PF_INET6, SOCK_RAW, IPPROTO_ICMPV6)) == -1 ||
       getsockopt(fd, IPPROTO_IPV6, IPV6_UNICAST_HOPS, &hop_limit, &len) ||
 #if defined(IPV6_TCLASS) && defined(IPTOS_CLASS_CS6)
@@ -106,43 +111,43 @@
       !set_ipv6pktinfo(fd) ||
       setsockopt(fd, IPPROTO_IPV6, IPV6_UNICAST_HOPS, &val, sizeof(val)) ||
       setsockopt(fd, IPPROTO_IPV6, IPV6_MULTICAST_HOPS, &val, sizeof(val)) ||
-      setsockopt(fd, IPPROTO_ICMPV6, ICMP6_FILTER, &filter, sizeof(filter)) == -1)
-    die (_("cannot create ICMPv6 socket: %s"), NULL, EC_BADNET);
-  
-   daemon->icmp6fd = fd;
-   
-   if (daemon->doing_ra)
-     ra_start_unsolicited(now, NULL);
+      setsockopt(fd, IPPROTO_ICMPV6, ICMP6_FILTER, &filter,
+                 sizeof(filter)) == -1)
+    die(_("cannot create ICMPv6 socket: %s"), NULL, EC_BADNET);
+
+  daemon->icmp6fd = fd;
+
+  if (daemon->doing_ra)
+    ra_start_unsolicited(now, NULL);
 }
 
 void ra_start_unsolicited(time_t now, struct dhcp_context *context)
-{   
-   /* init timers so that we do ra's for some/all soon. some ra_times will end up zeroed
+{
+  /* init timers so that we do ra's for some/all soon. some ra_times will end up zeroed
      if it's not appropriate to advertise those contexts.
      This gets re-called on a netlink route-change to re-do the advertisement
      and pick up new interfaces */
-  
+
   if (context)
     context->ra_short_period_start = context->ra_time = now;
   else
     for (context = daemon->dhcp6; context; context = context->next)
-      if (!(context->flags & CONTEXT_TEMPLATE))
-	{
-	  context->ra_time = now + (rand16()/13000); /* range 0 - 5 */
-	  /* re-do frequently for a minute or so, in case the first gets lost. */
-	  context->ra_short_period_start = now;
-	}
+      if (!(context->flags & CONTEXT_TEMPLATE)) {
+        context->ra_time = now + (rand16() / 13000);    /* range 0 - 5 */
+        /* re-do frequently for a minute or so, in case the first gets lost. */
+        context->ra_short_period_start = now;
+      }
 }
 
 void icmp6_packet(time_t now)
 {
-  char interface[IF_NAMESIZE+1];
-  ssize_t sz; 
+  char interface[IF_NAMESIZE + 1];
+  ssize_t sz;
   int if_index = 0;
   struct cmsghdr *cmptr;
   struct msghdr msg;
   union {
-    struct cmsghdr align; /* this ensures alignment */
+    struct cmsghdr align;       /* this ensures alignment */
     char control6[CMSG_SPACE(sizeof(struct in6_pktinfo))];
   } control_u;
   struct sockaddr_in6 from;
@@ -157,92 +162,91 @@
   msg.msg_namelen = sizeof(from);
   msg.msg_iov = &daemon->outpacket;
   msg.msg_iovlen = 1;
-  
+
   if ((sz = recv_dhcp_packet(daemon->icmp6fd, &msg)) == -1 || sz < 8)
     return;
-   
-  packet = (unsigned char *)daemon->outpacket.iov_base;
-  
+
+  packet = (unsigned char *) daemon->outpacket.iov_base;
+
   for (cmptr = CMSG_FIRSTHDR(&msg); cmptr; cmptr = CMSG_NXTHDR(&msg, cmptr))
-    if (cmptr->cmsg_level == IPPROTO_IPV6 && cmptr->cmsg_type == daemon->v6pktinfo)
-      {
-	union {
-	  unsigned char *c;
-	  struct in6_pktinfo *p;
-	} p;
-	p.c = CMSG_DATA(cmptr);
-        
-	if_index = p.p->ipi6_ifindex;
-      }
-  
+    if (cmptr->cmsg_level == IPPROTO_IPV6
+        && cmptr->cmsg_type == daemon->v6pktinfo) {
+      union {
+        unsigned char *c;
+        struct in6_pktinfo *p;
+      } p;
+      p.c = CMSG_DATA(cmptr);
+
+      if_index = p.p->ipi6_ifindex;
+    }
+
   if (!indextoname(daemon->icmp6fd, if_index, interface))
     return;
-    
+
   if (!iface_check(AF_LOCAL, NULL, interface, NULL))
     return;
-  
+
   for (tmp = daemon->dhcp_except; tmp; tmp = tmp->next)
     if (tmp->name && wildcard_match(tmp->name, interface))
       return;
- 
+
   if (packet[1] != 0)
     return;
-  
+
   if (packet[0] == ICMP6_ECHO_REPLY)
-    lease_ping_reply(&from.sin6_addr, packet, interface); 
-  else if (packet[0] == ND_ROUTER_SOLICIT)
-    {
-      char *mac = "";
-      struct dhcp_bridge *bridge, *alias;
-      
-      /* look for link-layer address option for logging */
-      if (sz >= 16 && packet[8] == ICMP6_OPT_SOURCE_MAC && (packet[9] * 8) + 8 <= sz)
-	{
-	  if ((packet[9] * 8 - 2) * 3 - 1 >= MAXDNAME) {
-	    return;
-	  }
-	  print_mac(daemon->namebuff, &packet[10], (packet[9] * 8) - 2);
-	  mac = daemon->namebuff;
-	}
-         
-      if (!option_bool(OPT_QUIET_RA))
-	my_syslog(MS_DHCP | LOG_INFO, "RTR-SOLICIT(%s) %s", interface, mac);
-
-      /* If the incoming interface is an alias of some other one (as
-         specified by the --bridge-interface option), send an RA using
-         the context of the aliased interface. */
-      for (bridge = daemon->bridges; bridge; bridge = bridge->next)
-        {
-          int bridge_index = if_nametoindex(bridge->iface);
-          if (bridge_index)
-	    {
-	      for (alias = bridge->alias; alias; alias = alias->next)
-		if (wildcard_matchn(alias->iface, interface, IF_NAMESIZE))
-		  {
-		    /* Send an RA on if_index with information from
-		       bridge_index. */
-		    send_ra_alias(now, bridge_index, bridge->iface, NULL, if_index);
-		    break;
-		  }
-	      if (alias)
-		break;
-	    }
-        }
+    lease_ping_reply(&from.sin6_addr, packet, interface);
+  else if (packet[0] == ND_ROUTER_SOLICIT) {
+    char *mac = "";
+    struct dhcp_bridge *bridge, *alias;
+
+    /* look for link-layer address option for logging */
+    if (sz >= 16 && packet[8] == ICMP6_OPT_SOURCE_MAC
+        && (packet[9] * 8) + 8 <= sz) {
+      if ((packet[9] * 8 - 2) * 3 - 1 >= MAXDNAME) {
+        return;
+      }
+      print_mac(daemon->namebuff, &packet[10], (packet[9] * 8) - 2);
+      mac = daemon->namebuff;
+    }
+
+    if (!option_bool(OPT_QUIET_RA))
+      my_syslog(MS_DHCP | LOG_INFO, "RTR-SOLICIT(%s) %s", interface, mac);
 
-      /* If the incoming interface wasn't an alias, send an RA using
-	 the context of the incoming interface. */
-      if (!bridge)
-	/* source address may not be valid in solicit request. */
-	send_ra(now, if_index, interface, !IN6_IS_ADDR_UNSPECIFIED(&from.sin6_addr) ? &from.sin6_addr : NULL);
+    /* If the incoming interface is an alias of some other one (as
+       specified by the --bridge-interface option), send an RA using
+       the context of the aliased interface. */
+    for (bridge = daemon->bridges; bridge; bridge = bridge->next) {
+      int bridge_index = if_nametoindex(bridge->iface);
+      if (bridge_index) {
+        for (alias = bridge->alias; alias; alias = alias->next)
+          if (wildcard_matchn(alias->iface, interface, IF_NAMESIZE)) {
+            /* Send an RA on if_index with information from
+               bridge_index. */
+            send_ra_alias(now, bridge_index, bridge->iface, NULL, if_index);
+            break;
+          }
+        if (alias)
+          break;
+      }
     }
+
+    /* If the incoming interface wasn't an alias, send an RA using
+       the context of the incoming interface. */
+    if (!bridge)
+      /* source address may not be valid in solicit request. */
+      send_ra(now, if_index, interface,
+              !IN6_IS_ADDR_UNSPECIFIED(&from.sin6_addr) ? &from.
+              sin6_addr : NULL);
+  }
 }
 
-static void send_ra_alias(time_t now, int iface, char *iface_name, struct in6_addr *dest, int send_iface)
+static void send_ra_alias(time_t now, int iface, char *iface_name,
+                          struct in6_addr *dest, int send_iface)
 {
   struct ra_packet *ra;
   struct ra_param parm;
   struct sockaddr_in6 addr;
-  struct dhcp_context *context, *tmp,  **up;
+  struct dhcp_context *context, *tmp, **up;
   struct dhcp_netid iface_id;
   struct dhcp_opt *opt_cfg;
   struct ra_interface *ra_param = find_iface_param(iface_name);
@@ -251,7 +255,7 @@
 #ifdef HAVE_LINUX_NETWORK
   FILE *f;
 #endif
-  
+
   parm.ind = iface;
   parm.managed = 0;
   parm.other = 0;
@@ -263,12 +267,12 @@
   parm.glob_pref_time = parm.link_pref_time = parm.ula_pref_time = 0;
   parm.adv_interval = calc_interval(ra_param);
   parm.prio = calc_prio(ra_param);
-  
+
   reset_counter();
-  
+
   if (!(ra = expand(sizeof(struct ra_packet))))
     return;
-  
+
   ra->type = ND_ROUTER_ADVERT;
   ra->code = 0;
   ra->hop_limit = hop_limit;
@@ -280,13 +284,12 @@
   /* set tag with name == interface */
   iface_id.net = iface_name;
   iface_id.next = NULL;
-  parm.tags = &iface_id; 
-  
-  for (context = daemon->dhcp6; context; context = context->next)
-    {
-      context->flags &= ~CONTEXT_RA_DONE;
-      context->netid.next = &context->netid;
-    }
+  parm.tags = &iface_id;
+
+  for (context = daemon->dhcp6; context; context = context->next) {
+    context->flags &= ~CONTEXT_RA_DONE;
+    context->netid.next = &context->netid;
+  }
 
   if (!iface_enumerate(AF_INET6, &parm, add_prefixes))
     return;
@@ -296,7 +299,7 @@
   min_pref_time = 0xffffffff;
   if (parm.glob_pref_time != 0 && parm.glob_pref_time < min_pref_time)
     min_pref_time = parm.glob_pref_time;
-  
+
   if (parm.ula_pref_time != 0 && parm.ula_pref_time < min_pref_time)
     min_pref_time = parm.ula_pref_time;
 
@@ -305,102 +308,95 @@
 
   /* Look for constructed contexts associated with addresses which have gone, 
      and advertise them with preferred_time == 0  RFC 6204 4.3 L-13 */
-  for (up = &daemon->dhcp6, context = daemon->dhcp6; context; context = tmp)
-    {
-      tmp = context->next;
-
-      if (context->if_index == iface && (context->flags & CONTEXT_OLD))
-	{
-	  unsigned int old = difftime(now, context->address_lost_time);
-	  
-	  if (old > context->saved_valid)
-	    { 
-	      /* We've advertised this enough, time to go */
-	     
-	      /* If this context held the timeout, and there's another context in use
-		 transfer the timeout there. */
-	      if (context->ra_time != 0 && parm.found_context && parm.found_context->ra_time == 0)
-		new_timeout(parm.found_context, iface_name, now);
-	      
-	      *up = context->next;
-	      free(context);
-	    }
-	  else
-	    {
-	      struct prefix_opt *opt;
-	      struct in6_addr local = context->start6;
-	      int do_slaac = 0;
-
-	      old_prefix = 1;
-
-	      /* zero net part of address */
-	      setaddr6part(&local, addr6part(&local) & ~((context->prefix == 64) ? (u64)-1LL : (1LLU << (128 - context->prefix)) - 1LLU));
-	     
-	      
-	      if (context->flags & CONTEXT_RA)
-		{
-		  do_slaac = 1;
-		  if (context->flags & CONTEXT_DHCP)
-		    {
-		      parm.other = 1; 
-		      if (!(context->flags & CONTEXT_RA_STATELESS))
-			parm.managed = 1;
-		    }
-		}
-	      else
-		{
-		  /* don't do RA for non-ra-only unless --enable-ra is set */
-		  if (option_bool(OPT_RA))
-		    {
-		      parm.managed = 1;
-		      parm.other = 1;
-		    }
-		}
-
-	      if ((opt = expand(sizeof(struct prefix_opt))))
-		{
-		  opt->type = ICMP6_OPT_PREFIX;
-		  opt->len = 4;
-		  opt->prefix_len = context->prefix;
-		  /* autonomous only if we're not doing dhcp, set
-                     "on-link" unless "off-link" was specified */
-		  opt->flags = (do_slaac ? 0x40 : 0) |
-                    ((context->flags & CONTEXT_RA_OFF_LINK) ? 0 : 0x80);
-		  opt->valid_lifetime = htonl(context->saved_valid - old);
-		  opt->preferred_lifetime = htonl(0);
-		  opt->reserved = 0; 
-		  opt->prefix = local;
-		  
-		  inet_ntop(AF_INET6, &local, daemon->addrbuff, ADDRSTRLEN);
-		  if (!option_bool(OPT_QUIET_RA))
-		    my_syslog(MS_DHCP | LOG_INFO, "RTR-ADVERT(%s) %s old prefix", iface_name, daemon->addrbuff); 		    
-		}
-	   
-	      up = &context->next;
-	    }
-	}
-      else
-	up = &context->next;
-    }
-    
+  for (up = &daemon->dhcp6, context = daemon->dhcp6; context; context = tmp) {
+    tmp = context->next;
+
+    if (context->if_index == iface && (context->flags & CONTEXT_OLD)) {
+      unsigned int old = difftime(now, context->address_lost_time);
+
+      if (old > context->saved_valid) {
+        /* We've advertised this enough, time to go */
+
+        /* If this context held the timeout, and there's another context in use
+           transfer the timeout there. */
+        if (context->ra_time != 0 && parm.found_context
+            && parm.found_context->ra_time == 0)
+          new_timeout(parm.found_context, iface_name, now);
+
+        *up = context->next;
+        free(context);
+      } else {
+        struct prefix_opt *opt;
+        struct in6_addr local = context->start6;
+        int do_slaac = 0;
+
+        old_prefix = 1;
+
+        /* zero net part of address */
+        setaddr6part(&local,
+                     addr6part(&local) & ~((context->prefix == 64) ? (u64) -
+                                           1LL : (1LLU <<
+                                                  (128 - context->prefix)) -
+                                           1LLU));
+
+
+        if (context->flags & CONTEXT_RA) {
+          do_slaac = 1;
+          if (context->flags & CONTEXT_DHCP) {
+            parm.other = 1;
+            if (!(context->flags & CONTEXT_RA_STATELESS))
+              parm.managed = 1;
+          }
+        } else {
+          /* don't do RA for non-ra-only unless --enable-ra is set */
+          if (option_bool(OPT_RA)) {
+            parm.managed = 1;
+            parm.other = 1;
+          }
+        }
+
+        if ((opt = expand(sizeof(struct prefix_opt)))) {
+          opt->type = ICMP6_OPT_PREFIX;
+          opt->len = 4;
+          opt->prefix_len = context->prefix;
+          /* autonomous only if we're not doing dhcp, set
+             "on-link" unless "off-link" was specified */
+          opt->flags = (do_slaac ? 0x40 : 0) |
+              ((context->flags & CONTEXT_RA_OFF_LINK) ? 0 : 0x80);
+          opt->valid_lifetime = htonl(context->saved_valid - old);
+          opt->preferred_lifetime = htonl(0);
+          opt->reserved = 0;
+          opt->prefix = local;
+
+          inet_ntop(AF_INET6, &local, daemon->addrbuff, ADDRSTRLEN);
+          if (!option_bool(OPT_QUIET_RA))
+            my_syslog(MS_DHCP | LOG_INFO, "RTR-ADVERT(%s) %s old prefix",
+                      iface_name, daemon->addrbuff);
+        }
+
+        up = &context->next;
+      }
+    } else
+      up = &context->next;
+  }
+
   /* If we're advertising only old prefixes, set router lifetime to zero. */
   if (old_prefix && !parm.found_context)
     ra->lifetime = htons(0);
 
   /* No prefixes to advertise. */
   if (!old_prefix && !parm.found_context)
-    return; 
-  
+    return;
+
   /* If we're sending router address instead of prefix in at least on prefix,
      include the advertisement interval option. */
-  if (parm.adv_router)
-    {
-      put_opt6_char(ICMP6_OPT_ADV_INTERVAL);
-      put_opt6_char(1);
-      put_opt6_short(0);
-      /* interval value is in milliseconds */
-      put_opt6_long(1000 * calc_interval(find_iface_param(iface_name)));
-    }
+  if (parm.adv_router) {
+    put_opt6_char(ICMP6_OPT_ADV_INTERVAL);
+    put_opt6_char(1);
+    put_opt6_short(0);
+    /* interval value is in milliseconds */
+    put_opt6_long(1000 * calc_interval(find_iface_param(iface_name)));
+  }
 
   /* Set the MTU from ra_param if any, an MTU of 0 mean automatic for linux, */
   /* an MTU of -1 prevents the option from being sent. */
@@ -409,117 +405,105 @@
 #ifdef HAVE_LINUX_NETWORK
   /* Note that IPv6 MTU is not neccessarily the same as the IPv4 MTU
      available from SIOCGIFMTU */
-  if (mtu == 0)
-    {
-      char *mtu_name = ra_param ? ra_param->mtu_name : NULL;
-      sprintf(daemon->namebuff, "/proc/sys/net/ipv6/conf/%s/mtu", mtu_name ? : iface_name);
-      if ((f = fopen(daemon->namebuff, "r")))
-        {
-          if (fgets(daemon->namebuff, MAXDNAME, f))
-            mtu = atoi(daemon->namebuff);
-          fclose(f);
-        }
+  if (mtu == 0) {
+    char *mtu_name = ra_param ? ra_param->mtu_name : NULL;
+    sprintf(daemon->namebuff, "/proc/sys/net/ipv6/conf/%s/mtu",
+            mtu_name ? : iface_name);
+    if ((f = fopen(daemon->namebuff, "r"))) {
+      if (fgets(daemon->namebuff, MAXDNAME, f))
+        mtu = atoi(daemon->namebuff);
+      fclose(f);
     }
+  }
 #endif
-  if (mtu > 0)
-    {
-      put_opt6_char(ICMP6_OPT_MTU);
-      put_opt6_char(1);
-      put_opt6_short(0);
-      put_opt6_long(mtu);
-    }
-     
+  if (mtu > 0) {
+    put_opt6_char(ICMP6_OPT_MTU);
+    put_opt6_char(1);
+    put_opt6_short(0);
+    put_opt6_long(mtu);
+  }
+
   iface_enumerate(AF_LOCAL, &send_iface, add_lla);
- 
+
   /* RDNSS, RFC 6106, use relevant DHCP6 options */
-  (void)option_filter(parm.tags, NULL, daemon->dhcp_opts6);
-  
-  for (opt_cfg = daemon->dhcp_opts6; opt_cfg; opt_cfg = opt_cfg->next)
-    {
-      int i;
-      
-      /* netids match and not encapsulated? */
-      if (!(opt_cfg->flags & DHOPT_TAGOK))
+  (void) option_filter(parm.tags, NULL, daemon->dhcp_opts6);
+
+  for (opt_cfg = daemon->dhcp_opts6; opt_cfg; opt_cfg = opt_cfg->next) {
+    int i;
+
+    /* netids match and not encapsulated? */
+    if (!(opt_cfg->flags & DHOPT_TAGOK))
+      continue;
+
+    if (opt_cfg->opt == OPTION6_DNS_SERVER) {
+      struct in6_addr *a;
+      int len;
+
+      done_dns = 1;
+
+      if (opt_cfg->len == 0)
         continue;
-      
-      if (opt_cfg->opt == OPTION6_DNS_SERVER)
-        {
-	  struct in6_addr *a;
-	  int len;
-
-	  done_dns = 1;
-
-          if (opt_cfg->len == 0)
-	    continue;
-	  
-	  /* reduce len for any addresses we can't substitute */
-	  for (a = (struct in6_addr *)opt_cfg->val, len = opt_cfg->len, i = 0; 
-	       i < opt_cfg->len; i += IN6ADDRSZ, a++)
-	    if ((IN6_IS_ADDR_UNSPECIFIED(a) && parm.glob_pref_time == 0) ||
-		(IN6_IS_ADDR_ULA_ZERO(a) && parm.ula_pref_time == 0) ||
-		(IN6_IS_ADDR_LINK_LOCAL_ZERO(a) && parm.link_pref_time == 0))
-	      len -= IN6ADDRSZ;
-
-	  if (len != 0)
-	    {
-	      put_opt6_char(ICMP6_OPT_RDNSS);
-	      put_opt6_char((len/8) + 1);
-	      put_opt6_short(0);
-	      put_opt6_long(min_pref_time);
-	 
-	      for (a = (struct in6_addr *)opt_cfg->val, i = 0; i <  opt_cfg->len; i += IN6ADDRSZ, a++)
-		if (IN6_IS_ADDR_UNSPECIFIED(a))
-		  {
-		    if (parm.glob_pref_time != 0)
-		      put_opt6(&parm.link_global, IN6ADDRSZ);
-		  }
-		else if (IN6_IS_ADDR_ULA_ZERO(a))
-		  {
-		    if (parm.ula_pref_time != 0)
-		    put_opt6(&parm.ula, IN6ADDRSZ);
-		  }
-		else if (IN6_IS_ADDR_LINK_LOCAL_ZERO(a))
-		  {
-		    if (parm.link_pref_time != 0)
-		      put_opt6(&parm.link_local, IN6ADDRSZ);
-		  }
-		else
-		  put_opt6(a, IN6ADDRSZ);
-	    }
-	}
-      
-      if (opt_cfg->opt == OPTION6_DOMAIN_SEARCH && opt_cfg->len != 0)
-	{
-	  int len = ((opt_cfg->len+7)/8);
-	  
-	  put_opt6_char(ICMP6_OPT_DNSSL);
-	  put_opt6_char(len + 1);
-	  put_opt6_short(0);
-	  put_opt6_long(min_pref_time); 
-	  put_opt6(opt_cfg->val, opt_cfg->len);
-	  
-	  /* pad */
-	  for (i = opt_cfg->len; i < len * 8; i++)
-	    put_opt6_char(0);
-	}
+
+      /* reduce len for any addresses we can't substitute */
+      for (a = (struct in6_addr *) opt_cfg->val, len = opt_cfg->len, i = 0;
+           i < opt_cfg->len; i += IN6ADDRSZ, a++)
+        if ((IN6_IS_ADDR_UNSPECIFIED(a) && parm.glob_pref_time == 0) ||
+            (IN6_IS_ADDR_ULA_ZERO(a) && parm.ula_pref_time == 0) ||
+            (IN6_IS_ADDR_LINK_LOCAL_ZERO(a) && parm.link_pref_time == 0))
+          len -= IN6ADDRSZ;
+
+      if (len != 0) {
+        put_opt6_char(ICMP6_OPT_RDNSS);
+        put_opt6_char((len / 8) + 1);
+        put_opt6_short(0);
+        put_opt6_long(min_pref_time);
+
+        for (a = (struct in6_addr *) opt_cfg->val, i = 0; i < opt_cfg->len;
+             i += IN6ADDRSZ, a++)
+          if (IN6_IS_ADDR_UNSPECIFIED(a)) {
+            if (parm.glob_pref_time != 0)
+              put_opt6(&parm.link_global, IN6ADDRSZ);
+          } else if (IN6_IS_ADDR_ULA_ZERO(a)) {
+            if (parm.ula_pref_time != 0)
+              put_opt6(&parm.ula, IN6ADDRSZ);
+          } else if (IN6_IS_ADDR_LINK_LOCAL_ZERO(a)) {
+            if (parm.link_pref_time != 0)
+              put_opt6(&parm.link_local, IN6ADDRSZ);
+          } else
+            put_opt6(a, IN6ADDRSZ);
+      }
     }
-	
-  if (daemon->port == NAMESERVER_PORT && !done_dns && parm.link_pref_time != 0)
-    {
-      /* default == us, as long as we are supplying DNS service. */
-      put_opt6_char(ICMP6_OPT_RDNSS);
-      put_opt6_char(3);
+
+    if (opt_cfg->opt == OPTION6_DOMAIN_SEARCH && opt_cfg->len != 0) {
+      int len = ((opt_cfg->len + 7) / 8);
+
+      put_opt6_char(ICMP6_OPT_DNSSL);
+      put_opt6_char(len + 1);
       put_opt6_short(0);
-      put_opt6_long(min_pref_time); 
-      put_opt6(&parm.link_local, IN6ADDRSZ);
-    }
+      put_opt6_long(min_pref_time);
+      put_opt6(opt_cfg->val, opt_cfg->len);
+
+      /* pad */
+      for (i = opt_cfg->len; i < len * 8; i++)
+        put_opt6_char(0);
+    }
+  }
+
+  if (daemon->port == NAMESERVER_PORT && !done_dns && parm.link_pref_time != 0) {
+    /* default == us, as long as we are supplying DNS service. */
+    put_opt6_char(ICMP6_OPT_RDNSS);
+    put_opt6_char(3);
+    put_opt6_short(0);
+    put_opt6_long(min_pref_time);
+    put_opt6(&parm.link_local, IN6ADDRSZ);
+  }
 
   /* set managed bits unless we're providing only RA on this link */
   if (parm.managed)
-    ra->flags |= 0x80; /* M flag, managed, */
-   if (parm.other)
-    ra->flags |= 0x40; /* O flag, other */ 
-			
+    ra->flags |= 0x80;          /* M flag, managed, */
+  if (parm.other)
+    ra->flags |= 0x40;          /* O flag, other */
+
   /* decide where we're sending */
   memset(&addr, 0, sizeof(addr));
 #ifdef HAVE_SOCKADDR_SA_LEN
@@ -527,226 +511,208 @@
 #endif
   addr.sin6_family = AF_INET6;
   addr.sin6_port = htons(IPPROTO_ICMPV6);
-  if (dest)
-    {
-      addr.sin6_addr = *dest;
-      if (IN6_IS_ADDR_LINKLOCAL(dest) ||
-	  IN6_IS_ADDR_MC_LINKLOCAL(dest))
-	addr.sin6_scope_id = iface;
-    }
-  else
-    {
-      inet_pton(AF_INET6, ALL_NODES, &addr.sin6_addr); 
-      setsockopt(daemon->icmp6fd, IPPROTO_IPV6, IPV6_MULTICAST_IF, &send_iface, sizeof(send_iface));
-    }
-  
-  while (retry_send(sendto(daemon->icmp6fd, daemon->outpacket.iov_base, 
-			   save_counter(-1), 0, (struct sockaddr *)&addr, 
-			   sizeof(addr))));
-  
+  if (dest) {
+    addr.sin6_addr = *dest;
+    if (IN6_IS_ADDR_LINKLOCAL(dest) || IN6_IS_ADDR_MC_LINKLOCAL(dest))
+      addr.sin6_scope_id = iface;
+  } else {
+    inet_pton(AF_INET6, ALL_NODES, &addr.sin6_addr);
+    setsockopt(daemon->icmp6fd, IPPROTO_IPV6, IPV6_MULTICAST_IF, &send_iface,
+               sizeof(send_iface));
+  }
+
+  while (retry_send(sendto(daemon->icmp6fd, daemon->outpacket.iov_base,
+                           save_counter(-1), 0, (struct sockaddr *) &addr,
+                           sizeof(addr))));
+
 }
 
-static void send_ra(time_t now, int iface, char *iface_name, struct in6_addr *dest)
+static void send_ra(time_t now, int iface, char *iface_name,
+                    struct in6_addr *dest)
 {
   /* Send an RA on the same interface that the RA content is based
      on. */
   send_ra_alias(now, iface, iface_name, dest, iface);
 }
 
-static int add_prefixes(struct in6_addr *local,  int prefix,
-			int scope, int if_index, int flags, 
-			unsigned int preferred, unsigned int valid, void *vparam)
+static int add_prefixes(struct in6_addr *local, int prefix,
+                        int scope, int if_index, int flags,
+                        unsigned int preferred, unsigned int valid,
+                        void *vparam)
 {
   struct ra_param *param = vparam;
 
-  (void)scope; /* warning */
-  
-  if (if_index == param->ind)
-    {
-      if (IN6_IS_ADDR_LINKLOCAL(local))
-	{
-	  /* Can there be more than one LL address?
-	     Select the one with the longest preferred time 
-	     if there is. */
-	  if (preferred > param->link_pref_time)
-	    {
-	      param->link_pref_time = preferred;
-	      param->link_local = *local;
-	    }
-	}
-      else if (!IN6_IS_ADDR_LOOPBACK(local) &&
-	       !IN6_IS_ADDR_MULTICAST(local))
-	{
-	  int real_prefix = 0;
-	  int do_slaac = 0;
-	  int deprecate  = 0;
-	  int constructed = 0;
-	  int adv_router = 0;
-	  int off_link = 0;
-	  unsigned int time = 0xffffffff;
-	  struct dhcp_context *context;
-	  
-	  for (context = daemon->dhcp6; context; context = context->next)
-	    if (!(context->flags & (CONTEXT_TEMPLATE | CONTEXT_OLD)) &&
-		prefix <= context->prefix &&
-		is_same_net6(local, &context->start6, context->prefix) &&
-		is_same_net6(local, &context->end6, context->prefix))
-	      {
-		context->saved_valid = valid;
-
-		if (context->flags & CONTEXT_RA) 
-		  {
-		    do_slaac = 1;
-		    if (context->flags & CONTEXT_DHCP)
-		      {
-			param->other = 1; 
-			if (!(context->flags & CONTEXT_RA_STATELESS))
-			  param->managed = 1;
-		      }
-		  }
-		else
-		  {
-		    /* don't do RA for non-ra-only unless --enable-ra is set */
-		    if (!option_bool(OPT_RA))
-		      continue;
-		    param->managed = 1;
-		    param->other = 1;
-		  }
-
-		/* Configured to advertise router address, not prefix. See RFC 3775 7.2 
-		 In this case we do all addresses associated with a context, 
-		 hence the real_prefix setting here. */
-		if (context->flags & CONTEXT_RA_ROUTER)
-		  {
-		    adv_router = 1;
-		    param->adv_router = 1;
-		    real_prefix = context->prefix;
-		  }
-
-		/* find floor time, don't reduce below 3 * RA interval. */
-		if (time > context->lease_time)
-		  {
-		    time = context->lease_time;
-		    if (time < ((unsigned int)(3 * param->adv_interval)))
-		      time = 3 * param->adv_interval;
-		  }
-
-		if (context->flags & CONTEXT_DEPRECATE)
-		  deprecate = 1;
-		
-		if (context->flags & CONTEXT_CONSTRUCTED)
-		  constructed = 1;
-
-
-		/* collect dhcp-range tags */
-		if (context->netid.next == &context->netid && context->netid.net)
-		  {
-		    context->netid.next = param->tags;
-		    param->tags = &context->netid;
-		  }
-		  
-		/* subsequent prefixes on the same interface 
-		   and subsequent instances of this prefix don't need timers.
-		   Be careful not to find the same prefix twice with different
-		   addresses unless we're advertising the actual addresses. */
-		if (!(context->flags & CONTEXT_RA_DONE))
-		  {
-		    if (!param->first)
-		      context->ra_time = 0;
-		    context->flags |= CONTEXT_RA_DONE;
-		    real_prefix = context->prefix;
-                    off_link = (context->flags & CONTEXT_RA_OFF_LINK);
-		  }
-
-		param->first = 0;
-		/* found_context is the _last_ one we found, so if there's 
-		   more than one, it's not the first. */
-		param->found_context = context;
-	      }
-
-	  /* configured time is ceiling */
-	  if (!constructed || valid > time)
-	    valid = time;
-	  
-	  if (flags & IFACE_DEPRECATED)
-	    preferred = 0;
-	  
-	  if (deprecate)
-	    time = 0;
-	  
-	  /* configured time is ceiling */
-	  if (!constructed || preferred > time)
-	    preferred = time;
-	  
-	  if (IN6_IS_ADDR_ULA(local))
-	    {
-	      if (preferred > param->ula_pref_time)
-		{
-		  param->ula_pref_time = preferred;
-		  param->ula = *local;
-		}
-	    }
-	  else 
-	    {
-	      if (preferred > param->glob_pref_time)
-		{
-		  param->glob_pref_time = preferred;
-		  param->link_global = *local;
-		}
-	    }
-	  
-	  if (real_prefix != 0)
-	    {
-	      struct prefix_opt *opt;
-	     	      
-	      if ((opt = expand(sizeof(struct prefix_opt))))
-		{
-		  /* zero net part of address */
-		  if (!adv_router)
-		    setaddr6part(local, addr6part(local) & ~((real_prefix == 64) ? (u64)-1LL : (1LLU << (128 - real_prefix)) - 1LLU));
-		  
-		  opt->type = ICMP6_OPT_PREFIX;
-		  opt->len = 4;
-		  opt->prefix_len = real_prefix;
-		  /* autonomous only if we're not doing dhcp, set
-                     "on-link" unless "off-link" was specified */
-		  opt->flags = (off_link ? 0 : 0x80);
-		  if (do_slaac)
-		    opt->flags |= 0x40;
-		  if (adv_router)
-		    opt->flags |= 0x20;
-		  opt->valid_lifetime = htonl(valid);
-		  opt->preferred_lifetime = htonl(preferred);
-		  opt->reserved = 0; 
-		  opt->prefix = *local;
-		  
-		  inet_ntop(AF_INET6, local, daemon->addrbuff, ADDRSTRLEN);
-		  if (!option_bool(OPT_QUIET_RA))
-		    my_syslog(MS_DHCP | LOG_INFO, "RTR-ADVERT(%s) %s", param->if_name, daemon->addrbuff); 		    
-		}
-	    }
-	}
-    }          
+  (void) scope;                 /* warning */
+
+  if (if_index == param->ind) {
+    if (IN6_IS_ADDR_LINKLOCAL(local)) {
+      /* Can there be more than one LL address?
+         Select the one with the longest preferred time
+         if there is. */
+      if (preferred > param->link_pref_time) {
+        param->link_pref_time = preferred;
+        param->link_local = *local;
+      }
+    } else if (!IN6_IS_ADDR_LOOPBACK(local) && !IN6_IS_ADDR_MULTICAST(local)) {
+      int real_prefix = 0;
+      int do_slaac = 0;
+      int deprecate = 0;
+      int constructed = 0;
+      int adv_router = 0;
+      int off_link = 0;
+      unsigned int time = 0xffffffff;
+      struct dhcp_context *context;
+
+      for (context = daemon->dhcp6; context; context = context->next)
+        if (!(context->flags & (CONTEXT_TEMPLATE | CONTEXT_OLD)) &&
+            prefix <= context->prefix &&
+            is_same_net6(local, &context->start6, context->prefix) &&
+            is_same_net6(local, &context->end6, context->prefix)) {
+          context->saved_valid = valid;
+
+          if (context->flags & CONTEXT_RA) {
+            do_slaac = 1;
+            if (context->flags & CONTEXT_DHCP) {
+              param->other = 1;
+              if (!(context->flags & CONTEXT_RA_STATELESS))
+                param->managed = 1;
+            }
+          } else {
+            /* don't do RA for non-ra-only unless --enable-ra is set */
+            if (!option_bool(OPT_RA))
+              continue;
+            param->managed = 1;
+            param->other = 1;
+          }
+
+          /* Configured to advertise router address, not prefix. See RFC 3775 7.2
+             In this case we do all addresses associated with a context,
+             hence the real_prefix setting here. */
+          if (context->flags & CONTEXT_RA_ROUTER) {
+            adv_router = 1;
+            param->adv_router = 1;
+            real_prefix = context->prefix;
+          }
+
+          /* find floor time, don't reduce below 3 * RA interval. */
+          if (time > context->lease_time) {
+            time = context->lease_time;
+            if (time < ((unsigned int) (3 * param->adv_interval)))
+              time = 3 * param->adv_interval;
+          }
+
+          if (context->flags & CONTEXT_DEPRECATE)
+            deprecate = 1;
+
+          if (context->flags & CONTEXT_CONSTRUCTED)
+            constructed = 1;
+
+
+          /* collect dhcp-range tags */
+          if (context->netid.next == &context->netid && context->netid.net) {
+            context->netid.next = param->tags;
+            param->tags = &context->netid;
+          }
+
+          /* subsequent prefixes on the same interface
+             and subsequent instances of this prefix don't need timers.
+             Be careful not to find the same prefix twice with different
+             addresses unless we're advertising the actual addresses. */
+          if (!(context->flags & CONTEXT_RA_DONE)) {
+            if (!param->first)
+              context->ra_time = 0;
+            context->flags |= CONTEXT_RA_DONE;
+            real_prefix = context->prefix;
+            off_link = (context->flags & CONTEXT_RA_OFF_LINK);
+          }
+
+          param->first = 0;
+          /* found_context is the _last_ one we found, so if there's
+             more than one, it's not the first. */
+          param->found_context = context;
+        }
+
+      /* configured time is ceiling */
+      if (!constructed || valid > time)
+        valid = time;
+
+      if (flags & IFACE_DEPRECATED)
+        preferred = 0;
+
+      if (deprecate)
+        time = 0;
+
+      /* configured time is ceiling */
+      if (!constructed || preferred > time)
+        preferred = time;
+
+      if (IN6_IS_ADDR_ULA(local)) {
+        if (preferred > param->ula_pref_time) {
+          param->ula_pref_time = preferred;
+          param->ula = *local;
+        }
+      } else {
+        if (preferred > param->glob_pref_time) {
+          param->glob_pref_time = preferred;
+          param->link_global = *local;
+        }
+      }
+
+      if (real_prefix != 0) {
+        struct prefix_opt *opt;
+
+        if ((opt = expand(sizeof(struct prefix_opt)))) {
+          /* zero net part of address */
+          if (!adv_router)
+            setaddr6part(local,
+                         addr6part(local) & ~((real_prefix == 64) ? (u64) -
+                                              1LL : (1LLU <<
+                                                     (128 - real_prefix)) -
+                                              1LLU));
+
+          opt->type = ICMP6_OPT_PREFIX;
+          opt->len = 4;
+          opt->prefix_len = real_prefix;
+          /* autonomous only if we're not doing dhcp, set
+             "on-link" unless "off-link" was specified */
+          opt->flags = (off_link ? 0 : 0x80);
+          if (do_slaac)
+            opt->flags |= 0x40;
+          if (adv_router)
+            opt->flags |= 0x20;
+          opt->valid_lifetime = htonl(valid);
+          opt->preferred_lifetime = htonl(preferred);
+          opt->reserved = 0;
+          opt->prefix = *local;
+
+          inet_ntop(AF_INET6, local, daemon->addrbuff, ADDRSTRLEN);
+          if (!option_bool(OPT_QUIET_RA))
+            my_syslog(MS_DHCP | LOG_INFO, "RTR-ADVERT(%s) %s", param->if_name,
+                      daemon->addrbuff);
+        }
+      }
+    }
+  }
   return 1;
 }
 
-static int add_lla(int index, unsigned int type, char *mac, size_t maclen, void *parm)
+static int add_lla(int index, unsigned int type, char *mac, size_t maclen,
+                   void *parm)
 {
-  (void)type;
+  (void) type;
 
-  if (index == *((int *)parm))
-    {
-      /* size is in units of 8 octets and includes type and length (2 bytes)
-	 add 7 to round up */
-      int len = (maclen + 9) >> 3;
-      unsigned char *p = expand(len << 3);
-      memset(p, 0, len << 3);
-      *p++ = ICMP6_OPT_SOURCE_MAC;
-      *p++ = len;
-      memcpy(p, mac, maclen);
+  if (index == *((int *) parm)) {
+    /* size is in units of 8 octets and includes type and length (2 bytes)
+       add 7 to round up */
+    int len = (maclen + 9) >> 3;
+    unsigned char *p = expand(len << 3);
+    memset(p, 0, len << 3);
+    *p++ = ICMP6_OPT_SOURCE_MAC;
+    *p++ = len;
+    memcpy(p, mac, maclen);
 
-      return 0;
-    }
+    return 0;
+  }
 
   return 1;
 }
@@ -757,197 +723,187 @@
   struct dhcp_context *context;
   time_t next_event;
   struct alias_param aparam;
-    
+
   param.now = now;
   param.iface = 0;
 
-  while (1)
-    {
-      /* find overdue events, and time of first future event */
-      for (next_event = 0, context = daemon->dhcp6; context; context = context->next)
-	if (context->ra_time != 0)
-	  {
-	    if (difftime(context->ra_time, now) <= 0.0)
-	      break; /* overdue */
-	    
-	    if (next_event == 0 || difftime(next_event, context->ra_time) > 0.0)
-	      next_event = context->ra_time;
-	  }
-      
-      /* none overdue */
-      if (!context)
-	break;
-      
-      if ((context->flags & CONTEXT_OLD) && 
-	  context->if_index != 0 && 
-	  indextoname(daemon->icmp6fd, context->if_index, param.name))
-	{
-	  /* A context for an old address. We'll not find the interface by 
-	     looking for addresses, but we know it anyway, since the context is
-	     constructed */
-	  param.iface = context->if_index;
-	  new_timeout(context, param.name, now);
-	}
-      else if (iface_enumerate(AF_INET6, &param, iface_search))
-	/* There's a context overdue, but we can't find an interface
-	   associated with it, because it's for a subnet we dont 
-	   have an interface on. Probably we're doing DHCP on
-	   a remote subnet via a relay. Zero the timer, since we won't
-	   ever be able to send ra's and satisfy it. */
-	context->ra_time = 0;
-      
-      if (param.iface != 0 &&
-	  iface_check(AF_LOCAL, NULL, param.name, NULL))
-	{
-	  struct iname *tmp;
-	  for (tmp = daemon->dhcp_except; tmp; tmp = tmp->next)
-	    if (tmp->name && wildcard_match(tmp->name, param.name))
-	      break;
-	  if (!tmp)
-            {
-              send_ra(now, param.iface, param.name, NULL); 
-
-              /* Also send on all interfaces that are aliases of this
-                 one. */
-              for (aparam.bridge = daemon->bridges;
-                   aparam.bridge;
-                   aparam.bridge = aparam.bridge->next)
-                if ((int)if_nametoindex(aparam.bridge->iface) == param.iface)
-                  {
-                    /* Count the number of alias interfaces for this
-                       'bridge', by calling iface_enumerate with
-                       send_ra_to_aliases and NULL alias_ifs. */
-                    aparam.iface = param.iface;
-                    aparam.alias_ifs = NULL;
-                    aparam.num_alias_ifs = 0;
-                    iface_enumerate(AF_LOCAL, &aparam, send_ra_to_aliases);
-                    my_syslog(MS_DHCP | LOG_INFO, "RTR-ADVERT(%s) %s => %d alias(es)",
-                              param.name, daemon->addrbuff, aparam.num_alias_ifs);
-
-                    /* Allocate memory to store the alias interface
-                       indices. */
-                    aparam.alias_ifs = (int *)whine_malloc(aparam.num_alias_ifs *
-                                                           sizeof(int));
-                    if (aparam.alias_ifs)
-                      {
-                        /* Use iface_enumerate again to get the alias
-                           interface indices, then send on each of
-                           those. */
-                        aparam.max_alias_ifs = aparam.num_alias_ifs;
-                        aparam.num_alias_ifs = 0;
-                        iface_enumerate(AF_LOCAL, &aparam, send_ra_to_aliases);
-                        for (; aparam.num_alias_ifs; aparam.num_alias_ifs--)
-                          {
-                            my_syslog(MS_DHCP | LOG_INFO, "RTR-ADVERT(%s) %s => i/f %d",
-                                      param.name, daemon->addrbuff,
-                                      aparam.alias_ifs[aparam.num_alias_ifs - 1]);
-                            send_ra_alias(now,
-                                          param.iface,
-                                          param.name,
-                                          NULL,
-                                          aparam.alias_ifs[aparam.num_alias_ifs - 1]);
-                          }
-                        free(aparam.alias_ifs);
-                      }
-
-                    /* The source interface can only appear in at most
-                       one --bridge-interface. */
-                    break;
-                  }
+  while (1) {
+    /* find overdue events, and time of first future event */
+    for (next_event = 0, context = daemon->dhcp6; context;
+         context = context->next)
+      if (context->ra_time != 0) {
+        if (difftime(context->ra_time, now) <= 0.0)
+          break;                /* overdue */
+
+        if (next_event == 0 || difftime(next_event, context->ra_time) > 0.0)
+          next_event = context->ra_time;
+      }
+
+    /* none overdue */
+    if (!context)
+      break;
+
+    if ((context->flags & CONTEXT_OLD) &&
+        context->if_index != 0 &&
+        indextoname(daemon->icmp6fd, context->if_index, param.name)) {
+      /* A context for an old address. We'll not find the interface by
+         looking for addresses, but we know it anyway, since the context is
+         constructed */
+      param.iface = context->if_index;
+      new_timeout(context, param.name, now);
+    } else if (iface_enumerate(AF_INET6, &param, iface_search))
+      /* There's a context overdue, but we can't find an interface
+         associated with it, because it's for a subnet we dont
+         have an interface on. Probably we're doing DHCP on
+         a remote subnet via a relay. Zero the timer, since we won't
+         ever be able to send ra's and satisfy it. */
+      context->ra_time = 0;
+
+    if (param.iface != 0 && iface_check(AF_LOCAL, NULL, param.name, NULL)) {
+      struct iname *tmp;
+      for (tmp = daemon->dhcp_except; tmp; tmp = tmp->next)
+        if (tmp->name && wildcard_match(tmp->name, param.name))
+          break;
+      if (!tmp) {
+        send_ra(now, param.iface, param.name, NULL);
+
+        /* Also send on all interfaces that are aliases of this
+           one. */
+        for (aparam.bridge = daemon->bridges;
+             aparam.bridge; aparam.bridge = aparam.bridge->next)
+          if ((int) if_nametoindex(aparam.bridge->iface) == param.iface) {
+            /* Count the number of alias interfaces for this
+               'bridge', by calling iface_enumerate with
+               send_ra_to_aliases and NULL alias_ifs. */
+            aparam.iface = param.iface;
+            aparam.alias_ifs = NULL;
+            aparam.num_alias_ifs = 0;
+            iface_enumerate(AF_LOCAL, &aparam, send_ra_to_aliases);
+            my_syslog(MS_DHCP | LOG_INFO, "RTR-ADVERT(%s) %s => %d alias(es)",
+                      param.name, daemon->addrbuff, aparam.num_alias_ifs);
+
+            /* Allocate memory to store the alias interface
+               indices. */
+            aparam.alias_ifs = (int *) whine_malloc(aparam.num_alias_ifs *
+                                                    sizeof(int));
+            if (aparam.alias_ifs) {
+              /* Use iface_enumerate again to get the alias
+                 interface indices, then send on each of
+                 those. */
+              aparam.max_alias_ifs = aparam.num_alias_ifs;
+              aparam.num_alias_ifs = 0;
+              iface_enumerate(AF_LOCAL, &aparam, send_ra_to_aliases);
+              for (; aparam.num_alias_ifs; aparam.num_alias_ifs--) {
+                my_syslog(MS_DHCP | LOG_INFO, "RTR-ADVERT(%s) %s => i/f %d",
+                          param.name, daemon->addrbuff,
+                          aparam.alias_ifs[aparam.num_alias_ifs - 1]);
+                send_ra_alias(now,
+                              param.iface,
+                              param.name,
+                              NULL, aparam.alias_ifs[aparam.num_alias_ifs - 1]);
+              }
+              free(aparam.alias_ifs);
             }
-	}
-    }      
+
+            /* The source interface can only appear in at most
+               one --bridge-interface. */
+            break;
+          }
+      }
+    }
+  }
   return next_event;
 }
 
-static int send_ra_to_aliases(int index, unsigned int type, char *mac, size_t maclen, void *parm)
+static int send_ra_to_aliases(int index, unsigned int type, char *mac,
+                              size_t maclen, void *parm)
 {
-  struct alias_param *aparam = (struct alias_param *)parm;
+  struct alias_param *aparam = (struct alias_param *) parm;
   char ifrn_name[IFNAMSIZ];
   struct dhcp_bridge *alias;
 
-  (void)type;
-  (void)mac;
-  (void)maclen;
+  (void) type;
+  (void) mac;
+  (void) maclen;
 
   if (if_indextoname(index, ifrn_name))
     for (alias = aparam->bridge->alias; alias; alias = alias->next)
-      if (wildcard_matchn(alias->iface, ifrn_name, IFNAMSIZ))
-        {
-          if (aparam->alias_ifs && (aparam->num_alias_ifs < aparam->max_alias_ifs))
-            aparam->alias_ifs[aparam->num_alias_ifs] = index;
-          aparam->num_alias_ifs++;
-        }
+      if (wildcard_matchn(alias->iface, ifrn_name, IFNAMSIZ)) {
+        if (aparam->alias_ifs
+            && (aparam->num_alias_ifs < aparam->max_alias_ifs))
+          aparam->alias_ifs[aparam->num_alias_ifs] = index;
+        aparam->num_alias_ifs++;
+      }
 
   return 1;
 }
 
-static int iface_search(struct in6_addr *local,  int prefix,
-			int scope, int if_index, int flags, 
-			int preferred, int valid, void *vparam)
+static int iface_search(struct in6_addr *local, int prefix,
+                        int scope, int if_index, int flags,
+                        int preferred, int valid, void *vparam)
 {
   struct search_param *param = vparam;
   struct dhcp_context *context;
 
-  (void)scope;
-  (void)preferred;
-  (void)valid;
- 
+  (void) scope;
+  (void) preferred;
+  (void) valid;
+
   for (context = daemon->dhcp6; context; context = context->next)
     if (!(context->flags & (CONTEXT_TEMPLATE | CONTEXT_OLD)) &&
-	prefix <= context->prefix &&
-	is_same_net6(local, &context->start6, context->prefix) &&
-	is_same_net6(local, &context->end6, context->prefix) &&
-	context->ra_time != 0 && 
-	difftime(context->ra_time, param->now) <= 0.0)
-      {
-	/* found an interface that's overdue for RA determine new 
-	   timeout value and arrange for RA to be sent unless interface is
-	   still doing DAD.*/
-	
-	if (!(flags & IFACE_TENTATIVE))
-	  param->iface = if_index;
-	
-	/* should never fail */
-	if (!indextoname(daemon->icmp6fd, if_index, param->name))
-	  {
-	    param->iface = 0;
-	    return 0;
-	  }
-	
-	new_timeout(context, param->name, param->now);
-	
-	/* zero timers for other contexts on the same subnet, so they don't timeout 
-	   independently */
-	for (context = context->next; context; context = context->next)
-	  if (prefix <= context->prefix &&
-	      is_same_net6(local, &context->start6, context->prefix) &&
-	      is_same_net6(local, &context->end6, context->prefix))
-	    context->ra_time = 0;
-	
-	return 0; /* found, abort */
+        prefix <= context->prefix &&
+        is_same_net6(local, &context->start6, context->prefix) &&
+        is_same_net6(local, &context->end6, context->prefix) &&
+        context->ra_time != 0 &&
+        difftime(context->ra_time, param->now) <= 0.0) {
+      /* found an interface that's overdue for RA determine new
+         timeout value and arrange for RA to be sent unless interface is
+         still doing DAD. */
+
+      if (!(flags & IFACE_TENTATIVE))
+        param->iface = if_index;
+
+      /* should never fail */
+      if (!indextoname(daemon->icmp6fd, if_index, param->name)) {
+        param->iface = 0;
+        return 0;
       }
-  
-  return 1; /* keep searching */
+
+      new_timeout(context, param->name, param->now);
+
+      /* zero timers for other contexts on the same subnet, so they don't timeout
+         independently */
+      for (context = context->next; context; context = context->next)
+        if (prefix <= context->prefix &&
+            is_same_net6(local, &context->start6, context->prefix) &&
+            is_same_net6(local, &context->end6, context->prefix))
+          context->ra_time = 0;
+
+      return 0;                 /* found, abort */
+    }
+
+  return 1;                     /* keep searching */
 }
- 
-static void new_timeout(struct dhcp_context *context, char *iface_name, time_t now)
+
+static void new_timeout(struct dhcp_context *context, char *iface_name,
+                        time_t now)
 {
   if (difftime(now, context->ra_short_period_start) < 60.0)
     /* range 5 - 20 */
-    context->ra_time = now + 5 + (rand16()/4400);
-  else
-    {
-      /* range 3/4 - 1 times MaxRtrAdvInterval */
-      unsigned int adv_interval = calc_interval(find_iface_param(iface_name));
-      context->ra_time = now + (3 * adv_interval)/4 + ((adv_interval * (unsigned int)rand16()) >> 18);
-    }
+    context->ra_time = now + 5 + (rand16() / 4400);
+  else {
+    /* range 3/4 - 1 times MaxRtrAdvInterval */
+    unsigned int adv_interval = calc_interval(find_iface_param(iface_name));
+    context->ra_time =
+        now + (3 * adv_interval) / 4 +
+        ((adv_interval * (unsigned int) rand16()) >> 18);
+  }
 }
 
 static struct ra_interface *find_iface_param(char *iface)
 {
   struct ra_interface *ra;
-  
+
   for (ra = daemon->ra_interfaces; ra; ra = ra->next)
     if (wildcard_match(ra->name, iface))
       return ra;
@@ -958,42 +914,40 @@
 static unsigned int calc_interval(struct ra_interface *ra)
 {
   int interval = 600;
-  
-  if (ra && ra->interval != 0)
-    {
-      interval = ra->interval;
-      if (interval > 1800)
-	interval = 1800;
-      else if (interval < 4)
-	interval = 4;
-    }
-  
-  return (unsigned int)interval;
+
+  if (ra && ra->interval != 0) {
+    interval = ra->interval;
+    if (interval > 1800)
+      interval = 1800;
+    else if (interval < 4)
+      interval = 4;
+  }
+
+  return (unsigned int) interval;
 }
 
 static unsigned int calc_lifetime(struct ra_interface *ra)
 {
-  int lifetime, interval = (int)calc_interval(ra);
-  
-  if (!ra || ra->lifetime == -1) /* not specified */
+  int lifetime, interval = (int) calc_interval(ra);
+
+  if (!ra || ra->lifetime == -1)        /* not specified */
     lifetime = 3 * interval;
-  else
-    {
-      lifetime = ra->lifetime;
-      if (lifetime < interval && lifetime != 0)
-	lifetime = interval;
-      else if (lifetime > 9000)
-	lifetime = 9000;
-    }
-  
-  return (unsigned int)lifetime;
+  else {
+    lifetime = ra->lifetime;
+    if (lifetime < interval && lifetime != 0)
+      lifetime = interval;
+    else if (lifetime > 9000)
+      lifetime = 9000;
+  }
+
+  return (unsigned int) lifetime;
 }
 
 static unsigned int calc_prio(struct ra_interface *ra)
 {
   if (ra)
     return ra->prio;
-  
+
   return 0;
 }
 
Index: dnsmasq-2.78/src/rfc1035.c
===================================================================
--- dnsmasq-2.78.orig/src/rfc1035.c	2017-10-02 21:13:51.000000000 +0800
+++ dnsmasq-2.78/src/rfc1035.c	2018-10-29 16:14:19.477440027 +0800
@@ -16,140 +16,125 @@
 
 #include "dnsmasq.h"
 
-int extract_name(struct dns_header *header, size_t plen, unsigned char **pp, 
-		 char *name, int isExtract, int extrabytes)
+int extract_name(struct dns_header *header, size_t plen, unsigned char **pp,
+                 char *name, int isExtract, int extrabytes)
 {
-  unsigned char *cp = (unsigned char *)name, *p = *pp, *p1 = NULL;
+  unsigned char *cp = (unsigned char *) name, *p = *pp, *p1 = NULL;
   unsigned int j, l, namelen = 0, hops = 0;
   int retvalue = 1;
-  
+
   if (isExtract)
     *cp = 0;
 
-  while (1)
-    { 
-      unsigned int label_type;
+  while (1) {
+    unsigned int label_type;
+
+    if (!CHECK_LEN(header, p, plen, 1))
+      return 0;
+
+    if ((l = *p++) == 0)
+      /* end marker */
+    {
+      /* check that there are the correct no of bytes after the name */
+      if (!CHECK_LEN(header, p1 ? p1 : p, plen, extrabytes))
+        return 0;
+
+      if (isExtract) {
+        if (cp != (unsigned char *) name)
+          cp--;
+        *cp = 0;                /* terminate: lose final period */
+      } else if (*cp != 0)
+        retvalue = 2;
+
+      if (p1)                   /* we jumped via compression */
+        *pp = p1;
+      else
+        *pp = p;
+
+      return retvalue;
+    }
+
+    label_type = l & 0xc0;
 
+    if (label_type == 0xc0) {   /* pointer */
       if (!CHECK_LEN(header, p, plen, 1))
-	return 0;
-      
-      if ((l = *p++) == 0) 
-	/* end marker */
-	{
-	  /* check that there are the correct no of bytes after the name */
-	  if (!CHECK_LEN(header, p1 ? p1 : p, plen, extrabytes))
-	    return 0;
-	  
-	  if (isExtract)
-	    {
-	      if (cp != (unsigned char *)name)
-		cp--;
-	      *cp = 0; /* terminate: lose final period */
-	    }
-	  else if (*cp != 0)
-	    retvalue = 2;
-	  
-	  if (p1) /* we jumped via compression */
-	    *pp = p1;
-	  else
-	    *pp = p;
-	  
-	  return retvalue;
-	}
-
-      label_type = l & 0xc0;
-      
-      if (label_type == 0xc0) /* pointer */
-	{ 
-	  if (!CHECK_LEN(header, p, plen, 1))
-	    return 0;
-	      
-	  /* get offset */
-	  l = (l&0x3f) << 8;
-	  l |= *p++;
-	  
-	  if (!p1) /* first jump, save location to go back to */
-	    p1 = p;
-	      
-	  hops++; /* break malicious infinite loops */
-	  if (hops > 255)
-	    return 0;
-	  
-	  p = l + (unsigned char *)header;
-	}
-      else if (label_type == 0x00)
-	{ /* label_type = 0 -> label. */
-	  namelen += l + 1; /* include period */
-	  if (namelen >= MAXDNAME)
-	    return 0;
-	  if (!CHECK_LEN(header, p, plen, l))
-	    return 0;
-	  
-	  for(j=0; j<l; j++, p++)
-	    if (isExtract)
-	      {
-		unsigned char c = *p;
+        return 0;
+
+      /* get offset */
+      l = (l & 0x3f) << 8;
+      l |= *p++;
+
+      if (!p1)                  /* first jump, save location to go back to */
+        p1 = p;
+
+      hops++;                   /* break malicious infinite loops */
+      if (hops > 255)
+        return 0;
+
+      p = l + (unsigned char *) header;
+    } else if (label_type == 0x00) {    /* label_type = 0 -> label. */
+      namelen += l + 1;         /* include period */
+      if (namelen >= MAXDNAME)
+        return 0;
+      if (!CHECK_LEN(header, p, plen, l))
+        return 0;
+
+      for (j = 0; j < l; j++, p++)
+        if (isExtract) {
+          unsigned char c = *p;
 #ifdef HAVE_DNSSEC
-		if (option_bool(OPT_DNSSEC_VALID))
-		  {
-		    if (c == 0 || c == '.' || c == NAME_ESCAPE)
-		      {
-			*cp++ = NAME_ESCAPE;
-			*cp++ = c+1;
-		      }
-		    else
-		      *cp++ = c; 
-		  }
-		else
+          if (option_bool(OPT_DNSSEC_VALID)) {
+            if (c == 0 || c == '.' || c == NAME_ESCAPE) {
+              *cp++ = NAME_ESCAPE;
+              *cp++ = c + 1;
+            } else
+              *cp++ = c;
+          } else
 #endif
-		if (c != 0 && c != '.')
-		  *cp++ = c;
-		else
-		  return 0;
-	      }
-	    else 
-	      {
-		unsigned char c1 = *cp, c2 = *p;
-		
-		if (c1 == 0)
-		  retvalue = 2;
-		else 
-		  {
-		    cp++;
-		    if (c1 >= 'A' && c1 <= 'Z')
-		      c1 += 'a' - 'A';
+          if (c != 0 && c != '.')
+            *cp++ = c;
+          else
+            return 0;
+        } else {
+          unsigned char c1 = *cp, c2 = *p;
+
+          if (c1 == 0)
+            retvalue = 2;
+          else {
+            cp++;
+            if (c1 >= 'A' && c1 <= 'Z')
+              c1 += 'a' - 'A';
 #ifdef HAVE_DNSSEC
-		    if (option_bool(OPT_DNSSEC_VALID) && c1 == NAME_ESCAPE)
-		      c1 = (*cp++)-1;
+            if (option_bool(OPT_DNSSEC_VALID) && c1 == NAME_ESCAPE)
+              c1 = (*cp++) - 1;
 #endif
-		    
-		    if (c2 >= 'A' && c2 <= 'Z')
-		      c2 += 'a' - 'A';
-		     
-		    if (c1 != c2)
-		      retvalue =  2;
-		  }
-	      }
-	    
-	  if (isExtract)
-	    *cp++ = '.';
-	  else if (*cp != 0 && *cp++ != '.')
-	    retvalue = 2;
-	}
-      else
-	return 0; /* label types 0x40 and 0x80 not supported */
-    }
+
+            if (c2 >= 'A' && c2 <= 'Z')
+              c2 += 'a' - 'A';
+
+            if (c1 != c2)
+              retvalue = 2;
+          }
+        }
+
+      if (isExtract)
+        *cp++ = '.';
+      else if (*cp != 0 && *cp++ != '.')
+        retvalue = 2;
+    } else
+      return 0;                 /* label types 0x40 and 0x80 not supported */
+  }
 }
- 
+
 /* Max size of input string (for IPv6) is 75 chars.) */
 #define MAXARPANAME 75
 int in_arpa_name_2_addr(char *namein, struct all_addr *addrp)
 {
   int j;
-  char name[MAXARPANAME+1], *cp1;
-  unsigned char *addr = (unsigned char *)addrp;
+  char name[MAXARPANAME + 1], *cp1;
+  unsigned char *addr = (unsigned char *) addrp;
   char *lastchunk = NULL, *penchunk = NULL;
-  
+
   if (strlen(namein) > MAXARPANAME)
     return 0;
 
@@ -157,180 +142,167 @@
 
   /* turn name into a series of asciiz strings */
   /* j counts no of labels */
-  for(j = 1,cp1 = name; *namein; cp1++, namein++)
-    if (*namein == '.')
-      {
-	penchunk = lastchunk;
-        lastchunk = cp1 + 1;
-	*cp1 = 0;
-	j++;
-      }
-    else
+  for (j = 1, cp1 = name; *namein; cp1++, namein++)
+    if (*namein == '.') {
+      penchunk = lastchunk;
+      lastchunk = cp1 + 1;
+      *cp1 = 0;
+      j++;
+    } else
       *cp1 = *namein;
-  
+
   *cp1 = 0;
 
-  if (j<3)
+  if (j < 3)
     return 0;
 
-  if (hostname_isequal(lastchunk, "arpa") && hostname_isequal(penchunk, "in-addr"))
-    {
-      /* IP v4 */
-      /* address arrives as a name of the form
-	 www.xxx.yyy.zzz.in-addr.arpa
-	 some of the low order address octets might be missing
-	 and should be set to zero. */
-      for (cp1 = name; cp1 != penchunk; cp1 += strlen(cp1)+1)
-	{
-	  /* check for digits only (weeds out things like
-	     50.0/24.67.28.64.in-addr.arpa which are used 
-	     as CNAME targets according to RFC 2317 */
-	  char *cp;
-	  for (cp = cp1; *cp; cp++)
-	    if (!isdigit((unsigned char)*cp))
-	      return 0;
-	  
-	  addr[3] = addr[2];
-	  addr[2] = addr[1];
-	  addr[1] = addr[0];
-	  addr[0] = atoi(cp1);
-	}
-
-      return F_IPV4;
+  if (hostname_isequal(lastchunk, "arpa")
+      && hostname_isequal(penchunk, "in-addr")) {
+    /* IP v4 */
+    /* address arrives as a name of the form
+       www.xxx.yyy.zzz.in-addr.arpa
+       some of the low order address octets might be missing
+       and should be set to zero. */
+    for (cp1 = name; cp1 != penchunk; cp1 += strlen(cp1) + 1) {
+      /* check for digits only (weeds out things like
+         50.0/24.67.28.64.in-addr.arpa which are used
+         as CNAME targets according to RFC 2317 */
+      char *cp;
+      for (cp = cp1; *cp; cp++)
+        if (!isdigit((unsigned char) *cp))
+          return 0;
+
+      addr[3] = addr[2];
+      addr[2] = addr[1];
+      addr[1] = addr[0];
+      addr[0] = atoi(cp1);
     }
+
+    return F_IPV4;
+  }
 #ifdef HAVE_IPV6
-  else if (hostname_isequal(penchunk, "ip6") && 
-	   (hostname_isequal(lastchunk, "int") || hostname_isequal(lastchunk, "arpa")))
-    {
-      /* IP v6:
-         Address arrives as 0.1.2.3.4.5.6.7.8.9.a.b.c.d.e.f.ip6.[int|arpa]
-    	 or \[xfedcba9876543210fedcba9876543210/128].ip6.[int|arpa]
-      
-	 Note that most of these the various representations are obsolete and 
-	 left-over from the many DNS-for-IPv6 wars. We support all the formats
-	 that we can since there is no reason not to.
-      */
-
-      if (*name == '\\' && *(name+1) == '[' && 
-	  (*(name+2) == 'x' || *(name+2) == 'X'))
-	{	  
-	  for (j = 0, cp1 = name+3; *cp1 && isxdigit((unsigned char) *cp1) && j < 32; cp1++, j++)
-	    {
-	      char xdig[2];
-	      xdig[0] = *cp1;
-	      xdig[1] = 0;
-	      if (j%2)
-		addr[j/2] |= strtol(xdig, NULL, 16);
-	      else
-		addr[j/2] = strtol(xdig, NULL, 16) << 4;
-	    }
-	  
-	  if (*cp1 == '/' && j == 32)
-	    return F_IPV6;
-	}
-      else
-	{
-	  for (cp1 = name; cp1 != penchunk; cp1 += strlen(cp1)+1)
-	    {
-	      if (*(cp1+1) || !isxdigit((unsigned char)*cp1))
-		return 0;
-	      
-	      for (j = sizeof(struct all_addr)-1; j>0; j--)
-		addr[j] = (addr[j] >> 4) | (addr[j-1] << 4);
-	      addr[0] = (addr[0] >> 4) | (strtol(cp1, NULL, 16) << 4);
-	    }
-	  
-	  return F_IPV6;
-	}
+  else if (hostname_isequal(penchunk, "ip6") &&
+           (hostname_isequal(lastchunk, "int")
+            || hostname_isequal(lastchunk, "arpa"))) {
+    /* IP v6:
+       Address arrives as 0.1.2.3.4.5.6.7.8.9.a.b.c.d.e.f.ip6.[int|arpa]
+       or \[xfedcba9876543210fedcba9876543210/128].ip6.[int|arpa]
+
+       Note that most of these the various representations are obsolete and
+       left-over from the many DNS-for-IPv6 wars. We support all the formats
+       that we can since there is no reason not to.
+     */
+
+    if (*name == '\\' && *(name + 1) == '[' &&
+        (*(name + 2) == 'x' || *(name + 2) == 'X')) {
+      for (j = 0, cp1 = name + 3;
+           *cp1 && isxdigit((unsigned char) *cp1) && j < 32; cp1++, j++) {
+        char xdig[2];
+        xdig[0] = *cp1;
+        xdig[1] = 0;
+        if (j % 2)
+          addr[j / 2] |= strtol(xdig, NULL, 16);
+        else
+          addr[j / 2] = strtol(xdig, NULL, 16) << 4;
+      }
+
+      if (*cp1 == '/' && j == 32)
+        return F_IPV6;
+    } else {
+      for (cp1 = name; cp1 != penchunk; cp1 += strlen(cp1) + 1) {
+        if (*(cp1 + 1) || !isxdigit((unsigned char) *cp1))
+          return 0;
+
+        for (j = sizeof(struct all_addr) - 1; j > 0; j--)
+          addr[j] = (addr[j] >> 4) | (addr[j - 1] << 4);
+        addr[0] = (addr[0] >> 4) | (strtol(cp1, NULL, 16) << 4);
+      }
+
+      return F_IPV6;
     }
+  }
 #endif
-  
+
   return 0;
 }
 
-unsigned char *skip_name(unsigned char *ansp, struct dns_header *header, size_t plen, int extrabytes)
+unsigned char *skip_name(unsigned char *ansp, struct dns_header *header,
+                         size_t plen, int extrabytes)
 {
-  while(1)
-    {
-      unsigned int label_type;
-      
-      if (!CHECK_LEN(header, ansp, plen, 1))
-	return NULL;
-      
-      label_type = (*ansp) & 0xc0;
-
-      if (label_type == 0xc0)
-	{
-	  /* pointer for compression. */
-	  ansp += 2;	
-	  break;
-	}
-      else if (label_type == 0x80)
-	return NULL; /* reserved */
-      else if (label_type == 0x40)
-	{
-	  /* Extended label type */
-	  unsigned int count;
-	  
-	  if (!CHECK_LEN(header, ansp, plen, 2))
-	    return NULL;
-	  
-	  if (((*ansp++) & 0x3f) != 1)
-	    return NULL; /* we only understand bitstrings */
-	  
-	  count = *(ansp++); /* Bits in bitstring */
-	  
-	  if (count == 0) /* count == 0 means 256 bits */
-	    ansp += 32;
-	  else
-	    ansp += ((count-1)>>3)+1;
-	}
+  while (1) {
+    unsigned int label_type;
+
+    if (!CHECK_LEN(header, ansp, plen, 1))
+      return NULL;
+
+    label_type = (*ansp) & 0xc0;
+
+    if (label_type == 0xc0) {
+      /* pointer for compression. */
+      ansp += 2;
+      break;
+    } else if (label_type == 0x80)
+      return NULL;              /* reserved */
+    else if (label_type == 0x40) {
+      /* Extended label type */
+      unsigned int count;
+
+      if (!CHECK_LEN(header, ansp, plen, 2))
+        return NULL;
+
+      if (((*ansp++) & 0x3f) != 1)
+        return NULL;            /* we only understand bitstrings */
+
+      count = *(ansp++);        /* Bits in bitstring */
+
+      if (count == 0)           /* count == 0 means 256 bits */
+        ansp += 32;
       else
-	{ /* label type == 0 Bottom six bits is length */
-	  unsigned int len = (*ansp++) & 0x3f;
-	  
-	  if (!ADD_RDLEN(header, ansp, plen, len))
-	    return NULL;
-
-	  if (len == 0)
-	    break; /* zero length label marks the end. */
-	}
+        ansp += ((count - 1) >> 3) + 1;
+    } else {                    /* label type == 0 Bottom six bits is length */
+      unsigned int len = (*ansp++) & 0x3f;
+
+      if (!ADD_RDLEN(header, ansp, plen, len))
+        return NULL;
+
+      if (len == 0)
+        break;                  /* zero length label marks the end. */
     }
+  }
 
   if (!CHECK_LEN(header, ansp, plen, extrabytes))
     return NULL;
-  
+
   return ansp;
 }
 
 unsigned char *skip_questions(struct dns_header *header, size_t plen)
 {
   int q;
-  unsigned char *ansp = (unsigned char *)(header+1);
+  unsigned char *ansp = (unsigned char *) (header + 1);
+
+  for (q = ntohs(header->qdcount); q != 0; q--) {
+    if (!(ansp = skip_name(ansp, header, plen, 4)))
+      return NULL;
+    ansp += 4;                  /* class and type */
+  }
 
-  for (q = ntohs(header->qdcount); q != 0; q--)
-    {
-      if (!(ansp = skip_name(ansp, header, plen, 4)))
-	return NULL;
-      ansp += 4; /* class and type */
-    }
-  
   return ansp;
 }
 
-unsigned char *skip_section(unsigned char *ansp, int count, struct dns_header *header, size_t plen)
+unsigned char *skip_section(unsigned char *ansp, int count,
+                            struct dns_header *header, size_t plen)
 {
   int i, rdlen;
-  
-  for (i = 0; i < count; i++)
-    {
-      if (!(ansp = skip_name(ansp, header, plen, 10)))
-	return NULL; 
-      ansp += 8; /* type, class, TTL */
-      GETSHORT(rdlen, ansp);
-      if (!ADD_RDLEN(header, ansp, plen, rdlen))
-	return NULL;
-    }
+
+  for (i = 0; i < count; i++) {
+    if (!(ansp = skip_name(ansp, header, plen, 10)))
+      return NULL;
+    ansp += 8;                  /* type, class, TTL */
+    GETSHORT(rdlen, ansp);
+    if (!ADD_RDLEN(header, ansp, plen, rdlen))
+      return NULL;
+  }
 
   return ansp;
 }
@@ -346,233 +318,221 @@
 {
   int q;
   unsigned int crc = 0xffffffff;
-  unsigned char *p1, *p = (unsigned char *)(header+1);
+  unsigned char *p1, *p = (unsigned char *) (header + 1);
 
-  for (q = ntohs(header->qdcount); q != 0; q--) 
-    {
-      if (!extract_name(header, plen, &p, name, 1, 4))
-	return crc; /* bad packet */
-      
-      for (p1 = (unsigned char *)name; *p1; p1++)
-	{
-	  int i = 8;
-	  char c = *p1;
-
-	  if (c >= 'A' && c <= 'Z')
-	    c += 'a' - 'A';
-
-	  crc ^= c << 24;
-	  while (i--)
-	    crc = crc & 0x80000000 ? (crc << 1) ^ 0x04c11db7 : crc << 1;
-	}
-      
-      /* CRC the class and type as well */
-      for (p1 = p; p1 < p+4; p1++)
-	{
-	  int i = 8;
-	  crc ^= *p1 << 24;
-	  while (i--)
-	    crc = crc & 0x80000000 ? (crc << 1) ^ 0x04c11db7 : crc << 1;
-	}
-
-      p += 4;
-      if (!CHECK_LEN(header, p, plen, 0))
-	return crc; /* bad packet */
+  for (q = ntohs(header->qdcount); q != 0; q--) {
+    if (!extract_name(header, plen, &p, name, 1, 4))
+      return crc;               /* bad packet */
+
+    for (p1 = (unsigned char *) name; *p1; p1++) {
+      int i = 8;
+      char c = *p1;
+
+      if (c >= 'A' && c <= 'Z')
+        c += 'a' - 'A';
+
+      crc ^= c << 24;
+      while (i--)
+        crc = crc & 0x80000000 ? (crc << 1) ^ 0x04c11db7 : crc << 1;
     }
 
+    /* CRC the class and type as well */
+    for (p1 = p; p1 < p + 4; p1++) {
+      int i = 8;
+      crc ^= *p1 << 24;
+      while (i--)
+        crc = crc & 0x80000000 ? (crc << 1) ^ 0x04c11db7 : crc << 1;
+    }
+
+    p += 4;
+    if (!CHECK_LEN(header, p, plen, 0))
+      return crc;               /* bad packet */
+  }
+
   return crc;
 }
 #endif
 
-size_t resize_packet(struct dns_header *header, size_t plen, unsigned char *pheader, size_t hlen)
+size_t resize_packet(struct dns_header * header, size_t plen,
+                     unsigned char *pheader, size_t hlen)
 {
   unsigned char *ansp = skip_questions(header, plen);
-    
+
   /* if packet is malformed, just return as-is. */
   if (!ansp)
     return plen;
-  
-  if (!(ansp = skip_section(ansp, ntohs(header->ancount) + ntohs(header->nscount) + ntohs(header->arcount),
-			    header, plen)))
+
+  if (!
+      (ansp =
+       skip_section(ansp,
+                    ntohs(header->ancount) + ntohs(header->nscount) +
+                    ntohs(header->arcount), header, plen)))
     return plen;
-    
+
   /* restore pseudoheader */
-  if (pheader && ntohs(header->arcount) == 0)
-    {
-      /* must use memmove, may overlap */
-      memmove(ansp, pheader, hlen);
-      header->arcount = htons(1);
-      ansp += hlen;
-    }
+  if (pheader && ntohs(header->arcount) == 0) {
+    /* must use memmove, may overlap */
+    memmove(ansp, pheader, hlen);
+    header->arcount = htons(1);
+    ansp += hlen;
+  }
 
-  return ansp - (unsigned char *)header;
+  return ansp - (unsigned char *) header;
 }
 
-/* is addr in the non-globally-routed IP space? */ 
-int private_net(struct in_addr addr, int ban_localhost) 
+/* is addr in the non-globally-routed IP space? */
+int private_net(struct in_addr addr, int ban_localhost)
 {
   in_addr_t ip_addr = ntohl(addr.s_addr);
 
-  return
-    (((ip_addr & 0xFF000000) == 0x7F000000) && ban_localhost)  /* 127.0.0.0/8    (loopback) */ ||
-    ((ip_addr & 0xFF000000) == 0x00000000)  /* RFC 5735 section 3. "here" network */ ||
-    ((ip_addr & 0xFF000000) == 0x0A000000)  /* 10.0.0.0/8     (private)  */ ||
-    ((ip_addr & 0xFFF00000) == 0xAC100000)  /* 172.16.0.0/12  (private)  */ ||
-    ((ip_addr & 0xFFFF0000) == 0xC0A80000)  /* 192.168.0.0/16 (private)  */ ||
-    ((ip_addr & 0xFFFF0000) == 0xA9FE0000)  /* 169.254.0.0/16 (zeroconf) */ ||
-    ((ip_addr & 0xFFFFFF00) == 0xC0000200)  /* 192.0.2.0/24   (test-net) */ ||
-    ((ip_addr & 0xFFFFFF00) == 0xC6336400)  /* 198.51.100.0/24(test-net) */ ||
-    ((ip_addr & 0xFFFFFF00) == 0xCB007100)  /* 203.0.113.0/24 (test-net) */ ||
-    ((ip_addr & 0xFFFFFFFF) == 0xFFFFFFFF)  /* 255.255.255.255/32 (broadcast)*/ ;
+  return (((ip_addr & 0xFF000000) == 0x7F000000) && ban_localhost) /* 127.0.0.0/8    (loopback) */ ||
+      ((ip_addr & 0xFF000000) == 0x00000000) /* RFC 5735 section 3. "here" network */ ||
+      ((ip_addr & 0xFF000000) == 0x0A000000) /* 10.0.0.0/8     (private)  */ ||
+      ((ip_addr & 0xFFF00000) == 0xAC100000) /* 172.16.0.0/12  (private)  */ ||
+      ((ip_addr & 0xFFFF0000) == 0xC0A80000) /* 192.168.0.0/16 (private)  */ ||
+      ((ip_addr & 0xFFFF0000) == 0xA9FE0000) /* 169.254.0.0/16 (zeroconf) */ ||
+      ((ip_addr & 0xFFFFFF00) == 0xC0000200) /* 192.0.2.0/24   (test-net) */ ||
+      ((ip_addr & 0xFFFFFF00) == 0xC6336400) /* 198.51.100.0/24(test-net) */ ||
+      ((ip_addr & 0xFFFFFF00) == 0xCB007100) /* 203.0.113.0/24 (test-net) */ ||
+      ((ip_addr & 0xFFFFFFFF) ==
+       0xFFFFFFFF) /* 255.255.255.255/32 (broadcast) */ ;
 }
 
 #ifdef HAVE_IPV6
 static int private_net6(struct in6_addr *a)
 {
-  return 
-    IN6_IS_ADDR_UNSPECIFIED(a) || /* RFC 6303 4.3 */
-    IN6_IS_ADDR_LOOPBACK(a) ||    /* RFC 6303 4.3 */
-    IN6_IS_ADDR_LINKLOCAL(a) ||   /* RFC 6303 4.5 */
-    ((unsigned char *)a)[0] == 0xfd ||   /* RFC 6303 4.4 */
-    ((u32 *)a)[0] == htonl(0x20010db8); /* RFC 6303 4.6 */
+  return IN6_IS_ADDR_UNSPECIFIED(a) ||  /* RFC 6303 4.3 */
+      IN6_IS_ADDR_LOOPBACK(a) ||        /* RFC 6303 4.3 */
+      IN6_IS_ADDR_LINKLOCAL(a) ||       /* RFC 6303 4.5 */
+      ((unsigned char *) a)[0] == 0xfd ||       /* RFC 6303 4.4 */
+      ((u32 *) a)[0] == htonl(0x20010db8);      /* RFC 6303 4.6 */
 }
 #endif
 
 
-static unsigned char *do_doctor(unsigned char *p, int count, struct dns_header *header, size_t qlen, char *name, int *doctored)
+static unsigned char *do_doctor(unsigned char *p, int count,
+                                struct dns_header *header, size_t qlen,
+                                char *name, int *doctored)
 {
   int i, qtype, qclass, rdlen;
 
-  for (i = count; i != 0; i--)
-    {
-      if (name && option_bool(OPT_LOG))
-	{
-	  if (!extract_name(header, qlen, &p, name, 1, 10))
-	    return 0;
-	}
-      else if (!(p = skip_name(p, header, qlen, 10)))
-	return 0; /* bad packet */
-      
-      GETSHORT(qtype, p); 
-      GETSHORT(qclass, p);
-      p += 4; /* ttl */
-      GETSHORT(rdlen, p);
-      
-      if (qclass == C_IN && qtype == T_A)
-	{
-	  struct doctor *doctor;
-	  struct in_addr addr;
-	  
-	  if (!CHECK_LEN(header, p, qlen, INADDRSZ))
-	    return 0;
-	  
-	  /* alignment */
-	  memcpy(&addr, p, INADDRSZ);
-	  
-	  for (doctor = daemon->doctors; doctor; doctor = doctor->next)
-	    {
-	      if (doctor->end.s_addr == 0)
-		{
-		  if (!is_same_net(doctor->in, addr, doctor->mask))
-		    continue;
-		}
-	      else if (ntohl(doctor->in.s_addr) > ntohl(addr.s_addr) || 
-		       ntohl(doctor->end.s_addr) < ntohl(addr.s_addr))
-		continue;
-	      
-	      addr.s_addr &= ~doctor->mask.s_addr;
-	      addr.s_addr |= (doctor->out.s_addr & doctor->mask.s_addr);
-	      /* Since we munged the data, the server it came from is no longer authoritative */
-	      header->hb3 &= ~HB3_AA;
-	      *doctored = 1;
-	      memcpy(p, &addr, INADDRSZ);
-	      break;
-	    }
-	}
-      else if (qtype == T_TXT && name && option_bool(OPT_LOG))
-	{
-	  unsigned char *p1 = p;
-	  if (!CHECK_LEN(header, p1, qlen, rdlen))
-	    return 0;
-	  while ((p1 - p) < rdlen)
-	    {
-	      unsigned int i, len = *p1;
-	      unsigned char *p2 = p1;
-	      if ((p1 + len - p) >= rdlen)
-	        return 0; /* bad packet */
-	      /* make counted string zero-term  and sanitise */
-	      for (i = 0; i < len; i++)
-		{
-		  if (!isprint((int)*(p2+1)))
-		    break;
-		  
-		  *p2 = *(p2+1);
-		  p2++;
-		}
-	      *p2 = 0;
-	      my_syslog(LOG_INFO, "reply %s is %s", name, p1);
-	      /* restore */
-	      memmove(p1 + 1, p1, i);
-	      *p1 = len;
-	      p1 += len+1;
-	    }
-	}		  
-      
-      if (!ADD_RDLEN(header, p, qlen, rdlen))
-	 return 0; /* bad packet */
+  for (i = count; i != 0; i--) {
+    if (name && option_bool(OPT_LOG)) {
+      if (!extract_name(header, qlen, &p, name, 1, 10))
+        return 0;
+    } else if (!(p = skip_name(p, header, qlen, 10)))
+      return 0;                 /* bad packet */
+
+    GETSHORT(qtype, p);
+    GETSHORT(qclass, p);
+    p += 4;                     /* ttl */
+    GETSHORT(rdlen, p);
+
+    if (qclass == C_IN && qtype == T_A) {
+      struct doctor *doctor;
+      struct in_addr addr;
+
+      if (!CHECK_LEN(header, p, qlen, INADDRSZ))
+        return 0;
+
+      /* alignment */
+      memcpy(&addr, p, INADDRSZ);
+
+      for (doctor = daemon->doctors; doctor; doctor = doctor->next) {
+        if (doctor->end.s_addr == 0) {
+          if (!is_same_net(doctor->in, addr, doctor->mask))
+            continue;
+        } else if (ntohl(doctor->in.s_addr) > ntohl(addr.s_addr) ||
+                   ntohl(doctor->end.s_addr) < ntohl(addr.s_addr))
+          continue;
+
+        addr.s_addr &= ~doctor->mask.s_addr;
+        addr.s_addr |= (doctor->out.s_addr & doctor->mask.s_addr);
+        /* Since we munged the data, the server it came from is no longer authoritative */
+        header->hb3 &= ~HB3_AA;
+        *doctored = 1;
+        memcpy(p, &addr, INADDRSZ);
+        break;
+      }
+    } else if (qtype == T_TXT && name && option_bool(OPT_LOG)) {
+      unsigned char *p1 = p;
+      if (!CHECK_LEN(header, p1, qlen, rdlen))
+        return 0;
+      while ((p1 - p) < rdlen) {
+        unsigned int i, len = *p1;
+        unsigned char *p2 = p1;
+        if ((p1 + len - p) >= rdlen)
+          return 0;             /* bad packet */
+        /* make counted string zero-term  and sanitise */
+        for (i = 0; i < len; i++) {
+          if (!isprint((int) *(p2 + 1)))
+            break;
+
+          *p2 = *(p2 + 1);
+          p2++;
+        }
+        *p2 = 0;
+        my_syslog(LOG_INFO, "reply %s is %s", name, p1);
+        /* restore */
+        memmove(p1 + 1, p1, i);
+        *p1 = len;
+        p1 += len + 1;
+      }
     }
-  
-  return p; 
+
+    if (!ADD_RDLEN(header, p, qlen, rdlen))
+      return 0;                 /* bad packet */
+  }
+
+  return p;
 }
 
-static int find_soa(struct dns_header *header, size_t qlen, char *name, int *doctored)
+static int find_soa(struct dns_header *header, size_t qlen, char *name,
+                    int *doctored)
 {
   unsigned char *p;
   int qtype, qclass, rdlen;
   unsigned long ttl, minttl = ULONG_MAX;
   int i, found_soa = 0;
-  
+
   /* first move to NS section and find TTL from any SOA section */
   if (!(p = skip_questions(header, qlen)) ||
       !(p = do_doctor(p, ntohs(header->ancount), header, qlen, name, doctored)))
-    return 0;  /* bad packet */
-  
-  for (i = ntohs(header->nscount); i != 0; i--)
-    {
-      if (!(p = skip_name(p, header, qlen, 10)))
-	return 0; /* bad packet */
-      
-      GETSHORT(qtype, p); 
-      GETSHORT(qclass, p);
-      GETLONG(ttl, p);
-      GETSHORT(rdlen, p);
-      
-      if ((qclass == C_IN) && (qtype == T_SOA))
-	{
-	  found_soa = 1;
-	  if (ttl < minttl)
-	    minttl = ttl;
-
-	  /* MNAME */
-	  if (!(p = skip_name(p, header, qlen, 0)))
-	    return 0;
-	  /* RNAME */
-	  if (!(p = skip_name(p, header, qlen, 20)))
-	    return 0;
-	  p += 16; /* SERIAL REFRESH RETRY EXPIRE */
-	  
-	  GETLONG(ttl, p); /* minTTL */
-	  if (ttl < minttl)
-	    minttl = ttl;
-	}
-      else if (!ADD_RDLEN(header, p, qlen, rdlen))
-	return 0; /* bad packet */
-    }
-  
+    return 0;                   /* bad packet */
+
+  for (i = ntohs(header->nscount); i != 0; i--) {
+    if (!(p = skip_name(p, header, qlen, 10)))
+      return 0;                 /* bad packet */
+
+    GETSHORT(qtype, p);
+    GETSHORT(qclass, p);
+    GETLONG(ttl, p);
+    GETSHORT(rdlen, p);
+
+    if ((qclass == C_IN) && (qtype == T_SOA)) {
+      found_soa = 1;
+      if (ttl < minttl)
+        minttl = ttl;
+
+      /* MNAME */
+      if (!(p = skip_name(p, header, qlen, 0)))
+        return 0;
+      /* RNAME */
+      if (!(p = skip_name(p, header, qlen, 20)))
+        return 0;
+      p += 16;                  /* SERIAL REFRESH RETRY EXPIRE */
+
+      GETLONG(ttl, p);          /* minTTL */
+      if (ttl < minttl)
+        minttl = ttl;
+    } else if (!ADD_RDLEN(header, p, qlen, rdlen))
+      return 0;                 /* bad packet */
+  }
+
   /* rewrite addresses in additional section too */
   if (!do_doctor(p, ntohs(header->arcount), header, qlen, NULL, doctored))
     return 0;
-  
+
   if (!found_soa)
     minttl = daemon->neg_ttl;
 
@@ -583,8 +543,9 @@
    either because of lack of memory, or lack of SOA records.  These are treated by the cache code as 
    expired and cleaned out that way. 
    Return 1 if we reject an address because it look like part of dns-rebinding attack. */
-int extract_addresses(struct dns_header *header, size_t qlen, char *name, time_t now, 
-		      char **ipsets, int is_sign, int check_rebind, int no_cache_dnssec, int secure, int *doctored)
+int extract_addresses(struct dns_header *header, size_t qlen, char *name,
+                      time_t now, char **ipsets, int is_sign, int check_rebind,
+                      int no_cache_dnssec, int secure, int *doctored)
 {
   unsigned char *p, *p1, *endrr, *namep;
   int i, j, qtype, qclass, aqtype, aqclass, ardlen, res, searched_soa = 0;
@@ -593,267 +554,243 @@
 #ifdef HAVE_IPSET
   char **ipsets_cur;
 #else
-  (void)ipsets; /* unused */
+  (void) ipsets;                /* unused */
 #endif
-  
+
   cache_start_insert();
 
   /* find_soa is needed for dns_doctor and logging side-effects, so don't call it lazily if there are any. */
-  if (daemon->doctors || option_bool(OPT_LOG) || option_bool(OPT_DNSSEC_VALID))
-    {
-      searched_soa = 1;
-      ttl = find_soa(header, qlen, name, doctored);
+  if (daemon->doctors || option_bool(OPT_LOG) || option_bool(OPT_DNSSEC_VALID)) {
+    searched_soa = 1;
+    ttl = find_soa(header, qlen, name, doctored);
 #ifdef HAVE_DNSSEC
-      if (*doctored && secure)
-	return 0;
+    if (*doctored && secure)
+      return 0;
 #endif
-    }
-  
+  }
+
   /* go through the questions. */
-  p = (unsigned char *)(header+1);
-  
-  for (i = ntohs(header->qdcount); i != 0; i--)
-    {
-      int found = 0, cname_count = CNAME_CHAIN;
-      struct crec *cpp = NULL;
-      int flags = RCODE(header) == NXDOMAIN ? F_NXDOMAIN : 0;
-      int secflag = secure ?  F_DNSSECOK : 0;
-      unsigned long cttl = ULONG_MAX, attl;
-
-      namep = p;
-      if (!extract_name(header, qlen, &p, name, 1, 4))
-	return 0; /* bad packet */
-           
-      GETSHORT(qtype, p); 
-      GETSHORT(qclass, p);
-      
-      if (qclass != C_IN)
-	continue;
-
-      /* PTRs: we chase CNAMEs here, since we have no way to 
-	 represent them in the cache. */
-      if (qtype == T_PTR)
-	{ 
-	  int name_encoding = in_arpa_name_2_addr(name, &addr);
-	  
-	  if (!name_encoding)
-	    continue;
-
-	  if (!(flags & F_NXDOMAIN))
-	    {
-	    cname_loop:
-	      if (!(p1 = skip_questions(header, qlen)))
-		return 0;
-	      
-	      for (j = ntohs(header->ancount); j != 0; j--) 
-		{
-		  unsigned char *tmp = namep;
-		  /* the loop body overwrites the original name, so get it back here. */
-		  if (!extract_name(header, qlen, &tmp, name, 1, 0) ||
-		      !(res = extract_name(header, qlen, &p1, name, 0, 10)))
-		    return 0; /* bad packet */
-		  
-		  GETSHORT(aqtype, p1); 
-		  GETSHORT(aqclass, p1);
-		  GETLONG(attl, p1);
-		  if ((daemon->max_ttl != 0) && (attl > daemon->max_ttl) && !is_sign)
-		    {
-		      (p1) -= 4;
-		      PUTLONG(daemon->max_ttl, p1);
-		    }
-		  GETSHORT(ardlen, p1);
-		  endrr = p1+ardlen;
-		  
-		  /* TTL of record is minimum of CNAMES and PTR */
-		  if (attl < cttl)
-		    cttl = attl;
-
-		  if (aqclass == C_IN && res != 2 && (aqtype == T_CNAME || aqtype == T_PTR))
-		    {
-		      if (!extract_name(header, qlen, &p1, name, 1, 0))
-			return 0;
-		      
-		      if (aqtype == T_CNAME)
-			{
-			  if (!cname_count-- || secure)
-			    return 0; /* looped CNAMES, or DNSSEC, which we can't cache. */
-			  goto cname_loop;
-			}
-		      
-		      cache_insert(name, &addr, now, cttl, name_encoding | secflag | F_REVERSE);
-		      found = 1; 
-		    }
-		  
-		  p1 = endrr;
-		  if (!CHECK_LEN(header, p1, qlen, 0))
-		    return 0; /* bad packet */
-		}
-	    }
-	  
-	   if (!found && !option_bool(OPT_NO_NEG))
-	    {
-	      if (!searched_soa)
-		{
-		  searched_soa = 1;
-		  ttl = find_soa(header, qlen, NULL, doctored);
-		}
-	      if (ttl)
-		cache_insert(NULL, &addr, now, ttl, name_encoding | F_REVERSE | F_NEG | flags | secflag);	
-	    }
-	}
-      else
-	{
-	  /* everything other than PTR */
-	  struct crec *newc;
-	  int addrlen;
-
-	  if (qtype == T_A)
-	    {
-	      addrlen = INADDRSZ;
-	      flags |= F_IPV4;
-	    }
+  p = (unsigned char *) (header + 1);
+
+  for (i = ntohs(header->qdcount); i != 0; i--) {
+    int found = 0, cname_count = CNAME_CHAIN;
+    struct crec *cpp = NULL;
+    int flags = RCODE(header) == NXDOMAIN ? F_NXDOMAIN : 0;
+    int secflag = secure ? F_DNSSECOK : 0;
+    unsigned long cttl = ULONG_MAX, attl;
+
+    namep = p;
+    if (!extract_name(header, qlen, &p, name, 1, 4))
+      return 0;                 /* bad packet */
+
+    GETSHORT(qtype, p);
+    GETSHORT(qclass, p);
+
+    if (qclass != C_IN)
+      continue;
+
+    /* PTRs: we chase CNAMEs here, since we have no way to
+       represent them in the cache. */
+    if (qtype == T_PTR) {
+      int name_encoding = in_arpa_name_2_addr(name, &addr);
+
+      if (!name_encoding)
+        continue;
+
+      if (!(flags & F_NXDOMAIN)) {
+      cname_loop:
+        if (!(p1 = skip_questions(header, qlen)))
+          return 0;
+
+        for (j = ntohs(header->ancount); j != 0; j--) {
+          unsigned char *tmp = namep;
+          /* the loop body overwrites the original name, so get it back here. */
+          if (!extract_name(header, qlen, &tmp, name, 1, 0) ||
+              !(res = extract_name(header, qlen, &p1, name, 0, 10)))
+            return 0;           /* bad packet */
+
+          GETSHORT(aqtype, p1);
+          GETSHORT(aqclass, p1);
+          GETLONG(attl, p1);
+          if ((daemon->max_ttl != 0) && (attl > daemon->max_ttl) && !is_sign) {
+            (p1) -= 4;
+            PUTLONG(daemon->max_ttl, p1);
+          }
+          GETSHORT(ardlen, p1);
+          endrr = p1 + ardlen;
+
+          /* TTL of record is minimum of CNAMES and PTR */
+          if (attl < cttl)
+            cttl = attl;
+
+          if (aqclass == C_IN && res != 2
+              && (aqtype == T_CNAME || aqtype == T_PTR)) {
+            if (!extract_name(header, qlen, &p1, name, 1, 0))
+              return 0;
+
+            if (aqtype == T_CNAME) {
+              if (!cname_count-- || secure)
+                return 0;       /* looped CNAMES, or DNSSEC, which we can't cache. */
+              goto cname_loop;
+            }
+
+            cache_insert(name, &addr, now, cttl,
+                         name_encoding | secflag | F_REVERSE);
+            found = 1;
+          }
+
+          p1 = endrr;
+          if (!CHECK_LEN(header, p1, qlen, 0))
+            return 0;           /* bad packet */
+        }
+      }
+
+      if (!found && !option_bool(OPT_NO_NEG)) {
+        if (!searched_soa) {
+          searched_soa = 1;
+          ttl = find_soa(header, qlen, NULL, doctored);
+        }
+        if (ttl)
+          cache_insert(NULL, &addr, now, ttl,
+                       name_encoding | F_REVERSE | F_NEG | flags | secflag);
+      }
+    } else {
+      /* everything other than PTR */
+      struct crec *newc;
+      int addrlen;
+
+      if (qtype == T_A) {
+        addrlen = INADDRSZ;
+        flags |= F_IPV4;
+      }
 #ifdef HAVE_IPV6
-	  else if (qtype == T_AAAA)
-	    {
-	      addrlen = IN6ADDRSZ;
-	      flags |= F_IPV6;
-	    }
+      else if (qtype == T_AAAA) {
+        addrlen = IN6ADDRSZ;
+        flags |= F_IPV6;
+      }
 #endif
-	  else 
-	    continue;
-	    
-	cname_loop1:
-	  if (!(p1 = skip_questions(header, qlen)))
-	    return 0;
-	  
-	  for (j = ntohs(header->ancount); j != 0; j--) 
-	    {
-	      if (!(res = extract_name(header, qlen, &p1, name, 0, 10)))
-		return 0; /* bad packet */
-	      
-	      GETSHORT(aqtype, p1); 
-	      GETSHORT(aqclass, p1);
-	      GETLONG(attl, p1);
-	      if ((daemon->max_ttl != 0) && (attl > daemon->max_ttl) && !is_sign)
-		{
-		  (p1) -= 4;
-		  PUTLONG(daemon->max_ttl, p1);
-		}
-	      GETSHORT(ardlen, p1);
-	      endrr = p1+ardlen;
-	      
-	      if (aqclass == C_IN && res != 2 && (aqtype == T_CNAME || aqtype == qtype))
-		{
-		  if (aqtype == T_CNAME)
-		    {
-		      if (!cname_count--)
-			return 0; /* looped CNAMES */
-		      newc = cache_insert(name, NULL, now, attl, F_CNAME | F_FORWARD | secflag);
-		      if (newc)
-			{
-			  newc->addr.cname.target.cache = NULL;
-			  /* anything other than zero, to avoid being mistaken for CNAME to interface-name */ 
-			  newc->addr.cname.uid = 1; 
-			  if (cpp)
-			    {
-			      cpp->addr.cname.target.cache = newc;
-			      cpp->addr.cname.uid = newc->uid;
-			    }
-			}
-		      
-		      cpp = newc;
-		      if (attl < cttl)
-			cttl = attl;
-		      
-		      if (!extract_name(header, qlen, &p1, name, 1, 0))
-			return 0;
-		      goto cname_loop1;
-		    }
-		  else if (!(flags & F_NXDOMAIN))
-		    {
-		      found = 1;
-		      
-		      /* copy address into aligned storage */
-		      if (!CHECK_LEN(header, p1, qlen, addrlen))
-			return 0; /* bad packet */
-		      memcpy(&addr, p1, addrlen);
-		      
-		      /* check for returned address in private space */
-		      if (check_rebind)
-			{
-			  if ((flags & F_IPV4) &&
-			      private_net(addr.addr.addr4, !option_bool(OPT_LOCAL_REBIND)))
-			    return 1;
-			  
+      else
+        continue;
+
+    cname_loop1:
+      if (!(p1 = skip_questions(header, qlen)))
+        return 0;
+
+      for (j = ntohs(header->ancount); j != 0; j--) {
+        if (!(res = extract_name(header, qlen, &p1, name, 0, 10)))
+          return 0;             /* bad packet */
+
+        GETSHORT(aqtype, p1);
+        GETSHORT(aqclass, p1);
+        GETLONG(attl, p1);
+        if ((daemon->max_ttl != 0) && (attl > daemon->max_ttl) && !is_sign) {
+          (p1) -= 4;
+          PUTLONG(daemon->max_ttl, p1);
+        }
+        GETSHORT(ardlen, p1);
+        endrr = p1 + ardlen;
+
+        if (aqclass == C_IN && res != 2
+            && (aqtype == T_CNAME || aqtype == qtype)) {
+          if (aqtype == T_CNAME) {
+            if (!cname_count--)
+              return 0;         /* looped CNAMES */
+            newc =
+                cache_insert(name, NULL, now, attl,
+                             F_CNAME | F_FORWARD | secflag);
+            if (newc) {
+              newc->addr.cname.target.cache = NULL;
+              /* anything other than zero, to avoid being mistaken for CNAME to interface-name */
+              newc->addr.cname.uid = 1;
+              if (cpp) {
+                cpp->addr.cname.target.cache = newc;
+                cpp->addr.cname.uid = newc->uid;
+              }
+            }
+
+            cpp = newc;
+            if (attl < cttl)
+              cttl = attl;
+
+            if (!extract_name(header, qlen, &p1, name, 1, 0))
+              return 0;
+            goto cname_loop1;
+          } else if (!(flags & F_NXDOMAIN)) {
+            found = 1;
+
+            /* copy address into aligned storage */
+            if (!CHECK_LEN(header, p1, qlen, addrlen))
+              return 0;         /* bad packet */
+            memcpy(&addr, p1, addrlen);
+
+            /* check for returned address in private space */
+            if (check_rebind) {
+              if ((flags & F_IPV4) &&
+                  private_net(addr.addr.addr4, !option_bool(OPT_LOCAL_REBIND)))
+                return 1;
+
 #ifdef HAVE_IPV6
-			  if ((flags & F_IPV6) &&
-			      IN6_IS_ADDR_V4MAPPED(&addr.addr.addr6))
-			    {
-			      struct in_addr v4;
-			      v4.s_addr = ((const uint32_t *) (&addr.addr.addr6))[3];
-			      if (private_net(v4, !option_bool(OPT_LOCAL_REBIND)))
-				return 1;
-			    }
+              if ((flags & F_IPV6) && IN6_IS_ADDR_V4MAPPED(&addr.addr.addr6)) {
+                struct in_addr v4;
+                v4.s_addr = ((const uint32_t *) (&addr.addr.addr6))[3];
+                if (private_net(v4, !option_bool(OPT_LOCAL_REBIND)))
+                  return 1;
+              }
 #endif
-			}
-		      
+            }
 #ifdef HAVE_IPSET
-		      if (ipsets && (flags & (F_IPV4 | F_IPV6)))
-			{
-			  ipsets_cur = ipsets;
-			  while (*ipsets_cur)
-			    {
-			      log_query((flags & (F_IPV4 | F_IPV6)) | F_IPSET, name, &addr, *ipsets_cur);
-			      add_to_ipset(*ipsets_cur++, &addr, flags, 0);
-			    }
-			}
+            if (ipsets && (flags & (F_IPV4 | F_IPV6))) {
+              ipsets_cur = ipsets;
+              while (*ipsets_cur) {
+                log_query((flags & (F_IPV4 | F_IPV6)) | F_IPSET, name, &addr,
+                          *ipsets_cur);
+                add_to_ipset(*ipsets_cur++, &addr, flags, 0);
+              }
+            }
 #endif
-		      
-		      newc = cache_insert(name, &addr, now, attl, flags | F_FORWARD | secflag);
-		      if (newc && cpp)
-			{
-			  cpp->addr.cname.target.cache = newc;
-			  cpp->addr.cname.uid = newc->uid;
-			}
-		      cpp = NULL;
-		    }
-		}
-	      
-	      p1 = endrr;
-	      if (!CHECK_LEN(header, p1, qlen, 0))
-		return 0; /* bad packet */
-	    }
-	  
-	  if (!found && !option_bool(OPT_NO_NEG))
-	    {
-	      if (!searched_soa)
-		{
-		  searched_soa = 1;
-		  ttl = find_soa(header, qlen, NULL, doctored);
-		}
-	      /* If there's no SOA to get the TTL from, but there is a CNAME 
-		 pointing at this, inherit its TTL */
-	      if (ttl || cpp)
-		{
-		  newc = cache_insert(name, NULL, now, ttl ? ttl : cttl, F_FORWARD | F_NEG | flags | secflag);	
-		  if (newc && cpp)
-		    {
-		      cpp->addr.cname.target.cache = newc;
-		      cpp->addr.cname.uid = newc->uid;
-		    }
-		}
-	    }
-	}
+
+            newc =
+                cache_insert(name, &addr, now, attl,
+                             flags | F_FORWARD | secflag);
+            if (newc && cpp) {
+              cpp->addr.cname.target.cache = newc;
+              cpp->addr.cname.uid = newc->uid;
+            }
+            cpp = NULL;
+          }
+        }
+
+        p1 = endrr;
+        if (!CHECK_LEN(header, p1, qlen, 0))
+          return 0;             /* bad packet */
+      }
+
+      if (!found && !option_bool(OPT_NO_NEG)) {
+        if (!searched_soa) {
+          searched_soa = 1;
+          ttl = find_soa(header, qlen, NULL, doctored);
+        }
+        /* If there's no SOA to get the TTL from, but there is a CNAME
+           pointing at this, inherit its TTL */
+        if (ttl || cpp) {
+          newc =
+              cache_insert(name, NULL, now, ttl ? ttl : cttl,
+                           F_FORWARD | F_NEG | flags | secflag);
+          if (newc && cpp) {
+            cpp->addr.cname.target.cache = newc;
+            cpp->addr.cname.uid = newc->uid;
+          }
+        }
+      }
     }
-  
+  }
+
   /* Don't put stuff from a truncated packet into the cache.
      Don't cache replies from non-recursive nameservers, since we may get a 
      reply containing a CNAME but not its target, even though the target 
      does exist. */
-  if (!(header->hb3 & HB3_TC) && 
-      !(header->hb4 & HB4_CD) &&
-      (header->hb4 & HB4_RA) &&
-      !no_cache_dnssec)
+  if (!(header->hb3 & HB3_TC) &&
+      !(header->hb4 & HB4_CD) && (header->hb4 & HB4_RA) && !no_cache_dnssec)
     cache_end_insert();
 
   return 0;
@@ -861,48 +798,49 @@
 
 /* If the packet holds exactly one query
    return F_IPV4 or F_IPV6  and leave the name from the query in name */
-unsigned int extract_request(struct dns_header *header, size_t qlen, char *name, unsigned short *typep)
+unsigned int extract_request(struct dns_header *header, size_t qlen, char *name,
+                             unsigned short *typep)
 {
-  unsigned char *p = (unsigned char *)(header+1);
+  unsigned char *p = (unsigned char *) (header + 1);
   int qtype, qclass;
 
   if (typep)
     *typep = 0;
 
   if (ntohs(header->qdcount) != 1 || OPCODE(header) != QUERY)
-    return 0; /* must be exactly one query. */
-  
+    return 0;                   /* must be exactly one query. */
+
   if (!extract_name(header, qlen, &p, name, 1, 4))
-    return 0; /* bad packet */
-   
-  GETSHORT(qtype, p); 
+    return 0;                   /* bad packet */
+
+  GETSHORT(qtype, p);
   GETSHORT(qclass, p);
 
   if (typep)
     *typep = qtype;
 
-  if (qclass == C_IN)
-    {
-      if (qtype == T_A)
-	return F_IPV4;
-      if (qtype == T_AAAA)
-	return F_IPV6;
-      if (qtype == T_ANY)
-	return  F_IPV4 | F_IPV6;
-    }
-  
+  if (qclass == C_IN) {
+    if (qtype == T_A)
+      return F_IPV4;
+    if (qtype == T_AAAA)
+      return F_IPV6;
+    if (qtype == T_ANY)
+      return F_IPV4 | F_IPV6;
+  }
+
   return F_QUERY;
 }
 
 
-size_t setup_reply(struct dns_header *header, size_t qlen,
-		struct all_addr *addrp, unsigned int flags, unsigned long ttl)
+size_t setup_reply(struct dns_header * header, size_t qlen,
+                   struct all_addr * addrp, unsigned int flags,
+                   unsigned long ttl)
 {
   unsigned char *p;
 
   if (!(p = skip_questions(header, qlen)))
     return 0;
-  
+
   /* clear authoritative and truncated flags, set QR flag */
   header->hb3 = (header->hb3 & ~(HB3_AA | HB3_TC)) | HB3_QR;
   /* set RA flag */
@@ -910,31 +848,31 @@
 
   header->nscount = htons(0);
   header->arcount = htons(0);
-  header->ancount = htons(0); /* no answers unless changed below */
+  header->ancount = htons(0);   /* no answers unless changed below */
   if (flags == F_NOERR)
     SET_RCODE(header, NOERROR); /* empty domain */
   else if (flags == F_NXDOMAIN)
     SET_RCODE(header, NXDOMAIN);
-  else if (flags == F_IPV4)
-    { /* we know the address */
-      SET_RCODE(header, NOERROR);
-      header->ancount = htons(1);
-      header->hb3 |= HB3_AA;
-      add_resource_record(header, NULL, NULL, sizeof(struct dns_header), &p, ttl, NULL, T_A, C_IN, "4", addrp);
-    }
+  else if (flags == F_IPV4) {   /* we know the address */
+    SET_RCODE(header, NOERROR);
+    header->ancount = htons(1);
+    header->hb3 |= HB3_AA;
+    add_resource_record(header, NULL, NULL, sizeof(struct dns_header), &p, ttl,
+                        NULL, T_A, C_IN, "4", addrp);
+  }
 #ifdef HAVE_IPV6
-  else if (flags == F_IPV6)
-    {
-      SET_RCODE(header, NOERROR);
-      header->ancount = htons(1);
-      header->hb3 |= HB3_AA;
-      add_resource_record(header, NULL, NULL, sizeof(struct dns_header), &p, ttl, NULL, T_AAAA, C_IN, "6", addrp);
-    }
+  else if (flags == F_IPV6) {
+    SET_RCODE(header, NOERROR);
+    header->ancount = htons(1);
+    header->hb3 |= HB3_AA;
+    add_resource_record(header, NULL, NULL, sizeof(struct dns_header), &p, ttl,
+                        NULL, T_AAAA, C_IN, "6", addrp);
+  }
 #endif
-  else /* nowhere to forward to */
+  else                          /* nowhere to forward to */
     SET_RCODE(header, REFUSED);
- 
-  return p - (unsigned char *)header;
+
+  return p - (unsigned char *) header;
 }
 
 /* check if name matches local names ie from /etc/hosts or DHCP or local mx names. */
@@ -950,15 +888,16 @@
   /* Note: the call to cache_find_by_name is intended to find any record which matches
      ie A, AAAA, CNAME. */
 
-  if ((crecp = cache_find_by_name(NULL, name, now, F_IPV4 | F_IPV6 | F_CNAME |F_NO_RR)) &&
-      (crecp->flags & (F_HOSTS | F_DHCP | F_CONFIG)))
+  if ((crecp =
+       cache_find_by_name(NULL, name, now, F_IPV4 | F_IPV6 | F_CNAME | F_NO_RR))
+      && (crecp->flags & (F_HOSTS | F_DHCP | F_CONFIG)))
     return 1;
-  
+
   for (naptr = daemon->naptr; naptr; naptr = naptr->next)
-     if (hostname_isequal(name, naptr->name))
+    if (hostname_isequal(name, naptr->name))
       return 1;
 
-   for (mx = daemon->mxnames; mx; mx = mx->next)
+  for (mx = daemon->mxnames; mx; mx = mx->next)
     if (hostname_isequal(name, mx->name))
       return 1;
 
@@ -973,15 +912,15 @@
   for (ptr = daemon->ptr; ptr; ptr = ptr->next)
     if (hostname_isequal(name, ptr->name))
       return 1;
- 
+
   return 0;
 }
 
 /* Is the packet a reply with the answer address equal to addr?
    If so mung is into an NXDOMAIN reply and also put that information
    in the cache. */
-int check_for_bogus_wildcard(struct dns_header *header, size_t qlen, char *name, 
-			     struct bogus_addr *baddr, time_t now)
+int check_for_bogus_wildcard(struct dns_header *header, size_t qlen, char *name,
+                             struct bogus_addr *baddr, time_t now)
 {
   unsigned char *p;
   int i, qtype, qclass, rdlen;
@@ -990,44 +929,43 @@
 
   /* skip over questions */
   if (!(p = skip_questions(header, qlen)))
-    return 0; /* bad packet */
+    return 0;                   /* bad packet */
 
-  for (i = ntohs(header->ancount); i != 0; i--)
-    {
-      if (!extract_name(header, qlen, &p, name, 1, 10))
-	return 0; /* bad packet */
-  
-      GETSHORT(qtype, p); 
-      GETSHORT(qclass, p);
-      GETLONG(ttl, p);
-      GETSHORT(rdlen, p);
-      
-      if (qclass == C_IN && qtype == T_A)
-	{
-	  if (!CHECK_LEN(header, p, qlen, INADDRSZ))
-	    return 0;
-	  
-	  for (baddrp = baddr; baddrp; baddrp = baddrp->next)
-	    if (memcmp(&baddrp->addr, p, INADDRSZ) == 0)
-	      {
-		/* Found a bogus address. Insert that info here, since there no SOA record
-		   to get the ttl from in the normal processing */
-		cache_start_insert();
-		cache_insert(name, NULL, now, ttl, F_IPV4 | F_FORWARD | F_NEG | F_NXDOMAIN);
-		cache_end_insert();
-		
-		return 1;
-	      }
-	}
-      
-      if (!ADD_RDLEN(header, p, qlen, rdlen))
-	return 0;
+  for (i = ntohs(header->ancount); i != 0; i--) {
+    if (!extract_name(header, qlen, &p, name, 1, 10))
+      return 0;                 /* bad packet */
+
+    GETSHORT(qtype, p);
+    GETSHORT(qclass, p);
+    GETLONG(ttl, p);
+    GETSHORT(rdlen, p);
+
+    if (qclass == C_IN && qtype == T_A) {
+      if (!CHECK_LEN(header, p, qlen, INADDRSZ))
+        return 0;
+
+      for (baddrp = baddr; baddrp; baddrp = baddrp->next)
+        if (memcmp(&baddrp->addr, p, INADDRSZ) == 0) {
+          /* Found a bogus address. Insert that info here, since there no SOA record
+             to get the ttl from in the normal processing */
+          cache_start_insert();
+          cache_insert(name, NULL, now, ttl,
+                       F_IPV4 | F_FORWARD | F_NEG | F_NXDOMAIN);
+          cache_end_insert();
+
+          return 1;
+        }
     }
-  
+
+    if (!ADD_RDLEN(header, p, qlen, rdlen))
+      return 0;
+  }
+
   return 0;
 }
 
-int check_for_ignored_address(struct dns_header *header, size_t qlen, struct bogus_addr *baddr)
+int check_for_ignored_address(struct dns_header *header, size_t qlen,
+                              struct bogus_addr *baddr)
 {
   unsigned char *p;
   int i, qtype, qclass, rdlen;
@@ -1035,38 +973,38 @@
 
   /* skip over questions */
   if (!(p = skip_questions(header, qlen)))
-    return 0; /* bad packet */
+    return 0;                   /* bad packet */
 
-  for (i = ntohs(header->ancount); i != 0; i--)
-    {
-      if (!(p = skip_name(p, header, qlen, 10)))
-	return 0; /* bad packet */
-      
-      GETSHORT(qtype, p); 
-      GETSHORT(qclass, p);
-      p += 4; /* TTL */
-      GETSHORT(rdlen, p);
-      
-      if (qclass == C_IN && qtype == T_A)
-	{
-	  if (!CHECK_LEN(header, p, qlen, INADDRSZ))
-	    return 0;
-	  
-	  for (baddrp = baddr; baddrp; baddrp = baddrp->next)
-	    if (memcmp(&baddrp->addr, p, INADDRSZ) == 0)
-	      return 1;
-	}
-      
-      if (!ADD_RDLEN(header, p, qlen, rdlen))
-	return 0;
+  for (i = ntohs(header->ancount); i != 0; i--) {
+    if (!(p = skip_name(p, header, qlen, 10)))
+      return 0;                 /* bad packet */
+
+    GETSHORT(qtype, p);
+    GETSHORT(qclass, p);
+    p += 4;                     /* TTL */
+    GETSHORT(rdlen, p);
+
+    if (qclass == C_IN && qtype == T_A) {
+      if (!CHECK_LEN(header, p, qlen, INADDRSZ))
+        return 0;
+
+      for (baddrp = baddr; baddrp; baddrp = baddrp->next)
+        if (memcmp(&baddrp->addr, p, INADDRSZ) == 0)
+          return 1;
     }
-  
+
+    if (!ADD_RDLEN(header, p, qlen, rdlen))
+      return 0;
+  }
+
   return 0;
 }
 
 
-int add_resource_record(struct dns_header *header, char *limit, int *truncp, int nameoffset, unsigned char **pp, 
-			unsigned long ttl, int *offset, unsigned short type, unsigned short class, char *format, ...)
+int add_resource_record(struct dns_header *header, char *limit, int *truncp,
+                        int nameoffset, unsigned char **pp, unsigned long ttl,
+                        int *offset, unsigned short type, unsigned short class,
+                        char *format, ...)
 {
   va_list ap;
   unsigned char *sav, *p = *pp;
@@ -1084,132 +1022,122 @@
   if (truncp && *truncp)
     return 0;
 
-  va_start(ap, format);   /* make ap point to 1st unamed argument */
+  va_start(ap, format);         /* make ap point to 1st unamed argument */
 
-  if (nameoffset > 0)
-    {
-      CHECK_LIMIT(2);
-      PUTSHORT(nameoffset | 0xc000, p);
+  if (nameoffset > 0) {
+    CHECK_LIMIT(2);
+    PUTSHORT(nameoffset | 0xc000, p);
+  } else {
+    char *name = va_arg(ap, char *);
+    if (name && !(p = do_rfc1035_name(p, name, limit))) {
+      va_end(ap);
+      goto truncated;
     }
-  else
-    {
-      char *name = va_arg(ap, char *);
-      if (name && !(p = do_rfc1035_name(p, name, limit)))
-	{
-	  va_end(ap);
-	  goto truncated;
-	}
-      
-      if (nameoffset < 0)
-	{
-	  CHECK_LIMIT(2);
-	  PUTSHORT(-nameoffset | 0xc000, p);
-	}
-      else
-	{
-	  CHECK_LIMIT(1);
-	  *p++ = 0;
-	}
+
+    if (nameoffset < 0) {
+      CHECK_LIMIT(2);
+      PUTSHORT(-nameoffset | 0xc000, p);
+    } else {
+      CHECK_LIMIT(1);
+      *p++ = 0;
     }
+  }
 
   /* type (2) + class (2) + ttl (4) + rdlen (2) */
   CHECK_LIMIT(10);
-  
+
   PUTSHORT(type, p);
   PUTSHORT(class, p);
-  PUTLONG(ttl, p);      /* TTL */
+  PUTLONG(ttl, p);              /* TTL */
 
-  sav = p;              /* Save pointer to RDLength field */
-  PUTSHORT(0, p);       /* Placeholder RDLength */
+  sav = p;                      /* Save pointer to RDLength field */
+  PUTSHORT(0, p);               /* Placeholder RDLength */
 
   for (; *format; format++)
-    switch (*format)
-      {
+    switch (*format) {
 #ifdef HAVE_IPV6
-      case '6':
-        CHECK_LIMIT(IN6ADDRSZ);
-	sval = va_arg(ap, char *); 
-	memcpy(p, sval, IN6ADDRSZ);
-	p += IN6ADDRSZ;
-	break;
+    case '6':
+      CHECK_LIMIT(IN6ADDRSZ);
+      sval = va_arg(ap, char *);
+      memcpy(p, sval, IN6ADDRSZ);
+      p += IN6ADDRSZ;
+      break;
 #endif
-	
-      case '4':
-        CHECK_LIMIT(INADDRSZ);
-	sval = va_arg(ap, char *); 
-	memcpy(p, sval, INADDRSZ);
-	p += INADDRSZ;
-	break;
-	
-      case 'b':
-        CHECK_LIMIT(1);
-	usval = va_arg(ap, int);
-	*p++ = usval;
-	break;
-	
-      case 's':
-        CHECK_LIMIT(2);
-	usval = va_arg(ap, int);
-	PUTSHORT(usval, p);
-	break;
-	
-      case 'l':
-        CHECK_LIMIT(4);
-	lval = va_arg(ap, long);
-	PUTLONG(lval, p);
-	break;
-	
-      case 'd':
-        /* get domain-name answer arg and store it in RDATA field */
-        if (offset)
-          *offset = p - (unsigned char *)header;
-        p = do_rfc1035_name(p, va_arg(ap, char *), limit);
-        if (!p)
-          {
-            va_end(ap);
-            goto truncated;
-          }
-        CHECK_LIMIT(1);
-        *p++ = 0;
-	break;
-	
-      case 't':
-	usval = va_arg(ap, int);
-        CHECK_LIMIT(usval);
-	sval = va_arg(ap, char *);
-	if (usval != 0)
-	  memcpy(p, sval, usval);
-	p += usval;
-	break;
-
-      case 'z':
-	sval = va_arg(ap, char *);
-	usval = sval ? strlen(sval) : 0;
-	if (usval > 255)
-	  usval = 255;
-        CHECK_LIMIT(usval + 1);
-	*p++ = (unsigned char)usval;
-	memcpy(p, sval, usval);
-	p += usval;
-	break;
+
+    case '4':
+      CHECK_LIMIT(INADDRSZ);
+      sval = va_arg(ap, char *);
+      memcpy(p, sval, INADDRSZ);
+      p += INADDRSZ;
+      break;
+
+    case 'b':
+      CHECK_LIMIT(1);
+      usval = va_arg(ap, int);
+      *p++ = usval;
+      break;
+
+    case 's':
+      CHECK_LIMIT(2);
+      usval = va_arg(ap, int);
+      PUTSHORT(usval, p);
+      break;
+
+    case 'l':
+      CHECK_LIMIT(4);
+      lval = va_arg(ap, long);
+      PUTLONG(lval, p);
+      break;
+
+    case 'd':
+      /* get domain-name answer arg and store it in RDATA field */
+      if (offset)
+        *offset = p - (unsigned char *) header;
+      p = do_rfc1035_name(p, va_arg(ap, char *), limit);
+      if (!p) {
+        va_end(ap);
+        goto truncated;
       }
+      CHECK_LIMIT(1);
+      *p++ = 0;
+      break;
+
+    case 't':
+      usval = va_arg(ap, int);
+      CHECK_LIMIT(usval);
+      sval = va_arg(ap, char *);
+      if (usval != 0)
+        memcpy(p, sval, usval);
+      p += usval;
+      break;
+
+    case 'z':
+      sval = va_arg(ap, char *);
+      usval = sval ? strlen(sval) : 0;
+      if (usval > 255)
+        usval = 255;
+      CHECK_LIMIT(usval + 1);
+      *p++ = (unsigned char) usval;
+      memcpy(p, sval, usval);
+      p += usval;
+      break;
+    }
 
 #undef CHECK_LIMIT
-  va_end(ap);	/* clean up variable argument pointer */
-  
+  va_end(ap);                   /* clean up variable argument pointer */
+
   j = p - sav - 2;
- /* this has already been checked against limit before */
- PUTSHORT(j, sav);     /* Now, store real RDLength */
-  
+  /* this has already been checked against limit before */
+  PUTSHORT(j, sav);             /* Now, store real RDLength */
+
   /* check for overflow of buffer */
-  if (limit && ((unsigned char *)limit - p) < 0)
-    {
-truncated:
-      if (truncp)
-	*truncp = 1;
-      return 0;
-    }
-  
+  if (limit && ((unsigned char *) limit - p) < 0) {
+  truncated:
+    if (truncp)
+      *truncp = 1;
+    return 0;
+  }
+
   *pp = p;
   return 1;
 }
@@ -1219,33 +1147,33 @@
   /* Return 0 ttl for DHCP entries, which might change
      before the lease expires, unless configured otherwise. */
 
-  if (crecp->flags & F_DHCP)
-    {
-      int conf_ttl = daemon->use_dhcp_ttl ? daemon->dhcp_ttl : daemon->local_ttl;
-      
-      /* Apply ceiling of actual lease length to configured TTL. */
-      if (!(crecp->flags & F_IMMORTAL) && (crecp->ttd - now) < conf_ttl)
-	return crecp->ttd - now;
-      
-      return conf_ttl;
-    }	  
-  
+  if (crecp->flags & F_DHCP) {
+    int conf_ttl = daemon->use_dhcp_ttl ? daemon->dhcp_ttl : daemon->local_ttl;
+
+    /* Apply ceiling of actual lease length to configured TTL. */
+    if (!(crecp->flags & F_IMMORTAL) && (crecp->ttd - now) < conf_ttl)
+      return crecp->ttd - now;
+
+    return conf_ttl;
+  }
+
   /* Immortal entries other than DHCP are local, and hold TTL in TTD field. */
   if (crecp->flags & F_IMMORTAL)
     return crecp->ttd;
 
   /* Return the Max TTL value if it is lower than the actual TTL */
-  if (daemon->max_ttl == 0 || ((unsigned)(crecp->ttd - now) < daemon->max_ttl))
+  if (daemon->max_ttl == 0 || ((unsigned) (crecp->ttd - now) < daemon->max_ttl))
     return crecp->ttd - now;
   else
     return daemon->max_ttl;
 }
-  
+
 
 /* return zero if we can't answer from cache, or packet size if we can */
-size_t answer_request(struct dns_header *header, char *limit, size_t qlen,  
-		      struct in_addr local_addr, struct in_addr local_netmask, 
-		      time_t now, int ad_reqd, int do_bit, int have_pseudoheader) 
+size_t answer_request(struct dns_header * header, char *limit, size_t qlen,
+                      struct in_addr local_addr, struct in_addr local_netmask,
+                      time_t now, int ad_reqd, int do_bit,
+                      int have_pseudoheader)
 {
   char *name = daemon->namebuff;
   unsigned char *p, *ansp;
@@ -1262,14 +1190,13 @@
 
   if (ntohs(header->ancount) != 0 ||
       ntohs(header->nscount) != 0 ||
-      ntohs(header->qdcount) == 0 || 
-      OPCODE(header) != QUERY )
+      ntohs(header->qdcount) == 0 || OPCODE(header) != QUERY)
     return 0;
-  
+
   /* Don't return AD set if checking disabled. */
   if (header->hb4 & HB4_CD)
     sec_data = 0;
-  
+
   /* If there is an  additional data section then it will be overwritten by
      partial replies, so we have to do a dry run to see if we can answer
      the query. */
@@ -1278,661 +1205,625 @@
 
   for (rec = daemon->mxnames; rec; rec = rec->next)
     rec->offset = 0;
-  
- rerun:
+
+rerun:
   /* determine end of question section (we put answers there) */
   if (!(ansp = skip_questions(header, qlen)))
-    return 0; /* bad packet */
-   
-  /* now process each question, answers go in RRs after the question */
-  p = (unsigned char *)(header+1);
+    return 0;                   /* bad packet */
 
-  for (q = ntohs(header->qdcount); q != 0; q--)
-    {
-      /* save pointer to name for copying into answers */
-      nameoffset = p - (unsigned char *)header;
+  /* now process each question, answers go in RRs after the question */
+  p = (unsigned char *) (header + 1);
 
-      /* now extract name as .-concatenated string into name */
-      if (!extract_name(header, qlen, &p, name, 1, 4))
-	return 0; /* bad packet */
-            
-      GETSHORT(qtype, p); 
-      GETSHORT(qclass, p);
-
-      ans = 0; /* have we answered this question */
-      
-      if (qtype == T_TXT || qtype == T_ANY)
-	{
-	  struct txt_record *t;
-	  for(t = daemon->txt; t ; t = t->next)
-	    {
-	      if (t->class == qclass && hostname_isequal(name, t->name))
-		{
-		  ans = 1;
-		  if (!dryrun)
-		    {
-		      unsigned long ttl = daemon->local_ttl;
-		      int ok = 1;
-		      log_query(F_CONFIG | F_RRNAME, name, NULL, "<TXT>");
+  for (q = ntohs(header->qdcount); q != 0; q--) {
+    /* save pointer to name for copying into answers */
+    nameoffset = p - (unsigned char *) header;
+
+    /* now extract name as .-concatenated string into name */
+    if (!extract_name(header, qlen, &p, name, 1, 4))
+      return 0;                 /* bad packet */
+
+    GETSHORT(qtype, p);
+    GETSHORT(qclass, p);
+
+    ans = 0;                    /* have we answered this question */
+
+    if (qtype == T_TXT || qtype == T_ANY) {
+      struct txt_record *t;
+      for (t = daemon->txt; t; t = t->next) {
+        if (t->class == qclass && hostname_isequal(name, t->name)) {
+          ans = 1;
+          if (!dryrun) {
+            unsigned long ttl = daemon->local_ttl;
+            int ok = 1;
+            log_query(F_CONFIG | F_RRNAME, name, NULL, "<TXT>");
 #ifndef NO_ID
-		      /* Dynamically generate stat record */
-		      if (t->stat != 0)
-			{
-			  ttl = 0;
-			  if (!cache_make_stat(t))
-			    ok = 0;
-			}
+            /* Dynamically generate stat record */
+            if (t->stat != 0) {
+              ttl = 0;
+              if (!cache_make_stat(t))
+                ok = 0;
+            }
 #endif
-		      if (ok && add_resource_record(header, limit, &trunc, nameoffset, &ansp, 
-						    ttl, NULL,
-						    T_TXT, t->class, "t", t->len, t->txt))
-			anscount++;
-
-		    }
-		}
-	    }
-	}
-
-      if (qclass == C_IN)
-	{
-	  struct txt_record *t;
-
-	  for (t = daemon->rr; t; t = t->next)
-	    if ((t->class == qtype || qtype == T_ANY) && hostname_isequal(name, t->name))
-	      {
-		ans = 1;
-		sec_data = 0;
-		if (!dryrun)
-		  {
-		    log_query(F_CONFIG | F_RRNAME, name, NULL, "<RR>");
-		    if (add_resource_record(header, limit, &trunc, nameoffset, &ansp, 
-					    daemon->local_ttl, NULL,
-					    t->class, C_IN, "t", t->len, t->txt))
-		      anscount ++;
-		  }
-	      }
-		
-	  if (qtype == T_PTR || qtype == T_ANY)
-	    {
-	      /* see if it's w.z.y.z.in-addr.arpa format */
-	      int is_arpa = in_arpa_name_2_addr(name, &addr);
-	      struct ptr_record *ptr;
-	      struct interface_name* intr = NULL;
-
-	      for (ptr = daemon->ptr; ptr; ptr = ptr->next)
-		if (hostname_isequal(name, ptr->name))
-		  break;
-
-	      if (is_arpa == F_IPV4)
-		for (intr = daemon->int_names; intr; intr = intr->next)
-		  {
-		    struct addrlist *addrlist;
-		    
-		    for (addrlist = intr->addr; addrlist; addrlist = addrlist->next)
-		      if (!(addrlist->flags & ADDRLIST_IPV6) && addr.addr.addr4.s_addr == addrlist->addr.addr.addr4.s_addr)
-			break;
-		    
-		    if (addrlist)
-		      break;
-		    else
-		      while (intr->next && strcmp(intr->intr, intr->next->intr) == 0)
-			intr = intr->next;
-		  }
+            if (ok
+                && add_resource_record(header, limit, &trunc, nameoffset, &ansp,
+                                       ttl, NULL, T_TXT, t->class, "t", t->len,
+                                       t->txt))
+              anscount++;
+
+          }
+        }
+      }
+    }
+
+    if (qclass == C_IN) {
+      struct txt_record *t;
+
+      for (t = daemon->rr; t; t = t->next)
+        if ((t->class == qtype || qtype == T_ANY)
+            && hostname_isequal(name, t->name)) {
+          ans = 1;
+          sec_data = 0;
+          if (!dryrun) {
+            log_query(F_CONFIG | F_RRNAME, name, NULL, "<RR>");
+            if (add_resource_record(header, limit, &trunc, nameoffset, &ansp,
+                                    daemon->local_ttl, NULL,
+                                    t->class, C_IN, "t", t->len, t->txt))
+              anscount++;
+          }
+        }
+
+      if (qtype == T_PTR || qtype == T_ANY) {
+        /* see if it's w.z.y.z.in-addr.arpa format */
+        int is_arpa = in_arpa_name_2_addr(name, &addr);
+        struct ptr_record *ptr;
+        struct interface_name *intr = NULL;
+
+        for (ptr = daemon->ptr; ptr; ptr = ptr->next)
+          if (hostname_isequal(name, ptr->name))
+            break;
+
+        if (is_arpa == F_IPV4)
+          for (intr = daemon->int_names; intr; intr = intr->next) {
+            struct addrlist *addrlist;
+
+            for (addrlist = intr->addr; addrlist; addrlist = addrlist->next)
+              if (!(addrlist->flags & ADDRLIST_IPV6)
+                  && addr.addr.addr4.s_addr == addrlist->addr.addr.addr4.s_addr)
+                break;
+
+            if (addrlist)
+              break;
+            else
+              while (intr->next && strcmp(intr->intr, intr->next->intr) == 0)
+                intr = intr->next;
+          }
 #ifdef HAVE_IPV6
-	      else if (is_arpa == F_IPV6)
-		for (intr = daemon->int_names; intr; intr = intr->next)
-		  {
-		    struct addrlist *addrlist;
-		    
-		    for (addrlist = intr->addr; addrlist; addrlist = addrlist->next)
-		      if ((addrlist->flags & ADDRLIST_IPV6) && IN6_ARE_ADDR_EQUAL(&addr.addr.addr6, &addrlist->addr.addr.addr6))
-			break;
-		    
-		    if (addrlist)
-		      break;
-		    else
-		      while (intr->next && strcmp(intr->intr, intr->next->intr) == 0)
-			intr = intr->next;
-		  }
+        else if (is_arpa == F_IPV6)
+          for (intr = daemon->int_names; intr; intr = intr->next) {
+            struct addrlist *addrlist;
+
+            for (addrlist = intr->addr; addrlist; addrlist = addrlist->next)
+              if ((addrlist->flags & ADDRLIST_IPV6)
+                  && IN6_ARE_ADDR_EQUAL(&addr.addr.addr6,
+                                        &addrlist->addr.addr.addr6))
+                break;
+
+            if (addrlist)
+              break;
+            else
+              while (intr->next && strcmp(intr->intr, intr->next->intr) == 0)
+                intr = intr->next;
+          }
 #endif
-	      
-	      if (intr)
-		{
-		  sec_data = 0;
-		  ans = 1;
-		  if (!dryrun)
-		    {
-		      log_query(is_arpa | F_REVERSE | F_CONFIG, intr->name, &addr, NULL);
-		      if (add_resource_record(header, limit, &trunc, nameoffset, &ansp, 
-					      daemon->local_ttl, NULL,
-					      T_PTR, C_IN, "d", intr->name))
-			anscount++;
-		    }
-		}
-	      else if (ptr)
-		{
-		  ans = 1;
-		  sec_data = 0;
-		  if (!dryrun)
-		    {
-		      log_query(F_CONFIG | F_RRNAME, name, NULL, "<PTR>");
-		      for (ptr = daemon->ptr; ptr; ptr = ptr->next)
-			if (hostname_isequal(name, ptr->name) &&
-			    add_resource_record(header, limit, &trunc, nameoffset, &ansp, 
-						daemon->local_ttl, NULL,
-						T_PTR, C_IN, "d", ptr->ptr))
-			  anscount++;
-			 
-		    }
-		}
-	      else if ((crecp = cache_find_by_addr(NULL, &addr, now, is_arpa)))
-		{
-		  /* Don't use cache when DNSSEC data required, unless we know that
-		     the zone is unsigned, which implies that we're doing
-		     validation. */
-		  if ((crecp->flags & (F_HOSTS | F_DHCP | F_CONFIG)) || 
-		      !do_bit || 
-		      (option_bool(OPT_DNSSEC_VALID) && !(crecp->flags & F_DNSSECOK)))
-		    {
-		      do 
-			{ 
-			  /* don't answer wildcard queries with data not from /etc/hosts or dhcp leases */
-			  if (qtype == T_ANY && !(crecp->flags & (F_HOSTS | F_DHCP)))
-			    continue;
-			  
-			  if (!(crecp->flags & F_DNSSECOK))
-			    sec_data = 0;
-			   
-			  ans = 1;
-			   
-			  if (crecp->flags & F_NEG)
-			    {
-			      auth = 0;
-			      if (crecp->flags & F_NXDOMAIN)
-				nxdomain = 1;
-			      if (!dryrun)
-				log_query(crecp->flags & ~F_FORWARD, name, &addr, NULL);
-			    }
-			  else
-			    {
-			      if (!(crecp->flags & (F_HOSTS | F_DHCP)))
-				auth = 0;
-			      if (!dryrun)
-				{
-				  log_query(crecp->flags & ~F_FORWARD, cache_get_name(crecp), &addr, 
-					    record_source(crecp->uid));
-				  
-				  if (add_resource_record(header, limit, &trunc, nameoffset, &ansp, 
-							  crec_ttl(crecp, now), NULL,
-							  T_PTR, C_IN, "d", cache_get_name(crecp)))
-				    anscount++;
-				}
-			    }
-			} while ((crecp = cache_find_by_addr(crecp, &addr, now, is_arpa)));
-		    }
-		}
-	      else if (is_rev_synth(is_arpa, &addr, name))
-		{
-		  ans = 1;
-		  sec_data = 0;
-		  if (!dryrun)
-		    {
-		      log_query(F_CONFIG | F_REVERSE | is_arpa, name, &addr, NULL); 
-		      
-		      if (add_resource_record(header, limit, &trunc, nameoffset, &ansp, 
-					      daemon->local_ttl, NULL,
-					      T_PTR, C_IN, "d", name))
-			      anscount++;
-		    }
-		}
-	      else if (option_bool(OPT_BOGUSPRIV) && (
+
+        if (intr) {
+          sec_data = 0;
+          ans = 1;
+          if (!dryrun) {
+            log_query(is_arpa | F_REVERSE | F_CONFIG, intr->name, &addr, NULL);
+            if (add_resource_record(header, limit, &trunc, nameoffset, &ansp,
+                                    daemon->local_ttl, NULL,
+                                    T_PTR, C_IN, "d", intr->name))
+              anscount++;
+          }
+        } else if (ptr) {
+          ans = 1;
+          sec_data = 0;
+          if (!dryrun) {
+            log_query(F_CONFIG | F_RRNAME, name, NULL, "<PTR>");
+            for (ptr = daemon->ptr; ptr; ptr = ptr->next)
+              if (hostname_isequal(name, ptr->name) &&
+                  add_resource_record(header, limit, &trunc, nameoffset, &ansp,
+                                      daemon->local_ttl, NULL,
+                                      T_PTR, C_IN, "d", ptr->ptr))
+                anscount++;
+
+          }
+        } else if ((crecp = cache_find_by_addr(NULL, &addr, now, is_arpa))) {
+          /* Don't use cache when DNSSEC data required, unless we know that
+             the zone is unsigned, which implies that we're doing
+             validation. */
+          if ((crecp->flags & (F_HOSTS | F_DHCP | F_CONFIG)) ||
+              !do_bit ||
+              (option_bool(OPT_DNSSEC_VALID) && !(crecp->flags & F_DNSSECOK))) {
+            do {
+              /* don't answer wildcard queries with data not from /etc/hosts or dhcp leases */
+              if (qtype == T_ANY && !(crecp->flags & (F_HOSTS | F_DHCP)))
+                continue;
+
+              if (!(crecp->flags & F_DNSSECOK))
+                sec_data = 0;
+
+              ans = 1;
+
+              if (crecp->flags & F_NEG) {
+                auth = 0;
+                if (crecp->flags & F_NXDOMAIN)
+                  nxdomain = 1;
+                if (!dryrun)
+                  log_query(crecp->flags & ~F_FORWARD, name, &addr, NULL);
+              } else {
+                if (!(crecp->flags & (F_HOSTS | F_DHCP)))
+                  auth = 0;
+                if (!dryrun) {
+                  log_query(crecp->flags & ~F_FORWARD, cache_get_name(crecp),
+                            &addr, record_source(crecp->uid));
+
+                  if (add_resource_record
+                      (header, limit, &trunc, nameoffset, &ansp,
+                       crec_ttl(crecp, now), NULL, T_PTR, C_IN, "d",
+                       cache_get_name(crecp)))
+                    anscount++;
+                }
+              }
+            } while ((crecp = cache_find_by_addr(crecp, &addr, now, is_arpa)));
+          }
+        } else if (is_rev_synth(is_arpa, &addr, name)) {
+          ans = 1;
+          sec_data = 0;
+          if (!dryrun) {
+            log_query(F_CONFIG | F_REVERSE | is_arpa, name, &addr, NULL);
+
+            if (add_resource_record(header, limit, &trunc, nameoffset, &ansp,
+                                    daemon->local_ttl, NULL,
+                                    T_PTR, C_IN, "d", name))
+              anscount++;
+          }
+        } else if (option_bool(OPT_BOGUSPRIV) && (
 #ifdef HAVE_IPV6
-		       (is_arpa == F_IPV6 && private_net6(&addr.addr.addr6)) ||
+                                                   (is_arpa == F_IPV6
+                                                    && private_net6(&addr.addr.
+                                                                    addr6)) ||
 #endif
-		       (is_arpa == F_IPV4 && private_net(addr.addr.addr4, 1))))
-		{
-		  struct server *serv;
-		  unsigned int namelen = strlen(name);
-		  char *nameend = name + namelen;
-
-		  /* see if have rev-server set */
-		  for (serv = daemon->servers; serv; serv = serv->next)
-		    {
-		      unsigned int domainlen;
-		      char *matchstart;
-
-		      if ((serv->flags & (SERV_HAS_DOMAIN | SERV_NO_ADDR)) != SERV_HAS_DOMAIN)
-		        continue;
-
-		      domainlen = strlen(serv->domain);
-		      if (domainlen == 0 || domainlen > namelen)
-		        continue;
-
-		      matchstart = nameend - domainlen;
-		      if (hostname_isequal(matchstart, serv->domain) &&
-		          (namelen == domainlen || *(matchstart-1) == '.' ))
-			break;
-		    }
-
-		  /* if no configured server, not in cache, enabled and private IPV4 address, return NXDOMAIN */
-		  if (!serv)
-		    {
-		      ans = 1;
-		      sec_data = 0;
-		      nxdomain = 1;
-		      if (!dryrun)
-			log_query(F_CONFIG | F_REVERSE | is_arpa | F_NEG | F_NXDOMAIN,
-				  name, &addr, NULL);
-		    }
-		}
-	    }
-	  
-	  for (flag = F_IPV4; flag; flag = (flag == F_IPV4) ? F_IPV6 : 0)
-	    {
-	      unsigned short type = T_A;
-	      struct interface_name *intr;
+                                                   (is_arpa == F_IPV4
+                                                    && private_net(addr.addr.
+                                                                   addr4,
+                                                                   1)))) {
+          struct server *serv;
+          unsigned int namelen = strlen(name);
+          char *nameend = name + namelen;
+
+          /* see if have rev-server set */
+          for (serv = daemon->servers; serv; serv = serv->next) {
+            unsigned int domainlen;
+            char *matchstart;
+
+            if ((serv->flags & (SERV_HAS_DOMAIN | SERV_NO_ADDR)) !=
+                SERV_HAS_DOMAIN)
+              continue;
+
+            domainlen = strlen(serv->domain);
+            if (domainlen == 0 || domainlen > namelen)
+              continue;
+
+            matchstart = nameend - domainlen;
+            if (hostname_isequal(matchstart, serv->domain) &&
+                (namelen == domainlen || *(matchstart - 1) == '.'))
+              break;
+          }
+
+          /* if no configured server, not in cache, enabled and private IPV4 address, return NXDOMAIN */
+          if (!serv) {
+            ans = 1;
+            sec_data = 0;
+            nxdomain = 1;
+            if (!dryrun)
+              log_query(F_CONFIG | F_REVERSE | is_arpa | F_NEG | F_NXDOMAIN,
+                        name, &addr, NULL);
+          }
+        }
+      }
+
+      for (flag = F_IPV4; flag; flag = (flag == F_IPV4) ? F_IPV6 : 0) {
+        unsigned short type = T_A;
+        struct interface_name *intr;
 
-	      if (flag == F_IPV6)
+        if (flag == F_IPV6)
 #ifdef HAVE_IPV6
-		type = T_AAAA;
+          type = T_AAAA;
 #else
-	        break;
+          break;
 #endif
-	      
-	      if (qtype != type && qtype != T_ANY)
-		continue;
-	      
-	      /* Check for "A for A"  queries; be rather conservative 
-		 about what looks like dotted-quad.  */
-	      if (qtype == T_A)
-		{
-		  char *cp;
-		  unsigned int i, a;
-		  int x;
-
-		  for (cp = name, i = 0, a = 0; *cp; i++)
-		    {
-		      if (!isdigit((unsigned char)*cp) || (x = strtol(cp, &cp, 10)) > 255) 
-			{
-			  i = 5;
-			  break;
-			}
-		      
-		      a = (a << 8) + x;
-		      
-		      if (*cp == '.') 
-			cp++;
-		    }
-		  
-		  if (i == 4)
-		    {
-		      ans = 1;
-		      sec_data = 0;
-		      if (!dryrun)
-			{
-			  addr.addr.addr4.s_addr = htonl(a);
-			  log_query(F_FORWARD | F_CONFIG | F_IPV4, name, &addr, NULL);
-			  if (add_resource_record(header, limit, &trunc, nameoffset, &ansp, 
-						  daemon->local_ttl, NULL, type, C_IN, "4", &addr))
-			    anscount++;
-			}
-		      continue;
-		    }
-		}
-
-	      /* interface name stuff */
-	    intname_restart:
-	      for (intr = daemon->int_names; intr; intr = intr->next)
-		if (hostname_isequal(name, intr->name))
-		  break;
-	      
-	      if (intr)
-		{
-		  struct addrlist *addrlist;
-		  int gotit = 0, localise = 0;
-
-		  enumerate_interfaces(0);
-		    
-		  /* See if a putative address is on the network from which we received
-		     the query, is so we'll filter other answers. */
-		  if (local_addr.s_addr != 0 && option_bool(OPT_LOCALISE) && type == T_A)
-		    for (intr = daemon->int_names; intr; intr = intr->next)
-		      if (hostname_isequal(name, intr->name))
-			for (addrlist = intr->addr; addrlist; addrlist = addrlist->next)
+
+        if (qtype != type && qtype != T_ANY)
+          continue;
+
+        /* Check for "A for A"  queries; be rather conservative
+           about what looks like dotted-quad.  */
+        if (qtype == T_A) {
+          char *cp;
+          unsigned int i, a;
+          int x;
+
+          for (cp = name, i = 0, a = 0; *cp; i++) {
+            if (!isdigit((unsigned char) *cp)
+                || (x = strtol(cp, &cp, 10)) > 255) {
+              i = 5;
+              break;
+            }
+
+            a = (a << 8) + x;
+
+            if (*cp == '.')
+              cp++;
+          }
+
+          if (i == 4) {
+            ans = 1;
+            sec_data = 0;
+            if (!dryrun) {
+              addr.addr.addr4.s_addr = htonl(a);
+              log_query(F_FORWARD | F_CONFIG | F_IPV4, name, &addr, NULL);
+              if (add_resource_record(header, limit, &trunc, nameoffset, &ansp,
+                                      daemon->local_ttl, NULL, type, C_IN, "4",
+                                      &addr))
+                anscount++;
+            }
+            continue;
+          }
+        }
+
+        /* interface name stuff */
+      intname_restart:
+        for (intr = daemon->int_names; intr; intr = intr->next)
+          if (hostname_isequal(name, intr->name))
+            break;
+
+        if (intr) {
+          struct addrlist *addrlist;
+          int gotit = 0, localise = 0;
+
+          enumerate_interfaces(0);
+
+          /* See if a putative address is on the network from which we received
+             the query, is so we'll filter other answers. */
+          if (local_addr.s_addr != 0 && option_bool(OPT_LOCALISE)
+              && type == T_A)
+            for (intr = daemon->int_names; intr; intr = intr->next)
+              if (hostname_isequal(name, intr->name))
+                for (addrlist = intr->addr; addrlist; addrlist = addrlist->next)
 #ifdef HAVE_IPV6
-			  if (!(addrlist->flags & ADDRLIST_IPV6))
+                  if (!(addrlist->flags & ADDRLIST_IPV6))
 #endif
-			    if (is_same_net(*((struct in_addr *)&addrlist->addr), local_addr, local_netmask))
-			      {
-				localise = 1;
-				break;
-			      }
-		  
-		  for (intr = daemon->int_names; intr; intr = intr->next)
-		    if (hostname_isequal(name, intr->name))
-		      {
-			for (addrlist = intr->addr; addrlist; addrlist = addrlist->next)
+                    if (is_same_net
+                        (*((struct in_addr *) &addrlist->addr), local_addr,
+                         local_netmask)) {
+                      localise = 1;
+                      break;
+                    }
+
+          for (intr = daemon->int_names; intr; intr = intr->next)
+            if (hostname_isequal(name, intr->name)) {
+              for (addrlist = intr->addr; addrlist; addrlist = addrlist->next)
 #ifdef HAVE_IPV6
-			  if (((addrlist->flags & ADDRLIST_IPV6) ? T_AAAA : T_A) == type)
+                if (((addrlist->flags & ADDRLIST_IPV6) ? T_AAAA : T_A) == type)
 #endif
-			    {
-			      if (localise && 
-				  !is_same_net(*((struct in_addr *)&addrlist->addr), local_addr, local_netmask))
-				continue;
+                {
+                  if (localise &&
+                      !is_same_net(*((struct in_addr *) &addrlist->addr),
+                                   local_addr, local_netmask))
+                    continue;
 
 #ifdef HAVE_IPV6
-			      if (addrlist->flags & ADDRLIST_REVONLY)
-				continue;
-#endif	
-			      ans = 1;	
-			      sec_data = 0;
-			      if (!dryrun)
-				{
-				  gotit = 1;
-				  log_query(F_FORWARD | F_CONFIG | flag, name, &addrlist->addr, NULL);
-				  if (add_resource_record(header, limit, &trunc, nameoffset, &ansp, 
-							  daemon->local_ttl, NULL, type, C_IN, 
-							  type == T_A ? "4" : "6", &addrlist->addr))
-				    anscount++;
-				}
-			    }
-		      }
-		  
-		  if (!dryrun && !gotit)
-		    log_query(F_FORWARD | F_CONFIG | flag | F_NEG, name, NULL, NULL);
-		     
-		  continue;
-		}
-
-	    cname_restart:
-	      if ((crecp = cache_find_by_name(NULL, name, now, flag | F_CNAME | (dryrun ? F_NO_RR : 0))))
-		{
-		  int localise = 0;
-		  
-		  /* See if a putative address is on the network from which we received
-		     the query, is so we'll filter other answers. */
-		  if (local_addr.s_addr != 0 && option_bool(OPT_LOCALISE) && flag == F_IPV4)
-		    {
-		      struct crec *save = crecp;
-		      do {
-			if ((crecp->flags & F_HOSTS) &&
-			    is_same_net(*((struct in_addr *)&crecp->addr), local_addr, local_netmask))
-			  {
-			    localise = 1;
-			    break;
-			  } 
-			} while ((crecp = cache_find_by_name(crecp, name, now, flag | F_CNAME)));
-		      crecp = save;
-		    }
-
-		  /* If the client asked for DNSSEC  don't use cached data. */
-		  if ((crecp->flags & (F_HOSTS | F_DHCP | F_CONFIG)) || !do_bit || !(crecp->flags & F_DNSSECOK))
-		    do
-		      { 
-			/* don't answer wildcard queries with data not from /etc/hosts
-			   or DHCP leases */
-			if (qtype == T_ANY && !(crecp->flags & (F_HOSTS | F_DHCP | F_CONFIG)))
-			  break;
-			
-			if (!(crecp->flags & F_DNSSECOK))
-			  sec_data = 0;
-			
-			if (crecp->flags & F_CNAME)
-			  {
-			    char *cname_target = cache_get_cname_target(crecp);
-			    
-			    if (!dryrun)
-			      {
-				log_query(crecp->flags, name, NULL, record_source(crecp->uid));
-				if (add_resource_record(header, limit, &trunc, nameoffset, &ansp, 
-							crec_ttl(crecp, now), &nameoffset,
-							T_CNAME, C_IN, "d", cname_target))
-				  anscount++;
-			      }
-			    
-			    strcpy(name, cname_target);
-			    /* check if target interface_name */
-			    if (crecp->addr.cname.uid == SRC_INTERFACE)
-			      goto intname_restart;
-			    else
-			      goto cname_restart;
-			  }
-			
-			if (crecp->flags & F_NEG)
-			  {
-			    ans = 1;
-			    auth = 0;
-			    if (crecp->flags & F_NXDOMAIN)
-			      nxdomain = 1;
-			    if (!dryrun)
-			      log_query(crecp->flags, name, NULL, NULL);
-			  }
-			else 
-			  {
-			    /* If we are returning local answers depending on network,
-			       filter here. */
-			    if (localise && 
-				(crecp->flags & F_HOSTS) &&
-				!is_same_net(*((struct in_addr *)&crecp->addr), local_addr, local_netmask))
-			      continue;
-			    
-			    if (!(crecp->flags & (F_HOSTS | F_DHCP)))
-			      auth = 0;
-			    
-			    ans = 1;
-			    if (!dryrun)
-			      {
-				log_query(crecp->flags & ~F_REVERSE, name, &crecp->addr.addr,
-					  record_source(crecp->uid));
-				
-				if (add_resource_record(header, limit, &trunc, nameoffset, &ansp, 
-							crec_ttl(crecp, now), NULL, type, C_IN, 
-							type == T_A ? "4" : "6", &crecp->addr))
-				  anscount++;
-			      }
-			  }
-		      } while ((crecp = cache_find_by_name(crecp, name, now, flag | F_CNAME)));
-		}
-	      else if (is_name_synthetic(flag, name, &addr))
-		{
-		  ans = 1;
-		  if (!dryrun)
-		    {
-		      log_query(F_FORWARD | F_CONFIG | flag, name, &addr, NULL);
-		      if (add_resource_record(header, limit, &trunc, nameoffset, &ansp, 
-					      daemon->local_ttl, NULL, type, C_IN, type == T_A ? "4" : "6", &addr))
-			anscount++;
-		    }
-		}
-	    }
-
-	  if (qtype == T_CNAME || qtype == T_ANY)
-	    {
-	      if ((crecp = cache_find_by_name(NULL, name, now, F_CNAME)) &&
-		  (qtype == T_CNAME || (crecp->flags & (F_HOSTS | F_DHCP | F_CONFIG  | (dryrun ? F_NO_RR : 0)))))
-		{
-		  if (!(crecp->flags & F_DNSSECOK))
-		    sec_data = 0;
-		  
-		  ans = 1;
-		  if (!dryrun)
-		    {
-		      log_query(crecp->flags, name, NULL, record_source(crecp->uid));
-		      if (add_resource_record(header, limit, &trunc, nameoffset, &ansp, 
-					      crec_ttl(crecp, now), &nameoffset,
-					      T_CNAME, C_IN, "d", cache_get_cname_target(crecp)))
-			anscount++;
-		    }
-		}
-	    }
-
-	  if (qtype == T_MX || qtype == T_ANY)
-	    {
-	      int found = 0;
-	      for (rec = daemon->mxnames; rec; rec = rec->next)
-		if (!rec->issrv && hostname_isequal(name, rec->name))
-		  {
-		  ans = found = 1;
-		  if (!dryrun)
-		    {
-		      int offset;
-		      log_query(F_CONFIG | F_RRNAME, name, NULL, "<MX>");
-		      if (add_resource_record(header, limit, &trunc, nameoffset, &ansp, daemon->local_ttl,
-					      &offset, T_MX, C_IN, "sd", rec->weight, rec->target))
-			{
-			  anscount++;
-			  if (rec->target)
-			    rec->offset = offset;
-			}
-		    }
-		  }
-	      
-	      if (!found && (option_bool(OPT_SELFMX) || option_bool(OPT_LOCALMX)) && 
-		  cache_find_by_name(NULL, name, now, F_HOSTS | F_DHCP | F_NO_RR))
-		{ 
-		  ans = 1;
-		  if (!dryrun)
-		    {
-		      log_query(F_CONFIG | F_RRNAME, name, NULL, "<MX>");
-		      if (add_resource_record(header, limit, &trunc, nameoffset, &ansp, daemon->local_ttl, NULL, 
-					      T_MX, C_IN, "sd", 1, 
-					      option_bool(OPT_SELFMX) ? name : daemon->mxtarget))
-			anscount++;
-		    }
-		}
-	    }
-	  	  
-	  if (qtype == T_SRV || qtype == T_ANY)
-	    {
-	      int found = 0;
-	      struct mx_srv_record *move = NULL, **up = &daemon->mxnames;
-
-	      for (rec = daemon->mxnames; rec; rec = rec->next)
-		if (rec->issrv && hostname_isequal(name, rec->name))
-		  {
-		    found = ans = 1;
-		    if (!dryrun)
-		      {
-			int offset;
-			log_query(F_CONFIG | F_RRNAME, name, NULL, "<SRV>");
-			if (add_resource_record(header, limit, &trunc, nameoffset, &ansp, daemon->local_ttl, 
-						&offset, T_SRV, C_IN, "sssd", 
-						rec->priority, rec->weight, rec->srvport, rec->target))
-			  {
-			    anscount++;
-			    if (rec->target)
-			      rec->offset = offset;
-			  }
-		      }
-		    
-		    /* unlink first SRV record found */
-		    if (!move)
-		      {
-			move = rec;
-			*up = rec->next;
-		      }
-		    else
-		      up = &rec->next;      
-		  }
-		else
-		  up = &rec->next;
-
-	      /* put first SRV record back at the end. */
-	      if (move)
-		{
-		  *up = move;
-		  move->next = NULL;
-		}
-	      
-	      if (!found && option_bool(OPT_FILTER) && (qtype == T_SRV || (qtype == T_ANY && strchr(name, '_'))))
-		{
-		  ans = 1;
-		  if (!dryrun)
-		    log_query(F_CONFIG | F_NEG, name, NULL, NULL);
-		}
-	    }
-
-	  if (qtype == T_NAPTR || qtype == T_ANY)
-	    {
-	      struct naptr *na;
-	      for (na = daemon->naptr; na; na = na->next)
-		if (hostname_isequal(name, na->name))
-		  {
-		    ans = 1;
-		    if (!dryrun)
-		      {
-			log_query(F_CONFIG | F_RRNAME, name, NULL, "<NAPTR>");
-			if (add_resource_record(header, limit, &trunc, nameoffset, &ansp, daemon->local_ttl, 
-						NULL, T_NAPTR, C_IN, "sszzzd", 
-						na->order, na->pref, na->flags, na->services, na->regexp, na->replace))
-			  anscount++;
-		      }
-		  }
-	    }
-	  
-	  if (qtype == T_MAILB)
-	    ans = 1, nxdomain = 1;
-
-	  if (qtype == T_SOA && option_bool(OPT_FILTER))
-	    {
-	      ans = 1; 
-	      if (!dryrun)
-		log_query(F_CONFIG | F_NEG, name, &addr, NULL);
-	    }
-	}
+                  if (addrlist->flags & ADDRLIST_REVONLY)
+                    continue;
+#endif
+                  ans = 1;
+                  sec_data = 0;
+                  if (!dryrun) {
+                    gotit = 1;
+                    log_query(F_FORWARD | F_CONFIG | flag, name,
+                              &addrlist->addr, NULL);
+                    if (add_resource_record
+                        (header, limit, &trunc, nameoffset, &ansp,
+                         daemon->local_ttl, NULL, type, C_IN,
+                         type == T_A ? "4" : "6", &addrlist->addr))
+                      anscount++;
+                  }
+                }
+            }
+
+          if (!dryrun && !gotit)
+            log_query(F_FORWARD | F_CONFIG | flag | F_NEG, name, NULL, NULL);
+
+          continue;
+        }
+
+      cname_restart:
+        if ((crecp =
+             cache_find_by_name(NULL, name, now,
+                                flag | F_CNAME | (dryrun ? F_NO_RR : 0)))) {
+          int localise = 0;
+
+          /* See if a putative address is on the network from which we received
+             the query, is so we'll filter other answers. */
+          if (local_addr.s_addr != 0 && option_bool(OPT_LOCALISE)
+              && flag == F_IPV4) {
+            struct crec *save = crecp;
+            do {
+              if ((crecp->flags & F_HOSTS) &&
+                  is_same_net(*((struct in_addr *) &crecp->addr), local_addr,
+                              local_netmask)) {
+                localise = 1;
+                break;
+              }
+            } while ((crecp =
+                      cache_find_by_name(crecp, name, now, flag | F_CNAME)));
+            crecp = save;
+          }
 
-      if (!ans)
-	return 0; /* failed to answer a question */
-    }
-  
-  if (dryrun)
-    {
-      dryrun = 0;
-      goto rerun;
+          /* If the client asked for DNSSEC  don't use cached data. */
+          if ((crecp->flags & (F_HOSTS | F_DHCP | F_CONFIG)) || !do_bit
+              || !(crecp->flags & F_DNSSECOK))
+            do {
+              /* don't answer wildcard queries with data not from /etc/hosts
+                 or DHCP leases */
+              if (qtype == T_ANY
+                  && !(crecp->flags & (F_HOSTS | F_DHCP | F_CONFIG)))
+                break;
+
+              if (!(crecp->flags & F_DNSSECOK))
+                sec_data = 0;
+
+              if (crecp->flags & F_CNAME) {
+                char *cname_target = cache_get_cname_target(crecp);
+
+                if (!dryrun) {
+                  log_query(crecp->flags, name, NULL,
+                            record_source(crecp->uid));
+                  if (add_resource_record
+                      (header, limit, &trunc, nameoffset, &ansp,
+                       crec_ttl(crecp, now), &nameoffset, T_CNAME, C_IN, "d",
+                       cname_target))
+                    anscount++;
+                }
+
+                strcpy(name, cname_target);
+                /* check if target interface_name */
+                if (crecp->addr.cname.uid == SRC_INTERFACE)
+                  goto intname_restart;
+                else
+                  goto cname_restart;
+              }
+
+              if (crecp->flags & F_NEG) {
+                ans = 1;
+                auth = 0;
+                if (crecp->flags & F_NXDOMAIN)
+                  nxdomain = 1;
+                if (!dryrun)
+                  log_query(crecp->flags, name, NULL, NULL);
+              } else {
+                /* If we are returning local answers depending on network,
+                   filter here. */
+                if (localise &&
+                    (crecp->flags & F_HOSTS) &&
+                    !is_same_net(*((struct in_addr *) &crecp->addr), local_addr,
+                                 local_netmask))
+                  continue;
+
+                if (!(crecp->flags & (F_HOSTS | F_DHCP)))
+                  auth = 0;
+
+                ans = 1;
+                if (!dryrun) {
+                  log_query(crecp->flags & ~F_REVERSE, name, &crecp->addr.addr,
+                            record_source(crecp->uid));
+
+                  if (add_resource_record
+                      (header, limit, &trunc, nameoffset, &ansp,
+                       crec_ttl(crecp, now), NULL, type, C_IN,
+                       type == T_A ? "4" : "6", &crecp->addr))
+                    anscount++;
+                }
+              }
+            } while ((crecp =
+                      cache_find_by_name(crecp, name, now, flag | F_CNAME)));
+        } else if (is_name_synthetic(flag, name, &addr)) {
+          ans = 1;
+          if (!dryrun) {
+            log_query(F_FORWARD | F_CONFIG | flag, name, &addr, NULL);
+            if (add_resource_record(header, limit, &trunc, nameoffset, &ansp,
+                                    daemon->local_ttl, NULL, type, C_IN,
+                                    type == T_A ? "4" : "6", &addr))
+              anscount++;
+          }
+        }
+      }
+
+      if (qtype == T_CNAME || qtype == T_ANY) {
+        if ((crecp = cache_find_by_name(NULL, name, now, F_CNAME)) &&
+            (qtype == T_CNAME
+             || (crecp->
+                 flags & (F_HOSTS | F_DHCP | F_CONFIG |
+                          (dryrun ? F_NO_RR : 0))))) {
+          if (!(crecp->flags & F_DNSSECOK))
+            sec_data = 0;
+
+          ans = 1;
+          if (!dryrun) {
+            log_query(crecp->flags, name, NULL, record_source(crecp->uid));
+            if (add_resource_record(header, limit, &trunc, nameoffset, &ansp,
+                                    crec_ttl(crecp, now), &nameoffset,
+                                    T_CNAME, C_IN, "d",
+                                    cache_get_cname_target(crecp)))
+              anscount++;
+          }
+        }
+      }
+
+      if (qtype == T_MX || qtype == T_ANY) {
+        int found = 0;
+        for (rec = daemon->mxnames; rec; rec = rec->next)
+          if (!rec->issrv && hostname_isequal(name, rec->name)) {
+            ans = found = 1;
+            if (!dryrun) {
+              int offset;
+              log_query(F_CONFIG | F_RRNAME, name, NULL, "<MX>");
+              if (add_resource_record
+                  (header, limit, &trunc, nameoffset, &ansp, daemon->local_ttl,
+                   &offset, T_MX, C_IN, "sd", rec->weight, rec->target)) {
+                anscount++;
+                if (rec->target)
+                  rec->offset = offset;
+              }
+            }
+          }
+
+        if (!found && (option_bool(OPT_SELFMX) || option_bool(OPT_LOCALMX)) &&
+            cache_find_by_name(NULL, name, now, F_HOSTS | F_DHCP | F_NO_RR)) {
+          ans = 1;
+          if (!dryrun) {
+            log_query(F_CONFIG | F_RRNAME, name, NULL, "<MX>");
+            if (add_resource_record
+                (header, limit, &trunc, nameoffset, &ansp, daemon->local_ttl,
+                 NULL, T_MX, C_IN, "sd", 1,
+                 option_bool(OPT_SELFMX) ? name : daemon->mxtarget))
+              anscount++;
+          }
+        }
+      }
+
+      if (qtype == T_SRV || qtype == T_ANY) {
+        int found = 0;
+        struct mx_srv_record *move = NULL, **up = &daemon->mxnames;
+
+        for (rec = daemon->mxnames; rec; rec = rec->next)
+          if (rec->issrv && hostname_isequal(name, rec->name)) {
+            found = ans = 1;
+            if (!dryrun) {
+              int offset;
+              log_query(F_CONFIG | F_RRNAME, name, NULL, "<SRV>");
+              if (add_resource_record
+                  (header, limit, &trunc, nameoffset, &ansp, daemon->local_ttl,
+                   &offset, T_SRV, C_IN, "sssd", rec->priority, rec->weight,
+                   rec->srvport, rec->target)) {
+                anscount++;
+                if (rec->target)
+                  rec->offset = offset;
+              }
+            }
+
+            /* unlink first SRV record found */
+            if (!move) {
+              move = rec;
+              *up = rec->next;
+            } else
+              up = &rec->next;
+          } else
+            up = &rec->next;
+
+        /* put first SRV record back at the end. */
+        if (move) {
+          *up = move;
+          move->next = NULL;
+        }
+
+        if (!found && option_bool(OPT_FILTER)
+            && (qtype == T_SRV || (qtype == T_ANY && strchr(name, '_')))) {
+          ans = 1;
+          if (!dryrun)
+            log_query(F_CONFIG | F_NEG, name, NULL, NULL);
+        }
+      }
+
+      if (qtype == T_NAPTR || qtype == T_ANY) {
+        struct naptr *na;
+        for (na = daemon->naptr; na; na = na->next)
+          if (hostname_isequal(name, na->name)) {
+            ans = 1;
+            if (!dryrun) {
+              log_query(F_CONFIG | F_RRNAME, name, NULL, "<NAPTR>");
+              if (add_resource_record
+                  (header, limit, &trunc, nameoffset, &ansp, daemon->local_ttl,
+                   NULL, T_NAPTR, C_IN, "sszzzd", na->order, na->pref,
+                   na->flags, na->services, na->regexp, na->replace))
+                anscount++;
+            }
+          }
+      }
+
+      if (qtype == T_MAILB)
+        ans = 1, nxdomain = 1;
+
+      if (qtype == T_SOA && option_bool(OPT_FILTER)) {
+        ans = 1;
+        if (!dryrun)
+          log_query(F_CONFIG | F_NEG, name, &addr, NULL);
+      }
     }
-  
+
+    if (!ans)
+      return 0;                 /* failed to answer a question */
+  }
+
+  if (dryrun) {
+    dryrun = 0;
+    goto rerun;
+  }
+
   /* create an additional data section, for stuff in SRV and MX record replies. */
   for (rec = daemon->mxnames; rec; rec = rec->next)
-    if (rec->offset != 0)
-      {
-	/* squash dupes */
-	struct mx_srv_record *tmp;
-	for (tmp = rec->next; tmp; tmp = tmp->next)
-	  if (tmp->offset != 0 && hostname_isequal(rec->target, tmp->target))
-	    tmp->offset = 0;
-	
-	crecp = NULL;
-	while ((crecp = cache_find_by_name(crecp, rec->target, now, F_IPV4 | F_IPV6)))
-	  {
+    if (rec->offset != 0) {
+      /* squash dupes */
+      struct mx_srv_record *tmp;
+      for (tmp = rec->next; tmp; tmp = tmp->next)
+        if (tmp->offset != 0 && hostname_isequal(rec->target, tmp->target))
+          tmp->offset = 0;
+
+      crecp = NULL;
+      while ((crecp =
+              cache_find_by_name(crecp, rec->target, now, F_IPV4 | F_IPV6))) {
 #ifdef HAVE_IPV6
-	    int type =  crecp->flags & F_IPV4 ? T_A : T_AAAA;
+        int type = crecp->flags & F_IPV4 ? T_A : T_AAAA;
 #else
-	    int type = T_A;
+        int type = T_A;
 #endif
-	    if (crecp->flags & F_NEG)
-	      continue;
+        if (crecp->flags & F_NEG)
+          continue;
 
-	    if (add_resource_record(header, limit, NULL, rec->offset, &ansp, 
-				    crec_ttl(crecp, now), NULL, type, C_IN, 
-				    crecp->flags & F_IPV4 ? "4" : "6", &crecp->addr))
-	      addncount++;
-	  }
+        if (add_resource_record(header, limit, NULL, rec->offset, &ansp,
+                                crec_ttl(crecp, now), NULL, type, C_IN,
+                                crecp->flags & F_IPV4 ? "4" : "6",
+                                &crecp->addr))
+          addncount++;
       }
-  
+    }
+
   /* done all questions, set up header and return length of result */
   /* clear authoritative and truncated flags, set QR flag */
   header->hb3 = (header->hb3 & ~(HB3_AA | HB3_TC)) | HB3_QR;
   /* set RA flag */
   header->hb4 |= HB4_RA;
-   
+
   /* authoritative - only hosts and DHCP derived names. */
   if (auth)
     header->hb3 |= HB3_AA;
-  
+
   /* truncation */
   if (trunc)
     header->hb3 |= HB3_TC;
-  
+
   if (nxdomain)
     SET_RCODE(header, NXDOMAIN);
   else
@@ -1941,16 +1832,18 @@
   header->nscount = htons(0);
   header->arcount = htons(addncount);
 
-  len = ansp - (unsigned char *)header;
-  
+  len = ansp - (unsigned char *) header;
+
   /* Advertise our packet size limit in our reply */
   if (have_pseudoheader)
-    len = add_pseudoheader(header, len, (unsigned char *)limit, daemon->edns_pktsz, 0, NULL, 0, do_bit, 0);
-  
+    len =
+        add_pseudoheader(header, len, (unsigned char *) limit,
+                         daemon->edns_pktsz, 0, NULL, 0, do_bit, 0);
+
   if (ad_reqd && sec_data)
     header->hb4 |= HB4_AD;
   else
     header->hb4 &= ~HB4_AD;
-  
+
   return len;
 }
Index: dnsmasq-2.78/src/rfc2131.c
===================================================================
--- dnsmasq-2.78.orig/src/rfc2131.c	2017-10-02 21:13:51.000000000 +0800
+++ dnsmasq-2.78/src/rfc2131.c	2018-10-29 16:14:19.489440028 +0800
@@ -26,49 +26,64 @@
 #endif
 
 static int sanitise(unsigned char *opt, char *buf);
-static struct in_addr server_id(struct dhcp_context *context, struct in_addr override, struct in_addr fallback);
-static unsigned int calc_time(struct dhcp_context *context, struct dhcp_config *config, unsigned char *opt);
-static void option_put(struct dhcp_packet *mess, unsigned char *end, int opt, int len, unsigned int val);
-static void option_put_string(struct dhcp_packet *mess, unsigned char *end, 
-			      int opt, char *string, int null_term);
+static struct in_addr server_id(struct dhcp_context *context,
+                                struct in_addr override,
+                                struct in_addr fallback);
+static unsigned int calc_time(struct dhcp_context *context,
+                              struct dhcp_config *config, unsigned char *opt);
+static void option_put(struct dhcp_packet *mess, unsigned char *end, int opt,
+                       int len, unsigned int val);
+static void option_put_string(struct dhcp_packet *mess, unsigned char *end,
+                              int opt, char *string, int null_term);
 static struct in_addr option_addr(unsigned char *opt);
 static unsigned int option_uint(unsigned char *opt, int offset, int size);
-static void log_packet(char *type, void *addr, unsigned char *ext_mac, 
-		       int mac_len, char *interface, char *string, char *err, u32 xid);
-static unsigned char *option_find(struct dhcp_packet *mess, size_t size, int opt_type, int minsize);
-static unsigned char *option_find1(unsigned char *p, unsigned char *end, int opt, int minsize);
-static size_t dhcp_packet_size(struct dhcp_packet *mess, unsigned char *agent_id, unsigned char *real_end);
+static void log_packet(char *type, void *addr, unsigned char *ext_mac,
+                       int mac_len, char *interface, char *string, char *err,
+                       u32 xid);
+static unsigned char *option_find(struct dhcp_packet *mess, size_t size,
+                                  int opt_type, int minsize);
+static unsigned char *option_find1(unsigned char *p, unsigned char *end,
+                                   int opt, int minsize);
+static size_t dhcp_packet_size(struct dhcp_packet *mess,
+                               unsigned char *agent_id,
+                               unsigned char *real_end);
 static void clear_packet(struct dhcp_packet *mess, unsigned char *end);
 static int in_list(unsigned char *list, int opt);
 static void do_options(struct dhcp_context *context,
-		       struct dhcp_packet *mess,
-		       unsigned char *end,
-		       unsigned char *req_options,
-		       char *hostname, 
-		       char *domain,
-		       struct dhcp_netid *netid,
-		       struct in_addr subnet_addr, 
-		       unsigned char fqdn_flags,
-		       int null_term, int pxe_arch,
-		       unsigned char *uuid,
-		       int vendor_class_len,
-		       time_t now,
-		       unsigned int lease_time,
-		       unsigned short fuzz);
-
-
-static void match_vendor_opts(unsigned char *opt, struct dhcp_opt *dopt); 
-static int do_encap_opts(struct dhcp_opt *opt, int encap, int flag, struct dhcp_packet *mess, unsigned char *end, int null_term);
-static void pxe_misc(struct dhcp_packet *mess, unsigned char *end, unsigned char *uuid);
+                       struct dhcp_packet *mess,
+                       unsigned char *end,
+                       unsigned char *req_options,
+                       char *hostname,
+                       char *domain,
+                       struct dhcp_netid *netid,
+                       struct in_addr subnet_addr,
+                       unsigned char fqdn_flags,
+                       int null_term, int pxe_arch,
+                       unsigned char *uuid,
+                       int vendor_class_len,
+                       time_t now,
+                       unsigned int lease_time, unsigned short fuzz);
+
+
+static void match_vendor_opts(unsigned char *opt, struct dhcp_opt *dopt);
+static int do_encap_opts(struct dhcp_opt *opt, int encap, int flag,
+                         struct dhcp_packet *mess, unsigned char *end,
+                         int null_term);
+static void pxe_misc(struct dhcp_packet *mess, unsigned char *end,
+                     unsigned char *uuid);
 static int prune_vendor_opts(struct dhcp_netid *netid);
-static struct dhcp_opt *pxe_opts(int pxe_arch, struct dhcp_netid *netid, struct in_addr local, time_t now);
+static struct dhcp_opt *pxe_opts(int pxe_arch, struct dhcp_netid *netid,
+                                 struct in_addr local, time_t now);
 struct dhcp_boot *find_boot(struct dhcp_netid *netid);
-static int pxe_uefi_workaround(int pxe_arch, struct dhcp_netid *netid, struct dhcp_packet *mess, struct in_addr local, time_t now, int pxe);
+static int pxe_uefi_workaround(int pxe_arch, struct dhcp_netid *netid,
+                               struct dhcp_packet *mess, struct in_addr local,
+                               time_t now, int pxe);
 static void apply_delay(u32 xid, time_t recvtime, struct dhcp_netid *netid);
 
 size_t dhcp_reply(struct dhcp_context *context, char *iface_name, int int_index,
-		  size_t sz, time_t now, int unicast_dest, int loopback,
-		  int *is_inform, int pxe, struct in_addr fallback, time_t recvtime)
+                  size_t sz, time_t now, int unicast_dest, int loopback,
+                  int *is_inform, int pxe, struct in_addr fallback,
+                  time_t recvtime)
 {
   unsigned char *opt, *clid = NULL;
   struct dhcp_lease *ltmp, *lease = NULL;
@@ -76,10 +91,12 @@
   struct dhcp_mac *mac;
   struct dhcp_netid_list *id_list;
   int clid_len = 0, ignore = 0, do_classes = 0, selecting = 0, pxearch = -1;
-  struct dhcp_packet *mess = (struct dhcp_packet *)daemon->dhcp_packet.iov_base;
-  unsigned char *end = (unsigned char *)(mess + 1); 
-  unsigned char *real_end = (unsigned char *)(mess + 1); 
-  char *hostname = NULL, *offer_hostname = NULL, *client_hostname = NULL, *domain = NULL;
+  struct dhcp_packet *mess =
+      (struct dhcp_packet *) daemon->dhcp_packet.iov_base;
+  unsigned char *end = (unsigned char *) (mess + 1);
+  unsigned char *real_end = (unsigned char *) (mess + 1);
+  char *hostname = NULL, *offer_hostname = NULL, *client_hostname =
+      NULL, *domain = NULL;
   int hostname_auth = 0, borken_opt = 0;
   unsigned char *req_options = NULL;
   char *message = NULL;
@@ -106,164 +123,164 @@
   /* set tag with name == interface */
   iface_id.net = iface_name;
   iface_id.next = NULL;
-  netid = &iface_id; 
-  
+  netid = &iface_id;
+
   if (mess->op != BOOTREQUEST || mess->hlen > DHCP_CHADDR_MAX)
     return 0;
-   
+
   if (mess->htype == 0 && mess->hlen != 0)
     return 0;
 
   /* check for DHCP rather than BOOTP */
-  if ((opt = option_find(mess, sz, OPTION_MESSAGE_TYPE, 1)))
-    {
-      u32 cookie = htonl(DHCP_COOKIE);
-      
-      /* only insist on a cookie for DHCP. */
-      if (memcmp(mess->options, &cookie, sizeof(u32)) != 0)
-	return 0;
-      
-      mess_type = option_uint(opt, 0, 1);
-      
-      /* two things to note here: expand_buf may move the packet,
-	 so reassign mess from daemon->packet. Also, the size
-	 sent includes the IP and UDP headers, hence the magic "-28" */
-      if ((opt = option_find(mess, sz, OPTION_MAXMESSAGE, 2)))
-	{
-	  size_t size = (size_t)option_uint(opt, 0, 2) - 28;
-	  
-	  if (size > DHCP_PACKET_MAX)
-	    size = DHCP_PACKET_MAX;
-	  else if (size < sizeof(struct dhcp_packet))
-	    size = sizeof(struct dhcp_packet);
-	  
-	  if (expand_buf(&daemon->dhcp_packet, size))
-	    {
-	      mess = (struct dhcp_packet *)daemon->dhcp_packet.iov_base;
-	      real_end = end = ((unsigned char *)mess) + size;
-	    }
-	}
-
-      /* Some buggy clients set ciaddr when they shouldn't, so clear that here since
-	 it can affect the context-determination code. */
-      if ((option_find(mess, sz, OPTION_REQUESTED_IP, INADDRSZ) || mess_type == DHCPDISCOVER))
-	mess->ciaddr.s_addr = 0;
-
-      /* search for device identity from CPEWAN devices, we pass this through to the script */
-      if ((opt = option_find(mess, sz, OPTION_VENDOR_IDENT_OPT, 5)))
-	{
-	  unsigned  int elen, offset, len = option_len(opt);
-	  
-	  for (offset = 0; offset < (len - 5); offset += elen + 5)
-	    {
-	      elen = option_uint(opt, offset + 4 , 1);
-	      if (option_uint(opt, offset, 4) == BRDBAND_FORUM_IANA && offset + elen + 5 <= len)
-		{
-		  unsigned char *x = option_ptr(opt, offset + 5);
-		  unsigned char *y = option_ptr(opt, offset + elen + 5);
-		  oui = option_find1(x, y, 1, 1);
-		  serial = option_find1(x, y, 2, 1);
+  if ((opt = option_find(mess, sz, OPTION_MESSAGE_TYPE, 1))) {
+    u32 cookie = htonl(DHCP_COOKIE);
+
+    /* only insist on a cookie for DHCP. */
+    if (memcmp(mess->options, &cookie, sizeof(u32)) != 0)
+      return 0;
+
+    mess_type = option_uint(opt, 0, 1);
+
+    /* two things to note here: expand_buf may move the packet,
+       so reassign mess from daemon->packet. Also, the size
+       sent includes the IP and UDP headers, hence the magic "-28" */
+    if ((opt = option_find(mess, sz, OPTION_MAXMESSAGE, 2))) {
+      size_t size = (size_t) option_uint(opt, 0, 2) - 28;
+
+      if (size > DHCP_PACKET_MAX)
+        size = DHCP_PACKET_MAX;
+      else if (size < sizeof(struct dhcp_packet))
+        size = sizeof(struct dhcp_packet);
+
+      if (expand_buf(&daemon->dhcp_packet, size)) {
+        mess = (struct dhcp_packet *) daemon->dhcp_packet.iov_base;
+        real_end = end = ((unsigned char *) mess) + size;
+      }
+    }
+
+    /* Some buggy clients set ciaddr when they shouldn't, so clear that here since
+       it can affect the context-determination code. */
+    if ((option_find(mess, sz, OPTION_REQUESTED_IP, INADDRSZ)
+         || mess_type == DHCPDISCOVER))
+      mess->ciaddr.s_addr = 0;
+
+    /* search for device identity from CPEWAN devices, we pass this through to the script */
+    if ((opt = option_find(mess, sz, OPTION_VENDOR_IDENT_OPT, 5))) {
+      unsigned int elen, offset, len = option_len(opt);
+
+      for (offset = 0; offset < (len - 5); offset += elen + 5) {
+        elen = option_uint(opt, offset + 4, 1);
+        if (option_uint(opt, offset, 4) == BRDBAND_FORUM_IANA
+            && offset + elen + 5 <= len) {
+          unsigned char *x = option_ptr(opt, offset + 5);
+          unsigned char *y = option_ptr(opt, offset + elen + 5);
+          oui = option_find1(x, y, 1, 1);
+          serial = option_find1(x, y, 2, 1);
 #ifdef HAVE_SCRIPT
-		  class = option_find1(x, y, 3, 1);		  
+          class = option_find1(x, y, 3, 1);
 #endif
-		  /* If TR069-id is present set the tag "cpewan-id" to facilitate echoing 
-		     the gateway id back. Note that the device class is optional */
-		  if (oui && serial)
-		    {
-		      cpewan_id.net = "cpewan-id";
-		      cpewan_id.next = netid;
-		      netid = &cpewan_id;
-		    }
-		  break;
-		}
-	    }
-	}
-      
-      if ((opt = option_find(mess, sz, OPTION_AGENT_ID, 1)))
-	{
-	  /* Any agent-id needs to be copied back out, verbatim, as the last option
-	     in the packet. Here, we shift it to the very end of the buffer, if it doesn't
-	     get overwritten, then it will be shuffled back at the end of processing.
-	     Note that the incoming options must not be overwritten here, so there has to 
-	     be enough free space at the end of the packet to copy the option. */
-	  unsigned char *sopt;
-	  unsigned int total = option_len(opt) + 2;
-	  unsigned char *last_opt = option_find1(&mess->options[0] + sizeof(u32), ((unsigned char *)mess) + sz,
-						 OPTION_END, 0);
-	  if (last_opt && last_opt < end - total)
-	    {
-	      end -= total;
-	      agent_id = end;
-	      memcpy(agent_id, opt, total);
-	    }
-
-	  /* look for RFC3527 Link selection sub-option */
-	  if ((sopt = option_find1(option_ptr(opt, 0), option_ptr(opt, option_len(opt)), SUBOPT_SUBNET_SELECT, INADDRSZ)))
-	    subnet_addr = option_addr(sopt);
-
-	  /* look for RFC5107 server-identifier-override */
-	  if ((sopt = option_find1(option_ptr(opt, 0), option_ptr(opt, option_len(opt)), SUBOPT_SERVER_OR, INADDRSZ)))
-	    override = option_addr(sopt);
-	  
-	  /* if a circuit-id or remote-is option is provided, exact-match to options. */ 
-	  for (vendor = daemon->dhcp_vendors; vendor; vendor = vendor->next)
-	    {
-	      int search;
-	      
-	      if (vendor->match_type == MATCH_CIRCUIT)
-		search = SUBOPT_CIRCUIT_ID;
-	      else if (vendor->match_type == MATCH_REMOTE)
-		search = SUBOPT_REMOTE_ID;
-	      else if (vendor->match_type == MATCH_SUBSCRIBER)
-		search = SUBOPT_SUBSCR_ID;
-	      else 
-		continue;
-
-	      if ((sopt = option_find1(option_ptr(opt, 0), option_ptr(opt, option_len(opt)), search, 1)) &&
-		  vendor->len == option_len(sopt) &&
-		  memcmp(option_ptr(sopt, 0), vendor->data, vendor->len) == 0)
-		{
-		  vendor->netid.next = netid;
-		  netid = &vendor->netid;
-		} 
-	    }
-	}
-
-      /* Check for RFC3011 subnet selector - only if RFC3527 one not present */
-      if (subnet_addr.s_addr == 0 && (opt = option_find(mess, sz, OPTION_SUBNET_SELECT, INADDRSZ)))
-	subnet_addr = option_addr(opt);
-      
-      /* If there is no client identifier option, use the hardware address */
-      if ((opt = option_find(mess, sz, OPTION_CLIENT_ID, 1)))
-	{
-	  clid_len = option_len(opt);
-	  clid = option_ptr(opt, 0);
-	}
-
-      /* do we have a lease in store? */
-      lease = lease_find_by_client(mess->chaddr, mess->hlen, mess->htype, clid, clid_len);
-
-      /* If this request is missing a clid, but we've seen one before, 
-	 use it again for option matching etc. */
-      if (lease && !clid && lease->clid)
-	{
-	  clid_len = lease->clid_len;
-	  clid = lease->clid;
-	}
+          /* If TR069-id is present set the tag "cpewan-id" to facilitate echoing
+             the gateway id back. Note that the device class is optional */
+          if (oui && serial) {
+            cpewan_id.net = "cpewan-id";
+            cpewan_id.next = netid;
+            netid = &cpewan_id;
+          }
+          break;
+        }
+      }
+    }
 
-      /* find mac to use for logging and hashing */
-      emac = extended_hwaddr(mess->htype, mess->hlen, mess->chaddr, clid_len, clid, &emac_len);
+    if ((opt = option_find(mess, sz, OPTION_AGENT_ID, 1))) {
+      /* Any agent-id needs to be copied back out, verbatim, as the last option
+         in the packet. Here, we shift it to the very end of the buffer, if it doesn't
+         get overwritten, then it will be shuffled back at the end of processing.
+         Note that the incoming options must not be overwritten here, so there has to
+         be enough free space at the end of the packet to copy the option. */
+      unsigned char *sopt;
+      unsigned int total = option_len(opt) + 2;
+      unsigned char *last_opt =
+          option_find1(&mess->options[0] + sizeof(u32),
+                       ((unsigned char *) mess) + sz,
+                       OPTION_END, 0);
+      if (last_opt && last_opt < end - total) {
+        end -= total;
+        agent_id = end;
+        memcpy(agent_id, opt, total);
+      }
+
+      /* look for RFC3527 Link selection sub-option */
+      if ((sopt =
+           option_find1(option_ptr(opt, 0), option_ptr(opt, option_len(opt)),
+                        SUBOPT_SUBNET_SELECT, INADDRSZ)))
+        subnet_addr = option_addr(sopt);
+
+      /* look for RFC5107 server-identifier-override */
+      if ((sopt =
+           option_find1(option_ptr(opt, 0), option_ptr(opt, option_len(opt)),
+                        SUBOPT_SERVER_OR, INADDRSZ)))
+        override = option_addr(sopt);
+
+      /* if a circuit-id or remote-is option is provided, exact-match to options. */
+      for (vendor = daemon->dhcp_vendors; vendor; vendor = vendor->next) {
+        int search;
+
+        if (vendor->match_type == MATCH_CIRCUIT)
+          search = SUBOPT_CIRCUIT_ID;
+        else if (vendor->match_type == MATCH_REMOTE)
+          search = SUBOPT_REMOTE_ID;
+        else if (vendor->match_type == MATCH_SUBSCRIBER)
+          search = SUBOPT_SUBSCR_ID;
+        else
+          continue;
+
+        if ((sopt =
+             option_find1(option_ptr(opt, 0), option_ptr(opt, option_len(opt)),
+                          search, 1)) && vendor->len == option_len(sopt)
+            && memcmp(option_ptr(sopt, 0), vendor->data, vendor->len) == 0) {
+          vendor->netid.next = netid;
+          netid = &vendor->netid;
+        }
+      }
     }
-  
+
+    /* Check for RFC3011 subnet selector - only if RFC3527 one not present */
+    if (subnet_addr.s_addr == 0
+        && (opt = option_find(mess, sz, OPTION_SUBNET_SELECT, INADDRSZ)))
+      subnet_addr = option_addr(opt);
+
+    /* If there is no client identifier option, use the hardware address */
+    if ((opt = option_find(mess, sz, OPTION_CLIENT_ID, 1))) {
+      clid_len = option_len(opt);
+      clid = option_ptr(opt, 0);
+    }
+
+    /* do we have a lease in store? */
+    lease =
+        lease_find_by_client(mess->chaddr, mess->hlen, mess->htype, clid,
+                             clid_len);
+
+    /* If this request is missing a clid, but we've seen one before,
+       use it again for option matching etc. */
+    if (lease && !clid && lease->clid) {
+      clid_len = lease->clid_len;
+      clid = lease->clid;
+    }
+
+    /* find mac to use for logging and hashing */
+    emac =
+        extended_hwaddr(mess->htype, mess->hlen, mess->chaddr, clid_len, clid,
+                        &emac_len);
+  }
+
   for (mac = daemon->dhcp_macs; mac; mac = mac->next)
     if (mac->hwaddr_len == mess->hlen &&
-	(mac->hwaddr_type == mess->htype || mac->hwaddr_type == 0) &&
-	memcmp_masked(mac->hwaddr, mess->chaddr, mess->hlen, mac->mask))
-      {
-	mac->netid.next = netid;
-	netid = &mac->netid;
-      }
-  
+        (mac->hwaddr_type == mess->htype || mac->hwaddr_type == 0) &&
+        memcmp_masked(mac->hwaddr, mess->chaddr, mess->hlen, mac->mask)) {
+      mac->netid.next = netid;
+      netid = &mac->netid;
+    }
+
   /* Determine network for this packet. Our caller will have already linked all the 
      contexts which match the addresses of the receiving interface but if the 
      machine has an address already, or came via a relay, or we have a subnet selector, 
@@ -271,146 +288,141 @@
      use the ciaddr. This is necessary because a  machine which got a lease via a 
      relay won't use the relay to renew. If matching a ciaddr fails but we have a context 
      from the physical network, continue using that to allow correct DHCPNAK generation later. */
-  if (mess->giaddr.s_addr || subnet_addr.s_addr || mess->ciaddr.s_addr)
-    {
-      struct dhcp_context *context_tmp, *context_new = NULL;
-      struct in_addr addr;
-      int force = 0;
-      
-      if (subnet_addr.s_addr)
-	{
-	  addr = subnet_addr;
-	  force = 1;
-	}
-      else if (mess->giaddr.s_addr)
-	{
-	  addr = mess->giaddr;
-	  force = 1;
-	}
+  if (mess->giaddr.s_addr || subnet_addr.s_addr || mess->ciaddr.s_addr) {
+    struct dhcp_context *context_tmp, *context_new = NULL;
+    struct in_addr addr;
+    int force = 0;
+
+    if (subnet_addr.s_addr) {
+      addr = subnet_addr;
+      force = 1;
+    } else if (mess->giaddr.s_addr) {
+      addr = mess->giaddr;
+      force = 1;
+    } else {
+      /* If ciaddr is in the hardware derived set of contexts, leave that unchanged */
+      addr = mess->ciaddr;
+      for (context_tmp = context; context_tmp;
+           context_tmp = context_tmp->current)
+        if (context_tmp->netmask.s_addr
+            && is_same_net(addr, context_tmp->start, context_tmp->netmask)
+            && is_same_net(addr, context_tmp->end, context_tmp->netmask)) {
+          context_new = context;
+          break;
+        }
+    }
+
+    if (!context_new)
+      for (context_tmp = daemon->dhcp; context_tmp;
+           context_tmp = context_tmp->next) {
+        struct in_addr netmask = context_tmp->netmask;
+
+        /* guess the netmask for relayed networks */
+        if (!(context_tmp->flags & CONTEXT_NETMASK)
+            && context_tmp->netmask.s_addr == 0) {
+          if (IN_CLASSA(ntohl(context_tmp->start.s_addr))
+              && IN_CLASSA(ntohl(context_tmp->end.s_addr)))
+            netmask.s_addr = htonl(0xff000000);
+          else if (IN_CLASSB(ntohl(context_tmp->start.s_addr))
+                   && IN_CLASSB(ntohl(context_tmp->end.s_addr)))
+            netmask.s_addr = htonl(0xffff0000);
+          else if (IN_CLASSC(ntohl(context_tmp->start.s_addr))
+                   && IN_CLASSC(ntohl(context_tmp->end.s_addr)))
+            netmask.s_addr = htonl(0xffffff00);
+        }
+
+        /* This section fills in context mainly when a client which is on a remote (relayed)
+           network renews a lease without using the relay, after dnsmasq has restarted. */
+        if (netmask.s_addr != 0 &&
+            is_same_net(addr, context_tmp->start, netmask) &&
+            is_same_net(addr, context_tmp->end, netmask)) {
+          context_tmp->netmask = netmask;
+          if (context_tmp->local.s_addr == 0)
+            context_tmp->local = fallback;
+          if (context_tmp->router.s_addr == 0)
+            context_tmp->router = mess->giaddr;
+
+          /* fill in missing broadcast addresses for relayed ranges */
+          if (!(context_tmp->flags & CONTEXT_BRDCAST)
+              && context_tmp->broadcast.s_addr == 0)
+            context_tmp->broadcast.s_addr =
+                context_tmp->start.s_addr | ~context_tmp->netmask.s_addr;
+
+          context_tmp->current = context_new;
+          context_new = context_tmp;
+        }
+      }
+
+    if (context_new || force)
+      context = context_new;
+  }
+
+  if (!context) {
+    my_syslog(MS_DHCP | LOG_WARNING,
+              _("no address range available for DHCP request %s %s"),
+              subnet_addr.s_addr ? _("with subnet selector") : _("via"),
+              subnet_addr.s_addr ? inet_ntoa(subnet_addr) : (mess->giaddr.
+                                                             s_addr ?
+                                                             inet_ntoa(mess->
+                                                                       giaddr) :
+                                                             iface_name));
+    return 0;
+  }
+
+  if (option_bool(OPT_LOG_OPTS)) {
+    struct dhcp_context *context_tmp;
+    for (context_tmp = context; context_tmp; context_tmp = context_tmp->current) {
+      strcpy(daemon->namebuff, inet_ntoa(context_tmp->start));
+      if (context_tmp->flags & (CONTEXT_STATIC | CONTEXT_PROXY))
+        my_syslog(MS_DHCP | LOG_INFO, _("%u available DHCP subnet: %s/%s"),
+                  ntohl(mess->xid), daemon->namebuff,
+                  inet_ntoa(context_tmp->netmask));
       else
-	{
-	  /* If ciaddr is in the hardware derived set of contexts, leave that unchanged */
-	  addr = mess->ciaddr;
-	  for (context_tmp = context; context_tmp; context_tmp = context_tmp->current)
-	    if (context_tmp->netmask.s_addr && 
-		is_same_net(addr, context_tmp->start, context_tmp->netmask) &&
-		is_same_net(addr, context_tmp->end, context_tmp->netmask))
-	      {
-		context_new = context;
-		break;
-	      }
-	} 
-		
-      if (!context_new)
-	for (context_tmp = daemon->dhcp; context_tmp; context_tmp = context_tmp->next)
-	  {
-	    struct in_addr netmask = context_tmp->netmask;
-
-	    /* guess the netmask for relayed networks */
-	    if (!(context_tmp->flags & CONTEXT_NETMASK) && context_tmp->netmask.s_addr == 0)
-	      {
-		if (IN_CLASSA(ntohl(context_tmp->start.s_addr)) && IN_CLASSA(ntohl(context_tmp->end.s_addr)))
-		  netmask.s_addr = htonl(0xff000000);
-		else if (IN_CLASSB(ntohl(context_tmp->start.s_addr)) && IN_CLASSB(ntohl(context_tmp->end.s_addr)))
-		  netmask.s_addr = htonl(0xffff0000);
-		else if (IN_CLASSC(ntohl(context_tmp->start.s_addr)) && IN_CLASSC(ntohl(context_tmp->end.s_addr)))
-		  netmask.s_addr = htonl(0xffffff00); 
-	      }
-	    
-	    /* This section fills in context mainly when a client which is on a remote (relayed)
-	       network renews a lease without using the relay, after dnsmasq has restarted. */
-	    if (netmask.s_addr != 0  && 
-		is_same_net(addr, context_tmp->start, netmask) &&
-		is_same_net(addr, context_tmp->end, netmask))
-	      {
-		context_tmp->netmask = netmask;
-		if (context_tmp->local.s_addr == 0)
-		  context_tmp->local = fallback;
-		if (context_tmp->router.s_addr == 0)
-		  context_tmp->router = mess->giaddr;
-	   
-		/* fill in missing broadcast addresses for relayed ranges */
-		if (!(context_tmp->flags & CONTEXT_BRDCAST) && context_tmp->broadcast.s_addr == 0 )
-		  context_tmp->broadcast.s_addr = context_tmp->start.s_addr | ~context_tmp->netmask.s_addr;
-		
-		context_tmp->current = context_new;
-		context_new = context_tmp;
-	      }
-	  }
-      
-      if (context_new || force)
-	context = context_new; 
-    }
-  
-  if (!context)
-    {
-      my_syslog(MS_DHCP | LOG_WARNING, _("no address range available for DHCP request %s %s"), 
-		subnet_addr.s_addr ? _("with subnet selector") : _("via"),
-		subnet_addr.s_addr ? inet_ntoa(subnet_addr) : (mess->giaddr.s_addr ? inet_ntoa(mess->giaddr) : iface_name));
-      return 0;
+        my_syslog(MS_DHCP | LOG_INFO, _("%u available DHCP range: %s -- %s"),
+                  ntohl(mess->xid), daemon->namebuff,
+                  inet_ntoa(context_tmp->end));
     }
+  }
 
-  if (option_bool(OPT_LOG_OPTS))
-    {
-      struct dhcp_context *context_tmp;
-      for (context_tmp = context; context_tmp; context_tmp = context_tmp->current)
-	{
-	  strcpy(daemon->namebuff, inet_ntoa(context_tmp->start));
-	  if (context_tmp->flags & (CONTEXT_STATIC | CONTEXT_PROXY))
-	    my_syslog(MS_DHCP | LOG_INFO, _("%u available DHCP subnet: %s/%s"),
-		      ntohl(mess->xid), daemon->namebuff, inet_ntoa(context_tmp->netmask));
-	  else
-	    my_syslog(MS_DHCP | LOG_INFO, _("%u available DHCP range: %s -- %s"), 
-		      ntohl(mess->xid), daemon->namebuff, inet_ntoa(context_tmp->end));
-	}
-    }
-  
   /* dhcp-match. If we have hex-and-wildcards, look for a left-anchored match.
      Otherwise assume the option is an array, and look for a matching element. 
      If no data given, existence of the option is enough. This code handles 
      rfc3925 V-I classes too. */
-  for (o = daemon->dhcp_match; o; o = o->next)
-    {
-      unsigned int len, elen, match = 0;
-      size_t offset, o2;
-
-      if (o->flags & DHOPT_RFC3925)
-	{
-	  if (!(opt = option_find(mess, sz, OPTION_VENDOR_IDENT, 5)))
-	    continue;
-	  
-	  for (offset = 0; offset < (option_len(opt) - 5u); offset += len + 5)
-	    {
-	      len = option_uint(opt, offset + 4 , 1);
-	      /* Need to take care that bad data can't run us off the end of the packet */
-	      if ((offset + len + 5 <= (unsigned)(option_len(opt))) &&
-		  (option_uint(opt, offset, 4) == (unsigned int)o->u.encap))
-		for (o2 = offset + 5; o2 < offset + len + 5; o2 += elen + 1)
-		  { 
-		    elen = option_uint(opt, o2, 1);
-		    if ((o2 + elen + 1 <= option_len(opt)) &&
-			(match = match_bytes(o, option_ptr(opt, o2 + 1), elen)))
-		      break;
-		  }
-	      if (match) 
-		break;
-	    }	  
-	}
-      else
-	{
-	  if (!(opt = option_find(mess, sz, o->opt, 1)))
-	    continue;
-	  
-	  match = match_bytes(o, option_ptr(opt, 0), option_len(opt));
-	} 
-
-      if (match)
-	{
-	  o->netid->next = netid;
-	  netid = o->netid;
-	}
+  for (o = daemon->dhcp_match; o; o = o->next) {
+    unsigned int len, elen, match = 0;
+    size_t offset, o2;
+
+    if (o->flags & DHOPT_RFC3925) {
+      if (!(opt = option_find(mess, sz, OPTION_VENDOR_IDENT, 5)))
+        continue;
+
+      for (offset = 0; offset < (option_len(opt) - 5u); offset += len + 5) {
+        len = option_uint(opt, offset + 4, 1);
+        /* Need to take care that bad data can't run us off the end of the packet */
+        if ((offset + len + 5 <= (unsigned) (option_len(opt))) &&
+            (option_uint(opt, offset, 4) == (unsigned int) o->u.encap))
+          for (o2 = offset + 5; o2 < offset + len + 5; o2 += elen + 1) {
+            elen = option_uint(opt, o2, 1);
+            if ((o2 + elen + 1 <= option_len(opt)) &&
+                (match = match_bytes(o, option_ptr(opt, o2 + 1), elen)))
+              break;
+          }
+        if (match)
+          break;
+      }
+    } else {
+      if (!(opt = option_find(mess, sz, o->opt, 1)))
+        continue;
+
+      match = match_bytes(o, option_ptr(opt, 0), option_len(opt));
     }
-	
+
+    if (match) {
+      o->netid->next = netid;
+      netid = o->netid;
+    }
+  }
+
   /* user-class options are, according to RFC3004, supposed to contain
      a set of counted strings. Here we check that this is so (by seeing
      if the counts are consistent with the overall option length) and if
@@ -420,337 +432,307 @@
      and just do the substring match. dhclient provides these broken options.
      The code, later, which sends user-class data to the lease-change script
      relies on the transformation done here.
-  */
+   */
 
-  if ((opt = option_find(mess, sz, OPTION_USER_CLASS, 1)))
-    {
-      unsigned char *ucp = option_ptr(opt, 0);
-      int tmp, j;
-      for (j = 0; j < option_len(opt); j += ucp[j] + 1);
-      if (j == option_len(opt))
-	for (j = 0; j < option_len(opt); j = tmp)
-	  {
-	    tmp = j + ucp[j] + 1;
-	    ucp[j] = 0;
-	  }
-    }
-    
-  for (vendor = daemon->dhcp_vendors; vendor; vendor = vendor->next)
-    {
-      int mopt;
-      
-      if (vendor->match_type == MATCH_VENDOR)
-	mopt = OPTION_VENDOR_ID;
-      else if (vendor->match_type == MATCH_USER)
-	mopt = OPTION_USER_CLASS; 
-      else
-	continue;
+  if ((opt = option_find(mess, sz, OPTION_USER_CLASS, 1))) {
+    unsigned char *ucp = option_ptr(opt, 0);
+    int tmp, j;
+    for (j = 0; j < option_len(opt); j += ucp[j] + 1);
+    if (j == option_len(opt))
+      for (j = 0; j < option_len(opt); j = tmp) {
+        tmp = j + ucp[j] + 1;
+        ucp[j] = 0;
+      }
+  }
+
+  for (vendor = daemon->dhcp_vendors; vendor; vendor = vendor->next) {
+    int mopt;
 
-      if ((opt = option_find(mess, sz, mopt, 1)))
-	{
-	  int i;
-	  for (i = 0; i <= (option_len(opt) - vendor->len); i++)
-	    if (memcmp(vendor->data, option_ptr(opt, i), vendor->len) == 0)
-	      {
-		vendor->netid.next = netid;
-		netid = &vendor->netid;
-		break;
-	      }
-	}
+    if (vendor->match_type == MATCH_VENDOR)
+      mopt = OPTION_VENDOR_ID;
+    else if (vendor->match_type == MATCH_USER)
+      mopt = OPTION_USER_CLASS;
+    else
+      continue;
+
+    if ((opt = option_find(mess, sz, mopt, 1))) {
+      int i;
+      for (i = 0; i <= (option_len(opt) - vendor->len); i++)
+        if (memcmp(vendor->data, option_ptr(opt, i), vendor->len) == 0) {
+          vendor->netid.next = netid;
+          netid = &vendor->netid;
+          break;
+        }
     }
+  }
 
   /* mark vendor-encapsulated options which match the client-supplied vendor class,
      save client-supplied vendor class */
-  if ((opt = option_find(mess, sz, OPTION_VENDOR_ID, 1)))
-    {
-      memcpy(daemon->dhcp_buff3, option_ptr(opt, 0), option_len(opt));
-      vendor_class_len = option_len(opt);
-    }
+  if ((opt = option_find(mess, sz, OPTION_VENDOR_ID, 1))) {
+    memcpy(daemon->dhcp_buff3, option_ptr(opt, 0), option_len(opt));
+    vendor_class_len = option_len(opt);
+  }
   match_vendor_opts(opt, daemon->dhcp_opts);
-  
-  if (option_bool(OPT_LOG_OPTS))
-    {
-      if (sanitise(opt, daemon->namebuff))
-	my_syslog(MS_DHCP | LOG_INFO, _("%u vendor class: %s"), ntohl(mess->xid), daemon->namebuff);
-      if (sanitise(option_find(mess, sz, OPTION_USER_CLASS, 1), daemon->namebuff))
-	my_syslog(MS_DHCP | LOG_INFO, _("%u user class: %s"), ntohl(mess->xid), daemon->namebuff);
-    }
+
+  if (option_bool(OPT_LOG_OPTS)) {
+    if (sanitise(opt, daemon->namebuff))
+      my_syslog(MS_DHCP | LOG_INFO, _("%u vendor class: %s"), ntohl(mess->xid),
+                daemon->namebuff);
+    if (sanitise(option_find(mess, sz, OPTION_USER_CLASS, 1), daemon->namebuff))
+      my_syslog(MS_DHCP | LOG_INFO, _("%u user class: %s"), ntohl(mess->xid),
+                daemon->namebuff);
+  }
 
   mess->op = BOOTREPLY;
-  
-  config = find_config(daemon->dhcp_conf, context, clid, clid_len, 
-		       mess->chaddr, mess->hlen, mess->htype, NULL);
+
+  config = find_config(daemon->dhcp_conf, context, clid, clid_len,
+                       mess->chaddr, mess->hlen, mess->htype, NULL);
 
   /* set "known" tag for known hosts */
-  if (config)
-    {
-      known_id.net = "known";
-      known_id.next = netid;
-      netid = &known_id;
-    }
-  else if (find_config(daemon->dhcp_conf, NULL, clid, clid_len, 
-		       mess->chaddr, mess->hlen, mess->htype, NULL))
-    {
-      known_id.net = "known-othernet";
-      known_id.next = netid;
-      netid = &known_id;
-    }
-  
-  if (mess_type == 0 && !pxe)
-    {
-      /* BOOTP request */
-      struct dhcp_netid id, bootp_id;
-      struct in_addr *logaddr = NULL;
-
-      /* must have a MAC addr for bootp */
-      if (mess->htype == 0 || mess->hlen == 0 || (context->flags & CONTEXT_PROXY))
-	return 0;
-      
-      if (have_config(config, CONFIG_DISABLE))
-	message = _("disabled");
-
-      end = mess->options + 64; /* BOOTP vend area is only 64 bytes */
-            
-      if (have_config(config, CONFIG_NAME))
-	{
-	  hostname = config->hostname;
-	  domain = config->domain;
-	}
-
-      if (config)
-	{
-	  struct dhcp_netid_list *list;
-
-	  for (list = config->netid; list; list = list->next)
-	    {
-	      list->list->next = netid;
-	      netid = list->list;
-	    }
-	}
-
-      /* Match incoming filename field as a netid. */
-      if (mess->file[0])
-	{
-	  memcpy(daemon->dhcp_buff2, mess->file, sizeof(mess->file));
-	  daemon->dhcp_buff2[sizeof(mess->file) + 1] = 0; /* ensure zero term. */
-	  id.net = (char *)daemon->dhcp_buff2;
-	  id.next = netid;
-	  netid = &id;
-	}
-
-      /* Add "bootp" as a tag to allow different options, address ranges etc
-	 for BOOTP clients */
-      bootp_id.net = "bootp";
-      bootp_id.next = netid;
-      netid = &bootp_id;
-      
-      tagif_netid = run_tag_if(netid);
-
-      for (id_list = daemon->dhcp_ignore; id_list; id_list = id_list->next)
-	if (match_netid(id_list->list, tagif_netid, 0))
-	  message = _("ignored");
-      
-      if (!message)
-	{
-	  int nailed = 0;
-
-	  if (have_config(config, CONFIG_ADDR))
-	    {
-	      nailed = 1;
-	      logaddr = &config->addr;
-	      mess->yiaddr = config->addr;
-	      if ((lease = lease_find_by_addr(config->addr)) &&
-		  (lease->hwaddr_len != mess->hlen ||
-		   lease->hwaddr_type != mess->htype ||
-		   memcmp(lease->hwaddr, mess->chaddr, lease->hwaddr_len) != 0))
-		message = _("address in use");
-	    }
-	  else
-	    {
-	      if (!(lease = lease_find_by_client(mess->chaddr, mess->hlen, mess->htype, NULL, 0)) ||
-		  !address_available(context, lease->addr, tagif_netid))
-		{
-		   if (lease)
-		     {
-		       /* lease exists, wrong network. */
-		       lease_prune(lease, now);
-		       lease = NULL;
-		     }
-		   if (!address_allocate(context, &mess->yiaddr, mess->chaddr, mess->hlen, tagif_netid, now, loopback))
-		     message = _("no address available");
-		}
-	      else
-		mess->yiaddr = lease->addr;
-	    }
-	  
-	  if (!message && !(context = narrow_context(context, mess->yiaddr, netid)))
-	    message = _("wrong network");
-	  else if (context->netid.net)
-	    {
-	      context->netid.next = netid;
-	      tagif_netid = run_tag_if(&context->netid);
-	    }
-
-	  log_tags(tagif_netid, ntohl(mess->xid));
-	    
-	  if (!message && !nailed)
-	    {
-	      for (id_list = daemon->bootp_dynamic; id_list; id_list = id_list->next)
-		if ((!id_list->list) || match_netid(id_list->list, tagif_netid, 0))
-		  break;
-	      if (!id_list)
-		message = _("no address configured");
-	    }
-
-	  if (!message && 
-	      !lease && 
-	      (!(lease = lease4_allocate(mess->yiaddr))))
-	    message = _("no leases left");
-	  
-	  if (!message)
-	    {
-	      logaddr = &mess->yiaddr;
-		
-	      lease_set_hwaddr(lease, mess->chaddr, NULL, mess->hlen, mess->htype, 0, now, 1);
-	      if (hostname)
-		lease_set_hostname(lease, hostname, 1, get_domain(lease->addr), domain); 
-	      /* infinite lease unless nailed in dhcp-host line. */
-	      lease_set_expires(lease,  
-				have_config(config, CONFIG_TIME) ? config->lease_time : 0xffffffff, 
-				now); 
-	      lease_set_interface(lease, int_index, now);
-	      
-	      clear_packet(mess, end);
-	      do_options(context, mess, end, NULL, hostname, get_domain(mess->yiaddr), 
-			 netid, subnet_addr, 0, 0, -1, NULL, vendor_class_len, now, 0xffffffff, 0);
-	    }
-	}
-      
-      log_packet("BOOTP", logaddr, mess->chaddr, mess->hlen, iface_name, NULL, message, mess->xid);
-      
-      return message ? 0 : dhcp_packet_size(mess, agent_id, real_end);
-    }
-      
-  if ((opt = option_find(mess, sz, OPTION_CLIENT_FQDN, 3)))
-    {
-      /* http://tools.ietf.org/wg/dhc/draft-ietf-dhc-fqdn-option/draft-ietf-dhc-fqdn-option-10.txt */
-      int len = option_len(opt);
-      char *pq = daemon->dhcp_buff;
-      unsigned char *pp, *op = option_ptr(opt, 0);
-      
-      fqdn_flags = *op;
-      len -= 3;
-      op += 3;
-      pp = op;
-      
-      /* NB, the following always sets at least one bit */
-      if (option_bool(OPT_FQDN_UPDATE))
-	{
-	  if (fqdn_flags & 0x01)
-	    {
-	      fqdn_flags |= 0x02; /* set O */
-	      fqdn_flags &= ~0x01; /* clear S */
-	    }
-	  fqdn_flags |= 0x08; /* set N */
-	}
-      else 
-	{
-	  if (!(fqdn_flags & 0x01))
-	    fqdn_flags |= 0x03; /* set S and O */
-	  fqdn_flags &= ~0x08; /* clear N */
-	}
-      
-      if (fqdn_flags & 0x04)
-	while (*op != 0 && ((op + (*op)) - pp) < len)
-	  {
-	    memcpy(pq, op+1, *op);
-	    pq += *op;
-	    op += (*op)+1;
-	    *(pq++) = '.';
-	  }
-      else
-	{
-	  memcpy(pq, op, len);
-	  if (len > 0 && op[len-1] == 0)
-	    borken_opt = 1;
-	  pq += len + 1;
-	}
-      
-      if (pq != daemon->dhcp_buff)
-	pq--;
-      
-      *pq = 0;
-      
-      if (legal_hostname(daemon->dhcp_buff))
-	offer_hostname = client_hostname = daemon->dhcp_buff;
-    }
-  else if ((opt = option_find(mess, sz, OPTION_HOSTNAME, 1)))
-    {
-      int len = option_len(opt);
-      memcpy(daemon->dhcp_buff, option_ptr(opt, 0), len);
-      /* Microsoft clients are broken, and need zero-terminated strings
-	 in options. We detect this state here, and do the same in
-	 any options we send */
-      if (len > 0 && daemon->dhcp_buff[len-1] == 0)
-	borken_opt = 1;
-      else
-	daemon->dhcp_buff[len] = 0;
-      if (legal_hostname(daemon->dhcp_buff))
-	client_hostname = daemon->dhcp_buff;
-    }
+  if (config) {
+    known_id.net = "known";
+    known_id.next = netid;
+    netid = &known_id;
+  } else if (find_config(daemon->dhcp_conf, NULL, clid, clid_len,
+                         mess->chaddr, mess->hlen, mess->htype, NULL)) {
+    known_id.net = "known-othernet";
+    known_id.next = netid;
+    netid = &known_id;
+  }
+
+  if (mess_type == 0 && !pxe) {
+    /* BOOTP request */
+    struct dhcp_netid id, bootp_id;
+    struct in_addr *logaddr = NULL;
 
-  if (client_hostname && option_bool(OPT_LOG_OPTS))
-    my_syslog(MS_DHCP | LOG_INFO, _("%u client provides name: %s"), ntohl(mess->xid), client_hostname);
-  
-  if (have_config(config, CONFIG_NAME))
-    {
+    /* must have a MAC addr for bootp */
+    if (mess->htype == 0 || mess->hlen == 0 || (context->flags & CONTEXT_PROXY))
+      return 0;
+
+    if (have_config(config, CONFIG_DISABLE))
+      message = _("disabled");
+
+    end = mess->options + 64;   /* BOOTP vend area is only 64 bytes */
+
+    if (have_config(config, CONFIG_NAME)) {
       hostname = config->hostname;
       domain = config->domain;
-      hostname_auth = 1;
-      /* be careful not to send an OFFER with a hostname not matching the DISCOVER. */
-      if (fqdn_flags != 0 || !client_hostname || hostname_isequal(hostname, client_hostname))
-        offer_hostname = hostname;
-    }
-  else if (client_hostname)
-    {
-      domain = strip_hostname(client_hostname);
-      
-      if (strlen(client_hostname) != 0)
-	{
-	  hostname = client_hostname;
-	  if (!config)
-	    {
-	      /* Search again now we have a hostname. 
-		 Only accept configs without CLID and HWADDR here, (they won't match)
-		 to avoid impersonation by name. */
-	      struct dhcp_config *new = find_config(daemon->dhcp_conf, context, NULL, 0,
-						    mess->chaddr, mess->hlen, 
-						    mess->htype, hostname);
-	      if (new && !have_config(new, CONFIG_CLID) && !new->hwaddr)
-		{
-		  config = new;
-		  /* set "known" tag for known hosts */
-		  known_id.net = "known";
-		  known_id.next = netid;
-		  netid = &known_id;
-		}
-	    }
-	}
-    }
-  
-  if (config)
-    {
+    }
+
+    if (config) {
       struct dhcp_netid_list *list;
-      
-      for (list = config->netid; list; list = list->next)
-	{
-	  list->list->next = netid;
-	  netid = list->list;
-	}
+
+      for (list = config->netid; list; list = list->next) {
+        list->list->next = netid;
+        netid = list->list;
+      }
     }
-  
+
+    /* Match incoming filename field as a netid. */
+    if (mess->file[0]) {
+      memcpy(daemon->dhcp_buff2, mess->file, sizeof(mess->file));
+      daemon->dhcp_buff2[sizeof(mess->file) + 1] = 0;   /* ensure zero term. */
+      id.net = (char *) daemon->dhcp_buff2;
+      id.next = netid;
+      netid = &id;
+    }
+
+    /* Add "bootp" as a tag to allow different options, address ranges etc
+       for BOOTP clients */
+    bootp_id.net = "bootp";
+    bootp_id.next = netid;
+    netid = &bootp_id;
+
+    tagif_netid = run_tag_if(netid);
+
+    for (id_list = daemon->dhcp_ignore; id_list; id_list = id_list->next)
+      if (match_netid(id_list->list, tagif_netid, 0))
+        message = _("ignored");
+
+    if (!message) {
+      int nailed = 0;
+
+      if (have_config(config, CONFIG_ADDR)) {
+        nailed = 1;
+        logaddr = &config->addr;
+        mess->yiaddr = config->addr;
+        if ((lease = lease_find_by_addr(config->addr)) &&
+            (lease->hwaddr_len != mess->hlen ||
+             lease->hwaddr_type != mess->htype ||
+             memcmp(lease->hwaddr, mess->chaddr, lease->hwaddr_len) != 0))
+          message = _("address in use");
+      } else {
+        if (!
+            (lease =
+             lease_find_by_client(mess->chaddr, mess->hlen, mess->htype, NULL,
+                                  0))
+            || !address_available(context, lease->addr, tagif_netid)) {
+          if (lease) {
+            /* lease exists, wrong network. */
+            lease_prune(lease, now);
+            lease = NULL;
+          }
+          if (!address_allocate
+              (context, &mess->yiaddr, mess->chaddr, mess->hlen, tagif_netid,
+               now, loopback))
+            message = _("no address available");
+        } else
+          mess->yiaddr = lease->addr;
+      }
+
+      if (!message && !(context = narrow_context(context, mess->yiaddr, netid)))
+        message = _("wrong network");
+      else if (context->netid.net) {
+        context->netid.next = netid;
+        tagif_netid = run_tag_if(&context->netid);
+      }
+
+      log_tags(tagif_netid, ntohl(mess->xid));
+
+      if (!message && !nailed) {
+        for (id_list = daemon->bootp_dynamic; id_list; id_list = id_list->next)
+          if ((!id_list->list) || match_netid(id_list->list, tagif_netid, 0))
+            break;
+        if (!id_list)
+          message = _("no address configured");
+      }
+
+      if (!message && !lease && (!(lease = lease4_allocate(mess->yiaddr))))
+        message = _("no leases left");
+
+      if (!message) {
+        logaddr = &mess->yiaddr;
+
+        lease_set_hwaddr(lease, mess->chaddr, NULL, mess->hlen, mess->htype, 0,
+                         now, 1);
+        if (hostname)
+          lease_set_hostname(lease, hostname, 1, get_domain(lease->addr),
+                             domain);
+        /* infinite lease unless nailed in dhcp-host line. */
+        lease_set_expires(lease,
+                          have_config(config,
+                                      CONFIG_TIME) ? config->
+                          lease_time : 0xffffffff, now);
+        lease_set_interface(lease, int_index, now);
+
+        clear_packet(mess, end);
+        do_options(context, mess, end, NULL, hostname, get_domain(mess->yiaddr),
+                   netid, subnet_addr, 0, 0, -1, NULL, vendor_class_len, now,
+                   0xffffffff, 0);
+      }
+    }
+
+    log_packet("BOOTP", logaddr, mess->chaddr, mess->hlen, iface_name, NULL,
+               message, mess->xid);
+
+    return message ? 0 : dhcp_packet_size(mess, agent_id, real_end);
+  }
+
+  if ((opt = option_find(mess, sz, OPTION_CLIENT_FQDN, 3))) {
+    /* http://tools.ietf.org/wg/dhc/draft-ietf-dhc-fqdn-option/draft-ietf-dhc-fqdn-option-10.txt */
+    int len = option_len(opt);
+    char *pq = daemon->dhcp_buff;
+    unsigned char *pp, *op = option_ptr(opt, 0);
+
+    fqdn_flags = *op;
+    len -= 3;
+    op += 3;
+    pp = op;
+
+    /* NB, the following always sets at least one bit */
+    if (option_bool(OPT_FQDN_UPDATE)) {
+      if (fqdn_flags & 0x01) {
+        fqdn_flags |= 0x02;     /* set O */
+        fqdn_flags &= ~0x01;    /* clear S */
+      }
+      fqdn_flags |= 0x08;       /* set N */
+    } else {
+      if (!(fqdn_flags & 0x01))
+        fqdn_flags |= 0x03;     /* set S and O */
+      fqdn_flags &= ~0x08;      /* clear N */
+    }
+
+    if (fqdn_flags & 0x04)
+      while (*op != 0 && ((op + (*op)) - pp) < len) {
+        memcpy(pq, op + 1, *op);
+        pq += *op;
+        op += (*op) + 1;
+        *(pq++) = '.';
+    } else {
+      memcpy(pq, op, len);
+      if (len > 0 && op[len - 1] == 0)
+        borken_opt = 1;
+      pq += len + 1;
+    }
+
+    if (pq != daemon->dhcp_buff)
+      pq--;
+
+    *pq = 0;
+
+    if (legal_hostname(daemon->dhcp_buff))
+      offer_hostname = client_hostname = daemon->dhcp_buff;
+  } else if ((opt = option_find(mess, sz, OPTION_HOSTNAME, 1))) {
+    int len = option_len(opt);
+    memcpy(daemon->dhcp_buff, option_ptr(opt, 0), len);
+    /* Microsoft clients are broken, and need zero-terminated strings
+       in options. We detect this state here, and do the same in
+       any options we send */
+    if (len > 0 && daemon->dhcp_buff[len - 1] == 0)
+      borken_opt = 1;
+    else
+      daemon->dhcp_buff[len] = 0;
+    if (legal_hostname(daemon->dhcp_buff))
+      client_hostname = daemon->dhcp_buff;
+  }
+
+  if (client_hostname && option_bool(OPT_LOG_OPTS))
+    my_syslog(MS_DHCP | LOG_INFO, _("%u client provides name: %s"),
+              ntohl(mess->xid), client_hostname);
+
+  if (have_config(config, CONFIG_NAME)) {
+    hostname = config->hostname;
+    domain = config->domain;
+    hostname_auth = 1;
+    /* be careful not to send an OFFER with a hostname not matching the DISCOVER. */
+    if (fqdn_flags != 0 || !client_hostname
+        || hostname_isequal(hostname, client_hostname))
+      offer_hostname = hostname;
+  } else if (client_hostname) {
+    domain = strip_hostname(client_hostname);
+
+    if (strlen(client_hostname) != 0) {
+      hostname = client_hostname;
+      if (!config) {
+        /* Search again now we have a hostname.
+           Only accept configs without CLID and HWADDR here, (they won't match)
+           to avoid impersonation by name. */
+        struct dhcp_config *new =
+            find_config(daemon->dhcp_conf, context, NULL, 0,
+                        mess->chaddr, mess->hlen,
+                        mess->htype, hostname);
+        if (new && !have_config(new, CONFIG_CLID) && !new->hwaddr) {
+          config = new;
+          /* set "known" tag for known hosts */
+          known_id.net = "known";
+          known_id.next = netid;
+          netid = &known_id;
+        }
+      }
+    }
+  }
+
+  if (config) {
+    struct dhcp_netid_list *list;
+
+    for (list = config->netid; list; list = list->next) {
+      list->list->next = netid;
+      netid = list->list;
+    }
+  }
+
   tagif_netid = run_tag_if(netid);
-  
+
   /* if all the netids in the ignore list are present, ignore this client */
   for (id_list = daemon->dhcp_ignore; id_list; id_list = id_list->next)
     if (match_netid(id_list->list, tagif_netid, 0))
@@ -759,738 +741,740 @@
   /* If configured, we can override the server-id to be the address of the relay, 
      so that all traffic goes via the relay and can pick up agent-id info. This can be
      configured for all relays, or by address. */
-  if (daemon->override && mess->giaddr.s_addr != 0 && override.s_addr == 0)
-    {
-      if (!daemon->override_relays)
-	override = mess->giaddr;
-      else
-	{
-	  struct addr_list *l;
-	  for (l = daemon->override_relays; l; l = l->next)
-	    if (l->addr.s_addr == mess->giaddr.s_addr)
-	      break;
-	  if (l)
-	    override = mess->giaddr;
-	}
+  if (daemon->override && mess->giaddr.s_addr != 0 && override.s_addr == 0) {
+    if (!daemon->override_relays)
+      override = mess->giaddr;
+    else {
+      struct addr_list *l;
+      for (l = daemon->override_relays; l; l = l->next)
+        if (l->addr.s_addr == mess->giaddr.s_addr)
+          break;
+      if (l)
+        override = mess->giaddr;
     }
+  }
 
   /* Can have setting to ignore the client ID for a particular MAC address or hostname */
   if (have_config(config, CONFIG_NOCLID))
     clid = NULL;
-          
+
   /* Check if client is PXE client. */
-  if (daemon->enable_pxe && 
-      (opt = option_find(mess, sz, OPTION_VENDOR_ID, 9)) && 
-      strncmp(option_ptr(opt, 0), "PXEClient", 9) == 0)
-    {
-      if ((opt = option_find(mess, sz, OPTION_PXE_UUID, 17)))
-	{
-	  memcpy(pxe_uuid, option_ptr(opt, 0), 17);
-	  uuid = pxe_uuid;
-	}
-
-      /* Check if this is really a PXE bootserver request, and handle specially if so. */
-      if ((mess_type == DHCPREQUEST || mess_type == DHCPINFORM) &&
-	  (opt = option_find(mess, sz, OPTION_VENDOR_CLASS_OPT, 1)) &&
-	  (opt = option_find1(option_ptr(opt, 0), option_ptr(opt, option_len(opt)), SUBOPT_PXE_BOOT_ITEM, 4)))
-	{
-	  struct pxe_service *service;
-	  int type = option_uint(opt, 0, 2);
-	  int layer = option_uint(opt, 2, 2);
-	  unsigned char save71[4];
-	  struct dhcp_opt opt71;
-
-	  if (ignore)
-	    return 0;
-
-	  if (layer & 0x8000)
-	    {
-	      my_syslog(MS_DHCP | LOG_ERR, _("PXE BIS not supported"));
-	      return 0;
-	    }
-
-	  memcpy(save71, option_ptr(opt, 0), 4);
-	  
-	  for (service = daemon->pxe_services; service; service = service->next)
-	    if (service->type == type)
-	      break;
-	  
-	  for (; context; context = context->current)
-	    if (match_netid(context->filter, tagif_netid, 1) &&
-		is_same_net(mess->ciaddr, context->start, context->netmask))
-	      break;
-	  
-	  if (!service || !service->basename || !context)
-	    return 0;
-	  	  
-	  clear_packet(mess, end);
-	  
-	  mess->yiaddr = mess->ciaddr;
-	  mess->ciaddr.s_addr = 0;
-	  if (service->sname)
-	    mess->siaddr = a_record_from_hosts(service->sname, now);
-	  else if (service->server.s_addr != 0)
-	    mess->siaddr = service->server; 
-	  else
-	    mess->siaddr = context->local; 
-	  
-	  if (strchr(service->basename, '.'))
-	    snprintf((char *)mess->file, sizeof(mess->file),
-		"%s", service->basename);
-	  else
-	    snprintf((char *)mess->file, sizeof(mess->file),
-		"%s.%d", service->basename, layer);
-	  
-	  option_put(mess, end, OPTION_MESSAGE_TYPE, 1, DHCPACK);
-	  option_put(mess, end, OPTION_SERVER_IDENTIFIER, INADDRSZ, htonl(context->local.s_addr));
-	  pxe_misc(mess, end, uuid);
-	  
-	  prune_vendor_opts(tagif_netid);
-	  opt71.val = save71;
-	  opt71.opt = SUBOPT_PXE_BOOT_ITEM;
-	  opt71.len = 4;
-	  opt71.flags = DHOPT_VENDOR_MATCH;
-	  opt71.netid = NULL;
-	  opt71.next = daemon->dhcp_opts;
-	  do_encap_opts(&opt71, OPTION_VENDOR_CLASS_OPT, DHOPT_VENDOR_MATCH, mess, end, 0);
-	  
-	  log_packet("PXE", &mess->yiaddr, emac, emac_len, iface_name, (char *)mess->file, NULL, mess->xid);
-	  log_tags(tagif_netid, ntohl(mess->xid));
-	  return dhcp_packet_size(mess, agent_id, real_end);	  
-	}
-      
-      if ((opt = option_find(mess, sz, OPTION_ARCH, 2)))
-	{
-	  pxearch = option_uint(opt, 0, 2);
-
-	  /* proxy DHCP here. */
-	  if ((mess_type == DHCPDISCOVER || (pxe && mess_type == DHCPREQUEST)))
-	    {
-	      struct dhcp_context *tmp;
-	      int workaround = 0;
-	      
-	      for (tmp = context; tmp; tmp = tmp->current)
-		if ((tmp->flags & CONTEXT_PROXY) &&
-		    match_netid(tmp->filter, tagif_netid, 1))
-		  break;
-	      
-	      if (tmp)
-		{
-		  struct dhcp_boot *boot;
-		  int redirect4011 = 0;
-
-		  if (tmp->netid.net)
-		    {
-		      tmp->netid.next = netid;
-		      tagif_netid = run_tag_if(&tmp->netid);
-		    }
-		  
-		  boot = find_boot(tagif_netid);
-		  
-		  mess->yiaddr.s_addr = 0;
-		  if  (mess_type == DHCPDISCOVER || mess->ciaddr.s_addr == 0)
-		    {
-		      mess->ciaddr.s_addr = 0;
-		      mess->flags |= htons(0x8000); /* broadcast */
-		    }
-		  
-		  clear_packet(mess, end);
-		  
-		  /* Redirect EFI clients to port 4011 */
-		  if (pxearch >= 6)
-		    {
-		      redirect4011 = 1;
-		      mess->siaddr = tmp->local;
-		    }
-		  
-		  /* Returns true if only one matching service is available. On port 4011, 
-		     it also inserts the boot file and server name. */
-		  workaround = pxe_uefi_workaround(pxearch, tagif_netid, mess, tmp->local, now, pxe);
-		  
-		  if (!workaround && boot)
-		    {
-		      /* Provide the bootfile here, for gPXE, and in case we have no menu items
-			 and set discovery_control = 8 */
-		      if (boot->next_server.s_addr) 
-			mess->siaddr = boot->next_server;
-		      else if (boot->tftp_sname) 
-			mess->siaddr = a_record_from_hosts(boot->tftp_sname, now);
-		      
-		      if (boot->file)
-			strncpy((char *)mess->file, boot->file, sizeof(mess->file)-1);
-		    }
-		  
-		  option_put(mess, end, OPTION_MESSAGE_TYPE, 1, 
-			     mess_type == DHCPDISCOVER ? DHCPOFFER : DHCPACK);
-		  option_put(mess, end, OPTION_SERVER_IDENTIFIER, INADDRSZ, htonl(tmp->local.s_addr));
-		  pxe_misc(mess, end, uuid);
-		  prune_vendor_opts(tagif_netid);
-		  if ((pxe && !workaround) || !redirect4011)
-		    do_encap_opts(pxe_opts(pxearch, tagif_netid, tmp->local, now), OPTION_VENDOR_CLASS_OPT, DHOPT_VENDOR_MATCH, mess, end, 0);
-	    
-		  log_packet("PXE", NULL, emac, emac_len, iface_name, ignore ? "proxy-ignored" : "proxy", NULL, mess->xid);
-		  log_tags(tagif_netid, ntohl(mess->xid));
-		  if (!ignore)
-		    apply_delay(mess->xid, recvtime, tagif_netid);
-		  return ignore ? 0 : dhcp_packet_size(mess, agent_id, real_end);	  
-		}
-	    }
-	}
+  if (daemon->enable_pxe &&
+      (opt = option_find(mess, sz, OPTION_VENDOR_ID, 9)) &&
+      strncmp(option_ptr(opt, 0), "PXEClient", 9) == 0) {
+    if ((opt = option_find(mess, sz, OPTION_PXE_UUID, 17))) {
+      memcpy(pxe_uuid, option_ptr(opt, 0), 17);
+      uuid = pxe_uuid;
+    }
+
+    /* Check if this is really a PXE bootserver request, and handle specially if so. */
+    if ((mess_type == DHCPREQUEST || mess_type == DHCPINFORM) &&
+        (opt = option_find(mess, sz, OPTION_VENDOR_CLASS_OPT, 1)) &&
+        (opt =
+         option_find1(option_ptr(opt, 0), option_ptr(opt, option_len(opt)),
+                      SUBOPT_PXE_BOOT_ITEM, 4))) {
+      struct pxe_service *service;
+      int type = option_uint(opt, 0, 2);
+      int layer = option_uint(opt, 2, 2);
+      unsigned char save71[4];
+      struct dhcp_opt opt71;
+
+      if (ignore)
+        return 0;
+
+      if (layer & 0x8000) {
+        my_syslog(MS_DHCP | LOG_ERR, _("PXE BIS not supported"));
+        return 0;
+      }
+
+      memcpy(save71, option_ptr(opt, 0), 4);
+
+      for (service = daemon->pxe_services; service; service = service->next)
+        if (service->type == type)
+          break;
+
+      for (; context; context = context->current)
+        if (match_netid(context->filter, tagif_netid, 1) &&
+            is_same_net(mess->ciaddr, context->start, context->netmask))
+          break;
+
+      if (!service || !service->basename || !context)
+        return 0;
+
+      clear_packet(mess, end);
+
+      mess->yiaddr = mess->ciaddr;
+      mess->ciaddr.s_addr = 0;
+      if (service->sname)
+        mess->siaddr = a_record_from_hosts(service->sname, now);
+      else if (service->server.s_addr != 0)
+        mess->siaddr = service->server;
+      else
+        mess->siaddr = context->local;
+
+      if (strchr(service->basename, '.'))
+        snprintf((char *) mess->file, sizeof(mess->file),
+                 "%s", service->basename);
+      else
+        snprintf((char *) mess->file, sizeof(mess->file),
+                 "%s.%d", service->basename, layer);
+
+      option_put(mess, end, OPTION_MESSAGE_TYPE, 1, DHCPACK);
+      option_put(mess, end, OPTION_SERVER_IDENTIFIER, INADDRSZ,
+                 htonl(context->local.s_addr));
+      pxe_misc(mess, end, uuid);
+
+      prune_vendor_opts(tagif_netid);
+      opt71.val = save71;
+      opt71.opt = SUBOPT_PXE_BOOT_ITEM;
+      opt71.len = 4;
+      opt71.flags = DHOPT_VENDOR_MATCH;
+      opt71.netid = NULL;
+      opt71.next = daemon->dhcp_opts;
+      do_encap_opts(&opt71, OPTION_VENDOR_CLASS_OPT, DHOPT_VENDOR_MATCH, mess,
+                    end, 0);
+
+      log_packet("PXE", &mess->yiaddr, emac, emac_len, iface_name,
+                 (char *) mess->file, NULL, mess->xid);
+      log_tags(tagif_netid, ntohl(mess->xid));
+      return dhcp_packet_size(mess, agent_id, real_end);
     }
 
+    if ((opt = option_find(mess, sz, OPTION_ARCH, 2))) {
+      pxearch = option_uint(opt, 0, 2);
+
+      /* proxy DHCP here. */
+      if ((mess_type == DHCPDISCOVER || (pxe && mess_type == DHCPREQUEST))) {
+        struct dhcp_context *tmp;
+        int workaround = 0;
+
+        for (tmp = context; tmp; tmp = tmp->current)
+          if ((tmp->flags & CONTEXT_PROXY) &&
+              match_netid(tmp->filter, tagif_netid, 1))
+            break;
+
+        if (tmp) {
+          struct dhcp_boot *boot;
+          int redirect4011 = 0;
+
+          if (tmp->netid.net) {
+            tmp->netid.next = netid;
+            tagif_netid = run_tag_if(&tmp->netid);
+          }
+
+          boot = find_boot(tagif_netid);
+
+          mess->yiaddr.s_addr = 0;
+          if (mess_type == DHCPDISCOVER || mess->ciaddr.s_addr == 0) {
+            mess->ciaddr.s_addr = 0;
+            mess->flags |= htons(0x8000);       /* broadcast */
+          }
+
+          clear_packet(mess, end);
+
+          /* Redirect EFI clients to port 4011 */
+          if (pxearch >= 6) {
+            redirect4011 = 1;
+            mess->siaddr = tmp->local;
+          }
+
+          /* Returns true if only one matching service is available. On port 4011,
+             it also inserts the boot file and server name. */
+          workaround =
+              pxe_uefi_workaround(pxearch, tagif_netid, mess, tmp->local, now,
+                                  pxe);
+
+          if (!workaround && boot) {
+            /* Provide the bootfile here, for gPXE, and in case we have no menu items
+               and set discovery_control = 8 */
+            if (boot->next_server.s_addr)
+              mess->siaddr = boot->next_server;
+            else if (boot->tftp_sname)
+              mess->siaddr = a_record_from_hosts(boot->tftp_sname, now);
+
+            if (boot->file)
+              strncpy((char *) mess->file, boot->file, sizeof(mess->file) - 1);
+          }
+
+          option_put(mess, end, OPTION_MESSAGE_TYPE, 1,
+                     mess_type == DHCPDISCOVER ? DHCPOFFER : DHCPACK);
+          option_put(mess, end, OPTION_SERVER_IDENTIFIER, INADDRSZ,
+                     htonl(tmp->local.s_addr));
+          pxe_misc(mess, end, uuid);
+          prune_vendor_opts(tagif_netid);
+          if ((pxe && !workaround) || !redirect4011)
+            do_encap_opts(pxe_opts(pxearch, tagif_netid, tmp->local, now),
+                          OPTION_VENDOR_CLASS_OPT, DHOPT_VENDOR_MATCH, mess,
+                          end, 0);
+
+          log_packet("PXE", NULL, emac, emac_len, iface_name,
+                     ignore ? "proxy-ignored" : "proxy", NULL, mess->xid);
+          log_tags(tagif_netid, ntohl(mess->xid));
+          if (!ignore)
+            apply_delay(mess->xid, recvtime, tagif_netid);
+          return ignore ? 0 : dhcp_packet_size(mess, agent_id, real_end);
+        }
+      }
+    }
+  }
+
   /* if we're just a proxy server, go no further */
   if ((context->flags & CONTEXT_PROXY) || pxe)
     return 0;
-  
-  if ((opt = option_find(mess, sz, OPTION_REQUESTED_OPTIONS, 0)))
-    {
-      req_options = (unsigned char *)daemon->dhcp_buff2;
-      memcpy(req_options, option_ptr(opt, 0), option_len(opt));
-      req_options[option_len(opt)] = OPTION_END;
-    }
-  
-  switch (mess_type)
-    {
-    case DHCPDECLINE:
-      if (!(opt = option_find(mess, sz, OPTION_SERVER_IDENTIFIER, INADDRSZ)) ||
-	  option_addr(opt).s_addr != server_id(context, override, fallback).s_addr)
-	return 0;
-      
-      /* sanitise any message. Paranoid? Moi? */
-      sanitise(option_find(mess, sz, OPTION_MESSAGE, 1), daemon->dhcp_buff);
-      
-      if (!(opt = option_find(mess, sz, OPTION_REQUESTED_IP, INADDRSZ)))
-	return 0;
-      
-      log_packet("DHCPDECLINE", option_ptr(opt, 0), emac, emac_len, iface_name, NULL, daemon->dhcp_buff, mess->xid);
-      
-      if (lease && lease->addr.s_addr == option_addr(opt).s_addr)
-	lease_prune(lease, now);
-      
-      if (have_config(config, CONFIG_ADDR) && 
-	  config->addr.s_addr == option_addr(opt).s_addr)
-	{
-	  prettyprint_time(daemon->dhcp_buff, DECLINE_BACKOFF);
-	  my_syslog(MS_DHCP | LOG_WARNING, _("disabling DHCP static address %s for %s"), 
-		    inet_ntoa(config->addr), daemon->dhcp_buff);
-	  config->flags |= CONFIG_DECLINED;
-	  config->decline_time = now;
-	}
-      else
-	/* make sure this host gets a different address next time. */
-	for (; context; context = context->current)
-	  context->addr_epoch++;
-      
+
+  if ((opt = option_find(mess, sz, OPTION_REQUESTED_OPTIONS, 0))) {
+    req_options = (unsigned char *) daemon->dhcp_buff2;
+    memcpy(req_options, option_ptr(opt, 0), option_len(opt));
+    req_options[option_len(opt)] = OPTION_END;
+  }
+
+  switch (mess_type) {
+  case DHCPDECLINE:
+    if (!(opt = option_find(mess, sz, OPTION_SERVER_IDENTIFIER, INADDRSZ)) ||
+        option_addr(opt).s_addr != server_id(context, override,
+                                             fallback).s_addr)
       return 0;
 
-    case DHCPRELEASE:
-      if (!(context = narrow_context(context, mess->ciaddr, tagif_netid)) ||
-	  !(opt = option_find(mess, sz, OPTION_SERVER_IDENTIFIER, INADDRSZ)) ||
-	  option_addr(opt).s_addr != server_id(context, override, fallback).s_addr)
-	return 0;
-      
-      if (lease && lease->addr.s_addr == mess->ciaddr.s_addr)
-	lease_prune(lease, now);
-      else
-	message = _("unknown lease");
+    /* sanitise any message. Paranoid? Moi? */
+    sanitise(option_find(mess, sz, OPTION_MESSAGE, 1), daemon->dhcp_buff);
 
-      log_packet("DHCPRELEASE", &mess->ciaddr, emac, emac_len, iface_name, NULL, message, mess->xid);
-	
+    if (!(opt = option_find(mess, sz, OPTION_REQUESTED_IP, INADDRSZ)))
       return 0;
-      
-    case DHCPDISCOVER:
-      if (ignore || have_config(config, CONFIG_DISABLE))
-	{
-	  if (option_bool(OPT_QUIET_DHCP))
-	    return 0;
-	  message = _("ignored");
-	  opt = NULL;
-	}
-      else 
-	{
-	  struct in_addr addr, conf;
-	  
-	  addr.s_addr = conf.s_addr = 0;
-
-	  if ((opt = option_find(mess, sz, OPTION_REQUESTED_IP, INADDRSZ)))	 
-	    addr = option_addr(opt);
-	  
-	  if (have_config(config, CONFIG_ADDR))
-	    {
-	      char *addrs = inet_ntoa(config->addr);
-	      
-	      if ((ltmp = lease_find_by_addr(config->addr)) && 
-		  ltmp != lease &&
-		  !config_has_mac(config, ltmp->hwaddr, ltmp->hwaddr_len, ltmp->hwaddr_type))
-		{
-		  int len;
-		  unsigned char *mac = extended_hwaddr(ltmp->hwaddr_type, ltmp->hwaddr_len,
-						       ltmp->hwaddr, ltmp->clid_len, ltmp->clid, &len);
-		  my_syslog(MS_DHCP | LOG_WARNING, _("not using configured address %s because it is leased to %s"),
-			    addrs, print_mac(daemon->namebuff, mac, len));
-		}
-	      else
-		{
-		  struct dhcp_context *tmp;
-		  for (tmp = context; tmp; tmp = tmp->current)
-		    if (context->router.s_addr == config->addr.s_addr)
-		      break;
-		  if (tmp)
-		    my_syslog(MS_DHCP | LOG_WARNING, _("not using configured address %s because it is in use by the server or relay"), addrs);
-		  else if (have_config(config, CONFIG_DECLINED) &&
-			   difftime(now, config->decline_time) < (float)DECLINE_BACKOFF)
-		    my_syslog(MS_DHCP | LOG_WARNING, _("not using configured address %s because it was previously declined"), addrs);
-		  else
-		    conf = config->addr;
-		}
-	    }
-	  
-	  if (conf.s_addr)
-	    mess->yiaddr = conf;
-	  else if (lease && 
-		   address_available(context, lease->addr, tagif_netid) && 
-		   !config_find_by_address(daemon->dhcp_conf, lease->addr))
-	    mess->yiaddr = lease->addr;
-	  else if (opt && address_available(context, addr, tagif_netid) && !lease_find_by_addr(addr) && 
-		   !config_find_by_address(daemon->dhcp_conf, addr) && do_icmp_ping(now, addr, 0, loopback))
-	    mess->yiaddr = addr;
-	  else if (emac_len == 0)
-	    message = _("no unique-id");
-	  else if (!address_allocate(context, &mess->yiaddr, emac, emac_len, tagif_netid, now, loopback))
-	    message = _("no address available");      
-	}
-      
-      log_packet("DHCPDISCOVER", opt ? option_ptr(opt, 0) : NULL, emac, emac_len, iface_name, NULL, message, mess->xid); 
-
-      if (message || !(context = narrow_context(context, mess->yiaddr, tagif_netid)))
-	return 0;
-
-      if (context->netid.net)
-	{
-	  context->netid.next = netid;
-	  tagif_netid = run_tag_if(&context->netid);
-	}
 
-      log_tags(tagif_netid, ntohl(mess->xid));
-      apply_delay(mess->xid, recvtime, tagif_netid);
-      log_packet("DHCPOFFER" , &mess->yiaddr, emac, emac_len, iface_name, NULL, NULL, mess->xid);
-      
-      time = calc_time(context, config, option_find(mess, sz, OPTION_LEASE_TIME, 4));
-      clear_packet(mess, end);
-      option_put(mess, end, OPTION_MESSAGE_TYPE, 1, DHCPOFFER);
-      option_put(mess, end, OPTION_SERVER_IDENTIFIER, INADDRSZ, ntohl(server_id(context, override, fallback).s_addr));
-      option_put(mess, end, OPTION_LEASE_TIME, 4, time);
-      /* T1 and T2 are required in DHCPOFFER by HP's wacky Jetdirect client. */
-      do_options(context, mess, end, req_options, offer_hostname, get_domain(mess->yiaddr), 
-		 netid, subnet_addr, fqdn_flags, borken_opt, pxearch, uuid, vendor_class_len, now, time, fuzz);
-      
-      return dhcp_packet_size(mess, agent_id, real_end);
-      
-    case DHCPREQUEST:
-      if (ignore || have_config(config, CONFIG_DISABLE))
-	return 0;
+    log_packet("DHCPDECLINE", option_ptr(opt, 0), emac, emac_len, iface_name,
+               NULL, daemon->dhcp_buff, mess->xid);
+
+    if (lease && lease->addr.s_addr == option_addr(opt).s_addr)
+      lease_prune(lease, now);
+
+    if (have_config(config, CONFIG_ADDR) &&
+        config->addr.s_addr == option_addr(opt).s_addr) {
+      prettyprint_time(daemon->dhcp_buff, DECLINE_BACKOFF);
+      my_syslog(MS_DHCP | LOG_WARNING,
+                _("disabling DHCP static address %s for %s"),
+                inet_ntoa(config->addr), daemon->dhcp_buff);
+      config->flags |= CONFIG_DECLINED;
+      config->decline_time = now;
+    } else
+      /* make sure this host gets a different address next time. */
+      for (; context; context = context->current)
+        context->addr_epoch++;
+
+    return 0;
+
+  case DHCPRELEASE:
+    if (!(context = narrow_context(context, mess->ciaddr, tagif_netid)) ||
+        !(opt = option_find(mess, sz, OPTION_SERVER_IDENTIFIER, INADDRSZ)) ||
+        option_addr(opt).s_addr != server_id(context, override,
+                                             fallback).s_addr)
+      return 0;
+
+    if (lease && lease->addr.s_addr == mess->ciaddr.s_addr)
+      lease_prune(lease, now);
+    else
+      message = _("unknown lease");
+
+    log_packet("DHCPRELEASE", &mess->ciaddr, emac, emac_len, iface_name, NULL,
+               message, mess->xid);
+
+    return 0;
+
+  case DHCPDISCOVER:
+    if (ignore || have_config(config, CONFIG_DISABLE)) {
+      if (option_bool(OPT_QUIET_DHCP))
+        return 0;
+      message = _("ignored");
+      opt = NULL;
+    } else {
+      struct in_addr addr, conf;
+
+      addr.s_addr = conf.s_addr = 0;
+
       if ((opt = option_find(mess, sz, OPTION_REQUESTED_IP, INADDRSZ)))
-	{
-	  /* SELECTING  or INIT_REBOOT */
-	  mess->yiaddr = option_addr(opt);
-	  
-	  /* send vendor and user class info for new or recreated lease */
-	  do_classes = 1;
-	  
-	  if ((opt = option_find(mess, sz, OPTION_SERVER_IDENTIFIER, INADDRSZ)))
-	    {
-	      /* SELECTING */
-	      selecting = 1;
-	      
-	      if (override.s_addr != 0)
-		{
-		  if (option_addr(opt).s_addr != override.s_addr)
-		    return 0;
-		}
-	      else 
-		{
-		  for (; context; context = context->current)
-		    if (context->local.s_addr == option_addr(opt).s_addr)
-		      break;
-		  
-		  if (!context)
-		    {
-		      /* Handle very strange configs where clients have more than one route to the server.
-			 If a clients idea of its server-id matches any of our DHCP interfaces, we let it pass.
-			 Have to set override to make sure we echo back the correct server-id */
-		      struct irec *intr;
-		      
-		      enumerate_interfaces(0);
-
-		      for (intr = daemon->interfaces; intr; intr = intr->next)
-			if (intr->addr.sa.sa_family == AF_INET &&
-			    intr->addr.in.sin_addr.s_addr == option_addr(opt).s_addr &&
-			    intr->tftp_ok)
-			  break;
-
-		      if (intr)
-			override = intr->addr.in.sin_addr;
-		      else
-			{
-			  /* In auth mode, a REQUEST sent to the wrong server
-			     should be faulted, so that the client establishes 
-			     communication with us, otherwise, silently ignore. */
-			  if (!option_bool(OPT_AUTHORITATIVE))
-			    return 0;
-			  message = _("wrong server-ID");
-			}
-		    }
-		}
-
-	      /* If a lease exists for this host and another address, squash it. */
-	      if (lease && lease->addr.s_addr != mess->yiaddr.s_addr)
-		{
-		  lease_prune(lease, now);
-		  lease = NULL;
-		}
-	    }
-	  else
-	    {
-	      /* INIT-REBOOT */
-	      if (!lease && !option_bool(OPT_AUTHORITATIVE))
-		return 0;
-	      
-	      if (lease && lease->addr.s_addr != mess->yiaddr.s_addr)
-		message = _("wrong address");
-	    }
-	}
-      else
-	{
-	  /* RENEWING or REBINDING */ 
-	  /* Check existing lease for this address.
-	     We allow it to be missing if dhcp-authoritative mode
-	     as long as we can allocate the lease now - checked below.
-	     This makes for a smooth recovery from a lost lease DB */
-	  if ((lease && mess->ciaddr.s_addr != lease->addr.s_addr) ||
-	      (!lease && !option_bool(OPT_AUTHORITATIVE)))
-	    {
-	      /* A client rebinding will broadcast the request, so we may see it even 
-		 if the lease is held by another server. Just ignore it in that case. 
-		 If the request is unicast to us, then somethings wrong, NAK */
-	      if (!unicast_dest)
-		return 0;
-	      message = _("lease not found");
-	      /* ensure we broadcast NAK */
-	      unicast_dest = 0;
-	    }
-
-	  /* desynchronise renewals */
-	  fuzz = rand16();
-	  mess->yiaddr = mess->ciaddr;
-	}
-      
-      log_packet("DHCPREQUEST", &mess->yiaddr, emac, emac_len, iface_name, NULL, NULL, mess->xid);
- 
-      if (!message)
-	{
-	  struct dhcp_config *addr_config;
-	  struct dhcp_context *tmp = NULL;
-	  
-	  if (have_config(config, CONFIG_ADDR))
-	    for (tmp = context; tmp; tmp = tmp->current)
-	      if (context->router.s_addr == config->addr.s_addr)
-		break;
-	  
-	  if (!(context = narrow_context(context, mess->yiaddr, tagif_netid)))
-	    {
-	      /* If a machine moves networks whilst it has a lease, we catch that here. */
-	      message = _("wrong network");
-	      /* ensure we broadcast NAK */
-	      unicast_dest = 0;
-	    }
-	  
-	  /* Check for renewal of a lease which is outside the allowed range. */
-	  else if (!address_available(context, mess->yiaddr, tagif_netid) &&
-		   (!have_config(config, CONFIG_ADDR) || config->addr.s_addr != mess->yiaddr.s_addr))
-	    message = _("address not available");
-	  
-	  /* Check if a new static address has been configured. Be very sure that
-	     when the client does DISCOVER, it will get the static address, otherwise
-	     an endless protocol loop will ensue. */
-	  else if (!tmp && !selecting &&
-		   have_config(config, CONFIG_ADDR) && 
-		   (!have_config(config, CONFIG_DECLINED) ||
-		    difftime(now, config->decline_time) > (float)DECLINE_BACKOFF) &&
-		   config->addr.s_addr != mess->yiaddr.s_addr &&
-		   (!(ltmp = lease_find_by_addr(config->addr)) || ltmp == lease))
-	    message = _("static lease available");
-
-	  /* Check to see if the address is reserved as a static address for another host */
-	  else if ((addr_config = config_find_by_address(daemon->dhcp_conf, mess->yiaddr)) && addr_config != config)
-	    message = _("address reserved");
-
-	  else if (!lease && (ltmp = lease_find_by_addr(mess->yiaddr)))
-	    {
-	      /* If a host is configured with more than one MAC address, it's OK to 'nix 
-		 a lease from one of it's MACs to give the address to another. */
-	      if (config && config_has_mac(config, ltmp->hwaddr, ltmp->hwaddr_len, ltmp->hwaddr_type))
-		{
-		  my_syslog(MS_DHCP | LOG_INFO, _("abandoning lease to %s of %s"),
-			    print_mac(daemon->namebuff, ltmp->hwaddr, ltmp->hwaddr_len), 
-			    inet_ntoa(ltmp->addr));
-		  lease = ltmp;
-		}
-	      else
-		message = _("address in use");
-	    }
-
-	  if (!message)
-	    {
-	      if (emac_len == 0)
-		message = _("no unique-id");
-	      
-	      else if (!lease)
-		{	     
-		  if ((lease = lease4_allocate(mess->yiaddr)))
-		    do_classes = 1;
-		  else
-		    message = _("no leases left");
-		}
-	    }
-	}
-
-      if (message)
-	{
-	  log_packet("DHCPNAK", &mess->yiaddr, emac, emac_len, iface_name, NULL, message, mess->xid);
-	  
-	  mess->yiaddr.s_addr = 0;
-	  clear_packet(mess, end);
-	  option_put(mess, end, OPTION_MESSAGE_TYPE, 1, DHCPNAK);
-	  option_put(mess, end, OPTION_SERVER_IDENTIFIER, INADDRSZ, ntohl(server_id(context, override, fallback).s_addr));
-	  option_put_string(mess, end, OPTION_MESSAGE, message, borken_opt);
-	  /* This fixes a problem with the DHCP spec, broadcasting a NAK to a host on 
-	     a distant subnet which unicast a REQ to us won't work. */
-	  if (!unicast_dest || mess->giaddr.s_addr != 0 || 
-	      mess->ciaddr.s_addr == 0 || is_same_net(context->local, mess->ciaddr, context->netmask))
-	    {
-	      mess->flags |= htons(0x8000); /* broadcast */
-	      mess->ciaddr.s_addr = 0;
-	    }
-	}
-      else
-	{
-	  if (context->netid.net)
-	    {
-	      context->netid.next = netid;
-	      tagif_netid = run_tag_if( &context->netid);
-	    }
-
-	  log_tags(tagif_netid, ntohl(mess->xid));
-	  
-	  if (do_classes)
-	    {
-	      /* pick up INIT-REBOOT events. */
-	      lease->flags |= LEASE_CHANGED;
+        addr = option_addr(opt);
+
+      if (have_config(config, CONFIG_ADDR)) {
+        char *addrs = inet_ntoa(config->addr);
+
+        if ((ltmp = lease_find_by_addr(config->addr)) &&
+            ltmp != lease &&
+            !config_has_mac(config, ltmp->hwaddr, ltmp->hwaddr_len,
+                            ltmp->hwaddr_type)) {
+          int len;
+          unsigned char *mac =
+              extended_hwaddr(ltmp->hwaddr_type, ltmp->hwaddr_len,
+                              ltmp->hwaddr, ltmp->clid_len, ltmp->clid, &len);
+          my_syslog(MS_DHCP | LOG_WARNING,
+                    _
+                    ("not using configured address %s because it is leased to %s"),
+                    addrs, print_mac(daemon->namebuff, mac, len));
+        } else {
+          struct dhcp_context *tmp;
+          for (tmp = context; tmp; tmp = tmp->current)
+            if (context->router.s_addr == config->addr.s_addr)
+              break;
+          if (tmp)
+            my_syslog(MS_DHCP | LOG_WARNING,
+                      _
+                      ("not using configured address %s because it is in use by the server or relay"),
+                      addrs);
+          else if (have_config(config, CONFIG_DECLINED)
+                   && difftime(now,
+                               config->decline_time) < (float) DECLINE_BACKOFF)
+            my_syslog(MS_DHCP | LOG_WARNING,
+                      _
+                      ("not using configured address %s because it was previously declined"),
+                      addrs);
+          else
+            conf = config->addr;
+        }
+      }
+
+      if (conf.s_addr)
+        mess->yiaddr = conf;
+      else if (lease &&
+               address_available(context, lease->addr, tagif_netid) &&
+               !config_find_by_address(daemon->dhcp_conf, lease->addr))
+        mess->yiaddr = lease->addr;
+      else if (opt && address_available(context, addr, tagif_netid)
+               && !lease_find_by_addr(addr)
+               && !config_find_by_address(daemon->dhcp_conf, addr)
+               && do_icmp_ping(now, addr, 0, loopback))
+        mess->yiaddr = addr;
+      else if (emac_len == 0)
+        message = _("no unique-id");
+      else if (!address_allocate
+               (context, &mess->yiaddr, emac, emac_len, tagif_netid, now,
+                loopback))
+        message = _("no address available");
+    }
+
+    log_packet("DHCPDISCOVER", opt ? option_ptr(opt, 0) : NULL, emac, emac_len,
+               iface_name, NULL, message, mess->xid);
+
+    if (message
+        || !(context = narrow_context(context, mess->yiaddr, tagif_netid)))
+      return 0;
+
+    if (context->netid.net) {
+      context->netid.next = netid;
+      tagif_netid = run_tag_if(&context->netid);
+    }
+
+    log_tags(tagif_netid, ntohl(mess->xid));
+    apply_delay(mess->xid, recvtime, tagif_netid);
+    log_packet("DHCPOFFER", &mess->yiaddr, emac, emac_len, iface_name, NULL,
+               NULL, mess->xid);
+
+    time =
+        calc_time(context, config, option_find(mess, sz, OPTION_LEASE_TIME, 4));
+    clear_packet(mess, end);
+    option_put(mess, end, OPTION_MESSAGE_TYPE, 1, DHCPOFFER);
+    option_put(mess, end, OPTION_SERVER_IDENTIFIER, INADDRSZ,
+               ntohl(server_id(context, override, fallback).s_addr));
+    option_put(mess, end, OPTION_LEASE_TIME, 4, time);
+    /* T1 and T2 are required in DHCPOFFER by HP's wacky Jetdirect client. */
+    do_options(context, mess, end, req_options, offer_hostname,
+               get_domain(mess->yiaddr), netid, subnet_addr, fqdn_flags,
+               borken_opt, pxearch, uuid, vendor_class_len, now, time, fuzz);
+
+    return dhcp_packet_size(mess, agent_id, real_end);
+
+  case DHCPREQUEST:
+    if (ignore || have_config(config, CONFIG_DISABLE))
+      return 0;
+    if ((opt = option_find(mess, sz, OPTION_REQUESTED_IP, INADDRSZ))) {
+      /* SELECTING  or INIT_REBOOT */
+      mess->yiaddr = option_addr(opt);
+
+      /* send vendor and user class info for new or recreated lease */
+      do_classes = 1;
+
+      if ((opt = option_find(mess, sz, OPTION_SERVER_IDENTIFIER, INADDRSZ))) {
+        /* SELECTING */
+        selecting = 1;
+
+        if (override.s_addr != 0) {
+          if (option_addr(opt).s_addr != override.s_addr)
+            return 0;
+        } else {
+          for (; context; context = context->current)
+            if (context->local.s_addr == option_addr(opt).s_addr)
+              break;
+
+          if (!context) {
+            /* Handle very strange configs where clients have more than one route to the server.
+               If a clients idea of its server-id matches any of our DHCP interfaces, we let it pass.
+               Have to set override to make sure we echo back the correct server-id */
+            struct irec *intr;
+
+            enumerate_interfaces(0);
+
+            for (intr = daemon->interfaces; intr; intr = intr->next)
+              if (intr->addr.sa.sa_family == AF_INET &&
+                  intr->addr.in.sin_addr.s_addr == option_addr(opt).s_addr &&
+                  intr->tftp_ok)
+                break;
+
+            if (intr)
+              override = intr->addr.in.sin_addr;
+            else {
+              /* In auth mode, a REQUEST sent to the wrong server
+                 should be faulted, so that the client establishes
+                 communication with us, otherwise, silently ignore. */
+              if (!option_bool(OPT_AUTHORITATIVE))
+                return 0;
+              message = _("wrong server-ID");
+            }
+          }
+        }
+
+        /* If a lease exists for this host and another address, squash it. */
+        if (lease && lease->addr.s_addr != mess->yiaddr.s_addr) {
+          lease_prune(lease, now);
+          lease = NULL;
+        }
+      } else {
+        /* INIT-REBOOT */
+        if (!lease && !option_bool(OPT_AUTHORITATIVE))
+          return 0;
+
+        if (lease && lease->addr.s_addr != mess->yiaddr.s_addr)
+          message = _("wrong address");
+      }
+    } else {
+      /* RENEWING or REBINDING */
+      /* Check existing lease for this address.
+         We allow it to be missing if dhcp-authoritative mode
+         as long as we can allocate the lease now - checked below.
+         This makes for a smooth recovery from a lost lease DB */
+      if ((lease && mess->ciaddr.s_addr != lease->addr.s_addr) ||
+          (!lease && !option_bool(OPT_AUTHORITATIVE))) {
+        /* A client rebinding will broadcast the request, so we may see it even
+           if the lease is held by another server. Just ignore it in that case.
+           If the request is unicast to us, then somethings wrong, NAK */
+        if (!unicast_dest)
+          return 0;
+        message = _("lease not found");
+        /* ensure we broadcast NAK */
+        unicast_dest = 0;
+      }
+
+      /* desynchronise renewals */
+      fuzz = rand16();
+      mess->yiaddr = mess->ciaddr;
+    }
+
+    log_packet("DHCPREQUEST", &mess->yiaddr, emac, emac_len, iface_name, NULL,
+               NULL, mess->xid);
+
+    if (!message) {
+      struct dhcp_config *addr_config;
+      struct dhcp_context *tmp = NULL;
+
+      if (have_config(config, CONFIG_ADDR))
+        for (tmp = context; tmp; tmp = tmp->current)
+          if (context->router.s_addr == config->addr.s_addr)
+            break;
+
+      if (!(context = narrow_context(context, mess->yiaddr, tagif_netid))) {
+        /* If a machine moves networks whilst it has a lease, we catch that here. */
+        message = _("wrong network");
+        /* ensure we broadcast NAK */
+        unicast_dest = 0;
+      }
+
+      /* Check for renewal of a lease which is outside the allowed range. */
+      else if (!address_available(context, mess->yiaddr, tagif_netid) &&
+               (!have_config(config, CONFIG_ADDR)
+                || config->addr.s_addr != mess->yiaddr.s_addr))
+        message = _("address not available");
+
+      /* Check if a new static address has been configured. Be very sure that
+         when the client does DISCOVER, it will get the static address, otherwise
+         an endless protocol loop will ensue. */
+      else if (!tmp && !selecting &&
+               have_config(config, CONFIG_ADDR) &&
+               (!have_config(config, CONFIG_DECLINED) ||
+                difftime(now, config->decline_time) > (float) DECLINE_BACKOFF)
+               && config->addr.s_addr != mess->yiaddr.s_addr
+               && (!(ltmp = lease_find_by_addr(config->addr)) || ltmp == lease))
+        message = _("static lease available");
+
+      /* Check to see if the address is reserved as a static address for another host */
+      else if ((addr_config =
+                config_find_by_address(daemon->dhcp_conf, mess->yiaddr))
+               && addr_config != config)
+        message = _("address reserved");
+
+      else if (!lease && (ltmp = lease_find_by_addr(mess->yiaddr))) {
+        /* If a host is configured with more than one MAC address, it's OK to 'nix
+           a lease from one of it's MACs to give the address to another. */
+        if (config
+            && config_has_mac(config, ltmp->hwaddr, ltmp->hwaddr_len,
+                              ltmp->hwaddr_type)) {
+          my_syslog(MS_DHCP | LOG_INFO, _("abandoning lease to %s of %s"),
+                    print_mac(daemon->namebuff, ltmp->hwaddr, ltmp->hwaddr_len),
+                    inet_ntoa(ltmp->addr));
+          lease = ltmp;
+        } else
+          message = _("address in use");
+      }
+
+      if (!message) {
+        if (emac_len == 0)
+          message = _("no unique-id");
+
+        else if (!lease) {
+          if ((lease = lease4_allocate(mess->yiaddr)))
+            do_classes = 1;
+          else
+            message = _("no leases left");
+        }
+      }
+    }
+
+    if (message) {
+      log_packet("DHCPNAK", &mess->yiaddr, emac, emac_len, iface_name, NULL,
+                 message, mess->xid);
+
+      mess->yiaddr.s_addr = 0;
+      clear_packet(mess, end);
+      option_put(mess, end, OPTION_MESSAGE_TYPE, 1, DHCPNAK);
+      option_put(mess, end, OPTION_SERVER_IDENTIFIER, INADDRSZ,
+                 ntohl(server_id(context, override, fallback).s_addr));
+      option_put_string(mess, end, OPTION_MESSAGE, message, borken_opt);
+      /* This fixes a problem with the DHCP spec, broadcasting a NAK to a host on
+         a distant subnet which unicast a REQ to us won't work. */
+      if (!unicast_dest || mess->giaddr.s_addr != 0 ||
+          mess->ciaddr.s_addr == 0
+          || is_same_net(context->local, mess->ciaddr, context->netmask)) {
+        mess->flags |= htons(0x8000);   /* broadcast */
+        mess->ciaddr.s_addr = 0;
+      }
+    } else {
+      if (context->netid.net) {
+        context->netid.next = netid;
+        tagif_netid = run_tag_if(&context->netid);
+      }
+
+      log_tags(tagif_netid, ntohl(mess->xid));
+
+      if (do_classes) {
+        /* pick up INIT-REBOOT events. */
+        lease->flags |= LEASE_CHANGED;
 
 #ifdef HAVE_SCRIPT
-	      if (daemon->lease_change_command)
-		{
-		  struct dhcp_netid *n;
-		  
-		  if (mess->giaddr.s_addr)
-		    lease->giaddr = mess->giaddr;
-		  
-		  free(lease->extradata);
-		  lease->extradata = NULL;
-		  lease->extradata_size = lease->extradata_len = 0;
-		  
-		  add_extradata_opt(lease, option_find(mess, sz, OPTION_VENDOR_ID, 1));
-		  add_extradata_opt(lease, option_find(mess, sz, OPTION_HOSTNAME, 1));
-		  add_extradata_opt(lease, oui);
-		  add_extradata_opt(lease, serial);
-		  add_extradata_opt(lease, class);
-
-		  if ((opt = option_find(mess, sz, OPTION_AGENT_ID, 1)))
-		    {
-		      add_extradata_opt(lease, option_find1(option_ptr(opt, 0), option_ptr(opt, option_len(opt)), SUBOPT_CIRCUIT_ID, 1));
-		      add_extradata_opt(lease, option_find1(option_ptr(opt, 0), option_ptr(opt, option_len(opt)), SUBOPT_SUBSCR_ID, 1));
-		      add_extradata_opt(lease, option_find1(option_ptr(opt, 0), option_ptr(opt, option_len(opt)), SUBOPT_REMOTE_ID, 1));
-		    }
-		  else
-		    {
-		      add_extradata_opt(lease, NULL);
-		      add_extradata_opt(lease, NULL);
-		      add_extradata_opt(lease, NULL);
-		    }
-
-		  /* DNSMASQ_REQUESTED_OPTIONS */
-		  if ((opt = option_find(mess, sz, OPTION_REQUESTED_OPTIONS, 1)))
-		    {
-		      int len = option_len(opt);
-		      unsigned char *rop = option_ptr(opt, 0);
-		      char *q = daemon->namebuff;
-		      int i;
-		      for (i = 0; i < len; i++)
-		        {
-		          q += snprintf(q, MAXDNAME - (q - daemon->namebuff), "%d%s", rop[i], i + 1 == len ? "" : ",");
-		        }
-		      lease_add_extradata(lease, (unsigned char *)daemon->namebuff, (q - daemon->namebuff), 0); 
-		    }
-		  else
-		    {
-		      add_extradata_opt(lease, NULL);
-		    }
-
-		  /* space-concat tag set */
-		  if (!tagif_netid)
-		    add_extradata_opt(lease, NULL);
-		  else
-		    for (n = tagif_netid; n; n = n->next)
-		      {
-			struct dhcp_netid *n1;
-			/* kill dupes */
-			for (n1 = n->next; n1; n1 = n1->next)
-			  if (strcmp(n->net, n1->net) == 0)
-			    break;
-			if (!n1)
-			  lease_add_extradata(lease, (unsigned char *)n->net, strlen(n->net), n->next ? ' ' : 0); 
-		      }
-		  
-		  if ((opt = option_find(mess, sz, OPTION_USER_CLASS, 1)))
-		    {
-		      int len = option_len(opt);
-		      unsigned char *ucp = option_ptr(opt, 0);
-		      /* If the user-class option started as counted strings, the first byte will be zero. */
-		      if (len != 0 && ucp[0] == 0)
-			ucp++, len--;
-		      lease_add_extradata(lease, ucp, len, -1);
-		    }
-		}
+        if (daemon->lease_change_command) {
+          struct dhcp_netid *n;
+
+          if (mess->giaddr.s_addr)
+            lease->giaddr = mess->giaddr;
+
+          free(lease->extradata);
+          lease->extradata = NULL;
+          lease->extradata_size = lease->extradata_len = 0;
+
+          add_extradata_opt(lease, option_find(mess, sz, OPTION_VENDOR_ID, 1));
+          add_extradata_opt(lease, option_find(mess, sz, OPTION_HOSTNAME, 1));
+          add_extradata_opt(lease, oui);
+          add_extradata_opt(lease, serial);
+          add_extradata_opt(lease, class);
+
+          if ((opt = option_find(mess, sz, OPTION_AGENT_ID, 1))) {
+            add_extradata_opt(lease,
+                              option_find1(option_ptr(opt, 0),
+                                           option_ptr(opt, option_len(opt)),
+                                           SUBOPT_CIRCUIT_ID, 1));
+            add_extradata_opt(lease,
+                              option_find1(option_ptr(opt, 0),
+                                           option_ptr(opt, option_len(opt)),
+                                           SUBOPT_SUBSCR_ID, 1));
+            add_extradata_opt(lease,
+                              option_find1(option_ptr(opt, 0),
+                                           option_ptr(opt, option_len(opt)),
+                                           SUBOPT_REMOTE_ID, 1));
+          } else {
+            add_extradata_opt(lease, NULL);
+            add_extradata_opt(lease, NULL);
+            add_extradata_opt(lease, NULL);
+          }
+
+          /* DNSMASQ_REQUESTED_OPTIONS */
+          if ((opt = option_find(mess, sz, OPTION_REQUESTED_OPTIONS, 1))) {
+            int len = option_len(opt);
+            unsigned char *rop = option_ptr(opt, 0);
+            char *q = daemon->namebuff;
+            int i;
+            for (i = 0; i < len; i++) {
+              q += snprintf(q, MAXDNAME - (q - daemon->namebuff), "%d%s",
+                            rop[i], i + 1 == len ? "" : ",");
+            }
+            lease_add_extradata(lease, (unsigned char *) daemon->namebuff,
+                                (q - daemon->namebuff), 0);
+          } else {
+            add_extradata_opt(lease, NULL);
+          }
+
+          /* space-concat tag set */
+          if (!tagif_netid)
+            add_extradata_opt(lease, NULL);
+          else
+            for (n = tagif_netid; n; n = n->next) {
+              struct dhcp_netid *n1;
+              /* kill dupes */
+              for (n1 = n->next; n1; n1 = n1->next)
+                if (strcmp(n->net, n1->net) == 0)
+                  break;
+              if (!n1)
+                lease_add_extradata(lease, (unsigned char *) n->net,
+                                    strlen(n->net), n->next ? ' ' : 0);
+            }
+
+          if ((opt = option_find(mess, sz, OPTION_USER_CLASS, 1))) {
+            int len = option_len(opt);
+            unsigned char *ucp = option_ptr(opt, 0);
+            /* If the user-class option started as counted strings, the first byte will be zero. */
+            if (len != 0 && ucp[0] == 0)
+              ucp++, len--;
+            lease_add_extradata(lease, ucp, len, -1);
+          }
+        }
 #endif
-	    }
-	  
-	  if (!hostname_auth && (client_hostname = host_from_dns(mess->yiaddr)))
-	    {
-	      domain = get_domain(mess->yiaddr);
-	      hostname = client_hostname;
-	      hostname_auth = 1;
-	    }
-	  
-	  time = calc_time(context, config, option_find(mess, sz, OPTION_LEASE_TIME, 4));
-	  lease_set_hwaddr(lease, mess->chaddr, clid, mess->hlen, mess->htype, clid_len, now, do_classes);
-	  
-	  /* if all the netids in the ignore_name list are present, ignore client-supplied name */
-	  if (!hostname_auth)
-	    {
-	      for (id_list = daemon->dhcp_ignore_names; id_list; id_list = id_list->next)
-		if ((!id_list->list) || match_netid(id_list->list, tagif_netid, 0))
-		  break;
-	      if (id_list)
-		hostname = NULL;
-	    }
-	  
-	  /* Last ditch, if configured, generate hostname from mac address */
-	  if (!hostname && emac_len != 0)
-	    {
-	      for (id_list = daemon->dhcp_gen_names; id_list; id_list = id_list->next)
-		if ((!id_list->list) || match_netid(id_list->list, tagif_netid, 0))
-		  break;
-	      if (id_list)
-		{
-		  int i;
-
-		  hostname = daemon->dhcp_buff;
-		  /* buffer is 256 bytes, 3 bytes per octet */
-		  for (i = 0; (i < emac_len) && (i < 80); i++)
-		    hostname += sprintf(hostname, "%.2x%s", emac[i], (i == emac_len - 1) ? "" : "-");
-		  hostname = daemon->dhcp_buff;
-		}
-	    }
-
-	  if (hostname)
-	    lease_set_hostname(lease, hostname, hostname_auth, get_domain(lease->addr), domain);
-	  
-	  lease_set_expires(lease, time, now);
-	  lease_set_interface(lease, int_index, now);
-
-	  if (override.s_addr != 0)
-	    lease->override = override;
-	  else
-	    override = lease->override;
-
-	  log_packet("DHCPACK", &mess->yiaddr, emac, emac_len, iface_name, hostname, NULL, mess->xid);  
-	  
-	  clear_packet(mess, end);
-	  option_put(mess, end, OPTION_MESSAGE_TYPE, 1, DHCPACK);
-	  option_put(mess, end, OPTION_SERVER_IDENTIFIER, INADDRSZ, ntohl(server_id(context, override, fallback).s_addr));
-	  option_put(mess, end, OPTION_LEASE_TIME, 4, time);
-	  do_options(context, mess, end, req_options, hostname, get_domain(mess->yiaddr), 
-		     netid, subnet_addr, fqdn_flags, borken_opt, pxearch, uuid, vendor_class_len, now, time, fuzz);
-	}
-
-      return dhcp_packet_size(mess, agent_id, real_end); 
-      
-    case DHCPINFORM:
-      if (ignore || have_config(config, CONFIG_DISABLE))
-	message = _("ignored");
-      
-      log_packet("DHCPINFORM", &mess->ciaddr, emac, emac_len, iface_name, message, NULL, mess->xid);
-     
-      if (message || mess->ciaddr.s_addr == 0)
-	return 0;
-
-      /* For DHCPINFORM only, cope without a valid context */
-      context = narrow_context(context, mess->ciaddr, tagif_netid);
-      
-      /* Find a least based on IP address if we didn't
-	 get one from MAC address/client-d */
-      if (!lease &&
-	  (lease = lease_find_by_addr(mess->ciaddr)) && 
-	  lease->hostname)
-	hostname = lease->hostname;
-      
-      if (!hostname)
-	hostname = host_from_dns(mess->ciaddr);
-      
-      if (context && context->netid.net)
-	{
-	  context->netid.next = netid;
-	  tagif_netid = run_tag_if(&context->netid);
-	}
+      }
 
-      log_tags(tagif_netid, ntohl(mess->xid));
-      
-      log_packet("DHCPACK", &mess->ciaddr, emac, emac_len, iface_name, hostname, NULL, mess->xid);
-      
-      if (lease)
-	{
-	  lease_set_interface(lease, int_index, now);
-	  if (override.s_addr != 0)
-	    lease->override = override;
-	  else
-	    override = lease->override;
-	}
+      if (!hostname_auth && (client_hostname = host_from_dns(mess->yiaddr))) {
+        domain = get_domain(mess->yiaddr);
+        hostname = client_hostname;
+        hostname_auth = 1;
+      }
+
+      time =
+          calc_time(context, config,
+                    option_find(mess, sz, OPTION_LEASE_TIME, 4));
+      lease_set_hwaddr(lease, mess->chaddr, clid, mess->hlen, mess->htype,
+                       clid_len, now, do_classes);
+
+      /* if all the netids in the ignore_name list are present, ignore client-supplied name */
+      if (!hostname_auth) {
+        for (id_list = daemon->dhcp_ignore_names; id_list;
+             id_list = id_list->next)
+          if ((!id_list->list) || match_netid(id_list->list, tagif_netid, 0))
+            break;
+        if (id_list)
+          hostname = NULL;
+      }
+
+      /* Last ditch, if configured, generate hostname from mac address */
+      if (!hostname && emac_len != 0) {
+        for (id_list = daemon->dhcp_gen_names; id_list; id_list = id_list->next)
+          if ((!id_list->list) || match_netid(id_list->list, tagif_netid, 0))
+            break;
+        if (id_list) {
+          int i;
+
+          hostname = daemon->dhcp_buff;
+          /* buffer is 256 bytes, 3 bytes per octet */
+          for (i = 0; (i < emac_len) && (i < 80); i++)
+            hostname +=
+                sprintf(hostname, "%.2x%s", emac[i],
+                        (i == emac_len - 1) ? "" : "-");
+          hostname = daemon->dhcp_buff;
+        }
+      }
+
+      if (hostname)
+        lease_set_hostname(lease, hostname, hostname_auth,
+                           get_domain(lease->addr), domain);
+
+      lease_set_expires(lease, time, now);
+      lease_set_interface(lease, int_index, now);
+
+      if (override.s_addr != 0)
+        lease->override = override;
+      else
+        override = lease->override;
+
+      log_packet("DHCPACK", &mess->yiaddr, emac, emac_len, iface_name, hostname,
+                 NULL, mess->xid);
 
       clear_packet(mess, end);
       option_put(mess, end, OPTION_MESSAGE_TYPE, 1, DHCPACK);
-      option_put(mess, end, OPTION_SERVER_IDENTIFIER, INADDRSZ, ntohl(server_id(context, override, fallback).s_addr));
-     
-      /* RFC 2131 says that DHCPINFORM shouldn't include lease-time parameters, but 
-	 we supply a utility which makes DHCPINFORM requests to get this information.
-	 Only include lease time if OPTION_LEASE_TIME is in the parameter request list,
-	 which won't be true for ordinary clients, but will be true for the 
-	 dhcp_lease_time utility. */
-      if (lease && in_list(req_options, OPTION_LEASE_TIME))
-	{
-	  if (lease->expires == 0)
-	    time = 0xffffffff;
-	  else
-	    time = (unsigned int)difftime(lease->expires, now);
-	  option_put(mess, end, OPTION_LEASE_TIME, 4, time);
-	}
-
-      do_options(context, mess, end, req_options, hostname, get_domain(mess->ciaddr),
-		 netid, subnet_addr, fqdn_flags, borken_opt, pxearch, uuid, vendor_class_len, now, 0xffffffff, 0);
-      
-      *is_inform = 1; /* handle reply differently */
-      return dhcp_packet_size(mess, agent_id, real_end); 
+      option_put(mess, end, OPTION_SERVER_IDENTIFIER, INADDRSZ,
+                 ntohl(server_id(context, override, fallback).s_addr));
+      option_put(mess, end, OPTION_LEASE_TIME, 4, time);
+      do_options(context, mess, end, req_options, hostname,
+                 get_domain(mess->yiaddr), netid, subnet_addr, fqdn_flags,
+                 borken_opt, pxearch, uuid, vendor_class_len, now, time, fuzz);
+    }
+
+    return dhcp_packet_size(mess, agent_id, real_end);
+
+  case DHCPINFORM:
+    if (ignore || have_config(config, CONFIG_DISABLE))
+      message = _("ignored");
+
+    log_packet("DHCPINFORM", &mess->ciaddr, emac, emac_len, iface_name, message,
+               NULL, mess->xid);
+
+    if (message || mess->ciaddr.s_addr == 0)
+      return 0;
+
+    /* For DHCPINFORM only, cope without a valid context */
+    context = narrow_context(context, mess->ciaddr, tagif_netid);
+
+    /* Find a least based on IP address if we didn't
+       get one from MAC address/client-d */
+    if (!lease && (lease = lease_find_by_addr(mess->ciaddr)) && lease->hostname)
+      hostname = lease->hostname;
+
+    if (!hostname)
+      hostname = host_from_dns(mess->ciaddr);
+
+    if (context && context->netid.net) {
+      context->netid.next = netid;
+      tagif_netid = run_tag_if(&context->netid);
+    }
+
+    log_tags(tagif_netid, ntohl(mess->xid));
+
+    log_packet("DHCPACK", &mess->ciaddr, emac, emac_len, iface_name, hostname,
+               NULL, mess->xid);
+
+    if (lease) {
+      lease_set_interface(lease, int_index, now);
+      if (override.s_addr != 0)
+        lease->override = override;
+      else
+        override = lease->override;
+    }
+
+    clear_packet(mess, end);
+    option_put(mess, end, OPTION_MESSAGE_TYPE, 1, DHCPACK);
+    option_put(mess, end, OPTION_SERVER_IDENTIFIER, INADDRSZ,
+               ntohl(server_id(context, override, fallback).s_addr));
+
+    /* RFC 2131 says that DHCPINFORM shouldn't include lease-time parameters, but
+       we supply a utility which makes DHCPINFORM requests to get this information.
+       Only include lease time if OPTION_LEASE_TIME is in the parameter request list,
+       which won't be true for ordinary clients, but will be true for the
+       dhcp_lease_time utility. */
+    if (lease && in_list(req_options, OPTION_LEASE_TIME)) {
+      if (lease->expires == 0)
+        time = 0xffffffff;
+      else
+        time = (unsigned int) difftime(lease->expires, now);
+      option_put(mess, end, OPTION_LEASE_TIME, 4, time);
     }
-  
+
+    do_options(context, mess, end, req_options, hostname,
+               get_domain(mess->ciaddr), netid, subnet_addr, fqdn_flags,
+               borken_opt, pxearch, uuid, vendor_class_len, now, 0xffffffff, 0);
+
+    *is_inform = 1;             /* handle reply differently */
+    return dhcp_packet_size(mess, agent_id, real_end);
+  }
+
   return 0;
 }
 
@@ -1502,50 +1486,50 @@
    then the client-id is using the usual encoding and use the rest of the 
    client-id: if not we can use the whole client-id. This should give
    sane MAC address logs. */
-unsigned char *extended_hwaddr(int hwtype, int hwlen, unsigned char *hwaddr, 
-				      int clid_len, unsigned char *clid, int *len_out)
+unsigned char *extended_hwaddr(int hwtype, int hwlen, unsigned char *hwaddr,
+                               int clid_len, unsigned char *clid, int *len_out)
 {
-  if (hwlen == 0 && clid && clid_len > 3)
-    {
-      if (clid[0]  == hwtype)
-	{
-	  *len_out = clid_len - 1 ;
-	  return clid + 1;
-	}
-
+  if (hwlen == 0 && clid && clid_len > 3) {
+    if (clid[0] == hwtype) {
+      *len_out = clid_len - 1;
+      return clid + 1;
+    }
 #if defined(ARPHRD_EUI64) && defined(ARPHRD_IEEE1394)
-      if (clid[0] ==  ARPHRD_EUI64 && hwtype == ARPHRD_IEEE1394)
-	{
-	  *len_out = clid_len - 1 ;
-	  return clid + 1;
-	}
-#endif
-      
-      *len_out = clid_len;
-      return clid;
+    if (clid[0] == ARPHRD_EUI64 && hwtype == ARPHRD_IEEE1394) {
+      *len_out = clid_len - 1;
+      return clid + 1;
     }
-  
+#endif
+
+    *len_out = clid_len;
+    return clid;
+  }
+
   *len_out = hwlen;
   return hwaddr;
 }
 
-static unsigned int calc_time(struct dhcp_context *context, struct dhcp_config *config, unsigned char *opt)
+static unsigned int calc_time(struct dhcp_context *context,
+                              struct dhcp_config *config, unsigned char *opt)
 {
-  unsigned int time = have_config(config, CONFIG_TIME) ? config->lease_time : context->lease_time;
-  
-  if (opt)
-    { 
-      unsigned int req_time = option_uint(opt, 0, 4);
-      if (req_time < 120 )
-	req_time = 120; /* sanity */
-      if (time == 0xffffffff || (req_time != 0xffffffff && req_time < time))
-	time = req_time;
-    }
+  unsigned int time =
+      have_config(config,
+                  CONFIG_TIME) ? config->lease_time : context->lease_time;
+
+  if (opt) {
+    unsigned int req_time = option_uint(opt, 0, 4);
+    if (req_time < 120)
+      req_time = 120;           /* sanity */
+    if (time == 0xffffffff || (req_time != 0xffffffff && req_time < time))
+      time = req_time;
+  }
 
   return time;
 }
 
-static struct in_addr server_id(struct dhcp_context *context, struct in_addr override, struct in_addr fallback)
+static struct in_addr server_id(struct dhcp_context *context,
+                                struct in_addr override,
+                                struct in_addr fallback)
 {
   if (override.s_addr != 0)
     return override;
@@ -1559,22 +1543,21 @@
 {
   char *p;
   int i;
-  
+
   *buf = 0;
-  
+
   if (!opt)
     return 0;
 
   p = option_ptr(opt, 0);
 
-  for (i = option_len(opt); i > 0; i--)
-    {
-      char c = *p++;
-      if (isprint((int)c))
-	*buf++ = c;
-    }
-  *buf = 0; /* add terminator */
-  
+  for (i = option_len(opt); i > 0; i--) {
+    char c = *p++;
+    if (isprint((int) c))
+      *buf++ = c;
+  }
+  *buf = 0;                     /* add terminator */
+
   return 1;
 }
 
@@ -1584,94 +1567,98 @@
   if (!opt)
     lease_add_extradata(lease, NULL, 0, 0);
   else
-    lease_add_extradata(lease, option_ptr(opt, 0), option_len(opt), 0); 
+    lease_add_extradata(lease, option_ptr(opt, 0), option_len(opt), 0);
 }
 #endif
 
-static void log_packet(char *type, void *addr, unsigned char *ext_mac, 
-		       int mac_len, char *interface, char *string, char *err, u32 xid)
+static void log_packet(char *type, void *addr, unsigned char *ext_mac,
+                       int mac_len, char *interface, char *string, char *err,
+                       u32 xid)
 {
   struct in_addr a;
- 
+
   if (!err && !option_bool(OPT_LOG_OPTS) && option_bool(OPT_QUIET_DHCP))
     return;
-  
+
   /* addr may be misaligned */
   if (addr)
     memcpy(&a, addr, sizeof(a));
-  
+
   print_mac(daemon->namebuff, ext_mac, mac_len);
-  
-  if(option_bool(OPT_LOG_OPTS))
-     my_syslog(MS_DHCP | LOG_INFO, "%u %s(%s) %s%s%s %s%s",
-	       ntohl(xid), 
-	       type,
-	       interface, 
-	       addr ? inet_ntoa(a) : "",
-	       addr ? " " : "",
-	       daemon->namebuff,
-	       string ? string : "",
-	       err ? err : "");
+
+  if (option_bool(OPT_LOG_OPTS))
+    my_syslog(MS_DHCP | LOG_INFO, "%u %s(%s) %s%s%s %s%s",
+              ntohl(xid),
+              type,
+              interface,
+              addr ? inet_ntoa(a) : "",
+              addr ? " " : "",
+              daemon->namebuff, string ? string : "", err ? err : "");
   else
     my_syslog(MS_DHCP | LOG_INFO, "%s(%s) %s%s%s %s%s",
-	      type,
-	      interface, 
-	      addr ? inet_ntoa(a) : "",
-	      addr ? " " : "",
-	      daemon->namebuff,
-	      string ? string : "",
-	      err ? err : "");
+              type,
+              interface,
+              addr ? inet_ntoa(a) : "",
+              addr ? " " : "",
+              daemon->namebuff, string ? string : "", err ? err : "");
 }
 
 static void log_options(unsigned char *start, u32 xid)
 {
-  while (*start != OPTION_END)
-    {
-      char *optname = option_string(AF_INET, start[0], option_ptr(start, 0), option_len(start), daemon->namebuff, MAXDNAME);
-      
-      my_syslog(MS_DHCP | LOG_INFO, "%u sent size:%3d option:%3d %s  %s", 
-		ntohl(xid), option_len(start), start[0], optname, daemon->namebuff);
-      start += start[1] + 2;
-    }
+  while (*start != OPTION_END) {
+    char *optname =
+        option_string(AF_INET, start[0], option_ptr(start, 0),
+                      option_len(start), daemon->namebuff, MAXDNAME);
+
+    my_syslog(MS_DHCP | LOG_INFO, "%u sent size:%3d option:%3d %s  %s",
+              ntohl(xid), option_len(start), start[0], optname,
+              daemon->namebuff);
+    start += start[1] + 2;
+  }
 }
 
-static unsigned char *option_find1(unsigned char *p, unsigned char *end, int opt, int minsize)
-{
-  while (1) 
-    {
-      if (p >= end)
-	return NULL;
-      else if (*p == OPTION_END)
-	return opt == OPTION_END ? p : NULL;
-      else if (*p == OPTION_PAD)
-	p++;
-      else 
-	{ 
-	  int opt_len;
-	  if (p > end - 2)
-	    return NULL; /* malformed packet */
-	  opt_len = option_len(p);
-	  if (p > end - (2 + opt_len))
-	    return NULL; /* malformed packet */
-	  if (*p == opt && opt_len >= minsize)
-	    return p;
-	  p += opt_len + 2;
-	}
+static unsigned char *option_find1(unsigned char *p, unsigned char *end,
+                                   int opt, int minsize)
+{
+  while (1) {
+    if (p >= end)
+      return NULL;
+    else if (*p == OPTION_END)
+      return opt == OPTION_END ? p : NULL;
+    else if (*p == OPTION_PAD)
+      p++;
+    else {
+      int opt_len;
+      if (p > end - 2)
+        return NULL;            /* malformed packet */
+      opt_len = option_len(p);
+      if (p > end - (2 + opt_len))
+        return NULL;            /* malformed packet */
+      if (*p == opt && opt_len >= minsize)
+        return p;
+      p += opt_len + 2;
     }
+  }
 }
- 
-static unsigned char *option_find(struct dhcp_packet *mess, size_t size, int opt_type, int minsize)
+
+static unsigned char *option_find(struct dhcp_packet *mess, size_t size,
+                                  int opt_type, int minsize)
 {
   unsigned char *ret, *overload;
-  
+
   /* skip over DHCP cookie; */
-  if ((ret = option_find1(&mess->options[0] + sizeof(u32), ((unsigned char *)mess) + size, opt_type, minsize)))
+  if ((ret =
+       option_find1(&mess->options[0] + sizeof(u32),
+                    ((unsigned char *) mess) + size, opt_type, minsize)))
     return ret;
 
   /* look for overload option. */
-  if (!(overload = option_find1(&mess->options[0] + sizeof(u32), ((unsigned char *)mess) + size, OPTION_OVERLOAD, 1)))
+  if (!
+      (overload =
+       option_find1(&mess->options[0] + sizeof(u32),
+                    ((unsigned char *) mess) + size, OPTION_OVERLOAD, 1)))
     return NULL;
-  
+
   /* Can we look in filename area ? */
   if ((overload[2] & 1) &&
       (ret = option_find1(&mess->file[0], &mess->file[128], opt_type, minsize)))
@@ -1679,7 +1666,8 @@
 
   /* finally try sname area */
   if ((overload[2] & 2) &&
-      (ret = option_find1(&mess->sname[0], &mess->sname[64], opt_type, minsize)))
+      (ret =
+       option_find1(&mess->sname[0], &mess->sname[64], opt_type, minsize)))
     return ret;
 
   return NULL;
@@ -1687,7 +1675,7 @@
 
 static struct in_addr option_addr(unsigned char *opt)
 {
-   /* this worries about unaligned data in the option. */
+  /* this worries about unaligned data in the option. */
   /* struct in_addr is network byte order */
   struct in_addr ret;
 
@@ -1702,7 +1690,7 @@
   unsigned int ret = 0;
   int i;
   unsigned char *p = option_ptr(opt, offset);
-  
+
   for (i = 0; i < size; i++)
     ret = (ret << 8) | *p++;
 
@@ -1716,151 +1704,147 @@
   return start;
 }
 
-/* only for use when building packet: doesn't check for bad data. */ 
+/* only for use when building packet: doesn't check for bad data. */
 static unsigned char *find_overload(struct dhcp_packet *mess)
 {
   unsigned char *p = &mess->options[0] + sizeof(u32);
-  
-  while (*p != 0)
-    {
-      if (*p == OPTION_OVERLOAD)
-	return p;
-      p += p[1] + 2;
-    }
+
+  while (*p != 0) {
+    if (*p == OPTION_OVERLOAD)
+      return p;
+    p += p[1] + 2;
+  }
   return NULL;
 }
 
-static size_t dhcp_packet_size(struct dhcp_packet *mess, unsigned char *agent_id, unsigned char *real_end)
+static size_t dhcp_packet_size(struct dhcp_packet *mess,
+                               unsigned char *agent_id, unsigned char *real_end)
 {
   unsigned char *p = dhcp_skip_opts(&mess->options[0] + sizeof(u32));
   unsigned char *overload;
   size_t ret;
-  
+
   /* move agent_id back down to the end of the packet */
-  if (agent_id)
-    {
-      memmove(p, agent_id, real_end - agent_id);
-      p += real_end - agent_id;
-      memset(p, 0, real_end - p); /* in case of overlap */
-    }
-  
+  if (agent_id) {
+    memmove(p, agent_id, real_end - agent_id);
+    p += real_end - agent_id;
+    memset(p, 0, real_end - p); /* in case of overlap */
+  }
+
   /* add END options to the regions. */
   overload = find_overload(mess);
-  
-  if (overload && (option_uint(overload, 0, 1) & 1))
-    {
-      *dhcp_skip_opts(mess->file) = OPTION_END;
-      if (option_bool(OPT_LOG_OPTS))
-	log_options(mess->file, mess->xid);
-    }
-  else if (option_bool(OPT_LOG_OPTS) && strlen((char *)mess->file) != 0)
-    my_syslog(MS_DHCP | LOG_INFO, _("%u bootfile name: %s"), ntohl(mess->xid), (char *)mess->file);
-  
-  if (overload && (option_uint(overload, 0, 1) & 2))
-    {
-      *dhcp_skip_opts(mess->sname) = OPTION_END;
-      if (option_bool(OPT_LOG_OPTS))
-	log_options(mess->sname, mess->xid);
-    }
-  else if (option_bool(OPT_LOG_OPTS) && strlen((char *)mess->sname) != 0)
-    my_syslog(MS_DHCP | LOG_INFO, _("%u server name: %s"), ntohl(mess->xid), (char *)mess->sname);
+
+  if (overload && (option_uint(overload, 0, 1) & 1)) {
+    *dhcp_skip_opts(mess->file) = OPTION_END;
+    if (option_bool(OPT_LOG_OPTS))
+      log_options(mess->file, mess->xid);
+  } else if (option_bool(OPT_LOG_OPTS) && strlen((char *) mess->file) != 0)
+    my_syslog(MS_DHCP | LOG_INFO, _("%u bootfile name: %s"), ntohl(mess->xid),
+              (char *) mess->file);
+
+  if (overload && (option_uint(overload, 0, 1) & 2)) {
+    *dhcp_skip_opts(mess->sname) = OPTION_END;
+    if (option_bool(OPT_LOG_OPTS))
+      log_options(mess->sname, mess->xid);
+  } else if (option_bool(OPT_LOG_OPTS) && strlen((char *) mess->sname) != 0)
+    my_syslog(MS_DHCP | LOG_INFO, _("%u server name: %s"), ntohl(mess->xid),
+              (char *) mess->sname);
 
 
   *p++ = OPTION_END;
-  
-  if (option_bool(OPT_LOG_OPTS))
-    {
-      if (mess->siaddr.s_addr != 0)
-	my_syslog(MS_DHCP | LOG_INFO, _("%u next server: %s"), ntohl(mess->xid), inet_ntoa(mess->siaddr));
-      
-      if ((mess->flags & htons(0x8000)) && mess->ciaddr.s_addr == 0)
-	my_syslog(MS_DHCP | LOG_INFO, _("%u broadcast response"), ntohl(mess->xid));
-      
-      log_options(&mess->options[0] + sizeof(u32), mess->xid);
-    } 
-  
-  ret = (size_t)(p - (unsigned char *)mess);
-  
+
+  if (option_bool(OPT_LOG_OPTS)) {
+    if (mess->siaddr.s_addr != 0)
+      my_syslog(MS_DHCP | LOG_INFO, _("%u next server: %s"), ntohl(mess->xid),
+                inet_ntoa(mess->siaddr));
+
+    if ((mess->flags & htons(0x8000)) && mess->ciaddr.s_addr == 0)
+      my_syslog(MS_DHCP | LOG_INFO, _("%u broadcast response"),
+                ntohl(mess->xid));
+
+    log_options(&mess->options[0] + sizeof(u32), mess->xid);
+  }
+
+  ret = (size_t) (p - (unsigned char *) mess);
+
   if (ret < MIN_PACKETSZ)
     ret = MIN_PACKETSZ;
-  
+
   return ret;
 }
 
-static unsigned char *free_space(struct dhcp_packet *mess, unsigned char *end, int opt, int len)
+static unsigned char *free_space(struct dhcp_packet *mess, unsigned char *end,
+                                 int opt, int len)
 {
   unsigned char *p = dhcp_skip_opts(&mess->options[0] + sizeof(u32));
-  
+
   if (p + len + 3 >= end)
     /* not enough space in options area, try and use overload, if poss */
-    {
-      unsigned char *overload;
-      
-      if (!(overload = find_overload(mess)) &&
-	  (mess->file[0] == 0 || mess->sname[0] == 0))
-	{
-	  /* attempt to overload fname and sname areas, we've reserved space for the
-	     overflow option previuously. */
-	  overload = p;
-	  *(p++) = OPTION_OVERLOAD;
-	  *(p++) = 1;
-	}
-      
-      p = NULL;
-      
-      /* using filename field ? */
-      if (overload)
-	{
-	  if (mess->file[0] == 0)
-	    overload[2] |= 1;
-	  
-	  if (overload[2] & 1)
-	    {
-	      p = dhcp_skip_opts(mess->file);
-	      if (p + len + 3 >= mess->file + sizeof(mess->file))
-		p = NULL;
-	    }
-	  
-	  if (!p)
-	    {
-	      /* try to bring sname into play (it may be already) */
-	      if (mess->sname[0] == 0)
-		overload[2] |= 2;
-	      
-	      if (overload[2] & 2)
-		{
-		  p = dhcp_skip_opts(mess->sname);
-		  if (p + len + 3 >= mess->sname + sizeof(mess->sname))
-		    p = NULL;
-		}
-	    }
-	}
-      
-      if (!p)
-	my_syslog(MS_DHCP | LOG_WARNING, _("cannot send DHCP/BOOTP option %d: no space left in packet"), opt);
-    }
- 
-  if (p)
-    {
-      *(p++) = opt;
-      *(p++) = len;
+  {
+    unsigned char *overload;
+
+    if (!(overload = find_overload(mess)) &&
+        (mess->file[0] == 0 || mess->sname[0] == 0)) {
+      /* attempt to overload fname and sname areas, we've reserved space for the
+         overflow option previuously. */
+      overload = p;
+      *(p++) = OPTION_OVERLOAD;
+      *(p++) = 1;
+    }
+
+    p = NULL;
+
+    /* using filename field ? */
+    if (overload) {
+      if (mess->file[0] == 0)
+        overload[2] |= 1;
+
+      if (overload[2] & 1) {
+        p = dhcp_skip_opts(mess->file);
+        if (p + len + 3 >= mess->file + sizeof(mess->file))
+          p = NULL;
+      }
+
+      if (!p) {
+        /* try to bring sname into play (it may be already) */
+        if (mess->sname[0] == 0)
+          overload[2] |= 2;
+
+        if (overload[2] & 2) {
+          p = dhcp_skip_opts(mess->sname);
+          if (p + len + 3 >= mess->sname + sizeof(mess->sname))
+            p = NULL;
+        }
+      }
     }
 
+    if (!p)
+      my_syslog(MS_DHCP | LOG_WARNING,
+                _("cannot send DHCP/BOOTP option %d: no space left in packet"),
+                opt);
+  }
+
+  if (p) {
+    *(p++) = opt;
+    *(p++) = len;
+  }
+
   return p;
 }
-	      
-static void option_put(struct dhcp_packet *mess, unsigned char *end, int opt, int len, unsigned int val)
+
+static void option_put(struct dhcp_packet *mess, unsigned char *end, int opt,
+                       int len, unsigned int val)
 {
   int i;
   unsigned char *p = free_space(mess, end, opt, len);
-  
-  if (p) 
+
+  if (p)
     for (i = 0; i < len; i++)
       *(p++) = val >> (8 * (len - (i + 1)));
 }
 
-static void option_put_string(struct dhcp_packet *mess, unsigned char *end, int opt, 
-			      char *string, int null_term)
+static void option_put_string(struct dhcp_packet *mess, unsigned char *end,
+                              int opt, char *string, int null_term)
 {
   unsigned char *p;
   size_t len = strlen(string);
@@ -1873,33 +1857,30 @@
 }
 
 /* return length, note this only does the data part */
-static int do_opt(struct dhcp_opt *opt, unsigned char *p, struct dhcp_context *context, int null_term)
+static int do_opt(struct dhcp_opt *opt, unsigned char *p,
+                  struct dhcp_context *context, int null_term)
 {
   int len = opt->len;
-  
+
   if ((opt->flags & DHOPT_STRING) && null_term && len != 255)
     len++;
 
-  if (p && len != 0)
-    {
-      if (context && (opt->flags & DHOPT_ADDR))
-	{
-	  int j;
-	  struct in_addr *a = (struct in_addr *)opt->val;
-	  for (j = 0; j < opt->len; j+=INADDRSZ, a++)
-	    {
-	      /* zero means "self" (but not in vendorclass options.) */
-	      if (a->s_addr == 0)
-		memcpy(p, &context->local, INADDRSZ);
-	      else
-		memcpy(p, a, INADDRSZ);
-	      p += INADDRSZ;
-	    }
-	}
-      else
-	/* empty string may be extended to "\0" by null_term */
-	memcpy(p, opt->val ? opt->val : (unsigned char *)"", len);
-    }  
+  if (p && len != 0) {
+    if (context && (opt->flags & DHOPT_ADDR)) {
+      int j;
+      struct in_addr *a = (struct in_addr *) opt->val;
+      for (j = 0; j < opt->len; j += INADDRSZ, a++) {
+        /* zero means "self" (but not in vendorclass options.) */
+        if (a->s_addr == 0)
+          memcpy(p, &context->local, INADDRSZ);
+        else
+          memcpy(p, a, INADDRSZ);
+        p += INADDRSZ;
+      }
+    } else
+      /* empty string may be extended to "\0" by null_term */
+      memcpy(p, opt->val ? opt->val : (unsigned char *) "", len);
+  }
   return len;
 }
 
@@ -1907,10 +1888,10 @@
 {
   int i;
 
-   /* If no requested options, send everything, not nothing. */
+  /* If no requested options, send everything, not nothing. */
   if (!list)
     return 1;
-  
+
   for (i = 0; list[i] != OPTION_END; i++)
     if (opt == list[i])
       return 1;
@@ -1921,11 +1902,11 @@
 static struct dhcp_opt *option_find2(int opt)
 {
   struct dhcp_opt *opts;
-  
+
   for (opts = daemon->dhcp_opts; opts; opts = opts->next)
     if (opts->opt == opt && (opts->flags & DHOPT_TAGOK))
       return opts;
-  
+
   return NULL;
 }
 
@@ -1933,73 +1914,67 @@
    config-supplied vendor class */
 static void match_vendor_opts(unsigned char *opt, struct dhcp_opt *dopt)
 {
-  for (; dopt; dopt = dopt->next)
-    {
-      dopt->flags &= ~DHOPT_VENDOR_MATCH;
-      if (opt && (dopt->flags & DHOPT_VENDOR))
-	{
-	  int i, len = 0;
-	  if (dopt->u.vendor_class)
-	    len = strlen((char *)dopt->u.vendor_class);
-	  for (i = 0; i <= (option_len(opt) - len); i++)
-	    if (len == 0 || memcmp(dopt->u.vendor_class, option_ptr(opt, i), len) == 0)
-	      {
-		dopt->flags |= DHOPT_VENDOR_MATCH;
-		break;
-	      }
-	}
-    }
-}
-
-static int do_encap_opts(struct dhcp_opt *opt, int encap, int flag,  
-			 struct dhcp_packet *mess, unsigned char *end, int null_term)
+  for (; dopt; dopt = dopt->next) {
+    dopt->flags &= ~DHOPT_VENDOR_MATCH;
+    if (opt && (dopt->flags & DHOPT_VENDOR)) {
+      int i, len = 0;
+      if (dopt->u.vendor_class)
+        len = strlen((char *) dopt->u.vendor_class);
+      for (i = 0; i <= (option_len(opt) - len); i++)
+        if (len == 0
+            || memcmp(dopt->u.vendor_class, option_ptr(opt, i), len) == 0) {
+          dopt->flags |= DHOPT_VENDOR_MATCH;
+          break;
+        }
+    }
+  }
+}
+
+static int do_encap_opts(struct dhcp_opt *opt, int encap, int flag,
+                         struct dhcp_packet *mess, unsigned char *end,
+                         int null_term)
 {
   int len, enc_len, ret = 0;
   struct dhcp_opt *start;
   unsigned char *p;
-    
+
   /* find size in advance */
   for (enc_len = 0, start = opt; opt; opt = opt->next)
-    if (opt->flags & flag)
-      {
-	int new = do_opt(opt, NULL, NULL, null_term) + 2;
-	ret  = 1;
-	if (enc_len + new <= 255)
-	  enc_len += new;
-	else
-	  {
-	    p = free_space(mess, end, encap, enc_len);
-	    for (; start && start != opt; start = start->next)
-	      if (p && (start->flags & flag))
-		{
-		  len = do_opt(start, p + 2, NULL, null_term);
-		  *(p++) = start->opt;
-		  *(p++) = len;
-		  p += len;
-		}
-	    enc_len = new;
-	    start = opt;
-	  }
-      }
-  
-  if (enc_len != 0 &&
-      (p = free_space(mess, end, encap, enc_len + 1)))
-    {
-      for (; start; start = start->next)
-	if (start->flags & flag)
-	  {
-	    len = do_opt(start, p + 2, NULL, null_term);
-	    *(p++) = start->opt;
-	    *(p++) = len;
-	    p += len;
-	  }
-      *p = OPTION_END;
+    if (opt->flags & flag) {
+      int new = do_opt(opt, NULL, NULL, null_term) + 2;
+      ret = 1;
+      if (enc_len + new <= 255)
+        enc_len += new;
+      else {
+        p = free_space(mess, end, encap, enc_len);
+        for (; start && start != opt; start = start->next)
+          if (p && (start->flags & flag)) {
+            len = do_opt(start, p + 2, NULL, null_term);
+            *(p++) = start->opt;
+            *(p++) = len;
+            p += len;
+          }
+        enc_len = new;
+        start = opt;
+      }
     }
 
+  if (enc_len != 0 && (p = free_space(mess, end, encap, enc_len + 1))) {
+    for (; start; start = start->next)
+      if (start->flags & flag) {
+        len = do_opt(start, p + 2, NULL, null_term);
+        *(p++) = start->opt;
+        *(p++) = len;
+        p += len;
+      }
+    *p = OPTION_END;
+  }
+
   return ret;
 }
 
-static void pxe_misc(struct dhcp_packet *mess, unsigned char *end, unsigned char *uuid)
+static void pxe_misc(struct dhcp_packet *mess, unsigned char *end,
+                     unsigned char *uuid)
 {
   unsigned char *p;
 
@@ -2015,13 +1990,12 @@
 
   /* prune vendor-encapsulated options based on netid, and look if we're forcing them to be sent */
   for (opt = daemon->dhcp_opts; opt; opt = opt->next)
-    if (opt->flags & DHOPT_VENDOR_MATCH)
-      {
-	if (!match_netid(opt->netid, netid, 1))
-	  opt->flags &= ~DHOPT_VENDOR_MATCH;
-	else if (opt->flags & DHOPT_FORCE)
-	  force = 1;
-      }
+    if (opt->flags & DHOPT_VENDOR_MATCH) {
+      if (!match_netid(opt->netid, netid, 1))
+        opt->flags &= ~DHOPT_VENDOR_MATCH;
+      else if (opt->flags & DHOPT_FORCE)
+        force = 1;
+    }
   return force;
 }
 
@@ -2031,175 +2005,169 @@
    and jamb the data direct into the DHCP file, siaddr and sname fields.
    Note that in this case, we have to assume that layer zero would be requested
    by the client PXE stack. */
-static int pxe_uefi_workaround(int pxe_arch, struct dhcp_netid *netid, struct dhcp_packet *mess, struct in_addr local, time_t now, int pxe)
+static int pxe_uefi_workaround(int pxe_arch, struct dhcp_netid *netid,
+                               struct dhcp_packet *mess, struct in_addr local,
+                               time_t now, int pxe)
 {
   struct pxe_service *service, *found;
 
   /* Only workaround UEFI archs. */
   if (pxe_arch < 6)
     return 0;
-  
-  for (found = NULL, service = daemon->pxe_services; service; service = service->next)
-    if (pxe_arch == service->CSA && service->basename && match_netid(service->netid, netid, 1))
-      {
-	if (found)
-	  return 0; /* More than one relevant menu item */
-	  
-	found = service;
-      }
+
+  for (found = NULL, service = daemon->pxe_services; service;
+       service = service->next)
+    if (pxe_arch == service->CSA && service->basename
+        && match_netid(service->netid, netid, 1)) {
+      if (found)
+        return 0;               /* More than one relevant menu item */
+
+      found = service;
+    }
 
   if (!found)
-    return 0; /* No relevant menu items. */
-  
+    return 0;                   /* No relevant menu items. */
+
   if (!pxe)
-     return 1;
-  
-  if (found->sname)
-    {
-      mess->siaddr = a_record_from_hosts(found->sname, now);
-      snprintf((char *)mess->sname, sizeof(mess->sname), "%s", found->sname);
-    }
-  else 
-    {
-      if (found->server.s_addr != 0)
-	mess->siaddr = found->server; 
-      else
-	mess->siaddr = local;
-  
-      inet_ntop(AF_INET, &mess->siaddr, (char *)mess->sname, INET_ADDRSTRLEN);
-    }
-  
-  snprintf((char *)mess->file, sizeof(mess->file), 
-	   strchr(found->basename, '.') ? "%s" : "%s.0", found->basename);
-  
+    return 1;
+
+  if (found->sname) {
+    mess->siaddr = a_record_from_hosts(found->sname, now);
+    snprintf((char *) mess->sname, sizeof(mess->sname), "%s", found->sname);
+  } else {
+    if (found->server.s_addr != 0)
+      mess->siaddr = found->server;
+    else
+      mess->siaddr = local;
+
+    inet_ntop(AF_INET, &mess->siaddr, (char *) mess->sname, INET_ADDRSTRLEN);
+  }
+
+  snprintf((char *) mess->file, sizeof(mess->file),
+           strchr(found->basename, '.') ? "%s" : "%s.0", found->basename);
+
   return 1;
 }
 
-static struct dhcp_opt *pxe_opts(int pxe_arch, struct dhcp_netid *netid, struct in_addr local, time_t now)
+static struct dhcp_opt *pxe_opts(int pxe_arch, struct dhcp_netid *netid,
+                                 struct in_addr local, time_t now)
 {
-#define NUM_OPTS 4  
+#define NUM_OPTS 4
 
-  unsigned  char *p, *q;
+  unsigned char *p, *q;
   struct pxe_service *service;
   static struct dhcp_opt *o, *ret;
   int i, j = NUM_OPTS - 1;
   struct in_addr boot_server;
-  
+
   /* We pass back references to these, hence they are declared static */
   static unsigned char discovery_control;
-  static unsigned char fake_prompt[] = { 0, 'P', 'X', 'E' }; 
+  static unsigned char fake_prompt[] = { 0, 'P', 'X', 'E' };
   static struct dhcp_opt *fake_opts = NULL;
-  
+
   /* Disable multicast, since we don't support it, and broadcast
      unless we need it */
   discovery_control = 3;
-  
+
   ret = daemon->dhcp_opts;
-  
-  if (!fake_opts && !(fake_opts = whine_malloc(NUM_OPTS * sizeof(struct dhcp_opt))))
+
+  if (!fake_opts
+      && !(fake_opts = whine_malloc(NUM_OPTS * sizeof(struct dhcp_opt))))
     return ret;
 
-  for (i = 0; i < NUM_OPTS; i++)
-    {
-      fake_opts[i].flags = DHOPT_VENDOR_MATCH;
-      fake_opts[i].netid = NULL;
-      fake_opts[i].next = i == (NUM_OPTS - 1) ? ret : &fake_opts[i+1];
-    }
-  
+  for (i = 0; i < NUM_OPTS; i++) {
+    fake_opts[i].flags = DHOPT_VENDOR_MATCH;
+    fake_opts[i].netid = NULL;
+    fake_opts[i].next = i == (NUM_OPTS - 1) ? ret : &fake_opts[i + 1];
+  }
+
   /* create the data for the PXE_MENU and PXE_SERVERS options. */
-  p = (unsigned char *)daemon->dhcp_buff;
-  q = (unsigned char *)daemon->dhcp_buff3;
+  p = (unsigned char *) daemon->dhcp_buff;
+  q = (unsigned char *) daemon->dhcp_buff3;
 
   for (i = 0, service = daemon->pxe_services; service; service = service->next)
-    if (pxe_arch == service->CSA && match_netid(service->netid, netid, 1))
-      {
-	size_t len = strlen(service->menu);
-	/* opt 43 max size is 255. encapsulated option has type and length
-	   bytes, so its max size is 253. */
-	if (p - (unsigned char *)daemon->dhcp_buff + len + 3 < 253)
-	  {
-	    *(p++) = service->type >> 8;
-	    *(p++) = service->type;
-	    *(p++) = len;
-	    memcpy(p, service->menu, len);
-	    p += len;
-	    i++;
-	  }
-	else
-	  {
-	  toobig:
-	    my_syslog(MS_DHCP | LOG_ERR, _("PXE menu too large"));
-	    return daemon->dhcp_opts;
-	  }
-	
-	boot_server = service->basename ? local : 
-	  (service->sname ? a_record_from_hosts(service->sname, now) : service->server);
-	
-	if (boot_server.s_addr != 0)
-	  {
-	    if (q - (unsigned char *)daemon->dhcp_buff3 + 3 + INADDRSZ >= 253)
-	      goto toobig;
-	    
-	    /* Boot service with known address - give it */
-	    *(q++) = service->type >> 8;
-	    *(q++) = service->type;
-	    *(q++) = 1;
-	    /* dest misaligned */
-	    memcpy(q, &boot_server.s_addr, INADDRSZ);
-	    q += INADDRSZ;
-	  }
-	else if (service->type != 0)
-	  /* We don't know the server for a service type, so we'll
-	     allow the client to broadcast for it */
-	  discovery_control = 2;
+    if (pxe_arch == service->CSA && match_netid(service->netid, netid, 1)) {
+      size_t len = strlen(service->menu);
+      /* opt 43 max size is 255. encapsulated option has type and length
+         bytes, so its max size is 253. */
+      if (p - (unsigned char *) daemon->dhcp_buff + len + 3 < 253) {
+        *(p++) = service->type >> 8;
+        *(p++) = service->type;
+        *(p++) = len;
+        memcpy(p, service->menu, len);
+        p += len;
+        i++;
+      } else {
+      toobig:
+        my_syslog(MS_DHCP | LOG_ERR, _("PXE menu too large"));
+        return daemon->dhcp_opts;
       }
 
+      boot_server = service->basename ? local :
+          (service->sname ? a_record_from_hosts(service->sname, now) : service->
+           server);
+
+      if (boot_server.s_addr != 0) {
+        if (q - (unsigned char *) daemon->dhcp_buff3 + 3 + INADDRSZ >= 253)
+          goto toobig;
+
+        /* Boot service with known address - give it */
+        *(q++) = service->type >> 8;
+        *(q++) = service->type;
+        *(q++) = 1;
+        /* dest misaligned */
+        memcpy(q, &boot_server.s_addr, INADDRSZ);
+        q += INADDRSZ;
+      } else if (service->type != 0)
+        /* We don't know the server for a service type, so we'll
+           allow the client to broadcast for it */
+        discovery_control = 2;
+    }
+
   /* if no prompt, wait forever if there's a choice */
   fake_prompt[0] = (i > 1) ? 255 : 0;
-  
+
   if (i == 0)
-    discovery_control = 8; /* no menu - just use use mess->filename */
-  else
-    {
+    discovery_control = 8;      /* no menu - just use use mess->filename */
+  else {
+    ret = &fake_opts[j--];
+    ret->len = p - (unsigned char *) daemon->dhcp_buff;
+    ret->val = (unsigned char *) daemon->dhcp_buff;
+    ret->opt = SUBOPT_PXE_MENU;
+
+    if (q - (unsigned char *) daemon->dhcp_buff3 != 0) {
       ret = &fake_opts[j--];
-      ret->len = p - (unsigned char *)daemon->dhcp_buff;
-      ret->val = (unsigned char *)daemon->dhcp_buff;
-      ret->opt = SUBOPT_PXE_MENU;
-
-      if (q - (unsigned char *)daemon->dhcp_buff3 != 0)
-	{
-	  ret = &fake_opts[j--]; 
-	  ret->len = q - (unsigned char *)daemon->dhcp_buff3;
-	  ret->val = (unsigned char *)daemon->dhcp_buff3;
-	  ret->opt = SUBOPT_PXE_SERVERS;
-	}
+      ret->len = q - (unsigned char *) daemon->dhcp_buff3;
+      ret->val = (unsigned char *) daemon->dhcp_buff3;
+      ret->opt = SUBOPT_PXE_SERVERS;
     }
+  }
 
   for (o = daemon->dhcp_opts; o; o = o->next)
     if ((o->flags & DHOPT_VENDOR_MATCH) && o->opt == SUBOPT_PXE_MENU_PROMPT)
       break;
-  
-  if (!o)
-    {
-      ret = &fake_opts[j--]; 
-      ret->len = sizeof(fake_prompt);
-      ret->val = fake_prompt;
-      ret->opt = SUBOPT_PXE_MENU_PROMPT;
-    }
-  
-  ret = &fake_opts[j--]; 
+
+  if (!o) {
+    ret = &fake_opts[j--];
+    ret->len = sizeof(fake_prompt);
+    ret->val = fake_prompt;
+    ret->opt = SUBOPT_PXE_MENU_PROMPT;
+  }
+
+  ret = &fake_opts[j--];
   ret->len = 1;
   ret->opt = SUBOPT_PXE_DISCOVERY;
-  ret->val= &discovery_control;
- 
+  ret->val = &discovery_control;
+
   return ret;
 }
-  
+
 static void clear_packet(struct dhcp_packet *mess, unsigned char *end)
 {
   memset(mess->sname, 0, sizeof(mess->sname));
   memset(mess->file, 0, sizeof(mess->file));
-  memset(&mess->options[0] + sizeof(u32), 0, end - (&mess->options[0] + sizeof(u32)));
+  memset(&mess->options[0] + sizeof(u32), 0,
+         end - (&mess->options[0] + sizeof(u32)));
   mess->siaddr.s_addr = 0;
 }
 
@@ -2215,26 +2183,24 @@
     /* No match, look for one without a netid */
     for (boot = daemon->boot_config; boot; boot = boot->next)
       if (match_netid(boot->netid, netid, 1))
-	break;
+        break;
 
   return boot;
 }
 
 static void do_options(struct dhcp_context *context,
-		       struct dhcp_packet *mess,
-		       unsigned char *end, 
-		       unsigned char *req_options,
-		       char *hostname, 
-		       char *domain,
-		       struct dhcp_netid *netid,
-		       struct in_addr subnet_addr,
-		       unsigned char fqdn_flags,
-		       int null_term, int pxe_arch,
-		       unsigned char *uuid,
-		       int vendor_class_len,
-		       time_t now,
-		       unsigned int lease_time,
-		       unsigned short fuzz)
+                       struct dhcp_packet *mess,
+                       unsigned char *end,
+                       unsigned char *req_options,
+                       char *hostname,
+                       char *domain,
+                       struct dhcp_netid *netid,
+                       struct in_addr subnet_addr,
+                       unsigned char fqdn_flags,
+                       int null_term, int pxe_arch,
+                       unsigned char *uuid,
+                       int vendor_class_len,
+                       time_t now, unsigned int lease_time, unsigned short fuzz)
 {
   struct dhcp_opt *opt, *config_opts = daemon->dhcp_opts;
   struct dhcp_boot *boot;
@@ -2249,107 +2215,97 @@
   /* filter options based on tags, those we want get DHOPT_TAGOK bit set */
   if (context)
     context->netid.next = NULL;
-  tagif = option_filter(netid, context && context->netid.net ? &context->netid : NULL, config_opts);
-	
+  tagif = option_filter(netid, context
+                        && context->netid.net ? &context->netid : NULL,
+                        config_opts);
+
   /* logging */
-  if (option_bool(OPT_LOG_OPTS) && req_options)
-    {
-      char *q = daemon->namebuff;
-      for (i = 0; req_options[i] != OPTION_END; i++)
-	{
-	  char *s = option_string(AF_INET, req_options[i], NULL, 0, NULL, 0);
-	  q += snprintf(q, MAXDNAME - (q - daemon->namebuff),
-			"%d%s%s%s", 
-			req_options[i],
-			strlen(s) != 0 ? ":" : "",
-			s, 
-			req_options[i+1] == OPTION_END ? "" : ", ");
-	  if (req_options[i+1] == OPTION_END || (q - daemon->namebuff) > 40)
-	    {
-	      q = daemon->namebuff;
-	      my_syslog(MS_DHCP | LOG_INFO, _("%u requested options: %s"), ntohl(mess->xid), daemon->namebuff);
-	    }
-	}
+  if (option_bool(OPT_LOG_OPTS) && req_options) {
+    char *q = daemon->namebuff;
+    for (i = 0; req_options[i] != OPTION_END; i++) {
+      char *s = option_string(AF_INET, req_options[i], NULL, 0, NULL, 0);
+      q += snprintf(q, MAXDNAME - (q - daemon->namebuff),
+                    "%d%s%s%s",
+                    req_options[i],
+                    strlen(s) != 0 ? ":" : "",
+                    s, req_options[i + 1] == OPTION_END ? "" : ", ");
+      if (req_options[i + 1] == OPTION_END || (q - daemon->namebuff) > 40) {
+        q = daemon->namebuff;
+        my_syslog(MS_DHCP | LOG_INFO, _("%u requested options: %s"),
+                  ntohl(mess->xid), daemon->namebuff);
+      }
     }
-      
+  }
+
   for (id_list = daemon->force_broadcast; id_list; id_list = id_list->next)
     if ((!id_list->list) || match_netid(id_list->list, netid, 0))
       break;
   if (id_list)
-    mess->flags |= htons(0x8000); /* force broadcast */
-  
+    mess->flags |= htons(0x8000);       /* force broadcast */
+
   if (context)
     mess->siaddr = context->local;
-  
+
   /* See if we can send the boot stuff as options.
      To do this we need a requested option list, BOOTP
      and very old DHCP clients won't have this, we also 
      provide an manual option to disable it.
      Some PXE ROMs have bugs (surprise!) and need zero-terminated 
      names, so we always send those.  */
-  if ((boot = find_boot(tagif)))
-    {
-      if (boot->sname)
-	{	  
-	  if (!option_bool(OPT_NO_OVERRIDE) &&
-	      req_options && 
-	      in_list(req_options, OPTION_SNAME))
-	    option_put_string(mess, end, OPTION_SNAME, boot->sname, 1);
-	  else
-	    strncpy((char *)mess->sname, boot->sname, sizeof(mess->sname)-1);
-	}
-      
-      if (boot->file)
-	{
-	  if (!option_bool(OPT_NO_OVERRIDE) &&
-	      req_options && 
-	      in_list(req_options, OPTION_FILENAME))
-	    option_put_string(mess, end, OPTION_FILENAME, boot->file, 1);
-	  else
-	    strncpy((char *)mess->file, boot->file, sizeof(mess->file)-1);
-	}
-      
-      if (boot->next_server.s_addr) 
-	mess->siaddr = boot->next_server;
-      else if (boot->tftp_sname)
-	mess->siaddr = a_record_from_hosts(boot->tftp_sname, now);
+  if ((boot = find_boot(tagif))) {
+    if (boot->sname) {
+      if (!option_bool(OPT_NO_OVERRIDE) &&
+          req_options && in_list(req_options, OPTION_SNAME))
+        option_put_string(mess, end, OPTION_SNAME, boot->sname, 1);
+      else
+        strncpy((char *) mess->sname, boot->sname, sizeof(mess->sname) - 1);
     }
-  else
+
+    if (boot->file) {
+      if (!option_bool(OPT_NO_OVERRIDE) &&
+          req_options && in_list(req_options, OPTION_FILENAME))
+        option_put_string(mess, end, OPTION_FILENAME, boot->file, 1);
+      else
+        strncpy((char *) mess->file, boot->file, sizeof(mess->file) - 1);
+    }
+
+    if (boot->next_server.s_addr)
+      mess->siaddr = boot->next_server;
+    else if (boot->tftp_sname)
+      mess->siaddr = a_record_from_hosts(boot->tftp_sname, now);
+  } else
     /* Use the values of the relevant options if no dhcp-boot given and
        they're not explicitly asked for as options. OPTION_END is used
        as an internal way to specify siaddr without using dhcp-boot, for use in
        dhcp-optsfile. */
-    {
-      if ((!req_options || !in_list(req_options, OPTION_FILENAME)) &&
-	  (opt = option_find2(OPTION_FILENAME)) && !(opt->flags & DHOPT_FORCE))
-	{
-	  strncpy((char *)mess->file, (char *)opt->val, sizeof(mess->file)-1);
-	  done_file = 1;
-	}
-      
-      if ((!req_options || !in_list(req_options, OPTION_SNAME)) &&
-	  (opt = option_find2(OPTION_SNAME)) && !(opt->flags & DHOPT_FORCE))
-	{
-	  strncpy((char *)mess->sname, (char *)opt->val, sizeof(mess->sname)-1);
-	  done_server = 1;
-	}
-      
-      if ((opt = option_find2(OPTION_END)))
-	mess->siaddr.s_addr = ((struct in_addr *)opt->val)->s_addr;	
-    }
-        
+  {
+    if ((!req_options || !in_list(req_options, OPTION_FILENAME)) &&
+        (opt = option_find2(OPTION_FILENAME)) && !(opt->flags & DHOPT_FORCE)) {
+      strncpy((char *) mess->file, (char *) opt->val, sizeof(mess->file) - 1);
+      done_file = 1;
+    }
+
+    if ((!req_options || !in_list(req_options, OPTION_SNAME)) &&
+        (opt = option_find2(OPTION_SNAME)) && !(opt->flags & DHOPT_FORCE)) {
+      strncpy((char *) mess->sname, (char *) opt->val, sizeof(mess->sname) - 1);
+      done_server = 1;
+    }
+
+    if ((opt = option_find2(OPTION_END)))
+      mess->siaddr.s_addr = ((struct in_addr *) opt->val)->s_addr;
+  }
+
   /* We don't want to do option-overload for BOOTP, so make the file and sname
      fields look like they are in use, even when they aren't. This gets restored
      at the end of this function. */
 
-  if (!req_options || option_bool(OPT_NO_OVERRIDE))
-    {
-      f0 = mess->file[0];
-      mess->file[0] = 1;
-      s0 = mess->sname[0];
-      mess->sname[0] = 1;
-    }
-      
+  if (!req_options || option_bool(OPT_NO_OVERRIDE)) {
+    f0 = mess->file[0];
+    mess->file[0] = 1;
+    s0 = mess->sname[0];
+    mess->sname[0] = 1;
+  }
+
   /* At this point, if mess->sname or mess->file are zeroed, they are available
      for option overload, reserve space for the overload option. */
   if (mess->file[0] == 0 || mess->sname[0] == 0)
@@ -2357,187 +2313,173 @@
 
   /* rfc3011 says this doesn't need to be in the requested options list. */
   if (subnet_addr.s_addr)
-    option_put(mess, end, OPTION_SUBNET_SELECT, INADDRSZ, ntohl(subnet_addr.s_addr));
-   
-  if (lease_time != 0xffffffff)
-    { 
-      unsigned int t1val = lease_time/2; 
-      unsigned int t2val = (lease_time*7)/8;
-      unsigned int hval;
-      
-      /* If set by user, sanity check, so not longer than lease. */
-      if ((opt = option_find2(OPTION_T1)))
-	{
-	  hval = ntohl(*((unsigned int *)opt->val));
-	  if (hval < lease_time && hval > 2)
-	    t1val = hval;
-	}
-
-       if ((opt = option_find2(OPTION_T2)))
-	{
-	  hval = ntohl(*((unsigned int *)opt->val));
-	  if (hval < lease_time && hval > 2)
-	    t2val = hval;
-	}
-       	  
-       /* ensure T1 is still < T2 */
-       if (t2val <= t1val)
-	 t1val = t2val - 1; 
-
-       while (fuzz > (t1val/8))
-	 fuzz = fuzz/2;
-	 
-       t1val -= fuzz;
-       t2val -= fuzz;
-       
-       option_put(mess, end, OPTION_T1, 4, t1val);
-       option_put(mess, end, OPTION_T2, 4, t2val);
+    option_put(mess, end, OPTION_SUBNET_SELECT, INADDRSZ,
+               ntohl(subnet_addr.s_addr));
+
+  if (lease_time != 0xffffffff) {
+    unsigned int t1val = lease_time / 2;
+    unsigned int t2val = (lease_time * 7) / 8;
+    unsigned int hval;
+
+    /* If set by user, sanity check, so not longer than lease. */
+    if ((opt = option_find2(OPTION_T1))) {
+      hval = ntohl(*((unsigned int *) opt->val));
+      if (hval < lease_time && hval > 2)
+        t1val = hval;
     }
 
-  /* replies to DHCPINFORM may not have a valid context */
-  if (context)
-    {
-      if (!option_find2(OPTION_NETMASK))
-	option_put(mess, end, OPTION_NETMASK, INADDRSZ, ntohl(context->netmask.s_addr));
-  
-      /* May not have a "guessed" broadcast address if we got no packets via a relay
-	 from this net yet (ie just unicast renewals after a restart */
-      if (context->broadcast.s_addr &&
-	  !option_find2(OPTION_BROADCAST))
-	option_put(mess, end, OPTION_BROADCAST, INADDRSZ, ntohl(context->broadcast.s_addr));
-      
-      /* Same comments as broadcast apply, and also may not be able to get a sensible
-	 default when using subnet select.  User must configure by steam in that case. */
-      if (context->router.s_addr &&
-	  in_list(req_options, OPTION_ROUTER) &&
-	  !option_find2(OPTION_ROUTER))
-	option_put(mess, end, OPTION_ROUTER, INADDRSZ, ntohl(context->router.s_addr));
-      
-      if (daemon->port == NAMESERVER_PORT &&
-	  in_list(req_options, OPTION_DNSSERVER) &&
-	  !option_find2(OPTION_DNSSERVER))
-	option_put(mess, end, OPTION_DNSSERVER, INADDRSZ, ntohl(context->local.s_addr));
+    if ((opt = option_find2(OPTION_T2))) {
+      hval = ntohl(*((unsigned int *) opt->val));
+      if (hval < lease_time && hval > 2)
+        t2val = hval;
     }
 
-  if (domain && in_list(req_options, OPTION_DOMAINNAME) && 
+    /* ensure T1 is still < T2 */
+    if (t2val <= t1val)
+      t1val = t2val - 1;
+
+    while (fuzz > (t1val / 8))
+      fuzz = fuzz / 2;
+
+    t1val -= fuzz;
+    t2val -= fuzz;
+
+    option_put(mess, end, OPTION_T1, 4, t1val);
+    option_put(mess, end, OPTION_T2, 4, t2val);
+  }
+
+  /* replies to DHCPINFORM may not have a valid context */
+  if (context) {
+    if (!option_find2(OPTION_NETMASK))
+      option_put(mess, end, OPTION_NETMASK, INADDRSZ,
+                 ntohl(context->netmask.s_addr));
+
+    /* May not have a "guessed" broadcast address if we got no packets via a relay
+       from this net yet (ie just unicast renewals after a restart */
+    if (context->broadcast.s_addr && !option_find2(OPTION_BROADCAST))
+      option_put(mess, end, OPTION_BROADCAST, INADDRSZ,
+                 ntohl(context->broadcast.s_addr));
+
+    /* Same comments as broadcast apply, and also may not be able to get a sensible
+       default when using subnet select.  User must configure by steam in that case. */
+    if (context->router.s_addr &&
+        in_list(req_options, OPTION_ROUTER) && !option_find2(OPTION_ROUTER))
+      option_put(mess, end, OPTION_ROUTER, INADDRSZ,
+                 ntohl(context->router.s_addr));
+
+    if (daemon->port == NAMESERVER_PORT &&
+        in_list(req_options, OPTION_DNSSERVER) &&
+        !option_find2(OPTION_DNSSERVER))
+      option_put(mess, end, OPTION_DNSSERVER, INADDRSZ,
+                 ntohl(context->local.s_addr));
+  }
+
+  if (domain && in_list(req_options, OPTION_DOMAINNAME) &&
       !option_find2(OPTION_DOMAINNAME))
     option_put_string(mess, end, OPTION_DOMAINNAME, domain, null_term);
- 
+
   /* Note that we ignore attempts to set the fqdn using --dhc-option=81,<name> */
-  if (hostname)
-    {
-      if (in_list(req_options, OPTION_HOSTNAME) &&
-	  !option_find2(OPTION_HOSTNAME))
-	option_put_string(mess, end, OPTION_HOSTNAME, hostname, null_term);
-      
-      if (fqdn_flags != 0)
-	{
-	  len = strlen(hostname) + 3;
-	  
-	  if (fqdn_flags & 0x04)
-	    len += 2;
-	  else if (null_term)
-	    len++;
-
-	  if (domain)
-	    len += strlen(domain) + 1;
-	  else if (fqdn_flags & 0x04)
-	    len--;
-
-	  if ((p = free_space(mess, end, OPTION_CLIENT_FQDN, len)))
-	    {
-	      *(p++) = fqdn_flags & 0x0f; /* MBZ bits to zero */ 
-	      *(p++) = 255;
-	      *(p++) = 255;
-
-	      if (fqdn_flags & 0x04)
-		{
-		  p = do_rfc1035_name(p, hostname, NULL);
-		  if (domain)
-		    {
-		      p = do_rfc1035_name(p, domain, NULL);
-		      *p++ = 0;
-		    }
-		}
-	      else
-		{
-		  memcpy(p, hostname, strlen(hostname));
-		  p += strlen(hostname);
-		  if (domain)
-		    {
-		      *(p++) = '.';
-		      memcpy(p, domain, strlen(domain));
-		      p += strlen(domain);
-		    }
-		  if (null_term)
-		    *(p++) = 0;
-		}
-	    }
-	}
-    }      
+  if (hostname) {
+    if (in_list(req_options, OPTION_HOSTNAME) && !option_find2(OPTION_HOSTNAME))
+      option_put_string(mess, end, OPTION_HOSTNAME, hostname, null_term);
 
-  for (opt = config_opts; opt; opt = opt->next)
-    {
-      int optno = opt->opt;
+    if (fqdn_flags != 0) {
+      len = strlen(hostname) + 3;
 
-      /* netids match and not encapsulated? */
-      if (!(opt->flags & DHOPT_TAGOK))
-	continue;
-      
-      /* was it asked for, or are we sending it anyway? */
-      if (!(opt->flags & DHOPT_FORCE) && !in_list(req_options, optno))
-	continue;
-      
-      /* prohibit some used-internally options. T1 and T2 already handled. */
-      if (optno == OPTION_CLIENT_FQDN ||
-	  optno == OPTION_MAXMESSAGE ||
-	  optno == OPTION_OVERLOAD ||
-	  optno == OPTION_PAD ||
-	  optno == OPTION_END ||
-	  optno == OPTION_T1 ||
-	  optno == OPTION_T2)
-	continue;
-
-      if (optno == OPTION_SNAME && done_server)
-	continue;
-
-      if (optno == OPTION_FILENAME && done_file)
-	continue;
-      
-      /* For the options we have default values on
-	 dhc-option=<optionno> means "don't include this option"
-	 not "include a zero-length option" */
-      if (opt->len == 0 && 
-	  (optno == OPTION_NETMASK ||
-	   optno == OPTION_BROADCAST ||
-	   optno == OPTION_ROUTER ||
-	   optno == OPTION_DNSSERVER || 
-	   optno == OPTION_DOMAINNAME ||
-	   optno == OPTION_HOSTNAME))
-	continue;
-
-      /* vendor-class comes from elsewhere for PXE */
-      if (pxe_arch != -1 && optno == OPTION_VENDOR_ID)
-	continue;
-      
-      /* always force null-term for filename and servername - buggy PXE again. */
-      len = do_opt(opt, NULL, context, 
-		   (optno == OPTION_SNAME || optno == OPTION_FILENAME) ? 1 : null_term);
-
-      if ((p = free_space(mess, end, optno, len)))
-	{
-	  do_opt(opt, p, context, 
-		 (optno == OPTION_SNAME || optno == OPTION_FILENAME) ? 1 : null_term);
-	  
-	  /* If we send a vendor-id, revisit which vendor-ops we consider 
-	     it appropriate to send. */
-	  if (optno == OPTION_VENDOR_ID)
-	    {
-	      match_vendor_opts(p - 2, config_opts);
-	      done_vendor_class = 1;
-	    }
-	}  
+      if (fqdn_flags & 0x04)
+        len += 2;
+      else if (null_term)
+        len++;
+
+      if (domain)
+        len += strlen(domain) + 1;
+      else if (fqdn_flags & 0x04)
+        len--;
+
+      if ((p = free_space(mess, end, OPTION_CLIENT_FQDN, len))) {
+        *(p++) = fqdn_flags & 0x0f;     /* MBZ bits to zero */
+        *(p++) = 255;
+        *(p++) = 255;
+
+        if (fqdn_flags & 0x04) {
+          p = do_rfc1035_name(p, hostname, NULL);
+          if (domain) {
+            p = do_rfc1035_name(p, domain, NULL);
+            *p++ = 0;
+          }
+        } else {
+          memcpy(p, hostname, strlen(hostname));
+          p += strlen(hostname);
+          if (domain) {
+            *(p++) = '.';
+            memcpy(p, domain, strlen(domain));
+            p += strlen(domain);
+          }
+          if (null_term)
+            *(p++) = 0;
+        }
+      }
     }
+  }
+
+  for (opt = config_opts; opt; opt = opt->next) {
+    int optno = opt->opt;
+
+    /* netids match and not encapsulated? */
+    if (!(opt->flags & DHOPT_TAGOK))
+      continue;
+
+    /* was it asked for, or are we sending it anyway? */
+    if (!(opt->flags & DHOPT_FORCE) && !in_list(req_options, optno))
+      continue;
+
+    /* prohibit some used-internally options. T1 and T2 already handled. */
+    if (optno == OPTION_CLIENT_FQDN ||
+        optno == OPTION_MAXMESSAGE ||
+        optno == OPTION_OVERLOAD ||
+        optno == OPTION_PAD ||
+        optno == OPTION_END || optno == OPTION_T1 || optno == OPTION_T2)
+      continue;
+
+    if (optno == OPTION_SNAME && done_server)
+      continue;
+
+    if (optno == OPTION_FILENAME && done_file)
+      continue;
+
+    /* For the options we have default values on
+       dhc-option=<optionno> means "don't include this option"
+       not "include a zero-length option" */
+    if (opt->len == 0 &&
+        (optno == OPTION_NETMASK ||
+         optno == OPTION_BROADCAST ||
+         optno == OPTION_ROUTER ||
+         optno == OPTION_DNSSERVER ||
+         optno == OPTION_DOMAINNAME || optno == OPTION_HOSTNAME))
+      continue;
+
+    /* vendor-class comes from elsewhere for PXE */
+    if (pxe_arch != -1 && optno == OPTION_VENDOR_ID)
+      continue;
+
+    /* always force null-term for filename and servername - buggy PXE again. */
+    len = do_opt(opt, NULL, context,
+                 (optno == OPTION_SNAME
+                  || optno == OPTION_FILENAME) ? 1 : null_term);
+
+    if ((p = free_space(mess, end, optno, len))) {
+      do_opt(opt, p, context,
+             (optno == OPTION_SNAME
+              || optno == OPTION_FILENAME) ? 1 : null_term);
+
+      /* If we send a vendor-id, revisit which vendor-ops we consider
+         it appropriate to send. */
+      if (optno == OPTION_VENDOR_ID) {
+        match_vendor_opts(p - 2, config_opts);
+        done_vendor_class = 1;
+      }
+    }
+  }
 
   /* Now send options to be encapsulated in arbitrary options, 
      eg dhcp-option=encap:172,17,.......
@@ -2547,116 +2489,108 @@
      all the options which match each outer in turn. */
   for (opt = config_opts; opt; opt = opt->next)
     opt->flags &= ~DHOPT_ENCAP_DONE;
-  
-  for (opt = config_opts; opt; opt = opt->next)
-    {
-      int flags;
-      
-      if ((flags = (opt->flags & (DHOPT_ENCAPSULATE | DHOPT_RFC3925))))
-	{
-	  int found = 0;
-	  struct dhcp_opt *o;
-
-	  if (opt->flags & DHOPT_ENCAP_DONE)
-	    continue;
-
-	  for (len = 0, o = config_opts; o; o = o->next)
-	    {
-	      int outer = flags & DHOPT_ENCAPSULATE ? o->u.encap : OPTION_VENDOR_IDENT_OPT;
-
-	      o->flags &= ~DHOPT_ENCAP_MATCH;
-	      
-	      if (!(o->flags & flags) || opt->u.encap != o->u.encap)
-		continue;
-	      
-	      o->flags |= DHOPT_ENCAP_DONE;
-	      if (match_netid(o->netid, tagif, 1) &&
-		  ((o->flags & DHOPT_FORCE) || in_list(req_options, outer)))
-		{
-		  o->flags |= DHOPT_ENCAP_MATCH;
-		  found = 1;
-		  len += do_opt(o, NULL, NULL, 0) + 2;
-		}
-	    } 
-	  
-	  if (found)
-	    { 
-	      if (flags & DHOPT_ENCAPSULATE)
-		do_encap_opts(config_opts, opt->u.encap, DHOPT_ENCAP_MATCH, mess, end, null_term);
-	      else if (len > 250)
-		my_syslog(MS_DHCP | LOG_WARNING, _("cannot send RFC3925 option: too many options for enterprise number %d"), opt->u.encap);
-	      else if ((p = free_space(mess, end,  OPTION_VENDOR_IDENT_OPT, len + 5)))
-		{
-		  int swap_ent = htonl(opt->u.encap);
-		  memcpy(p, &swap_ent, 4);
-		  p += 4;
-		  *(p++) = len;
-		  for (o = config_opts; o; o = o->next)
-		    if (o->flags & DHOPT_ENCAP_MATCH)
-		      {
-			len = do_opt(o, p + 2, NULL, 0);
-			*(p++) = o->opt;
-			*(p++) = len;
-			p += len;
-		      }     
-		}
-	    }
-	}
-    }      
 
-  force_encap = prune_vendor_opts(tagif);
-  
-  if (context && pxe_arch != -1)
-    {
-      pxe_misc(mess, end, uuid);
-      if (!pxe_uefi_workaround(pxe_arch, tagif, mess, context->local, now, 0))
-	config_opts = pxe_opts(pxe_arch, tagif, context->local, now);
+  for (opt = config_opts; opt; opt = opt->next) {
+    int flags;
+
+    if ((flags = (opt->flags & (DHOPT_ENCAPSULATE | DHOPT_RFC3925)))) {
+      int found = 0;
+      struct dhcp_opt *o;
+
+      if (opt->flags & DHOPT_ENCAP_DONE)
+        continue;
+
+      for (len = 0, o = config_opts; o; o = o->next) {
+        int outer =
+            flags & DHOPT_ENCAPSULATE ? o->u.encap : OPTION_VENDOR_IDENT_OPT;
+
+        o->flags &= ~DHOPT_ENCAP_MATCH;
+
+        if (!(o->flags & flags) || opt->u.encap != o->u.encap)
+          continue;
+
+        o->flags |= DHOPT_ENCAP_DONE;
+        if (match_netid(o->netid, tagif, 1) &&
+            ((o->flags & DHOPT_FORCE) || in_list(req_options, outer))) {
+          o->flags |= DHOPT_ENCAP_MATCH;
+          found = 1;
+          len += do_opt(o, NULL, NULL, 0) + 2;
+        }
+      }
+
+      if (found) {
+        if (flags & DHOPT_ENCAPSULATE)
+          do_encap_opts(config_opts, opt->u.encap, DHOPT_ENCAP_MATCH, mess, end,
+                        null_term);
+        else if (len > 250)
+          my_syslog(MS_DHCP | LOG_WARNING,
+                    _
+                    ("cannot send RFC3925 option: too many options for enterprise number %d"),
+                    opt->u.encap);
+        else if ((p = free_space(mess, end, OPTION_VENDOR_IDENT_OPT, len + 5))) {
+          int swap_ent = htonl(opt->u.encap);
+          memcpy(p, &swap_ent, 4);
+          p += 4;
+          *(p++) = len;
+          for (o = config_opts; o; o = o->next)
+            if (o->flags & DHOPT_ENCAP_MATCH) {
+              len = do_opt(o, p + 2, NULL, 0);
+              *(p++) = o->opt;
+              *(p++) = len;
+              p += len;
+            }
+        }
+      }
     }
+  }
+
+  force_encap = prune_vendor_opts(tagif);
+
+  if (context && pxe_arch != -1) {
+    pxe_misc(mess, end, uuid);
+    if (!pxe_uefi_workaround(pxe_arch, tagif, mess, context->local, now, 0))
+      config_opts = pxe_opts(pxe_arch, tagif, context->local, now);
+  }
 
   if ((force_encap || in_list(req_options, OPTION_VENDOR_CLASS_OPT)) &&
-      do_encap_opts(config_opts, OPTION_VENDOR_CLASS_OPT, DHOPT_VENDOR_MATCH, mess, end, null_term) && 
-      pxe_arch == -1 && !done_vendor_class && vendor_class_len != 0 &&
-      (p = free_space(mess, end, OPTION_VENDOR_ID, vendor_class_len)))
+      do_encap_opts(config_opts, OPTION_VENDOR_CLASS_OPT, DHOPT_VENDOR_MATCH,
+                    mess, end, null_term) && pxe_arch == -1
+      && !done_vendor_class && vendor_class_len != 0
+      && (p = free_space(mess, end, OPTION_VENDOR_ID, vendor_class_len)))
     /* If we send vendor encapsulated options, and haven't already sent option 60,
        echo back the value we got from the client. */
-    memcpy(p, daemon->dhcp_buff3, vendor_class_len);	    
-   
-   /* restore BOOTP anti-overload hack */
-  if (!req_options || option_bool(OPT_NO_OVERRIDE))
-    {
-      mess->file[0] = f0;
-      mess->sname[0] = s0;
-    }
+    memcpy(p, daemon->dhcp_buff3, vendor_class_len);
+
+  /* restore BOOTP anti-overload hack */
+  if (!req_options || option_bool(OPT_NO_OVERRIDE)) {
+    mess->file[0] = f0;
+    mess->sname[0] = s0;
+  }
 }
 
 static void apply_delay(u32 xid, time_t recvtime, struct dhcp_netid *netid)
 {
   struct delay_config *delay_conf;
-  
+
   /* Decide which delay_config option we're using */
-  for (delay_conf = daemon->delay_conf; delay_conf; delay_conf = delay_conf->next)
+  for (delay_conf = daemon->delay_conf; delay_conf;
+       delay_conf = delay_conf->next)
     if (match_netid(delay_conf->netid, netid, 0))
       break;
-  
+
   if (!delay_conf)
     /* No match, look for one without a netid */
-    for (delay_conf = daemon->delay_conf; delay_conf; delay_conf = delay_conf->next)
+    for (delay_conf = daemon->delay_conf; delay_conf;
+         delay_conf = delay_conf->next)
       if (match_netid(delay_conf->netid, netid, 1))
         break;
 
-  if (delay_conf)
-    {
-      if (!option_bool(OPT_QUIET_DHCP))
-	my_syslog(MS_DHCP | LOG_INFO, _("%u reply delay: %d"), ntohl(xid), delay_conf->delay);
-      delay_dhcp(recvtime, delay_conf->delay, -1, 0, 0);
-    }
+  if (delay_conf) {
+    if (!option_bool(OPT_QUIET_DHCP))
+      my_syslog(MS_DHCP | LOG_INFO, _("%u reply delay: %d"), ntohl(xid),
+                delay_conf->delay);
+    delay_dhcp(recvtime, delay_conf->delay, -1, 0, 0);
+  }
 }
 
 #endif
-  
-
-  
-  
-
-
-  
Index: dnsmasq-2.78/src/rfc3315.c
===================================================================
--- dnsmasq-2.78.orig/src/rfc3315.c	2017-10-02 21:13:51.000000000 +0800
+++ dnsmasq-2.78/src/rfc3315.c	2018-10-29 16:14:19.501440028 +0800
@@ -36,32 +36,47 @@
 #endif
 };
 
-static int dhcp6_maybe_relay(struct state *state, void *inbuff, size_t sz, 
-			     struct in6_addr *client_addr, int is_unicast, time_t now);
-static int dhcp6_no_relay(struct state *state, int msg_type, void *inbuff, size_t sz, int is_unicast, time_t now);
-static void log6_opts(int nest, unsigned int xid, void *start_opts, void *end_opts);
-static void log6_packet(struct state *state, char *type, struct in6_addr *addr, char *string);
-static void log6_quiet(struct state *state, char *type, struct in6_addr *addr, char *string);
-static void *opt6_find (void *opts, void *end, unsigned int search, unsigned int minsize);
+static int dhcp6_maybe_relay(struct state *state, void *inbuff, size_t sz,
+                             struct in6_addr *client_addr, int is_unicast,
+                             time_t now);
+static int dhcp6_no_relay(struct state *state, int msg_type, void *inbuff,
+                          size_t sz, int is_unicast, time_t now);
+static void log6_opts(int nest, unsigned int xid, void *start_opts,
+                      void *end_opts);
+static void log6_packet(struct state *state, char *type, struct in6_addr *addr,
+                        char *string);
+static void log6_quiet(struct state *state, char *type, struct in6_addr *addr,
+                       char *string);
+static void *opt6_find(void *opts, void *end, unsigned int search,
+                       unsigned int minsize);
 static void *opt6_next(void *opts, void *end);
 static unsigned int opt6_uint(unsigned char *opt, int offset, int size);
 static void get_context_tag(struct state *state, struct dhcp_context *context);
-static int check_ia(struct state *state, void *opt, void **endp, void **ia_option);
+static int check_ia(struct state *state, void *opt, void **endp,
+                    void **ia_option);
 static int build_ia(struct state *state, int *t1cntr);
 static void end_ia(int t1cntr, unsigned int min_time, int do_fuzz);
 #ifdef OPTION6_PREFIX_CLASS
-static struct prefix_class *prefix_class_from_context(struct dhcp_context *context);
+static struct prefix_class *prefix_class_from_context(struct dhcp_context
+                                                      *context);
 #endif
 static void mark_context_used(struct state *state, struct in6_addr *addr);
-static void mark_config_used(struct dhcp_context *context, struct in6_addr *addr);
+static void mark_config_used(struct dhcp_context *context,
+                             struct in6_addr *addr);
 static int check_address(struct state *state, struct in6_addr *addr);
-static void add_address(struct state *state, struct dhcp_context *context, unsigned int lease_time, void *ia_option, 
-			unsigned int *min_time, struct in6_addr *addr, time_t now);
-static void update_leases(struct state *state, struct dhcp_context *context, struct in6_addr *addr, unsigned int lease_time, time_t now);
+static void add_address(struct state *state, struct dhcp_context *context,
+                        unsigned int lease_time, void *ia_option,
+                        unsigned int *min_time, struct in6_addr *addr,
+                        time_t now);
+static void update_leases(struct state *state, struct dhcp_context *context,
+                          struct in6_addr *addr, unsigned int lease_time,
+                          time_t now);
 static int add_local_addrs(struct dhcp_context *context);
 static struct dhcp_netid *add_options(struct state *state, int do_refresh);
-static void calculate_times(struct dhcp_context *context, unsigned int *min_time, unsigned int *valid_timep, 
-			    unsigned int *preferred_timep, unsigned int lease_time);
+static void calculate_times(struct dhcp_context *context,
+                            unsigned int *min_time, unsigned int *valid_timep,
+                            unsigned int *preferred_timep,
+                            unsigned int lease_time);
 
 #define opt6_len(opt) ((int)(opt6_uint(opt, -2, 2)))
 #define opt6_type(opt) (opt6_uint(opt, -4, 2))
@@ -70,25 +85,26 @@
 #define opt6_user_vendor_ptr(opt, i) ((void *)&(((unsigned char *)(opt))[2+(i)]))
 #define opt6_user_vendor_len(opt) ((int)(opt6_uint(opt, -4, 2)))
 #define opt6_user_vendor_next(opt, end) (opt6_next(((void *) opt) - 2, end))
- 
 
-unsigned short dhcp6_reply(struct dhcp_context *context, int interface, char *iface_name,
-			   struct in6_addr *fallback,  struct in6_addr *ll_addr, struct in6_addr *ula_addr,
-			   size_t sz, struct in6_addr *client_addr, time_t now)
+
+unsigned short dhcp6_reply(struct dhcp_context *context, int interface,
+                           char *iface_name, struct in6_addr *fallback,
+                           struct in6_addr *ll_addr, struct in6_addr *ula_addr,
+                           size_t sz, struct in6_addr *client_addr, time_t now)
 {
   struct dhcp_vendor *vendor;
   int msg_type;
   struct state state;
-  
+
   if (sz <= 4)
     return 0;
-  
-  msg_type = *((unsigned char *)daemon->dhcp_packet.iov_base);
-  
+
+  msg_type = *((unsigned char *) daemon->dhcp_packet.iov_base);
+
   /* Mark these so we only match each at most once, to avoid tangled linked lists */
   for (vendor = daemon->dhcp_vendors; vendor; vendor = vendor->next)
     vendor->netid.next = &vendor->netid;
-  
+
   reset_counter();
   state.context = context;
   state.interface = interface;
@@ -100,146 +116,141 @@
   state.tags = NULL;
   state.link_address = NULL;
 
-  if (dhcp6_maybe_relay(&state, daemon->dhcp_packet.iov_base, sz, client_addr, 
-			IN6_IS_ADDR_MULTICAST(client_addr), now))
+  if (dhcp6_maybe_relay(&state, daemon->dhcp_packet.iov_base, sz, client_addr,
+                        IN6_IS_ADDR_MULTICAST(client_addr), now))
     return msg_type == DHCP6RELAYFORW ? DHCPV6_SERVER_PORT : DHCPV6_CLIENT_PORT;
 
   return 0;
 }
 
 /* This cost me blood to write, it will probably cost you blood to understand - srk. */
-static int dhcp6_maybe_relay(struct state *state, void *inbuff, size_t sz, 
-			     struct in6_addr *client_addr, int is_unicast, time_t now)
+static int dhcp6_maybe_relay(struct state *state, void *inbuff, size_t sz,
+                             struct in6_addr *client_addr, int is_unicast,
+                             time_t now)
 {
   void *end = inbuff + sz;
   void *opts = inbuff + 34;
-  int msg_type = *((unsigned char *)inbuff);
+  int msg_type = *((unsigned char *) inbuff);
   unsigned char *outmsgtypep;
   void *opt;
   struct dhcp_vendor *vendor;
 
   /* if not an encapsulated relayed message, just do the stuff */
-  if (msg_type != DHCP6RELAYFORW)
-    {
-      /* if link_address != NULL if points to the link address field of the 
-	 innermost nested RELAYFORW message, which is where we find the
-	 address of the network on which we can allocate an address.
-	 Recalculate the available contexts using that information. 
-
-      link_address == NULL means there's no relay in use, so we try and find the client's 
-      MAC address from the local ND cache. */
-      
-      if (!state->link_address)
-	get_client_mac(client_addr, state->interface, state->mac, &state->mac_len, &state->mac_type, now);
-      else
-	{
-	  struct dhcp_context *c;
-	  state->context = NULL;
-	   
-	  if (!IN6_IS_ADDR_LOOPBACK(state->link_address) &&
-	      !IN6_IS_ADDR_LINKLOCAL(state->link_address) &&
-	      !IN6_IS_ADDR_MULTICAST(state->link_address))
-	    for (c = daemon->dhcp6; c; c = c->next)
-	      if ((c->flags & CONTEXT_DHCP) &&
-		  !(c->flags & (CONTEXT_TEMPLATE | CONTEXT_OLD)) &&
-		  is_same_net6(state->link_address, &c->start6, c->prefix) &&
-		  is_same_net6(state->link_address, &c->end6, c->prefix))
-		{
-		  c->preferred = c->valid = 0xffffffff;
-		  c->current = state->context;
-		  state->context = c;
-		}
-	  
-	  if (!state->context)
-	    {
-	      inet_ntop(AF_INET6, state->link_address, daemon->addrbuff, ADDRSTRLEN); 
-	      my_syslog(MS_DHCP | LOG_WARNING, 
-			_("no address range available for DHCPv6 request from relay at %s"),
-			daemon->addrbuff);
-	      return 0;
-	    }
-	}
-	  
-      if (!state->context)
-	{
-	  my_syslog(MS_DHCP | LOG_WARNING, 
-		    _("no address range available for DHCPv6 request via %s"), state->iface_name);
-	  return 0;
-	}
+  if (msg_type != DHCP6RELAYFORW) {
+    /* if link_address != NULL if points to the link address field of the
+       innermost nested RELAYFORW message, which is where we find the
+       address of the network on which we can allocate an address.
+       Recalculate the available contexts using that information.
+
+       link_address == NULL means there's no relay in use, so we try and find the client's
+       MAC address from the local ND cache. */
+
+    if (!state->link_address)
+      get_client_mac(client_addr, state->interface, state->mac, &state->mac_len,
+                     &state->mac_type, now);
+    else {
+      struct dhcp_context *c;
+      state->context = NULL;
+
+      if (!IN6_IS_ADDR_LOOPBACK(state->link_address) &&
+          !IN6_IS_ADDR_LINKLOCAL(state->link_address) &&
+          !IN6_IS_ADDR_MULTICAST(state->link_address))
+        for (c = daemon->dhcp6; c; c = c->next)
+          if ((c->flags & CONTEXT_DHCP) &&
+              !(c->flags & (CONTEXT_TEMPLATE | CONTEXT_OLD)) &&
+              is_same_net6(state->link_address, &c->start6, c->prefix) &&
+              is_same_net6(state->link_address, &c->end6, c->prefix)) {
+            c->preferred = c->valid = 0xffffffff;
+            c->current = state->context;
+            state->context = c;
+          }
+
+      if (!state->context) {
+        inet_ntop(AF_INET6, state->link_address, daemon->addrbuff, ADDRSTRLEN);
+        my_syslog(MS_DHCP | LOG_WARNING,
+                  _
+                  ("no address range available for DHCPv6 request from relay at %s"),
+                  daemon->addrbuff);
+        return 0;
+      }
+    }
 
-      return dhcp6_no_relay(state, msg_type, inbuff, sz, is_unicast, now);
+    if (!state->context) {
+      my_syslog(MS_DHCP | LOG_WARNING,
+                _("no address range available for DHCPv6 request via %s"),
+                state->iface_name);
+      return 0;
     }
 
+    return dhcp6_no_relay(state, msg_type, inbuff, sz, is_unicast, now);
+  }
+
   /* must have at least msg_type+hopcount+link_address+peer_address+minimal size option
      which is               1   +    1   +    16      +     16     + 2 + 2 = 38 */
   if (sz < 38)
     return 0;
-  
+
   /* copy header stuff into reply message and set type to reply */
   if (!(outmsgtypep = put_opt6(inbuff, 34)))
     return 0;
   *outmsgtypep = DHCP6RELAYREPL;
 
   /* look for relay options and set tags if found. */
-  for (vendor = daemon->dhcp_vendors; vendor; vendor = vendor->next)
-    {
-      int mopt;
-      
-      if (vendor->match_type == MATCH_SUBSCRIBER)
-	mopt = OPTION6_SUBSCRIBER_ID;
-      else if (vendor->match_type == MATCH_REMOTE)
-	mopt = OPTION6_REMOTE_ID; 
-      else
-	continue;
+  for (vendor = daemon->dhcp_vendors; vendor; vendor = vendor->next) {
+    int mopt;
 
-      if ((opt = opt6_find(opts, end, mopt, 1)) &&
-	  vendor->len == opt6_len(opt) &&
-	  memcmp(vendor->data, opt6_ptr(opt, 0), vendor->len) == 0 &&
-	  vendor->netid.next != &vendor->netid)
-	{
-	  vendor->netid.next = state->tags;
-	  state->tags = &vendor->netid;
-	  break;
-	}
+    if (vendor->match_type == MATCH_SUBSCRIBER)
+      mopt = OPTION6_SUBSCRIBER_ID;
+    else if (vendor->match_type == MATCH_REMOTE)
+      mopt = OPTION6_REMOTE_ID;
+    else
+      continue;
+
+    if ((opt = opt6_find(opts, end, mopt, 1)) &&
+        vendor->len == opt6_len(opt) &&
+        memcmp(vendor->data, opt6_ptr(opt, 0), vendor->len) == 0 &&
+        vendor->netid.next != &vendor->netid) {
+      vendor->netid.next = state->tags;
+      state->tags = &vendor->netid;
+      break;
     }
-  
+  }
+
   /* RFC-6939 */
-  if ((opt = opt6_find(opts, end, OPTION6_CLIENT_MAC, 3)))
-    {
-      if (opt6_len(opt) - 2 > DHCP_CHADDR_MAX) {
-        return 0;
-      }
-      state->mac_type = opt6_uint(opt, 0, 2);
-      state->mac_len = opt6_len(opt) - 2;
-      memcpy(&state->mac[0], opt6_ptr(opt, 2), state->mac_len);
+  if ((opt = opt6_find(opts, end, OPTION6_CLIENT_MAC, 3))) {
+    if (opt6_len(opt) - 2 > DHCP_CHADDR_MAX) {
+      return 0;
     }
-  
-  for (opt = opts; opt; opt = opt6_next(opt, end))
-    {
-      if (opt6_ptr(opt, 0) + opt6_len(opt) >= end) {
-        return 0;
-      }
-      int o = new_opt6(opt6_type(opt));
-      if (opt6_type(opt) == OPTION6_RELAY_MSG)
-	{
-	  struct in6_addr align;
-	  /* the packet data is unaligned, copy to aligned storage */
-	  memcpy(&align, inbuff + 2, IN6ADDRSZ); 
-	  state->link_address = &align;
-	  /* zero is_unicast since that is now known to refer to the 
-	     relayed packet, not the original sent by the client */
-	  if (!dhcp6_maybe_relay(state, opt6_ptr(opt, 0), opt6_len(opt), client_addr, 0, now))
-	    return 0;
-	}
-      else if (opt6_type(opt) != OPTION6_CLIENT_MAC)
-	put_opt6(opt6_ptr(opt, 0), opt6_len(opt));
-      end_opt6(o);	    
+    state->mac_type = opt6_uint(opt, 0, 2);
+    state->mac_len = opt6_len(opt) - 2;
+    memcpy(&state->mac[0], opt6_ptr(opt, 2), state->mac_len);
+  }
+
+  for (opt = opts; opt; opt = opt6_next(opt, end)) {
+    if (opt6_ptr(opt, 0) + opt6_len(opt) >= end) {
+      return 0;
     }
-  
+    int o = new_opt6(opt6_type(opt));
+    if (opt6_type(opt) == OPTION6_RELAY_MSG) {
+      struct in6_addr align;
+      /* the packet data is unaligned, copy to aligned storage */
+      memcpy(&align, inbuff + 2, IN6ADDRSZ);
+      state->link_address = &align;
+      /* zero is_unicast since that is now known to refer to the
+         relayed packet, not the original sent by the client */
+      if (!dhcp6_maybe_relay
+          (state, opt6_ptr(opt, 0), opt6_len(opt), client_addr, 0, now))
+        return 0;
+    } else if (opt6_type(opt) != OPTION6_CLIENT_MAC)
+      put_opt6(opt6_ptr(opt, 0), opt6_len(opt));
+    end_opt6(o);
+  }
+
   return 1;
 }
 
-static int dhcp6_no_relay(struct state *state, int msg_type, void *inbuff, size_t sz, int is_unicast, time_t now)
+static int dhcp6_no_relay(struct state *state, int msg_type, void *inbuff,
+                          size_t sz, int is_unicast, time_t now)
 {
   void *opt;
   int i, o, o1, start_opts;
@@ -268,7 +279,7 @@
   state->hostname_auth = 0;
   state->hostname = NULL;
   state->client_hostname = NULL;
-  state->fqdn_flags = 0x01; /* default to send if we receive no FQDN option */
+  state->fqdn_flags = 0x01;     /* default to send if we receive no FQDN option */
 #ifdef OPTION6_PREFIX_CLASS
   state->send_prefix_class = NULL;
 #endif
@@ -276,7 +287,7 @@
   /* set tag with name == interface */
   iface_id.net = state->iface_name;
   iface_id.next = state->tags;
-  state->tags = &iface_id; 
+  state->tags = &iface_id;
 
   /* set tag "dhcpv6" */
   v6_id.net = "dhcpv6";
@@ -288,1258 +299,1221 @@
     return 0;
   start_opts = save_counter(-1);
   state->xid = outmsgtypep[3] | outmsgtypep[2] << 8 | outmsgtypep[1] << 16;
-   
+
   /* We're going to be linking tags from all context we use. 
      mark them as unused so we don't link one twice and break the list */
-  for (context_tmp = state->context; context_tmp; context_tmp = context_tmp->current)
-    {
-      context_tmp->netid.next = &context_tmp->netid;
-
-      if (option_bool(OPT_LOG_OPTS))
-	{
-	   inet_ntop(AF_INET6, &context_tmp->start6, daemon->dhcp_buff, ADDRSTRLEN); 
-	   inet_ntop(AF_INET6, &context_tmp->end6, daemon->dhcp_buff2, ADDRSTRLEN); 
-	   if (context_tmp->flags & (CONTEXT_STATIC))
-	     my_syslog(MS_DHCP | LOG_INFO, _("%u available DHCPv6 subnet: %s/%d"),
-		       state->xid, daemon->dhcp_buff, context_tmp->prefix);
-	   else
-	     my_syslog(MS_DHCP | LOG_INFO, _("%u available DHCP range: %s -- %s"), 
-		       state->xid, daemon->dhcp_buff, daemon->dhcp_buff2);
-	}
+  for (context_tmp = state->context; context_tmp;
+       context_tmp = context_tmp->current) {
+    context_tmp->netid.next = &context_tmp->netid;
+
+    if (option_bool(OPT_LOG_OPTS)) {
+      inet_ntop(AF_INET6, &context_tmp->start6, daemon->dhcp_buff, ADDRSTRLEN);
+      inet_ntop(AF_INET6, &context_tmp->end6, daemon->dhcp_buff2, ADDRSTRLEN);
+      if (context_tmp->flags & (CONTEXT_STATIC))
+        my_syslog(MS_DHCP | LOG_INFO, _("%u available DHCPv6 subnet: %s/%d"),
+                  state->xid, daemon->dhcp_buff, context_tmp->prefix);
+      else
+        my_syslog(MS_DHCP | LOG_INFO, _("%u available DHCP range: %s -- %s"),
+                  state->xid, daemon->dhcp_buff, daemon->dhcp_buff2);
     }
+  }
 
-  if ((opt = opt6_find(state->packet_options, state->end, OPTION6_CLIENT_ID, 1)))
-    {
-      state->clid = opt6_ptr(opt, 0);
-      state->clid_len = opt6_len(opt);
-      o = new_opt6(OPTION6_CLIENT_ID);
-      put_opt6(state->clid, state->clid_len);
-      end_opt6(o);
-    }
-  else if (msg_type != DHCP6IREQ)
+  if ((opt =
+       opt6_find(state->packet_options, state->end, OPTION6_CLIENT_ID, 1))) {
+    state->clid = opt6_ptr(opt, 0);
+    state->clid_len = opt6_len(opt);
+    o = new_opt6(OPTION6_CLIENT_ID);
+    put_opt6(state->clid, state->clid_len);
+    end_opt6(o);
+  } else if (msg_type != DHCP6IREQ)
     return 0;
 
   /* server-id must match except for SOLICIT, CONFIRM and REBIND messages */
-  if (msg_type != DHCP6SOLICIT && msg_type != DHCP6CONFIRM && msg_type != DHCP6IREQ && msg_type != DHCP6REBIND &&
-      (!(opt = opt6_find(state->packet_options, state->end, OPTION6_SERVER_ID, 1)) ||
-       opt6_len(opt) != daemon->duid_len ||
-       memcmp(opt6_ptr(opt, 0), daemon->duid, daemon->duid_len) != 0))
+  if (msg_type != DHCP6SOLICIT && msg_type != DHCP6CONFIRM
+      && msg_type != DHCP6IREQ && msg_type != DHCP6REBIND
+      &&
+      (!(opt =
+         opt6_find(state->packet_options, state->end, OPTION6_SERVER_ID, 1))
+       || opt6_len(opt) != daemon->duid_len
+       || memcmp(opt6_ptr(opt, 0), daemon->duid, daemon->duid_len) != 0))
     return 0;
-  
+
   o = new_opt6(OPTION6_SERVER_ID);
   put_opt6(daemon->duid, daemon->duid_len);
   end_opt6(o);
 
   if (is_unicast &&
-      (msg_type == DHCP6REQUEST || msg_type == DHCP6RENEW || msg_type == DHCP6RELEASE || msg_type == DHCP6DECLINE))
-    
-    {  
-      *outmsgtypep = DHCP6REPLY;
-      o1 = new_opt6(OPTION6_STATUS_CODE);
-      put_opt6_short(DHCP6USEMULTI);
-      put_opt6_string("Use multicast");
-      end_opt6(o1);
-      return 1;
-    }
+      (msg_type == DHCP6REQUEST || msg_type == DHCP6RENEW
+       || msg_type == DHCP6RELEASE || msg_type == DHCP6DECLINE))
+  {
+    *outmsgtypep = DHCP6REPLY;
+    o1 = new_opt6(OPTION6_STATUS_CODE);
+    put_opt6_short(DHCP6USEMULTI);
+    put_opt6_string("Use multicast");
+    end_opt6(o1);
+    return 1;
+  }
 
   /* match vendor and user class options */
-  for (vendor = daemon->dhcp_vendors; vendor; vendor = vendor->next)
-    {
-      int mopt;
-      
-      if (vendor->match_type == MATCH_VENDOR)
-	mopt = OPTION6_VENDOR_CLASS;
-      else if (vendor->match_type == MATCH_USER)
-	mopt = OPTION6_USER_CLASS; 
-      else
-	continue;
+  for (vendor = daemon->dhcp_vendors; vendor; vendor = vendor->next) {
+    int mopt;
+
+    if (vendor->match_type == MATCH_VENDOR)
+      mopt = OPTION6_VENDOR_CLASS;
+    else if (vendor->match_type == MATCH_USER)
+      mopt = OPTION6_USER_CLASS;
+    else
+      continue;
+
+    if ((opt = opt6_find(state->packet_options, state->end, mopt, 2))) {
+      void *enc_opt, *enc_end = opt6_ptr(opt, opt6_len(opt));
+      int offset = 0;
+
+      if (mopt == OPTION6_VENDOR_CLASS) {
+        if (opt6_len(opt) < 4)
+          continue;
+
+        if (vendor->enterprise != opt6_uint(opt, 0, 4))
+          continue;
+
+        offset = 4;
+      }
+
+      /* Note that format if user/vendor classes is different to DHCP options - no option types. */
+      for (enc_opt = opt6_ptr(opt, offset); enc_opt;
+           enc_opt = opt6_user_vendor_next(enc_opt, enc_end))
+        for (i = 0; i <= (opt6_user_vendor_len(enc_opt) - vendor->len); i++)
+          if (memcmp
+              (vendor->data, opt6_user_vendor_ptr(enc_opt, i),
+               vendor->len) == 0) {
+            vendor->netid.next = state->tags;
+            state->tags = &vendor->netid;
+            break;
+          }
+    }
+  }
+
+  if (option_bool(OPT_LOG_OPTS)
+      && (opt =
+          opt6_find(state->packet_options, state->end, OPTION6_VENDOR_CLASS,
+                    4)))
+    my_syslog(MS_DHCP | LOG_INFO, _("%u vendor class: %u"), state->xid,
+              opt6_uint(opt, 0, 4));
 
-      if ((opt = opt6_find(state->packet_options, state->end, mopt, 2)))
-	{
-	  void *enc_opt, *enc_end = opt6_ptr(opt, opt6_len(opt));
-	  int offset = 0;
-	  
-	  if (mopt == OPTION6_VENDOR_CLASS)
-	    {
-	      if (opt6_len(opt) < 4)
-		continue;
-	      
-	      if (vendor->enterprise != opt6_uint(opt, 0, 4))
-		continue;
-	    
-	      offset = 4;
-	    }
- 
-	  /* Note that format if user/vendor classes is different to DHCP options - no option types. */
-	  for (enc_opt = opt6_ptr(opt, offset); enc_opt; enc_opt = opt6_user_vendor_next(enc_opt, enc_end))
-	    for (i = 0; i <= (opt6_user_vendor_len(enc_opt) - vendor->len); i++)
-	      if (memcmp(vendor->data, opt6_user_vendor_ptr(enc_opt, i), vendor->len) == 0)
-		{
-		  vendor->netid.next = state->tags;
-		  state->tags = &vendor->netid;
-		  break;
-		}
-	}
-    }
-
-  if (option_bool(OPT_LOG_OPTS) && (opt = opt6_find(state->packet_options, state->end, OPTION6_VENDOR_CLASS, 4)))
-    my_syslog(MS_DHCP | LOG_INFO, _("%u vendor class: %u"), state->xid, opt6_uint(opt, 0, 4));
-  
   /* dhcp-match. If we have hex-and-wildcards, look for a left-anchored match.
      Otherwise assume the option is an array, and look for a matching element. 
      If no data given, existence of the option is enough. This code handles 
      V-I opts too. */
-  for (opt_cfg = daemon->dhcp_match6; opt_cfg; opt_cfg = opt_cfg->next)
-    {
-      int match = 0;
-      
-      if (opt_cfg->flags & DHOPT_RFC3925)
-	{
-	  for (opt = opt6_find(state->packet_options, state->end, OPTION6_VENDOR_OPTS, 4);
-	       opt;
-	       opt = opt6_find(opt6_next(opt, state->end), state->end, OPTION6_VENDOR_OPTS, 4))
-	    {
-	      void *vopt;
-	      void *vend = opt6_ptr(opt, opt6_len(opt));
-	      
-	      for (vopt = opt6_find(opt6_ptr(opt, 4), vend, opt_cfg->opt, 0);
-		   vopt;
-		   vopt = opt6_find(opt6_next(vopt, vend), vend, opt_cfg->opt, 0))
-		if ((match = match_bytes(opt_cfg, opt6_ptr(vopt, 0), opt6_len(vopt))))
-		  break;
-	    }
-	  if (match)
-	    break;
-	}
-      else
-	{
-	  if (!(opt = opt6_find(state->packet_options, state->end, opt_cfg->opt, 1)))
-	    continue;
-	  
-	  match = match_bytes(opt_cfg, opt6_ptr(opt, 0), opt6_len(opt));
-	} 
-  
+  for (opt_cfg = daemon->dhcp_match6; opt_cfg; opt_cfg = opt_cfg->next) {
+    int match = 0;
+
+    if (opt_cfg->flags & DHOPT_RFC3925) {
+      for (opt =
+           opt6_find(state->packet_options, state->end, OPTION6_VENDOR_OPTS, 4);
+           opt;
+           opt =
+           opt6_find(opt6_next(opt, state->end), state->end,
+                     OPTION6_VENDOR_OPTS, 4)) {
+        void *vopt;
+        void *vend = opt6_ptr(opt, opt6_len(opt));
+
+        for (vopt = opt6_find(opt6_ptr(opt, 4), vend, opt_cfg->opt, 0);
+             vopt;
+             vopt = opt6_find(opt6_next(vopt, vend), vend, opt_cfg->opt, 0))
+          if ((match = match_bytes(opt_cfg, opt6_ptr(vopt, 0), opt6_len(vopt))))
+            break;
+      }
       if (match)
-	{
-	  opt_cfg->netid->next = state->tags;
-	  state->tags = opt_cfg->netid;
-	}
-    }
+        break;
+    } else {
+      if (!
+          (opt = opt6_find(state->packet_options, state->end, opt_cfg->opt, 1)))
+        continue;
+
+      match = match_bytes(opt_cfg, opt6_ptr(opt, 0), opt6_len(opt));
+    }
+
+    if (match) {
+      opt_cfg->netid->next = state->tags;
+      state->tags = opt_cfg->netid;
+    }
+  }
+
+  if (state->mac_len != 0) {
+    if (option_bool(OPT_LOG_OPTS)) {
+      print_mac(daemon->dhcp_buff, state->mac, state->mac_len);
+      my_syslog(MS_DHCP | LOG_INFO, _("%u client MAC address: %s"), state->xid,
+                daemon->dhcp_buff);
+    }
+
+    for (mac_opt = daemon->dhcp_macs; mac_opt; mac_opt = mac_opt->next)
+      if ((unsigned) mac_opt->hwaddr_len == state->mac_len &&
+          ((unsigned) mac_opt->hwaddr_type == state->mac_type
+           || mac_opt->hwaddr_type == 0)
+          && memcmp_masked(mac_opt->hwaddr, state->mac, state->mac_len,
+                           mac_opt->mask)) {
+        mac_opt->netid.next = state->tags;
+        state->tags = &mac_opt->netid;
+      }
+  }
 
-  if (state->mac_len != 0)
-    {
-      if (option_bool(OPT_LOG_OPTS))
-	{
-	  print_mac(daemon->dhcp_buff, state->mac, state->mac_len);
-	  my_syslog(MS_DHCP | LOG_INFO, _("%u client MAC address: %s"), state->xid, daemon->dhcp_buff);
-	}
-
-      for (mac_opt = daemon->dhcp_macs; mac_opt; mac_opt = mac_opt->next)
-	if ((unsigned)mac_opt->hwaddr_len == state->mac_len &&
-	    ((unsigned)mac_opt->hwaddr_type == state->mac_type || mac_opt->hwaddr_type == 0) &&
-	    memcmp_masked(mac_opt->hwaddr, state->mac, state->mac_len, mac_opt->mask))
-	  {
-	    mac_opt->netid.next = state->tags;
-	    state->tags = &mac_opt->netid;
-	  }
-    }
-  
-  if ((opt = opt6_find(state->packet_options, state->end, OPTION6_FQDN, 1)))
-    {
-      /* RFC4704 refers */
-       int len = opt6_len(opt) - 1;
-       
-       state->fqdn_flags = opt6_uint(opt, 0, 1);
-       
-       /* Always force update, since the client has no way to do it itself. */
-       if (!option_bool(OPT_FQDN_UPDATE) && !(state->fqdn_flags & 0x01))
-	 state->fqdn_flags |= 0x03;
- 
-       state->fqdn_flags &= ~0x04;
-
-       if (len != 0 && len < 255)
-	 {
-	   unsigned char *pp, *op = opt6_ptr(opt, 1);
-	   char *pq = daemon->dhcp_buff;
-	   
-	   pp = op;
-	   while (*op != 0 && ((op + (*op)) - pp) < len)
-	     {
-	       memcpy(pq, op+1, *op);
-	       pq += *op;
-	       op += (*op)+1;
-	       *(pq++) = '.';
-	     }
-	   
-	   if (pq != daemon->dhcp_buff)
-	     pq--;
-	   *pq = 0;
-	   
-	   if (legal_hostname(daemon->dhcp_buff))
-	     {
-	       state->client_hostname = daemon->dhcp_buff;
-	       if (option_bool(OPT_LOG_OPTS))
-		 my_syslog(MS_DHCP | LOG_INFO, _("%u client provides name: %s"), state->xid, state->client_hostname); 
-	     }
-	 }
-    }	 
-  
-  if (state->clid)
-    {
-      config = find_config(daemon->dhcp_conf, state->context, state->clid, state->clid_len, state->mac, state->mac_len, state->mac_type, NULL);
-      
-      if (have_config(config, CONFIG_NAME))
-	{
-	  state->hostname = config->hostname;
-	  state->domain = config->domain;
-	  state->hostname_auth = 1;
-	}
-      else if (state->client_hostname)
-	{
-	  state->domain = strip_hostname(state->client_hostname);
-	  
-	  if (strlen(state->client_hostname) != 0)
-	    {
-	      state->hostname = state->client_hostname;
-	      if (!config)
-		{
-		  /* Search again now we have a hostname. 
-		     Only accept configs without CLID here, (it won't match)
-		     to avoid impersonation by name. */
-		  struct dhcp_config *new = find_config(daemon->dhcp_conf, state->context, NULL, 0, NULL, 0, 0, state->hostname);
-		  if (new && !have_config(new, CONFIG_CLID) && !new->hwaddr)
-		    config = new;
-		}
-	    }
-	}
+  if ((opt = opt6_find(state->packet_options, state->end, OPTION6_FQDN, 1))) {
+    /* RFC4704 refers */
+    int len = opt6_len(opt) - 1;
+
+    state->fqdn_flags = opt6_uint(opt, 0, 1);
+
+    /* Always force update, since the client has no way to do it itself. */
+    if (!option_bool(OPT_FQDN_UPDATE) && !(state->fqdn_flags & 0x01))
+      state->fqdn_flags |= 0x03;
+
+    state->fqdn_flags &= ~0x04;
+
+    if (len != 0 && len < 255) {
+      unsigned char *pp, *op = opt6_ptr(opt, 1);
+      char *pq = daemon->dhcp_buff;
+
+      pp = op;
+      while (*op != 0 && ((op + (*op)) - pp) < len) {
+        memcpy(pq, op + 1, *op);
+        pq += *op;
+        op += (*op) + 1;
+        *(pq++) = '.';
+      }
+
+      if (pq != daemon->dhcp_buff)
+        pq--;
+      *pq = 0;
+
+      if (legal_hostname(daemon->dhcp_buff)) {
+        state->client_hostname = daemon->dhcp_buff;
+        if (option_bool(OPT_LOG_OPTS))
+          my_syslog(MS_DHCP | LOG_INFO, _("%u client provides name: %s"),
+                    state->xid, state->client_hostname);
+      }
     }
+  }
 
-  if (config)
-    {
-      struct dhcp_netid_list *list;
-      
-      for (list = config->netid; list; list = list->next)
-        {
-          list->list->next = state->tags;
-          state->tags = list->list;
+  if (state->clid) {
+    config =
+        find_config(daemon->dhcp_conf, state->context, state->clid,
+                    state->clid_len, state->mac, state->mac_len,
+                    state->mac_type, NULL);
+
+    if (have_config(config, CONFIG_NAME)) {
+      state->hostname = config->hostname;
+      state->domain = config->domain;
+      state->hostname_auth = 1;
+    } else if (state->client_hostname) {
+      state->domain = strip_hostname(state->client_hostname);
+
+      if (strlen(state->client_hostname) != 0) {
+        state->hostname = state->client_hostname;
+        if (!config) {
+          /* Search again now we have a hostname.
+             Only accept configs without CLID here, (it won't match)
+             to avoid impersonation by name. */
+          struct dhcp_config *new =
+              find_config(daemon->dhcp_conf, state->context, NULL, 0, NULL, 0,
+                          0, state->hostname);
+          if (new && !have_config(new, CONFIG_CLID) && !new->hwaddr)
+            config = new;
         }
+      }
+    }
+  }
 
-      /* set "known" tag for known hosts */
-      known_id.net = "known";
-      known_id.next = state->tags;
-      state->tags = &known_id;
+  if (config) {
+    struct dhcp_netid_list *list;
 
-      if (have_config(config, CONFIG_DISABLE))
-	ignore = 1;
-    }
-  else if (state->clid &&
-	   find_config(daemon->dhcp_conf, NULL, state->clid, state->clid_len, state->mac, state->mac_len, state->mac_type, NULL))
-    {
-      known_id.net = "known-othernet";
-      known_id.next = state->tags;
-      state->tags = &known_id;
-    }
-  
+    for (list = config->netid; list; list = list->next) {
+      list->list->next = state->tags;
+      state->tags = list->list;
+    }
+
+    /* set "known" tag for known hosts */
+    known_id.net = "known";
+    known_id.next = state->tags;
+    state->tags = &known_id;
+
+    if (have_config(config, CONFIG_DISABLE))
+      ignore = 1;
+  } else if (state->clid &&
+             find_config(daemon->dhcp_conf, NULL, state->clid, state->clid_len,
+                         state->mac, state->mac_len, state->mac_type, NULL)) {
+    known_id.net = "known-othernet";
+    known_id.next = state->tags;
+    state->tags = &known_id;
+  }
 #ifdef OPTION6_PREFIX_CLASS
   /* OPTION_PREFIX_CLASS in ORO, send addresses in all prefix classes */
-  if (daemon->prefix_classes && (msg_type == DHCP6SOLICIT || msg_type == DHCP6REQUEST))
-    {
-      void *oro;
-      
-      if ((oro = opt6_find(state->packet_options, state->end, OPTION6_ORO, 0)))
-	for (i = 0; i <  opt6_len(oro) - 1; i += 2)
-	  if (opt6_uint(oro, i, 2) == OPTION6_PREFIX_CLASS)
-	    {
-	      dump_all_prefix_classes = 1;
-	      break;
-	    }
-      
-      if (msg_type != DHCP6SOLICIT || dump_all_prefix_classes)
-	/* Add the tags associated with prefix classes so we can use the DHCP ranges.
-	   Not done for SOLICIT as we add them  one-at-time. */
-	for (p = daemon->prefix_classes; p ; p = p->next)
-	  {
-	    p->tag.next = state->tags;
-	    state->tags = &p->tag;
-	  }
-    }    
+  if (daemon->prefix_classes
+      && (msg_type == DHCP6SOLICIT || msg_type == DHCP6REQUEST)) {
+    void *oro;
+
+    if ((oro = opt6_find(state->packet_options, state->end, OPTION6_ORO, 0)))
+      for (i = 0; i < opt6_len(oro) - 1; i += 2)
+        if (opt6_uint(oro, i, 2) == OPTION6_PREFIX_CLASS) {
+          dump_all_prefix_classes = 1;
+          break;
+        }
+
+    if (msg_type != DHCP6SOLICIT || dump_all_prefix_classes)
+      /* Add the tags associated with prefix classes so we can use the DHCP ranges.
+         Not done for SOLICIT as we add them  one-at-time. */
+      for (p = daemon->prefix_classes; p; p = p->next) {
+        p->tag.next = state->tags;
+        state->tags = &p->tag;
+      }
+  }
 #endif
 
   tagif = run_tag_if(state->tags);
-  
+
   /* if all the netids in the ignore list are present, ignore this client */
-  if (daemon->dhcp_ignore)
-    {
-      struct dhcp_netid_list *id_list;
-     
-      for (id_list = daemon->dhcp_ignore; id_list; id_list = id_list->next)
-	if (match_netid(id_list->list, tagif, 0))
-	  ignore = 1;
-    }
-  
+  if (daemon->dhcp_ignore) {
+    struct dhcp_netid_list *id_list;
+
+    for (id_list = daemon->dhcp_ignore; id_list; id_list = id_list->next)
+      if (match_netid(id_list->list, tagif, 0))
+        ignore = 1;
+  }
+
   /* if all the netids in the ignore_name list are present, ignore client-supplied name */
-  if (!state->hostname_auth)
-    {
-       struct dhcp_netid_list *id_list;
-       
-       for (id_list = daemon->dhcp_ignore_names; id_list; id_list = id_list->next)
-	 if ((!id_list->list) || match_netid(id_list->list, tagif, 0))
-	   break;
-       if (id_list)
-	 state->hostname = NULL;
-    }
-  
+  if (!state->hostname_auth) {
+    struct dhcp_netid_list *id_list;
+
+    for (id_list = daemon->dhcp_ignore_names; id_list; id_list = id_list->next)
+      if ((!id_list->list) || match_netid(id_list->list, tagif, 0))
+        break;
+    if (id_list)
+      state->hostname = NULL;
+  }
+
 
-  switch (msg_type)
+  switch (msg_type) {
+  default:
+    return 0;
+
+
+  case DHCP6SOLICIT:
     {
-    default:
-      return 0;
-      
-      
-    case DHCP6SOLICIT:
-      {
-      	int address_assigned = 0;
-	/* tags without all prefix-class tags */
-	struct dhcp_netid *solicit_tags;
-	struct dhcp_context *c;
-	
-	*outmsgtypep = DHCP6ADVERTISE;
-	
-	if (opt6_find(state->packet_options, state->end, OPTION6_RAPID_COMMIT, 0))
-	  {
-	    *outmsgtypep = DHCP6REPLY;
-	    state->lease_allocate = 1;
-	    o = new_opt6(OPTION6_RAPID_COMMIT);
-	    end_opt6(o);
-	  }
-	
-  	log6_quiet(state, "DHCPSOLICIT", NULL, ignore ? _("ignored") : NULL);
-
-      request_no_address:
-	solicit_tags = tagif;
-	
-	if (ignore)
-	  return 0;
-	
-	/* reset USED bits in leases */
-	lease6_reset();
-
-	/* Can use configured address max once per prefix */
-	for (c = state->context; c; c = c->current)
-	  c->flags &= ~CONTEXT_CONF_USED;
-
-	for (opt = state->packet_options; opt; opt = opt6_next(opt, state->end))
-	  {   
-	    void *ia_option, *ia_end;
-	    unsigned int min_time = 0xffffffff;
-	    int t1cntr;
-	    int ia_counter;
-	    /* set unless we're sending a particular prefix-class, when we
-	       want only dhcp-ranges with the correct tags set and not those without any tags. */
-	    int plain_range = 1;
-	    u32 lease_time;
-	    struct dhcp_lease *ltmp;
-	    struct in6_addr *req_addr;
-	    struct in6_addr addr;
-
-	    if (!check_ia(state, opt, &ia_end, &ia_option))
-	      continue;
-	    
-	    /* reset USED bits in contexts - one address per prefix per IAID */
-	    for (c = state->context; c; c = c->current)
-	      c->flags &= ~CONTEXT_USED;
+      int address_assigned = 0;
+      /* tags without all prefix-class tags */
+      struct dhcp_netid *solicit_tags;
+      struct dhcp_context *c;
+
+      *outmsgtypep = DHCP6ADVERTISE;
+
+      if (opt6_find(state->packet_options, state->end, OPTION6_RAPID_COMMIT, 0)) {
+        *outmsgtypep = DHCP6REPLY;
+        state->lease_allocate = 1;
+        o = new_opt6(OPTION6_RAPID_COMMIT);
+        end_opt6(o);
+      }
+
+      log6_quiet(state, "DHCPSOLICIT", NULL, ignore ? _("ignored") : NULL);
+
+    request_no_address:
+      solicit_tags = tagif;
+
+      if (ignore)
+        return 0;
+
+      /* reset USED bits in leases */
+      lease6_reset();
+
+      /* Can use configured address max once per prefix */
+      for (c = state->context; c; c = c->current)
+        c->flags &= ~CONTEXT_CONF_USED;
+
+      for (opt = state->packet_options; opt; opt = opt6_next(opt, state->end)) {
+        void *ia_option, *ia_end;
+        unsigned int min_time = 0xffffffff;
+        int t1cntr;
+        int ia_counter;
+        /* set unless we're sending a particular prefix-class, when we
+           want only dhcp-ranges with the correct tags set and not those without any tags. */
+        int plain_range = 1;
+        u32 lease_time;
+        struct dhcp_lease *ltmp;
+        struct in6_addr *req_addr;
+        struct in6_addr addr;
+
+        if (!check_ia(state, opt, &ia_end, &ia_option))
+          continue;
+
+        /* reset USED bits in contexts - one address per prefix per IAID */
+        for (c = state->context; c; c = c->current)
+          c->flags &= ~CONTEXT_USED;
 
 #ifdef OPTION6_PREFIX_CLASS
-	    if (daemon->prefix_classes && state->ia_type == OPTION6_IA_NA)
-	      {
-		void *prefix_opt;
-		int prefix_class;
-		
-		if (dump_all_prefix_classes)
-		  /* OPTION_PREFIX_CLASS in ORO, send addresses in all prefix classes */
-		  plain_range = 0;
-		else 
-		  { 
-		    if ((prefix_opt = opt6_find(opt6_ptr(opt, 12), ia_end, OPTION6_PREFIX_CLASS, 2)))
-		      {
-			
-			prefix_class = opt6_uint(prefix_opt, 0, 2);
-			
-			for (p = daemon->prefix_classes; p ; p = p->next)
-			  if (p->class == prefix_class)
-			    break;
-			
-			if (!p)
-			  my_syslog(MS_DHCP | LOG_WARNING, _("unknown prefix-class %d"), prefix_class);
-			else
-			  {
-			    /* add tag to list, and exclude undecorated dhcp-ranges */
-			    p->tag.next = state->tags;
-			    solicit_tags = run_tag_if(&p->tag);
-			    plain_range = 0;
-			    state->send_prefix_class = p;
-			  }
-		      }
-		    else
-		      {
-			/* client didn't ask for a prefix class, lets see if we can find one. */
-			for (p = daemon->prefix_classes; p ; p = p->next)
-			  {
-			    p->tag.next = NULL;
-			    if (match_netid(&p->tag, solicit_tags, 1))
-			      break;
-			  }
-			
-			if (p)
-			  {
-			    plain_range = 0;
-			    state->send_prefix_class = p;
-			  }
-		      }
-
-		    if (p && option_bool(OPT_LOG_OPTS))
-		      my_syslog(MS_DHCP | LOG_INFO, "%u prefix class %d tag:%s", state->xid, p->class, p->tag.net); 
-		  }
-	      }
+        if (daemon->prefix_classes && state->ia_type == OPTION6_IA_NA) {
+          void *prefix_opt;
+          int prefix_class;
+
+          if (dump_all_prefix_classes)
+            /* OPTION_PREFIX_CLASS in ORO, send addresses in all prefix classes */
+            plain_range = 0;
+          else {
+            if ((prefix_opt =
+                 opt6_find(opt6_ptr(opt, 12), ia_end, OPTION6_PREFIX_CLASS,
+                           2))) {
+
+              prefix_class = opt6_uint(prefix_opt, 0, 2);
+
+              for (p = daemon->prefix_classes; p; p = p->next)
+                if (p->class == prefix_class)
+                  break;
+
+              if (!p)
+                my_syslog(MS_DHCP | LOG_WARNING, _("unknown prefix-class %d"),
+                          prefix_class);
+              else {
+                /* add tag to list, and exclude undecorated dhcp-ranges */
+                p->tag.next = state->tags;
+                solicit_tags = run_tag_if(&p->tag);
+                plain_range = 0;
+                state->send_prefix_class = p;
+              }
+            } else {
+              /* client didn't ask for a prefix class, lets see if we can find one. */
+              for (p = daemon->prefix_classes; p; p = p->next) {
+                p->tag.next = NULL;
+                if (match_netid(&p->tag, solicit_tags, 1))
+                  break;
+              }
+
+              if (p) {
+                plain_range = 0;
+                state->send_prefix_class = p;
+              }
+            }
+
+            if (p && option_bool(OPT_LOG_OPTS))
+              my_syslog(MS_DHCP | LOG_INFO, "%u prefix class %d tag:%s",
+                        state->xid, p->class, p->tag.net);
+          }
+        }
 #endif
 
-	    o = build_ia(state, &t1cntr);
-	    if (address_assigned)
-		address_assigned = 2;
-
-	    for (ia_counter = 0; ia_option; ia_counter++, ia_option = opt6_find(opt6_next(ia_option, ia_end), ia_end, OPTION6_IAADDR, 24))
-	      {
-		req_addr = opt6_ptr(ia_option, 0);
-				
-		if ((c = address6_valid(state->context, req_addr, solicit_tags, plain_range)))
-		  {
-		    lease_time = c->lease_time;
-		    /* If the client asks for an address on the same network as a configured address, 
-		       offer the configured address instead, to make moving to newly-configured
-		       addresses automatic. */
-		    if (!(c->flags & CONTEXT_CONF_USED) && config_valid(config, c, &addr) && check_address(state, &addr))
-		      {
-			req_addr = &addr;
-			mark_config_used(c, &addr);
-			if (have_config(config, CONFIG_TIME))
-			  lease_time = config->lease_time;
-		      }
-		    else if (!(c = address6_available(state->context, req_addr, solicit_tags, plain_range)))
-		      continue; /* not an address we're allowed */
-		    else if (!check_address(state, req_addr))
-		      continue; /* address leased elsewhere */
-		    
-		    /* add address to output packet */
+        o = build_ia(state, &t1cntr);
+        if (address_assigned)
+          address_assigned = 2;
+
+        for (ia_counter = 0; ia_option;
+             ia_counter++, ia_option =
+             opt6_find(opt6_next(ia_option, ia_end), ia_end, OPTION6_IAADDR,
+                       24)) {
+          req_addr = opt6_ptr(ia_option, 0);
+
+          if ((c =
+               address6_valid(state->context, req_addr, solicit_tags,
+                              plain_range))) {
+            lease_time = c->lease_time;
+            /* If the client asks for an address on the same network as a configured address,
+               offer the configured address instead, to make moving to newly-configured
+               addresses automatic. */
+            if (!(c->flags & CONTEXT_CONF_USED)
+                && config_valid(config, c, &addr)
+                && check_address(state, &addr)) {
+              req_addr = &addr;
+              mark_config_used(c, &addr);
+              if (have_config(config, CONFIG_TIME))
+                lease_time = config->lease_time;
+            } else
+                if (!
+                    (c =
+                     address6_available(state->context, req_addr, solicit_tags,
+                                        plain_range)))
+              continue;         /* not an address we're allowed */
+            else if (!check_address(state, req_addr))
+              continue;         /* address leased elsewhere */
+
+            /* add address to output packet */
 #ifdef OPTION6_PREFIX_CLASS
-		    if (dump_all_prefix_classes && state->ia_type == OPTION6_IA_NA)
-		      state->send_prefix_class = prefix_class_from_context(c);
-#endif		    
-		    add_address(state, c, lease_time, ia_option, &min_time, req_addr, now);
-		    mark_context_used(state, req_addr);
-		    get_context_tag(state, c);
-		    address_assigned = 1;
-		  }
-	      }
-	    
-	    /* Suggest configured address(es) */
-	    for (c = state->context; c; c = c->current) 
-	      if (!(c->flags & CONTEXT_CONF_USED) &&
-		  match_netid(c->filter, solicit_tags, plain_range) &&
-		  config_valid(config, c, &addr) && 
-		  check_address(state, &addr))
-		{
-		  mark_config_used(state->context, &addr);
-		  if (have_config(config, CONFIG_TIME))
-		    lease_time = config->lease_time;
-		  else
-		    lease_time = c->lease_time;
-		  /* add address to output packet */
+            if (dump_all_prefix_classes && state->ia_type == OPTION6_IA_NA)
+              state->send_prefix_class = prefix_class_from_context(c);
+#endif
+            add_address(state, c, lease_time, ia_option, &min_time, req_addr,
+                        now);
+            mark_context_used(state, req_addr);
+            get_context_tag(state, c);
+            address_assigned = 1;
+          }
+        }
+
+        /* Suggest configured address(es) */
+        for (c = state->context; c; c = c->current)
+          if (!(c->flags & CONTEXT_CONF_USED) &&
+              match_netid(c->filter, solicit_tags, plain_range) &&
+              config_valid(config, c, &addr) && check_address(state, &addr)) {
+            mark_config_used(state->context, &addr);
+            if (have_config(config, CONFIG_TIME))
+              lease_time = config->lease_time;
+            else
+              lease_time = c->lease_time;
+            /* add address to output packet */
 #ifdef OPTION6_PREFIX_CLASS
-		  if (dump_all_prefix_classes && state->ia_type == OPTION6_IA_NA)
-		    state->send_prefix_class = prefix_class_from_context(c);
+            if (dump_all_prefix_classes && state->ia_type == OPTION6_IA_NA)
+              state->send_prefix_class = prefix_class_from_context(c);
 #endif
-		  add_address(state, c, lease_time, NULL, &min_time, &addr, now);
-		  mark_context_used(state, &addr);
-		  get_context_tag(state, c);
-		  address_assigned = 1;
-		}
-	    
-	    /* return addresses for existing leases */
-	    ltmp = NULL;
-	    while ((ltmp = lease6_find_by_client(ltmp, state->ia_type == OPTION6_IA_NA ? LEASE_NA : LEASE_TA, state->clid, state->clid_len, state->iaid)))
-	      {
-		req_addr = &ltmp->addr6;
-		if ((c = address6_available(state->context, req_addr, solicit_tags, plain_range)))
-		  {
+            add_address(state, c, lease_time, NULL, &min_time, &addr, now);
+            mark_context_used(state, &addr);
+            get_context_tag(state, c);
+            address_assigned = 1;
+          }
+
+        /* return addresses for existing leases */
+        ltmp = NULL;
+        while ((ltmp =
+                lease6_find_by_client(ltmp,
+                                      state->ia_type ==
+                                      OPTION6_IA_NA ? LEASE_NA : LEASE_TA,
+                                      state->clid, state->clid_len,
+                                      state->iaid))) {
+          req_addr = &ltmp->addr6;
+          if ((c =
+               address6_available(state->context, req_addr, solicit_tags,
+                                  plain_range))) {
 #ifdef OPTION6_PREFIX_CLASS
-		    if (dump_all_prefix_classes && state->ia_type == OPTION6_IA_NA)
-		      state->send_prefix_class = prefix_class_from_context(c);
+            if (dump_all_prefix_classes && state->ia_type == OPTION6_IA_NA)
+              state->send_prefix_class = prefix_class_from_context(c);
 #endif
-		    add_address(state, c, c->lease_time, NULL, &min_time, req_addr, now);
-		    mark_context_used(state, req_addr);
-		    get_context_tag(state, c);
-		    address_assigned = 1;
-		  }
-	      }
-		 	   
-	    /* Return addresses for all valid contexts which don't yet have one */
-	    while ((c = address6_allocate(state->context, state->clid, state->clid_len, state->ia_type == OPTION6_IA_TA,
-					  state->iaid, ia_counter, solicit_tags, plain_range, &addr)))
-	      {
+            add_address(state, c, c->lease_time, NULL, &min_time, req_addr,
+                        now);
+            mark_context_used(state, req_addr);
+            get_context_tag(state, c);
+            address_assigned = 1;
+          }
+        }
+
+        /* Return addresses for all valid contexts which don't yet have one */
+        while ((c =
+                address6_allocate(state->context, state->clid, state->clid_len,
+                                  state->ia_type == OPTION6_IA_TA, state->iaid,
+                                  ia_counter, solicit_tags, plain_range,
+                                  &addr))) {
 #ifdef OPTION6_PREFIX_CLASS
-		if (dump_all_prefix_classes && state->ia_type == OPTION6_IA_NA)
-		  state->send_prefix_class = prefix_class_from_context(c);
+          if (dump_all_prefix_classes && state->ia_type == OPTION6_IA_NA)
+            state->send_prefix_class = prefix_class_from_context(c);
 #endif
-		add_address(state, c, c->lease_time, NULL, &min_time, &addr, now);
-		mark_context_used(state, &addr);
-		get_context_tag(state, c);
-		address_assigned = 1;
-	      }
-	    
-	    if (address_assigned != 1)
-	      {
-		/* If the server will not assign any addresses to any IAs in a
-		   subsequent Request from the client, the server MUST send an Advertise
-		   message to the client that doesn't include any IA options. */
-		if (!state->lease_allocate)
-		  {
-		    save_counter(o);
-		    continue;
-		  }
-		
-		/* If the server cannot assign any addresses to an IA in the message
-		   from the client, the server MUST include the IA in the Reply message
-		   with no addresses in the IA and a Status Code option in the IA
-		   containing status code NoAddrsAvail. */
-		o1 = new_opt6(OPTION6_STATUS_CODE);
-		put_opt6_short(DHCP6NOADDRS);
-		put_opt6_string(_("address unavailable"));
-		end_opt6(o1);
-	      }
-	    
-	    end_ia(t1cntr, min_time, 0);
-	    end_opt6(o);	
-	  }
-
-	if (address_assigned) 
-	  {
-	    o1 = new_opt6(OPTION6_STATUS_CODE);
-	    put_opt6_short(DHCP6SUCCESS);
-	    put_opt6_string(_("success"));
-	    end_opt6(o1);
-	    
-	    /* If --dhcp-authoritative is set, we can tell client not to wait for
-	       other possible servers */
-	    o = new_opt6(OPTION6_PREFERENCE);
-	    put_opt6_char(option_bool(OPT_AUTHORITATIVE) ? 255 : 0);
-	    end_opt6(o);
-	    tagif = add_options(state, 0);
-	  }
-	else
-	  { 
-	    /* no address, return error */
-	    o1 = new_opt6(OPTION6_STATUS_CODE);
-	    put_opt6_short(DHCP6NOADDRS);
-	    put_opt6_string(_("no addresses available"));
-	    end_opt6(o1);
-
-	    /* Some clients will ask repeatedly when we're not giving
-	       out addresses because we're in stateless mode. Avoid spamming
-	       the log in that case. */
-	    for (c = state->context; c; c = c->current)
-	      if (!(c->flags & CONTEXT_RA_STATELESS))
-		{
-		  log6_packet(state, state->lease_allocate ? "DHCPREPLY" : "DHCPADVERTISE", NULL, _("no addresses available"));
-		  break;
-		}
-	  }
-
-	break;
-      }
-      
-    case DHCP6REQUEST:
-      {
-	int address_assigned = 0;
-	int start = save_counter(-1);
-
-	/* set reply message type */
-	*outmsgtypep = DHCP6REPLY;
-	state->lease_allocate = 1;
-
-	log6_quiet(state, "DHCPREQUEST", NULL, ignore ? _("ignored") : NULL);
-	
-	if (ignore)
-	  return 0;
-	
-	for (opt = state->packet_options; opt; opt = opt6_next(opt, state->end))
-	  {   
-	    void *ia_option, *ia_end;
-	    unsigned int min_time = 0xffffffff;
-	    int t1cntr;
-	    
-	     if (!check_ia(state, opt, &ia_end, &ia_option))
-	       continue;
-
-	     if (!ia_option)
-	       {
-		 /* If we get a request with a IA_*A without addresses, treat it exactly like
-		    a SOLICT with rapid commit set. */
-		 save_counter(start);
-		 goto request_no_address; 
-	       }
-
-	    o = build_ia(state, &t1cntr);
-	      
-	    for (; ia_option; ia_option = opt6_find(opt6_next(ia_option, ia_end), ia_end, OPTION6_IAADDR, 24))
-	      {
-		struct in6_addr *req_addr = opt6_ptr(ia_option, 0);
-		struct dhcp_context *dynamic, *c;
-		unsigned int lease_time;
-		struct in6_addr addr;
-		int config_ok = 0;
-		
-		if ((c = address6_valid(state->context, req_addr, tagif, 1)))
-		  config_ok = config_valid(config, c, &addr) && IN6_ARE_ADDR_EQUAL(&addr, req_addr);
-		
-		if ((dynamic = address6_available(state->context, req_addr, tagif, 1)) || c)
-		  {
-		    if (!dynamic && !config_ok)
-		      {
-			/* Static range, not configured. */
-			o1 = new_opt6(OPTION6_STATUS_CODE);
-			put_opt6_short(DHCP6NOADDRS);
-			put_opt6_string(_("address unavailable"));
-			end_opt6(o1);
-		      }
-		    else if (!check_address(state, req_addr))
-		      {
-			/* Address leased to another DUID/IAID */
-			o1 = new_opt6(OPTION6_STATUS_CODE);
-			put_opt6_short(DHCP6UNSPEC);
-			put_opt6_string(_("address in use"));
-			end_opt6(o1);
-		      } 
-		    else 
-		      {
-			if (!dynamic)
-			  dynamic = c;
-
-			lease_time = dynamic->lease_time;
-			
-			if (config_ok && have_config(config, CONFIG_TIME))
-			  lease_time = config->lease_time;
+          add_address(state, c, c->lease_time, NULL, &min_time, &addr, now);
+          mark_context_used(state, &addr);
+          get_context_tag(state, c);
+          address_assigned = 1;
+        }
+
+        if (address_assigned != 1) {
+          /* If the server will not assign any addresses to any IAs in a
+             subsequent Request from the client, the server MUST send an Advertise
+             message to the client that doesn't include any IA options. */
+          if (!state->lease_allocate) {
+            save_counter(o);
+            continue;
+          }
+
+          /* If the server cannot assign any addresses to an IA in the message
+             from the client, the server MUST include the IA in the Reply message
+             with no addresses in the IA and a Status Code option in the IA
+             containing status code NoAddrsAvail. */
+          o1 = new_opt6(OPTION6_STATUS_CODE);
+          put_opt6_short(DHCP6NOADDRS);
+          put_opt6_string(_("address unavailable"));
+          end_opt6(o1);
+        }
+
+        end_ia(t1cntr, min_time, 0);
+        end_opt6(o);
+      }
+
+      if (address_assigned) {
+        o1 = new_opt6(OPTION6_STATUS_CODE);
+        put_opt6_short(DHCP6SUCCESS);
+        put_opt6_string(_("success"));
+        end_opt6(o1);
+
+        /* If --dhcp-authoritative is set, we can tell client not to wait for
+           other possible servers */
+        o = new_opt6(OPTION6_PREFERENCE);
+        put_opt6_char(option_bool(OPT_AUTHORITATIVE) ? 255 : 0);
+        end_opt6(o);
+        tagif = add_options(state, 0);
+      } else {
+        /* no address, return error */
+        o1 = new_opt6(OPTION6_STATUS_CODE);
+        put_opt6_short(DHCP6NOADDRS);
+        put_opt6_string(_("no addresses available"));
+        end_opt6(o1);
+
+        /* Some clients will ask repeatedly when we're not giving
+           out addresses because we're in stateless mode. Avoid spamming
+           the log in that case. */
+        for (c = state->context; c; c = c->current)
+          if (!(c->flags & CONTEXT_RA_STATELESS)) {
+            log6_packet(state,
+                        state->lease_allocate ? "DHCPREPLY" : "DHCPADVERTISE",
+                        NULL, _("no addresses available"));
+            break;
+          }
+      }
+
+      break;
+    }
+
+  case DHCP6REQUEST:
+    {
+      int address_assigned = 0;
+      int start = save_counter(-1);
+
+      /* set reply message type */
+      *outmsgtypep = DHCP6REPLY;
+      state->lease_allocate = 1;
+
+      log6_quiet(state, "DHCPREQUEST", NULL, ignore ? _("ignored") : NULL);
+
+      if (ignore)
+        return 0;
+
+      for (opt = state->packet_options; opt; opt = opt6_next(opt, state->end)) {
+        void *ia_option, *ia_end;
+        unsigned int min_time = 0xffffffff;
+        int t1cntr;
+
+        if (!check_ia(state, opt, &ia_end, &ia_option))
+          continue;
+
+        if (!ia_option) {
+          /* If we get a request with a IA_*A without addresses, treat it exactly like
+             a SOLICT with rapid commit set. */
+          save_counter(start);
+          goto request_no_address;
+        }
+
+        o = build_ia(state, &t1cntr);
+
+        for (; ia_option;
+             ia_option =
+             opt6_find(opt6_next(ia_option, ia_end), ia_end, OPTION6_IAADDR,
+                       24)) {
+          struct in6_addr *req_addr = opt6_ptr(ia_option, 0);
+          struct dhcp_context *dynamic, *c;
+          unsigned int lease_time;
+          struct in6_addr addr;
+          int config_ok = 0;
+
+          if ((c = address6_valid(state->context, req_addr, tagif, 1)))
+            config_ok = config_valid(config, c, &addr)
+                && IN6_ARE_ADDR_EQUAL(&addr, req_addr);
+
+          if ((dynamic = address6_available(state->context, req_addr, tagif, 1))
+              || c) {
+            if (!dynamic && !config_ok) {
+              /* Static range, not configured. */
+              o1 = new_opt6(OPTION6_STATUS_CODE);
+              put_opt6_short(DHCP6NOADDRS);
+              put_opt6_string(_("address unavailable"));
+              end_opt6(o1);
+            } else if (!check_address(state, req_addr)) {
+              /* Address leased to another DUID/IAID */
+              o1 = new_opt6(OPTION6_STATUS_CODE);
+              put_opt6_short(DHCP6UNSPEC);
+              put_opt6_string(_("address in use"));
+              end_opt6(o1);
+            } else {
+              if (!dynamic)
+                dynamic = c;
+
+              lease_time = dynamic->lease_time;
+
+              if (config_ok && have_config(config, CONFIG_TIME))
+                lease_time = config->lease_time;
 
 #ifdef OPTION6_PREFIX_CLASS
-			if (dump_all_prefix_classes && state->ia_type == OPTION6_IA_NA)
-			  state->send_prefix_class = prefix_class_from_context(c);
+              if (dump_all_prefix_classes && state->ia_type == OPTION6_IA_NA)
+                state->send_prefix_class = prefix_class_from_context(c);
 #endif
-			add_address(state, dynamic, lease_time, ia_option, &min_time, req_addr, now);
-			get_context_tag(state, dynamic);
-			address_assigned = 1;
-		      }
-		  }
-		else 
-		  {
-		    /* requested address not on the correct link */
-		    o1 = new_opt6(OPTION6_STATUS_CODE);
-		    put_opt6_short(DHCP6NOTONLINK);
-		    put_opt6_string(_("not on link"));
-		    end_opt6(o1);
-		  }
-	      }
-	 
-	    end_ia(t1cntr, min_time, 0);
-	    end_opt6(o);	
-	  }
-
-	if (address_assigned) 
-	  {
-	    o1 = new_opt6(OPTION6_STATUS_CODE);
-	    put_opt6_short(DHCP6SUCCESS);
-	    put_opt6_string(_("success"));
-	    end_opt6(o1);
-	  }
-	else
-	  { 
-	    /* no address, return error */
-	    o1 = new_opt6(OPTION6_STATUS_CODE);
-	    put_opt6_short(DHCP6NOADDRS);
-	    put_opt6_string(_("no addresses available"));
-	    end_opt6(o1);
-	    log6_packet(state, "DHCPREPLY", NULL, _("no addresses available"));
-	  }
-
-	tagif = add_options(state, 0);
-	break;
-      }
-      
-  
-    case DHCP6RENEW:
-      {
-	/* set reply message type */
-	*outmsgtypep = DHCP6REPLY;
-	
-	log6_quiet(state, "DHCPRENEW", NULL, NULL);
-
-	for (opt = state->packet_options; opt; opt = opt6_next(opt, state->end))
-	  {
-	    void *ia_option, *ia_end;
-	    unsigned int min_time = 0xffffffff;
-	    int t1cntr, iacntr;
-	    
-	    if (!check_ia(state, opt, &ia_end, &ia_option))
-	      continue;
-	    
-	    o = build_ia(state, &t1cntr);
-	    iacntr = save_counter(-1); 
-	    
-	    for (; ia_option; ia_option = opt6_find(opt6_next(ia_option, ia_end), ia_end, OPTION6_IAADDR, 24))
-	      {
-		struct dhcp_lease *lease = NULL;
-		struct in6_addr *req_addr = opt6_ptr(ia_option, 0);
-		unsigned int preferred_time =  opt6_uint(ia_option, 16, 4);
-		unsigned int valid_time =  opt6_uint(ia_option, 20, 4);
-		char *message = NULL;
-		struct dhcp_context *this_context;
-		
-		if (!(lease = lease6_find(state->clid, state->clid_len,
-					  state->ia_type == OPTION6_IA_NA ? LEASE_NA : LEASE_TA, 
-					  state->iaid, req_addr)))
-		  {
-		    /* If the server cannot find a client entry for the IA the server
-		       returns the IA containing no addresses with a Status Code option set
-		       to NoBinding in the Reply message. */
-		    save_counter(iacntr);
-		    t1cntr = 0;
-		    
-		    log6_packet(state, "DHCPREPLY", req_addr, _("lease not found"));
-		    
-		    o1 = new_opt6(OPTION6_STATUS_CODE);
-		    put_opt6_short(DHCP6NOBINDING);
-		    put_opt6_string(_("no binding found"));
-		    end_opt6(o1);
-
-		    preferred_time = valid_time = 0;
-		    break;
-		  }
-		
-		
-		if ((this_context = address6_available(state->context, req_addr, tagif, 1)) ||
-		    (this_context = address6_valid(state->context, req_addr, tagif, 1)))
-		  {
-		    struct in6_addr addr;
-		    unsigned int lease_time;
-
-		    get_context_tag(state, this_context);
-		    
-		    if (config_valid(config, this_context, &addr) && IN6_ARE_ADDR_EQUAL(&addr, req_addr) && have_config(config, CONFIG_TIME))
-		      lease_time = config->lease_time;
-		    else 
-		      lease_time = this_context->lease_time;
-		    
-		    calculate_times(this_context, &min_time, &valid_time, &preferred_time, lease_time); 
-		    
-		    lease_set_expires(lease, valid_time, now);
-		    /* Update MAC record in case it's new information. */
-		    if (state->mac_len != 0)
-		      lease_set_hwaddr(lease, state->mac, state->clid, state->mac_len, state->mac_type, state->clid_len, now, 0);
-		    if (state->ia_type == OPTION6_IA_NA && state->hostname)
-		      {
-			char *addr_domain = get_domain6(req_addr);
-			if (!state->send_domain)
-			  state->send_domain = addr_domain;
-			lease_set_hostname(lease, state->hostname, state->hostname_auth, addr_domain, state->domain); 
-			message = state->hostname;
-		      }
-		    
-		    
-		    if (preferred_time == 0)
-		      message = _("deprecated");
-		  }
-		else
-		  {
-		    preferred_time = valid_time = 0;
-		    message = _("address invalid");
-		  } 
-
-		if (message && (message != state->hostname))
-		  log6_packet(state, "DHCPREPLY", req_addr, message);	
-		else
-		  log6_quiet(state, "DHCPREPLY", req_addr, message);
-	
-		o1 =  new_opt6(OPTION6_IAADDR);
-		put_opt6(req_addr, sizeof(*req_addr));
-		put_opt6_long(preferred_time);
-		put_opt6_long(valid_time);
-		end_opt6(o1);
-	      }
-	    
-	    end_ia(t1cntr, min_time, 1);
-	    end_opt6(o);
-	  }
-	
-	tagif = add_options(state, 0);
-	break;
-	
-      }
-      
-    case DHCP6CONFIRM:
-      {
-	int good_addr = 0;
-
-	/* set reply message type */
-	*outmsgtypep = DHCP6REPLY;
-	
-	log6_quiet(state, "DHCPCONFIRM", NULL, NULL);
-	
-	for (opt = state->packet_options; opt; opt = opt6_next(opt, state->end))
-	  {
-	    void *ia_option, *ia_end;
-	    
-	    for (check_ia(state, opt, &ia_end, &ia_option);
-		 ia_option;
-		 ia_option = opt6_find(opt6_next(ia_option, ia_end), ia_end, OPTION6_IAADDR, 24))
-	      {
-		struct in6_addr *req_addr = opt6_ptr(ia_option, 0);
-		
-		if (!address6_valid(state->context, req_addr, tagif, 1))
-		  {
-		    o1 = new_opt6(OPTION6_STATUS_CODE);
-		    put_opt6_short(DHCP6NOTONLINK);
-		    put_opt6_string(_("confirm failed"));
-		    end_opt6(o1);
-		    return 1;
-		  }
-
-		good_addr = 1;
-		log6_quiet(state, "DHCPREPLY", req_addr, state->hostname);
-	      }
-	  }	 
-	
-	/* No addresses, no reply: RFC 3315 18.2.2 */
-	if (!good_addr)
-	  return 0;
-
-	o1 = new_opt6(OPTION6_STATUS_CODE);
-	put_opt6_short(DHCP6SUCCESS );
-	put_opt6_string(_("all addresses still on link"));
-	end_opt6(o1);
-	break;
-    }
-      
-    case DHCP6IREQ:
-      {
-	/* We can't discriminate contexts based on address, as we don't know it.
-	   If there is only one possible context, we can use its tags */
-	if (state->context && state->context->netid.net && !state->context->current)
-	  {
-	    state->context->netid.next = NULL;
-	    state->context_tags =  &state->context->netid;
-	  }
-
-	/* Similarly, we can't determine domain from address, but if the FQDN is
-	   given in --dhcp-host, we can use that, and failing that we can use the 
-	   unqualified configured domain, if any. */
-	if (state->hostname_auth)
-	  state->send_domain = state->domain;
-	else
-	  state->send_domain = get_domain6(NULL);
-
-	log6_quiet(state, "DHCPINFORMATION-REQUEST", NULL, ignore ? _("ignored") : state->hostname);
-	if (ignore)
-	  return 0;
-	*outmsgtypep = DHCP6REPLY;
-	tagif = add_options(state, 1);
-	break;
-      }
-      
-      
-    case DHCP6RELEASE:
-      {
-	/* set reply message type */
-	*outmsgtypep = DHCP6REPLY;
-
-	log6_quiet(state, "DHCPRELEASE", NULL, NULL);
-
-	for (opt = state->packet_options; opt; opt = opt6_next(opt, state->end))
-	  {
-	    void *ia_option, *ia_end;
-	    int made_ia = 0;
-	    	    
-	    for (check_ia(state, opt, &ia_end, &ia_option);
-		 ia_option;
-		 ia_option = opt6_find(opt6_next(ia_option, ia_end), ia_end, OPTION6_IAADDR, 24)) 
-	      {
-		struct dhcp_lease *lease;
-		
-		if ((lease = lease6_find(state->clid, state->clid_len, state->ia_type == OPTION6_IA_NA ? LEASE_NA : LEASE_TA,
-					 state->iaid, opt6_ptr(ia_option, 0))))
-		  lease_prune(lease, now);
-		else
-		  {
-		    if (!made_ia)
-		      {
-			o = new_opt6(state->ia_type);
-			put_opt6_long(state->iaid);
-			if (state->ia_type == OPTION6_IA_NA)
-			  {
-			    put_opt6_long(0);
-			    put_opt6_long(0); 
-			  }
-			made_ia = 1;
-		      }
-		    
-		    o1 = new_opt6(OPTION6_IAADDR);
-		    put_opt6(opt6_ptr(ia_option, 0), IN6ADDRSZ);
-		    put_opt6_long(0);
-		    put_opt6_long(0);
-		    end_opt6(o1);
-		  }
-	      }
-	    
-	    if (made_ia)
-	      {
-		o1 = new_opt6(OPTION6_STATUS_CODE);
-		put_opt6_short(DHCP6NOBINDING);
-		put_opt6_string(_("no binding found"));
-		end_opt6(o1);
-		
-		end_opt6(o);
-	      }
-	  }
-	
-	o1 = new_opt6(OPTION6_STATUS_CODE);
-	put_opt6_short(DHCP6SUCCESS);
-	put_opt6_string(_("release received"));
-	end_opt6(o1);
-	
-	break;
-      }
-
-    case DHCP6DECLINE:
-      {
-	/* set reply message type */
-	*outmsgtypep = DHCP6REPLY;
-	
-	log6_quiet(state, "DHCPDECLINE", NULL, NULL);
-
-	for (opt = state->packet_options; opt; opt = opt6_next(opt, state->end))
-	  {
-	    void *ia_option, *ia_end;
-	    int made_ia = 0;
-	    	    
-	    for (check_ia(state, opt, &ia_end, &ia_option);
-		 ia_option;
-		 ia_option = opt6_find(opt6_next(ia_option, ia_end), ia_end, OPTION6_IAADDR, 24)) 
-	      {
-		struct dhcp_lease *lease;
-		struct in6_addr *addrp = opt6_ptr(ia_option, 0);
-
-		if (have_config(config, CONFIG_ADDR6) && IN6_ARE_ADDR_EQUAL(&config->addr6, addrp))
-		  {
-		    prettyprint_time(daemon->dhcp_buff3, DECLINE_BACKOFF);
-		    inet_ntop(AF_INET6, addrp, daemon->addrbuff, ADDRSTRLEN);
-		    my_syslog(MS_DHCP | LOG_WARNING, _("disabling DHCP static address %s for %s"), 
-			      daemon->addrbuff, daemon->dhcp_buff3);
-		    config->flags |= CONFIG_DECLINED;
-		    config->decline_time = now;
-		  }
-		else
-		  /* make sure this host gets a different address next time. */
-		  for (context_tmp = state->context; context_tmp; context_tmp = context_tmp->current)
-		    context_tmp->addr_epoch++;
-		
-		if ((lease = lease6_find(state->clid, state->clid_len, state->ia_type == OPTION6_IA_NA ? LEASE_NA : LEASE_TA,
-					 state->iaid, opt6_ptr(ia_option, 0))))
-		  lease_prune(lease, now);
-		else
-		  {
-		    if (!made_ia)
-		      {
-			o = new_opt6(state->ia_type);
-			put_opt6_long(state->iaid);
-			if (state->ia_type == OPTION6_IA_NA)
-			  {
-			    put_opt6_long(0);
-			    put_opt6_long(0); 
-			  }
-			made_ia = 1;
-		      }
-		    
-		    o1 = new_opt6(OPTION6_IAADDR);
-		    put_opt6(opt6_ptr(ia_option, 0), IN6ADDRSZ);
-		    put_opt6_long(0);
-		    put_opt6_long(0);
-		    end_opt6(o1);
-		  }
-	      }
-	    
-	    if (made_ia)
-	      {
-		o1 = new_opt6(OPTION6_STATUS_CODE);
-		put_opt6_short(DHCP6NOBINDING);
-		put_opt6_string(_("no binding found"));
-		end_opt6(o1);
-		
-		end_opt6(o);
-	      }
-	    
-	  }
-
-	/* We must answer with 'success' in global section anyway */
-	o1 = new_opt6(OPTION6_STATUS_CODE);
-	put_opt6_short(DHCP6SUCCESS);
-	put_opt6_string(_("success"));
-	end_opt6(o1);
-	break;
+              add_address(state, dynamic, lease_time, ia_option, &min_time,
+                          req_addr, now);
+              get_context_tag(state, dynamic);
+              address_assigned = 1;
+            }
+          } else {
+            /* requested address not on the correct link */
+            o1 = new_opt6(OPTION6_STATUS_CODE);
+            put_opt6_short(DHCP6NOTONLINK);
+            put_opt6_string(_("not on link"));
+            end_opt6(o1);
+          }
+        }
+
+        end_ia(t1cntr, min_time, 0);
+        end_opt6(o);
+      }
+
+      if (address_assigned) {
+        o1 = new_opt6(OPTION6_STATUS_CODE);
+        put_opt6_short(DHCP6SUCCESS);
+        put_opt6_string(_("success"));
+        end_opt6(o1);
+      } else {
+        /* no address, return error */
+        o1 = new_opt6(OPTION6_STATUS_CODE);
+        put_opt6_short(DHCP6NOADDRS);
+        put_opt6_string(_("no addresses available"));
+        end_opt6(o1);
+        log6_packet(state, "DHCPREPLY", NULL, _("no addresses available"));
+      }
+
+      tagif = add_options(state, 0);
+      break;
+    }
+
+
+  case DHCP6RENEW:
+    {
+      /* set reply message type */
+      *outmsgtypep = DHCP6REPLY;
+
+      log6_quiet(state, "DHCPRENEW", NULL, NULL);
+
+      for (opt = state->packet_options; opt; opt = opt6_next(opt, state->end)) {
+        void *ia_option, *ia_end;
+        unsigned int min_time = 0xffffffff;
+        int t1cntr, iacntr;
+
+        if (!check_ia(state, opt, &ia_end, &ia_option))
+          continue;
+
+        o = build_ia(state, &t1cntr);
+        iacntr = save_counter(-1);
+
+        for (; ia_option;
+             ia_option =
+             opt6_find(opt6_next(ia_option, ia_end), ia_end, OPTION6_IAADDR,
+                       24)) {
+          struct dhcp_lease *lease = NULL;
+          struct in6_addr *req_addr = opt6_ptr(ia_option, 0);
+          unsigned int preferred_time = opt6_uint(ia_option, 16, 4);
+          unsigned int valid_time = opt6_uint(ia_option, 20, 4);
+          char *message = NULL;
+          struct dhcp_context *this_context;
+
+          if (!(lease = lease6_find(state->clid, state->clid_len,
+                                    state->ia_type ==
+                                    OPTION6_IA_NA ? LEASE_NA : LEASE_TA,
+                                    state->iaid, req_addr))) {
+            /* If the server cannot find a client entry for the IA the server
+               returns the IA containing no addresses with a Status Code option set
+               to NoBinding in the Reply message. */
+            save_counter(iacntr);
+            t1cntr = 0;
+
+            log6_packet(state, "DHCPREPLY", req_addr, _("lease not found"));
+
+            o1 = new_opt6(OPTION6_STATUS_CODE);
+            put_opt6_short(DHCP6NOBINDING);
+            put_opt6_string(_("no binding found"));
+            end_opt6(o1);
+
+            preferred_time = valid_time = 0;
+            break;
+          }
+
+
+          if ((this_context =
+               address6_available(state->context, req_addr, tagif, 1))
+              || (this_context =
+                  address6_valid(state->context, req_addr, tagif, 1))) {
+            struct in6_addr addr;
+            unsigned int lease_time;
+
+            get_context_tag(state, this_context);
+
+            if (config_valid(config, this_context, &addr)
+                && IN6_ARE_ADDR_EQUAL(&addr, req_addr)
+                && have_config(config, CONFIG_TIME))
+              lease_time = config->lease_time;
+            else
+              lease_time = this_context->lease_time;
+
+            calculate_times(this_context, &min_time, &valid_time,
+                            &preferred_time, lease_time);
+
+            lease_set_expires(lease, valid_time, now);
+            /* Update MAC record in case it's new information. */
+            if (state->mac_len != 0)
+              lease_set_hwaddr(lease, state->mac, state->clid, state->mac_len,
+                               state->mac_type, state->clid_len, now, 0);
+            if (state->ia_type == OPTION6_IA_NA && state->hostname) {
+              char *addr_domain = get_domain6(req_addr);
+              if (!state->send_domain)
+                state->send_domain = addr_domain;
+              lease_set_hostname(lease, state->hostname, state->hostname_auth,
+                                 addr_domain, state->domain);
+              message = state->hostname;
+            }
+
+
+            if (preferred_time == 0)
+              message = _("deprecated");
+          } else {
+            preferred_time = valid_time = 0;
+            message = _("address invalid");
+          }
+
+          if (message && (message != state->hostname))
+            log6_packet(state, "DHCPREPLY", req_addr, message);
+          else
+            log6_quiet(state, "DHCPREPLY", req_addr, message);
+
+          o1 = new_opt6(OPTION6_IAADDR);
+          put_opt6(req_addr, sizeof(*req_addr));
+          put_opt6_long(preferred_time);
+          put_opt6_long(valid_time);
+          end_opt6(o1);
+        }
+
+        end_ia(t1cntr, min_time, 1);
+        end_opt6(o);
       }
 
+      tagif = add_options(state, 0);
+      break;
+
     }
-  
+
+  case DHCP6CONFIRM:
+    {
+      int good_addr = 0;
+
+      /* set reply message type */
+      *outmsgtypep = DHCP6REPLY;
+
+      log6_quiet(state, "DHCPCONFIRM", NULL, NULL);
+
+      for (opt = state->packet_options; opt; opt = opt6_next(opt, state->end)) {
+        void *ia_option, *ia_end;
+
+        for (check_ia(state, opt, &ia_end, &ia_option);
+             ia_option;
+             ia_option =
+             opt6_find(opt6_next(ia_option, ia_end), ia_end, OPTION6_IAADDR,
+                       24)) {
+          struct in6_addr *req_addr = opt6_ptr(ia_option, 0);
+
+          if (!address6_valid(state->context, req_addr, tagif, 1)) {
+            o1 = new_opt6(OPTION6_STATUS_CODE);
+            put_opt6_short(DHCP6NOTONLINK);
+            put_opt6_string(_("confirm failed"));
+            end_opt6(o1);
+            return 1;
+          }
+
+          good_addr = 1;
+          log6_quiet(state, "DHCPREPLY", req_addr, state->hostname);
+        }
+      }
+
+      /* No addresses, no reply: RFC 3315 18.2.2 */
+      if (!good_addr)
+        return 0;
+
+      o1 = new_opt6(OPTION6_STATUS_CODE);
+      put_opt6_short(DHCP6SUCCESS);
+      put_opt6_string(_("all addresses still on link"));
+      end_opt6(o1);
+      break;
+    }
+
+  case DHCP6IREQ:
+    {
+      /* We can't discriminate contexts based on address, as we don't know it.
+         If there is only one possible context, we can use its tags */
+      if (state->context && state->context->netid.net
+          && !state->context->current) {
+        state->context->netid.next = NULL;
+        state->context_tags = &state->context->netid;
+      }
+
+      /* Similarly, we can't determine domain from address, but if the FQDN is
+         given in --dhcp-host, we can use that, and failing that we can use the
+         unqualified configured domain, if any. */
+      if (state->hostname_auth)
+        state->send_domain = state->domain;
+      else
+        state->send_domain = get_domain6(NULL);
+
+      log6_quiet(state, "DHCPINFORMATION-REQUEST", NULL,
+                 ignore ? _("ignored") : state->hostname);
+      if (ignore)
+        return 0;
+      *outmsgtypep = DHCP6REPLY;
+      tagif = add_options(state, 1);
+      break;
+    }
+
+
+  case DHCP6RELEASE:
+    {
+      /* set reply message type */
+      *outmsgtypep = DHCP6REPLY;
+
+      log6_quiet(state, "DHCPRELEASE", NULL, NULL);
+
+      for (opt = state->packet_options; opt; opt = opt6_next(opt, state->end)) {
+        void *ia_option, *ia_end;
+        int made_ia = 0;
+
+        for (check_ia(state, opt, &ia_end, &ia_option);
+             ia_option;
+             ia_option =
+             opt6_find(opt6_next(ia_option, ia_end), ia_end, OPTION6_IAADDR,
+                       24)) {
+          struct dhcp_lease *lease;
+
+          if ((lease =
+               lease6_find(state->clid, state->clid_len,
+                           state->ia_type ==
+                           OPTION6_IA_NA ? LEASE_NA : LEASE_TA, state->iaid,
+                           opt6_ptr(ia_option, 0))))
+            lease_prune(lease, now);
+          else {
+            if (!made_ia) {
+              o = new_opt6(state->ia_type);
+              put_opt6_long(state->iaid);
+              if (state->ia_type == OPTION6_IA_NA) {
+                put_opt6_long(0);
+                put_opt6_long(0);
+              }
+              made_ia = 1;
+            }
+
+            o1 = new_opt6(OPTION6_IAADDR);
+            put_opt6(opt6_ptr(ia_option, 0), IN6ADDRSZ);
+            put_opt6_long(0);
+            put_opt6_long(0);
+            end_opt6(o1);
+          }
+        }
+
+        if (made_ia) {
+          o1 = new_opt6(OPTION6_STATUS_CODE);
+          put_opt6_short(DHCP6NOBINDING);
+          put_opt6_string(_("no binding found"));
+          end_opt6(o1);
+
+          end_opt6(o);
+        }
+      }
+
+      o1 = new_opt6(OPTION6_STATUS_CODE);
+      put_opt6_short(DHCP6SUCCESS);
+      put_opt6_string(_("release received"));
+      end_opt6(o1);
+
+      break;
+    }
+
+  case DHCP6DECLINE:
+    {
+      /* set reply message type */
+      *outmsgtypep = DHCP6REPLY;
+
+      log6_quiet(state, "DHCPDECLINE", NULL, NULL);
+
+      for (opt = state->packet_options; opt; opt = opt6_next(opt, state->end)) {
+        void *ia_option, *ia_end;
+        int made_ia = 0;
+
+        for (check_ia(state, opt, &ia_end, &ia_option);
+             ia_option;
+             ia_option =
+             opt6_find(opt6_next(ia_option, ia_end), ia_end, OPTION6_IAADDR,
+                       24)) {
+          struct dhcp_lease *lease;
+          struct in6_addr *addrp = opt6_ptr(ia_option, 0);
+
+          if (have_config(config, CONFIG_ADDR6)
+              && IN6_ARE_ADDR_EQUAL(&config->addr6, addrp)) {
+            prettyprint_time(daemon->dhcp_buff3, DECLINE_BACKOFF);
+            inet_ntop(AF_INET6, addrp, daemon->addrbuff, ADDRSTRLEN);
+            my_syslog(MS_DHCP | LOG_WARNING,
+                      _("disabling DHCP static address %s for %s"),
+                      daemon->addrbuff, daemon->dhcp_buff3);
+            config->flags |= CONFIG_DECLINED;
+            config->decline_time = now;
+          } else
+            /* make sure this host gets a different address next time. */
+            for (context_tmp = state->context; context_tmp;
+                 context_tmp = context_tmp->current)
+              context_tmp->addr_epoch++;
+
+          if ((lease =
+               lease6_find(state->clid, state->clid_len,
+                           state->ia_type ==
+                           OPTION6_IA_NA ? LEASE_NA : LEASE_TA, state->iaid,
+                           opt6_ptr(ia_option, 0))))
+            lease_prune(lease, now);
+          else {
+            if (!made_ia) {
+              o = new_opt6(state->ia_type);
+              put_opt6_long(state->iaid);
+              if (state->ia_type == OPTION6_IA_NA) {
+                put_opt6_long(0);
+                put_opt6_long(0);
+              }
+              made_ia = 1;
+            }
+
+            o1 = new_opt6(OPTION6_IAADDR);
+            put_opt6(opt6_ptr(ia_option, 0), IN6ADDRSZ);
+            put_opt6_long(0);
+            put_opt6_long(0);
+            end_opt6(o1);
+          }
+        }
+
+        if (made_ia) {
+          o1 = new_opt6(OPTION6_STATUS_CODE);
+          put_opt6_short(DHCP6NOBINDING);
+          put_opt6_string(_("no binding found"));
+          end_opt6(o1);
+
+          end_opt6(o);
+        }
+
+      }
+
+      /* We must answer with 'success' in global section anyway */
+      o1 = new_opt6(OPTION6_STATUS_CODE);
+      put_opt6_short(DHCP6SUCCESS);
+      put_opt6_string(_("success"));
+      end_opt6(o1);
+      break;
+    }
+
+  }
+
   log_tags(tagif, state->xid);
-  log6_opts(0, state->xid, daemon->outpacket.iov_base + start_opts, daemon->outpacket.iov_base + save_counter(-1));
-  
+  log6_opts(0, state->xid, daemon->outpacket.iov_base + start_opts,
+            daemon->outpacket.iov_base + save_counter(-1));
+
   return 1;
 
 }
 
-static struct dhcp_netid *add_options(struct state *state, int do_refresh)  
+static struct dhcp_netid *add_options(struct state *state, int do_refresh)
 {
   void *oro;
   /* filter options based on tags, those we want get DHOPT_TAGOK bit set */
-  struct dhcp_netid *tagif = option_filter(state->tags, state->context_tags, daemon->dhcp_opts6);
+  struct dhcp_netid *tagif =
+      option_filter(state->tags, state->context_tags, daemon->dhcp_opts6);
   struct dhcp_opt *opt_cfg;
   int done_dns = 0, done_refresh = !do_refresh, do_encap = 0;
   int i, o, o1;
 
   oro = opt6_find(state->packet_options, state->end, OPTION6_ORO, 0);
-  
-  for (opt_cfg = daemon->dhcp_opts6; opt_cfg; opt_cfg = opt_cfg->next)
-    {
-      /* netids match and not encapsulated? */
-      if (!(opt_cfg->flags & DHOPT_TAGOK))
-	continue;
-      
-      if (!(opt_cfg->flags & DHOPT_FORCE) && oro)
-	{
-	  for (i = 0; i <  opt6_len(oro) - 1; i += 2)
-	    if (opt6_uint(oro, i, 2) == (unsigned)opt_cfg->opt)
-	      break;
-	  
-	  /* option not requested */
-	  if (i >=  opt6_len(oro) - 1)
-	    continue;
-	}
-      
-      if (opt_cfg->opt == OPTION6_REFRESH_TIME)
-	done_refresh = 1;
-       
-      if (opt_cfg->opt == OPTION6_DNS_SERVER)
-	done_dns = 1;
-      
-      if (opt_cfg->flags & DHOPT_ADDR6)
-	{
-	  int len, j;
-	  struct in6_addr *a;
-	  
-	  for (a = (struct in6_addr *)opt_cfg->val, len = opt_cfg->len, j = 0; 
-	       j < opt_cfg->len; j += IN6ADDRSZ, a++)
-	    if ((IN6_IS_ADDR_ULA_ZERO(a) && IN6_IS_ADDR_UNSPECIFIED(state->ula_addr)) ||
-		(IN6_IS_ADDR_LINK_LOCAL_ZERO(a) && IN6_IS_ADDR_UNSPECIFIED(state->ll_addr)))
-	      len -= IN6ADDRSZ;
-	  
-	  if (len != 0)
-	    {
-	      
-	      o = new_opt6(opt_cfg->opt);
-	      	  
-	      for (a = (struct in6_addr *)opt_cfg->val, j = 0; j < opt_cfg->len; j+=IN6ADDRSZ, a++)
-		{
-		  if (IN6_IS_ADDR_UNSPECIFIED(a))
-		    {
-		      if (!add_local_addrs(state->context))
-			put_opt6(state->fallback, IN6ADDRSZ);
-		    }
-		  else if (IN6_IS_ADDR_ULA_ZERO(a))
-		    {
-		      if (!IN6_IS_ADDR_UNSPECIFIED(state->ula_addr))
-			put_opt6(state->ula_addr, IN6ADDRSZ);
-		    }
-		  else if (IN6_IS_ADDR_LINK_LOCAL_ZERO(a))
-		    {
-		      if (!IN6_IS_ADDR_UNSPECIFIED(state->ll_addr))
-			put_opt6(state->ll_addr, IN6ADDRSZ);
-		    }
-		  else
-		    put_opt6(a, IN6ADDRSZ);
-		}
-
-	      end_opt6(o);
-	    }
-	}
-      else
-	{
-	  o = new_opt6(opt_cfg->opt);
-	  if (opt_cfg->val)
-	    put_opt6(opt_cfg->val, opt_cfg->len);
-	  end_opt6(o);
-	}
-    }
-  
-  if (daemon->port == NAMESERVER_PORT && !done_dns)
-    {
-      o = new_opt6(OPTION6_DNS_SERVER);
-      if (!add_local_addrs(state->context))
-	put_opt6(state->fallback, IN6ADDRSZ);
-      end_opt6(o); 
-    }
 
-  if (state->context && !done_refresh)
-    {
-      struct dhcp_context *c;
-      unsigned int lease_time = 0xffffffff;
-      
-      /* Find the smallest lease tie of all contexts,
-	 subject to the RFC-4242 stipulation that this must not 
-	 be less than 600. */
-      for (c = state->context; c; c = c->next)
-	if (c->lease_time < lease_time)
-	  {
-	    if (c->lease_time < 600)
-	      lease_time = 600;
-	    else
-	      lease_time = c->lease_time;
-	  }
-
-      o = new_opt6(OPTION6_REFRESH_TIME);
-      put_opt6_long(lease_time);
-      end_opt6(o); 
+  for (opt_cfg = daemon->dhcp_opts6; opt_cfg; opt_cfg = opt_cfg->next) {
+    /* netids match and not encapsulated? */
+    if (!(opt_cfg->flags & DHOPT_TAGOK))
+      continue;
+
+    if (!(opt_cfg->flags & DHOPT_FORCE) && oro) {
+      for (i = 0; i < opt6_len(oro) - 1; i += 2)
+        if (opt6_uint(oro, i, 2) == (unsigned) opt_cfg->opt)
+          break;
+
+      /* option not requested */
+      if (i >= opt6_len(oro) - 1)
+        continue;
+    }
+
+    if (opt_cfg->opt == OPTION6_REFRESH_TIME)
+      done_refresh = 1;
+
+    if (opt_cfg->opt == OPTION6_DNS_SERVER)
+      done_dns = 1;
+
+    if (opt_cfg->flags & DHOPT_ADDR6) {
+      int len, j;
+      struct in6_addr *a;
+
+      for (a = (struct in6_addr *) opt_cfg->val, len = opt_cfg->len, j = 0;
+           j < opt_cfg->len; j += IN6ADDRSZ, a++)
+        if ((IN6_IS_ADDR_ULA_ZERO(a)
+             && IN6_IS_ADDR_UNSPECIFIED(state->ula_addr))
+            || (IN6_IS_ADDR_LINK_LOCAL_ZERO(a)
+                && IN6_IS_ADDR_UNSPECIFIED(state->ll_addr)))
+          len -= IN6ADDRSZ;
+
+      if (len != 0) {
+
+        o = new_opt6(opt_cfg->opt);
+
+        for (a = (struct in6_addr *) opt_cfg->val, j = 0; j < opt_cfg->len;
+             j += IN6ADDRSZ, a++) {
+          if (IN6_IS_ADDR_UNSPECIFIED(a)) {
+            if (!add_local_addrs(state->context))
+              put_opt6(state->fallback, IN6ADDRSZ);
+          } else if (IN6_IS_ADDR_ULA_ZERO(a)) {
+            if (!IN6_IS_ADDR_UNSPECIFIED(state->ula_addr))
+              put_opt6(state->ula_addr, IN6ADDRSZ);
+          } else if (IN6_IS_ADDR_LINK_LOCAL_ZERO(a)) {
+            if (!IN6_IS_ADDR_UNSPECIFIED(state->ll_addr))
+              put_opt6(state->ll_addr, IN6ADDRSZ);
+          } else
+            put_opt6(a, IN6ADDRSZ);
+        }
+
+        end_opt6(o);
+      }
+    } else {
+      o = new_opt6(opt_cfg->opt);
+      if (opt_cfg->val)
+        put_opt6(opt_cfg->val, opt_cfg->len);
+      end_opt6(o);
     }
-   
-    /* handle vendor-identifying vendor-encapsulated options,
-       dhcp-option = vi-encap:13,17,....... */
+  }
+
+  if (daemon->port == NAMESERVER_PORT && !done_dns) {
+    o = new_opt6(OPTION6_DNS_SERVER);
+    if (!add_local_addrs(state->context))
+      put_opt6(state->fallback, IN6ADDRSZ);
+    end_opt6(o);
+  }
+
+  if (state->context && !done_refresh) {
+    struct dhcp_context *c;
+    unsigned int lease_time = 0xffffffff;
+
+    /* Find the smallest lease tie of all contexts,
+       subject to the RFC-4242 stipulation that this must not
+       be less than 600. */
+    for (c = state->context; c; c = c->next)
+      if (c->lease_time < lease_time) {
+        if (c->lease_time < 600)
+          lease_time = 600;
+        else
+          lease_time = c->lease_time;
+      }
+
+    o = new_opt6(OPTION6_REFRESH_TIME);
+    put_opt6_long(lease_time);
+    end_opt6(o);
+  }
+
+  /* handle vendor-identifying vendor-encapsulated options,
+     dhcp-option = vi-encap:13,17,....... */
   for (opt_cfg = daemon->dhcp_opts6; opt_cfg; opt_cfg = opt_cfg->next)
     opt_cfg->flags &= ~DHOPT_ENCAP_DONE;
-    
+
   if (oro)
-    for (i = 0; i <  opt6_len(oro) - 1; i += 2)
+    for (i = 0; i < opt6_len(oro) - 1; i += 2)
       if (opt6_uint(oro, i, 2) == OPTION6_VENDOR_OPTS)
-	do_encap = 1;
-  
-  for (opt_cfg = daemon->dhcp_opts6; opt_cfg; opt_cfg = opt_cfg->next)
-    { 
-      if (opt_cfg->flags & DHOPT_RFC3925)
-	{
-	  int found = 0;
-	  struct dhcp_opt *oc;
-	  
-	  if (opt_cfg->flags & DHOPT_ENCAP_DONE)
-	    continue;
-	  
-	  for (oc = daemon->dhcp_opts6; oc; oc = oc->next)
-	    {
-	      oc->flags &= ~DHOPT_ENCAP_MATCH;
-	      
-	      if (!(oc->flags & DHOPT_RFC3925) || opt_cfg->u.encap != oc->u.encap)
-		continue;
-	      
-	      oc->flags |= DHOPT_ENCAP_DONE;
-	      if (match_netid(oc->netid, tagif, 1))
-		{
-		  /* option requested/forced? */
-		  if (!oro || do_encap || (oc->flags & DHOPT_FORCE))
-		    {
-		      oc->flags |= DHOPT_ENCAP_MATCH;
-		      found = 1;
-		    }
-		} 
-	    }
-	  
-	  if (found)
-	    { 
-	      o = new_opt6(OPTION6_VENDOR_OPTS);	      
-	      put_opt6_long(opt_cfg->u.encap);	
-	     
-	      for (oc = daemon->dhcp_opts6; oc; oc = oc->next)
-		if (oc->flags & DHOPT_ENCAP_MATCH)
-		  {
-		    o1 = new_opt6(oc->opt);
-		    put_opt6(oc->val, oc->len);
-		    end_opt6(o1);
-		  }
-	      end_opt6(o);
-	    }
-	}
-    }      
+        do_encap = 1;
 
+  for (opt_cfg = daemon->dhcp_opts6; opt_cfg; opt_cfg = opt_cfg->next) {
+    if (opt_cfg->flags & DHOPT_RFC3925) {
+      int found = 0;
+      struct dhcp_opt *oc;
+
+      if (opt_cfg->flags & DHOPT_ENCAP_DONE)
+        continue;
+
+      for (oc = daemon->dhcp_opts6; oc; oc = oc->next) {
+        oc->flags &= ~DHOPT_ENCAP_MATCH;
+
+        if (!(oc->flags & DHOPT_RFC3925) || opt_cfg->u.encap != oc->u.encap)
+          continue;
+
+        oc->flags |= DHOPT_ENCAP_DONE;
+        if (match_netid(oc->netid, tagif, 1)) {
+          /* option requested/forced? */
+          if (!oro || do_encap || (oc->flags & DHOPT_FORCE)) {
+            oc->flags |= DHOPT_ENCAP_MATCH;
+            found = 1;
+          }
+        }
+      }
 
-  if (state->hostname)
-    {
-      unsigned char *p;
-      size_t len = strlen(state->hostname);
-      
-      if (state->send_domain)
-	len += strlen(state->send_domain) + 2;
-
-      o = new_opt6(OPTION6_FQDN);
-      if ((p = expand(len + 2)))
-	{
-	  *(p++) = state->fqdn_flags;
-	  p = do_rfc1035_name(p, state->hostname, NULL);
-	  if (state->send_domain)
-	    {
-	      p = do_rfc1035_name(p, state->send_domain, NULL);
-	      *p = 0;
-	    }
-	}
-      end_opt6(o);
+      if (found) {
+        o = new_opt6(OPTION6_VENDOR_OPTS);
+        put_opt6_long(opt_cfg->u.encap);
+
+        for (oc = daemon->dhcp_opts6; oc; oc = oc->next)
+          if (oc->flags & DHOPT_ENCAP_MATCH) {
+            o1 = new_opt6(oc->opt);
+            put_opt6(oc->val, oc->len);
+            end_opt6(o1);
+          }
+        end_opt6(o);
+      }
     }
+  }
+
+
+  if (state->hostname) {
+    unsigned char *p;
+    size_t len = strlen(state->hostname);
+
+    if (state->send_domain)
+      len += strlen(state->send_domain) + 2;
+
+    o = new_opt6(OPTION6_FQDN);
+    if ((p = expand(len + 2))) {
+      *(p++) = state->fqdn_flags;
+      p = do_rfc1035_name(p, state->hostname, NULL);
+      if (state->send_domain) {
+        p = do_rfc1035_name(p, state->send_domain, NULL);
+        *p = 0;
+      }
+    }
+    end_opt6(o);
+  }
 
 
   /* logging */
-  if (option_bool(OPT_LOG_OPTS) && oro)
-    {
-      char *q = daemon->namebuff;
-      for (i = 0; i <  opt6_len(oro) - 1; i += 2)
-	{
-	  char *s = option_string(AF_INET6, opt6_uint(oro, i, 2), NULL, 0, NULL, 0);
-	  q += snprintf(q, MAXDNAME - (q - daemon->namebuff),
-			"%d%s%s%s", 
-			opt6_uint(oro, i, 2),
-			strlen(s) != 0 ? ":" : "",
-			s, 
-			(i > opt6_len(oro) - 3) ? "" : ", ");
-	  if ( i >  opt6_len(oro) - 3 || (q - daemon->namebuff) > 40)
-	    {
-	      q = daemon->namebuff;
-	      my_syslog(MS_DHCP | LOG_INFO, _("%u requested options: %s"), state->xid, daemon->namebuff);
-	    }
-	}
-    } 
+  if (option_bool(OPT_LOG_OPTS) && oro) {
+    char *q = daemon->namebuff;
+    for (i = 0; i < opt6_len(oro) - 1; i += 2) {
+      char *s = option_string(AF_INET6, opt6_uint(oro, i, 2), NULL, 0, NULL, 0);
+      q += snprintf(q, MAXDNAME - (q - daemon->namebuff),
+                    "%d%s%s%s",
+                    opt6_uint(oro, i, 2),
+                    strlen(s) != 0 ? ":" : "",
+                    s, (i > opt6_len(oro) - 3) ? "" : ", ");
+      if (i > opt6_len(oro) - 3 || (q - daemon->namebuff) > 40) {
+        q = daemon->namebuff;
+        my_syslog(MS_DHCP | LOG_INFO, _("%u requested options: %s"), state->xid,
+                  daemon->namebuff);
+      }
+    }
+  }
 
   return tagif;
 }
- 
+
 static int add_local_addrs(struct dhcp_context *context)
 {
   int done = 0;
-  
+
   for (; context; context = context->current)
-    if ((context->flags & CONTEXT_USED) && !IN6_IS_ADDR_UNSPECIFIED(&context->local6))
-      {
-	/* squash duplicates */
-	struct dhcp_context *c;
-	for (c = context->current; c; c = c->current)
-	  if ((c->flags & CONTEXT_USED) &&
-	      IN6_ARE_ADDR_EQUAL(&context->local6, &c->local6))
-	    break;
-	
-	if (!c)
-	  { 
-	    done = 1;
-	    put_opt6(&context->local6, IN6ADDRSZ);
-	  }
+    if ((context->flags & CONTEXT_USED)
+        && !IN6_IS_ADDR_UNSPECIFIED(&context->local6)) {
+      /* squash duplicates */
+      struct dhcp_context *c;
+      for (c = context->current; c; c = c->current)
+        if ((c->flags & CONTEXT_USED) &&
+            IN6_ARE_ADDR_EQUAL(&context->local6, &c->local6))
+          break;
+
+      if (!c) {
+        done = 1;
+        put_opt6(&context->local6, IN6ADDRSZ);
       }
+    }
 
   return done;
 }
@@ -1548,55 +1522,58 @@
 static void get_context_tag(struct state *state, struct dhcp_context *context)
 {
   /* get tags from context if we've not used it before */
-  if (context->netid.next == &context->netid && context->netid.net)
-    {
-      context->netid.next = state->context_tags;
-      state->context_tags = &context->netid;
-      if (!state->hostname_auth)
-	{
-	  struct dhcp_netid_list *id_list;
-	  
-	  for (id_list = daemon->dhcp_ignore_names; id_list; id_list = id_list->next)
-	    if ((!id_list->list) || match_netid(id_list->list, &context->netid, 0))
-	      break;
-	  if (id_list)
-	    state->hostname = NULL;
-	}
+  if (context->netid.next == &context->netid && context->netid.net) {
+    context->netid.next = state->context_tags;
+    state->context_tags = &context->netid;
+    if (!state->hostname_auth) {
+      struct dhcp_netid_list *id_list;
+
+      for (id_list = daemon->dhcp_ignore_names; id_list;
+           id_list = id_list->next)
+        if ((!id_list->list) || match_netid(id_list->list, &context->netid, 0))
+          break;
+      if (id_list)
+        state->hostname = NULL;
     }
-} 
+  }
+}
 
 #ifdef OPTION6_PREFIX_CLASS
-static struct prefix_class *prefix_class_from_context(struct dhcp_context *context)
+static struct prefix_class *prefix_class_from_context(struct dhcp_context
+                                                      *context)
 {
   struct prefix_class *p;
   struct dhcp_netid *t;
-  
-  for (p = daemon->prefix_classes; p ; p = p->next)
+
+  for (p = daemon->prefix_classes; p; p = p->next)
     for (t = context->filter; t; t = t->next)
       if (strcmp(p->tag.net, t->net) == 0)
-	return p;
-  
- return NULL;
+        return p;
+
+  return NULL;
 }
 #endif
 
-static int check_ia(struct state *state, void *opt, void **endp, void **ia_option)
+static int check_ia(struct state *state, void *opt, void **endp,
+                    void **ia_option)
 {
   state->ia_type = opt6_type(opt);
   *ia_option = NULL;
 
   if (state->ia_type != OPTION6_IA_NA && state->ia_type != OPTION6_IA_TA)
     return 0;
-  
+
   if (state->ia_type == OPTION6_IA_NA && opt6_len(opt) < 12)
     return 0;
-	    
+
   if (state->ia_type == OPTION6_IA_TA && opt6_len(opt) < 4)
     return 0;
-  
+
   *endp = opt6_ptr(opt, opt6_len(opt));
   state->iaid = opt6_uint(opt, 0, 4);
-  *ia_option = opt6_find(opt6_ptr(opt, state->ia_type == OPTION6_IA_NA ? 12 : 4), *endp, OPTION6_IAADDR, 24);
+  *ia_option =
+      opt6_find(opt6_ptr(opt, state->ia_type == OPTION6_IA_NA ? 12 : 4), *endp,
+                OPTION6_IAADDR, 24);
 
   return 1;
 }
@@ -1604,78 +1581,75 @@
 
 static int build_ia(struct state *state, int *t1cntr)
 {
-  int  o = new_opt6(state->ia_type);
- 
+  int o = new_opt6(state->ia_type);
+
   put_opt6_long(state->iaid);
   *t1cntr = 0;
-	    
-  if (state->ia_type == OPTION6_IA_NA)
-    {
-      /* save pointer */
-      *t1cntr = save_counter(-1);
-      /* so we can fill these in later */
-      put_opt6_long(0);
-      put_opt6_long(0); 
-    }
+
+  if (state->ia_type == OPTION6_IA_NA) {
+    /* save pointer */
+    *t1cntr = save_counter(-1);
+    /* so we can fill these in later */
+    put_opt6_long(0);
+    put_opt6_long(0);
+  }
 
   return o;
 }
 
 static void end_ia(int t1cntr, unsigned int min_time, int do_fuzz)
 {
-  if (t1cntr != 0)
-    {
-      /* go back an fill in fields in IA_NA option */
-      int sav = save_counter(t1cntr);
-      unsigned int t1, t2, fuzz = 0;
-
-      if (do_fuzz)
-	{
-	  fuzz = rand16();
-      
-	  while (fuzz > (min_time/16))
-	    fuzz = fuzz/2;
-	}
-      
-      t1 = (min_time == 0xffffffff) ? 0xffffffff : min_time/2 - fuzz;
-      t2 = (min_time == 0xffffffff) ? 0xffffffff : ((min_time/8)*7) - fuzz;
-      put_opt6_long(t1);
-      put_opt6_long(t2);
-      save_counter(sav);
-    }	
-}
-
-static void add_address(struct state *state, struct dhcp_context *context, unsigned int lease_time, void *ia_option, 
-			unsigned int *min_time, struct in6_addr *addr, time_t now)
+  if (t1cntr != 0) {
+    /* go back an fill in fields in IA_NA option */
+    int sav = save_counter(t1cntr);
+    unsigned int t1, t2, fuzz = 0;
+
+    if (do_fuzz) {
+      fuzz = rand16();
+
+      while (fuzz > (min_time / 16))
+        fuzz = fuzz / 2;
+    }
+
+    t1 = (min_time == 0xffffffff) ? 0xffffffff : min_time / 2 - fuzz;
+    t2 = (min_time == 0xffffffff) ? 0xffffffff : ((min_time / 8) * 7) - fuzz;
+    put_opt6_long(t1);
+    put_opt6_long(t2);
+    save_counter(sav);
+  }
+}
+
+static void add_address(struct state *state, struct dhcp_context *context,
+                        unsigned int lease_time, void *ia_option,
+                        unsigned int *min_time, struct in6_addr *addr,
+                        time_t now)
 {
   unsigned int valid_time = 0, preferred_time = 0;
   int o = new_opt6(OPTION6_IAADDR);
   struct dhcp_lease *lease;
 
   /* get client requested times */
-  if (ia_option)
-    {
-      preferred_time =  opt6_uint(ia_option, 16, 4);
-      valid_time =  opt6_uint(ia_option, 20, 4);
-    }
+  if (ia_option) {
+    preferred_time = opt6_uint(ia_option, 16, 4);
+    valid_time = opt6_uint(ia_option, 20, 4);
+  }
+
+  calculate_times(context, min_time, &valid_time, &preferred_time, lease_time);
 
-  calculate_times(context, min_time, &valid_time, &preferred_time, lease_time); 
-  
   put_opt6(addr, sizeof(*addr));
   put_opt6_long(preferred_time);
-  put_opt6_long(valid_time); 		    
-  
+  put_opt6_long(valid_time);
+
 #ifdef OPTION6_PREFIX_CLASS
-  if (state->send_prefix_class)
-    {
-      int o1 = new_opt6(OPTION6_PREFIX_CLASS);
-      put_opt6_short(state->send_prefix_class->class);
-      end_opt6(o1);
-    }
+  if (state->send_prefix_class) {
+    int o1 = new_opt6(OPTION6_PREFIX_CLASS);
+    put_opt6_short(state->send_prefix_class->class);
+    end_opt6(o1);
+  }
 #endif
 
   end_opt6(o);
-  
+
   if (state->lease_allocate)
     update_leases(state, context, addr, valid_time, now);
 
@@ -1683,24 +1657,24 @@
     lease->flags |= LEASE_USED;
 
   /* get tags from context if we've not used it before */
-  if (context->netid.next == &context->netid && context->netid.net)
-    {
-      context->netid.next = state->context_tags;
-      state->context_tags = &context->netid;
-      
-      if (!state->hostname_auth)
-	{
-	  struct dhcp_netid_list *id_list;
-	  
-	  for (id_list = daemon->dhcp_ignore_names; id_list; id_list = id_list->next)
-	    if ((!id_list->list) || match_netid(id_list->list, &context->netid, 0))
-	      break;
-	  if (id_list)
-	    state->hostname = NULL;
-	}
+  if (context->netid.next == &context->netid && context->netid.net) {
+    context->netid.next = state->context_tags;
+    state->context_tags = &context->netid;
+
+    if (!state->hostname_auth) {
+      struct dhcp_netid_list *id_list;
+
+      for (id_list = daemon->dhcp_ignore_names; id_list;
+           id_list = id_list->next)
+        if ((!id_list->list) || match_netid(id_list->list, &context->netid, 0))
+          break;
+      if (id_list)
+        state->hostname = NULL;
     }
+  }
 
-  log6_quiet(state, state->lease_allocate ? "DHCPREPLY" : "DHCPADVERTISE", addr, state->hostname);
+  log6_quiet(state, state->lease_allocate ? "DHCPREPLY" : "DHCPADVERTISE", addr,
+             state->hostname);
 
 }
 
@@ -1712,7 +1686,8 @@
 #ifdef OPTION6_PREFIX_CLASS
   for (context = state->context; context; context = context->current)
     if (is_same_net6(addr, &context->start6, context->prefix) &&
-	(!state->send_prefix_class || state->send_prefix_class == prefix_class_from_context(context)))
+        (!state->send_prefix_class
+         || state->send_prefix_class == prefix_class_from_context(context)))
       context->flags |= CONTEXT_USED;
 #else
   for (context = state->context; context; context = context->current)
@@ -1721,7 +1696,8 @@
 #endif
 }
 
-static void mark_config_used(struct dhcp_context *context, struct in6_addr *addr)
+static void mark_config_used(struct dhcp_context *context,
+                             struct in6_addr *addr)
 {
   for (; context; context = context->current)
     if (is_same_net6(addr, &context->start6, context->prefix))
@@ -1730,13 +1706,13 @@
 
 /* make sure address not leased to another CLID/IAID */
 static int check_address(struct state *state, struct in6_addr *addr)
-{ 
+{
   struct dhcp_lease *lease;
 
   if (!(lease = lease6_find_by_addr(addr, 128, 0)))
     return 1;
 
-  if (lease->clid_len != state->clid_len || 
+  if (lease->clid_len != state->clid_len ||
       memcmp(lease->clid, state->clid, state->clid_len) != 0 ||
       lease->iaid != state->iaid)
     return 0;
@@ -1761,296 +1737,296 @@
    *min_time - smallest valid time sent so far, to calculate T1 and T2.
    
    */
-static void calculate_times(struct dhcp_context *context, unsigned int *min_time, unsigned int *valid_timep, 
-			    unsigned int *preferred_timep, unsigned int lease_time)
+static void calculate_times(struct dhcp_context *context,
+                            unsigned int *min_time, unsigned int *valid_timep,
+                            unsigned int *preferred_timep,
+                            unsigned int lease_time)
 {
   unsigned int req_preferred = *preferred_timep, req_valid = *valid_timep;
   unsigned int valid_time = lease_time, preferred_time = lease_time;
-  
+
   /* RFC 3315: "A server ignores the lifetimes set
      by the client if the preferred lifetime is greater than the valid
      lifetime. */
-  if (req_preferred <= req_valid)
+  if (req_preferred <= req_valid) {
+    if (req_preferred != 0) {
+      /* 0 == "no preference from client" */
+      if (req_preferred < 120u)
+        req_preferred = 120u;   /* sanity */
+
+      if (req_preferred < preferred_time)
+        preferred_time = req_preferred;
+    }
+
+    if (req_valid != 0)
+      /* 0 == "no preference from client" */
     {
-      if (req_preferred != 0)
-	{
-	  /* 0 == "no preference from client" */
-	  if (req_preferred < 120u)
-	    req_preferred = 120u; /* sanity */
-	  
-	  if (req_preferred < preferred_time)
-	    preferred_time = req_preferred;
-	}
-      
-      if (req_valid != 0)
-	/* 0 == "no preference from client" */
-	{
-	  if (req_valid < 120u)
-	    req_valid = 120u; /* sanity */
-	  
-	  if (req_valid < valid_time)
-	    valid_time = req_valid;
-	}
+      if (req_valid < 120u)
+        req_valid = 120u;       /* sanity */
+
+      if (req_valid < valid_time)
+        valid_time = req_valid;
     }
+  }
 
   /* deprecate (preferred == 0) which configured, or when local address 
      is deprecated */
   if ((context->flags & CONTEXT_DEPRECATE) || context->preferred == 0)
     preferred_time = 0;
-  
+
   if (preferred_time != 0 && preferred_time < *min_time)
     *min_time = preferred_time;
-  
+
   if (valid_time != 0 && valid_time < *min_time)
     *min_time = valid_time;
-  
+
   *valid_timep = valid_time;
   *preferred_timep = preferred_time;
 }
 
-static void update_leases(struct state *state, struct dhcp_context *context, struct in6_addr *addr, unsigned int lease_time, time_t now)
+static void update_leases(struct state *state, struct dhcp_context *context,
+                          struct in6_addr *addr, unsigned int lease_time,
+                          time_t now)
 {
   struct dhcp_lease *lease = lease6_find_by_addr(addr, 128, 0);
 #ifdef HAVE_SCRIPT
   struct dhcp_netid *tagif = run_tag_if(state->tags);
 #endif
 
-  (void)context;
+  (void) context;
 
   if (!lease)
-    lease = lease6_allocate(addr, state->ia_type == OPTION6_IA_NA ? LEASE_NA : LEASE_TA);
-  
-  if (lease)
-    {
-      lease_set_expires(lease, lease_time, now);
-      lease_set_iaid(lease, state->iaid); 
-      lease_set_hwaddr(lease, state->mac, state->clid, state->mac_len, state->mac_type, state->clid_len, now, 0);
-      lease_set_interface(lease, state->interface, now);
-      if (state->hostname && state->ia_type == OPTION6_IA_NA)
-	{
-	  char *addr_domain = get_domain6(addr);
-	  if (!state->send_domain)
-	    state->send_domain = addr_domain;
-	  lease_set_hostname(lease, state->hostname, state->hostname_auth, addr_domain, state->domain);
-	}
-      
+    lease =
+        lease6_allocate(addr,
+                        state->ia_type == OPTION6_IA_NA ? LEASE_NA : LEASE_TA);
+
+  if (lease) {
+    lease_set_expires(lease, lease_time, now);
+    lease_set_iaid(lease, state->iaid);
+    lease_set_hwaddr(lease, state->mac, state->clid, state->mac_len,
+                     state->mac_type, state->clid_len, now, 0);
+    lease_set_interface(lease, state->interface, now);
+    if (state->hostname && state->ia_type == OPTION6_IA_NA) {
+      char *addr_domain = get_domain6(addr);
+      if (!state->send_domain)
+        state->send_domain = addr_domain;
+      lease_set_hostname(lease, state->hostname, state->hostname_auth,
+                         addr_domain, state->domain);
+    }
 #ifdef HAVE_SCRIPT
-      if (daemon->lease_change_command)
-	{
-	  void *class_opt;
-	  lease->flags |= LEASE_CHANGED;
-	  free(lease->extradata);
-	  lease->extradata = NULL;
-	  lease->extradata_size = lease->extradata_len = 0;
-	  lease->vendorclass_count = 0; 
-	  
-	  if ((class_opt = opt6_find(state->packet_options, state->end, OPTION6_VENDOR_CLASS, 4)))
-	    {
-	      void *enc_opt, *enc_end = opt6_ptr(class_opt, opt6_len(class_opt));
-	      lease->vendorclass_count++;
-	      /* send enterprise number first  */
-	      sprintf(daemon->dhcp_buff2, "%u", opt6_uint(class_opt, 0, 4));
-	      lease_add_extradata(lease, (unsigned char *)daemon->dhcp_buff2, strlen(daemon->dhcp_buff2), 0);
-	      
-	      if (opt6_len(class_opt) >= 6) 
-		for (enc_opt = opt6_ptr(class_opt, 4); enc_opt; enc_opt = opt6_next(enc_opt, enc_end))
-		  {
-		    lease->vendorclass_count++;
-		    lease_add_extradata(lease, opt6_ptr(enc_opt, 0), opt6_len(enc_opt), 0);
-		  }
-	    }
-	  
-	  lease_add_extradata(lease, (unsigned char *)state->client_hostname, 
-			      state->client_hostname ? strlen(state->client_hostname) : 0, 0);				
-	  
-	  /* space-concat tag set */
-	  if (!tagif && !context->netid.net)
-	    lease_add_extradata(lease, NULL, 0, 0);
-	  else
-	    {
-	      if (context->netid.net)
-		lease_add_extradata(lease, (unsigned char *)context->netid.net, strlen(context->netid.net), tagif ? ' ' : 0);
-	      
-	      if (tagif)
-		{
-		  struct dhcp_netid *n;
-		  for (n = tagif; n; n = n->next)
-		    {
-		      struct dhcp_netid *n1;
-		      /* kill dupes */
-		      for (n1 = n->next; n1; n1 = n1->next)
-			if (strcmp(n->net, n1->net) == 0)
-			  break;
-		      if (!n1)
-			lease_add_extradata(lease, (unsigned char *)n->net, strlen(n->net), n->next ? ' ' : 0); 
-		    }
-		}
-	    }
-	  
-	  if (state->link_address)
-	    inet_ntop(AF_INET6, state->link_address, daemon->addrbuff, ADDRSTRLEN);
-	  
-	  lease_add_extradata(lease, (unsigned char *)daemon->addrbuff, state->link_address ? strlen(daemon->addrbuff) : 0, 0);
-	  
-	  if ((class_opt = opt6_find(state->packet_options, state->end, OPTION6_USER_CLASS, 2)))
-	    {
-	      void *enc_opt, *enc_end = opt6_ptr(class_opt, opt6_len(class_opt));
-	      for (enc_opt = opt6_ptr(class_opt, 0); enc_opt; enc_opt = opt6_next(enc_opt, enc_end))
-		lease_add_extradata(lease, opt6_ptr(enc_opt, 0), opt6_len(enc_opt), 0);
-	    }
-	}
-#endif	
-      
-    }
-}
-			  
-			
-	
-static void log6_opts(int nest, unsigned int xid, void *start_opts, void *end_opts)
+    if (daemon->lease_change_command) {
+      void *class_opt;
+      lease->flags |= LEASE_CHANGED;
+      free(lease->extradata);
+      lease->extradata = NULL;
+      lease->extradata_size = lease->extradata_len = 0;
+      lease->vendorclass_count = 0;
+
+      if ((class_opt =
+           opt6_find(state->packet_options, state->end, OPTION6_VENDOR_CLASS,
+                     4))) {
+        void *enc_opt, *enc_end = opt6_ptr(class_opt, opt6_len(class_opt));
+        lease->vendorclass_count++;
+        /* send enterprise number first  */
+        sprintf(daemon->dhcp_buff2, "%u", opt6_uint(class_opt, 0, 4));
+        lease_add_extradata(lease, (unsigned char *) daemon->dhcp_buff2,
+                            strlen(daemon->dhcp_buff2), 0);
+
+        if (opt6_len(class_opt) >= 6)
+          for (enc_opt = opt6_ptr(class_opt, 4); enc_opt;
+               enc_opt = opt6_next(enc_opt, enc_end)) {
+            lease->vendorclass_count++;
+            lease_add_extradata(lease, opt6_ptr(enc_opt, 0), opt6_len(enc_opt),
+                                0);
+          }
+      }
+
+      lease_add_extradata(lease, (unsigned char *) state->client_hostname,
+                          state->client_hostname ? strlen(state->
+                                                          client_hostname) : 0,
+                          0);
+
+      /* space-concat tag set */
+      if (!tagif && !context->netid.net)
+        lease_add_extradata(lease, NULL, 0, 0);
+      else {
+        if (context->netid.net)
+          lease_add_extradata(lease, (unsigned char *) context->netid.net,
+                              strlen(context->netid.net), tagif ? ' ' : 0);
+
+        if (tagif) {
+          struct dhcp_netid *n;
+          for (n = tagif; n; n = n->next) {
+            struct dhcp_netid *n1;
+            /* kill dupes */
+            for (n1 = n->next; n1; n1 = n1->next)
+              if (strcmp(n->net, n1->net) == 0)
+                break;
+            if (!n1)
+              lease_add_extradata(lease, (unsigned char *) n->net,
+                                  strlen(n->net), n->next ? ' ' : 0);
+          }
+        }
+      }
+
+      if (state->link_address)
+        inet_ntop(AF_INET6, state->link_address, daemon->addrbuff, ADDRSTRLEN);
+
+      lease_add_extradata(lease, (unsigned char *) daemon->addrbuff,
+                          state->link_address ? strlen(daemon->addrbuff) : 0,
+                          0);
+
+      if ((class_opt =
+           opt6_find(state->packet_options, state->end, OPTION6_USER_CLASS,
+                     2))) {
+        void *enc_opt, *enc_end = opt6_ptr(class_opt, opt6_len(class_opt));
+        for (enc_opt = opt6_ptr(class_opt, 0); enc_opt;
+             enc_opt = opt6_next(enc_opt, enc_end))
+          lease_add_extradata(lease, opt6_ptr(enc_opt, 0), opt6_len(enc_opt),
+                              0);
+      }
+    }
+#endif
+
+  }
+}
+
+
+
+static void log6_opts(int nest, unsigned int xid, void *start_opts,
+                      void *end_opts)
 {
   void *opt;
   char *desc = nest ? "nest" : "sent";
-  
+
   if (!option_bool(OPT_LOG_OPTS) || start_opts == end_opts)
     return;
-  
-  for (opt = start_opts; opt; opt = opt6_next(opt, end_opts))
-    {
-      int type = opt6_type(opt);
-      void *ia_options = NULL;
-      char *optname;
-      
-      if (type == OPTION6_IA_NA)
-	{
-	  sprintf(daemon->namebuff, "IAID=%u T1=%u T2=%u",
-		  opt6_uint(opt, 0, 4), opt6_uint(opt, 4, 4), opt6_uint(opt, 8, 4));
-	  optname = "ia-na";
-	  ia_options = opt6_ptr(opt, 12);
-	}
-      else if (type == OPTION6_IA_TA)
-	{
-	  sprintf(daemon->namebuff, "IAID=%u", opt6_uint(opt, 0, 4));
-	  optname = "ia-ta";
-	  ia_options = opt6_ptr(opt, 4);
-	}
-      else if (type == OPTION6_IAADDR)
-	{
-	  inet_ntop(AF_INET6, opt6_ptr(opt, 0), daemon->addrbuff, ADDRSTRLEN);
-	  sprintf(daemon->namebuff, "%s PL=%u VL=%u", 
-		  daemon->addrbuff, opt6_uint(opt, 16, 4), opt6_uint(opt, 20, 4));
-	  optname = "iaaddr";
-	  ia_options = opt6_ptr(opt, 24);
-	}
+
+  for (opt = start_opts; opt; opt = opt6_next(opt, end_opts)) {
+    int type = opt6_type(opt);
+    void *ia_options = NULL;
+    char *optname;
+
+    if (type == OPTION6_IA_NA) {
+      sprintf(daemon->namebuff, "IAID=%u T1=%u T2=%u",
+              opt6_uint(opt, 0, 4), opt6_uint(opt, 4, 4), opt6_uint(opt, 8, 4));
+      optname = "ia-na";
+      ia_options = opt6_ptr(opt, 12);
+    } else if (type == OPTION6_IA_TA) {
+      sprintf(daemon->namebuff, "IAID=%u", opt6_uint(opt, 0, 4));
+      optname = "ia-ta";
+      ia_options = opt6_ptr(opt, 4);
+    } else if (type == OPTION6_IAADDR) {
+      inet_ntop(AF_INET6, opt6_ptr(opt, 0), daemon->addrbuff, ADDRSTRLEN);
+      sprintf(daemon->namebuff, "%s PL=%u VL=%u",
+              daemon->addrbuff, opt6_uint(opt, 16, 4), opt6_uint(opt, 20, 4));
+      optname = "iaaddr";
+      ia_options = opt6_ptr(opt, 24);
+    }
 #ifdef OPTION6_PREFIX_CLASS
-      else if (type == OPTION6_PREFIX_CLASS)
-	{
-	  optname = "prefix-class";
-	  sprintf(daemon->namebuff, "class=%u", opt6_uint(opt, 0, 2));
-	}
+    else if (type == OPTION6_PREFIX_CLASS) {
+      optname = "prefix-class";
+      sprintf(daemon->namebuff, "class=%u", opt6_uint(opt, 0, 2));
+    }
 #endif
-      else if (type == OPTION6_STATUS_CODE)
-	{
-	  int len = sprintf(daemon->namebuff, "%u ", opt6_uint(opt, 0, 2));
-	  memcpy(daemon->namebuff + len, opt6_ptr(opt, 2), opt6_len(opt)-2);
-	  daemon->namebuff[len + opt6_len(opt) - 2] = 0;
-	  optname = "status";
-	}
-      else
-	{
-	  /* account for flag byte on FQDN */
-	  int offset = type == OPTION6_FQDN ? 1 : 0;
-	  optname = option_string(AF_INET6, type, opt6_ptr(opt, offset), opt6_len(opt) - offset, daemon->namebuff, MAXDNAME);
-	}
-      
-      my_syslog(MS_DHCP | LOG_INFO, "%u %s size:%3d option:%3d %s  %s", 
-		xid, desc, opt6_len(opt), type, optname, daemon->namebuff);
-      
-      if (ia_options)
-	log6_opts(1, xid, ia_options, opt6_ptr(opt, opt6_len(opt)));
-    }
-}		 
- 
-static void log6_quiet(struct state *state, char *type, struct in6_addr *addr, char *string)
+    else if (type == OPTION6_STATUS_CODE) {
+      int len = sprintf(daemon->namebuff, "%u ", opt6_uint(opt, 0, 2));
+      memcpy(daemon->namebuff + len, opt6_ptr(opt, 2), opt6_len(opt) - 2);
+      daemon->namebuff[len + opt6_len(opt) - 2] = 0;
+      optname = "status";
+    } else {
+      /* account for flag byte on FQDN */
+      int offset = type == OPTION6_FQDN ? 1 : 0;
+      optname =
+          option_string(AF_INET6, type, opt6_ptr(opt, offset),
+                        opt6_len(opt) - offset, daemon->namebuff, MAXDNAME);
+    }
+
+    my_syslog(MS_DHCP | LOG_INFO, "%u %s size:%3d option:%3d %s  %s",
+              xid, desc, opt6_len(opt), type, optname, daemon->namebuff);
+
+    if (ia_options)
+      log6_opts(1, xid, ia_options, opt6_ptr(opt, opt6_len(opt)));
+  }
+}
+
+static void log6_quiet(struct state *state, char *type, struct in6_addr *addr,
+                       char *string)
 {
   if (option_bool(OPT_LOG_OPTS) || !option_bool(OPT_QUIET_DHCP6))
     log6_packet(state, type, addr, string);
 }
 
-static void log6_packet(struct state *state, char *type, struct in6_addr *addr, char *string)
+static void log6_packet(struct state *state, char *type, struct in6_addr *addr,
+                        char *string)
 {
   int clid_len = state->clid_len;
 
   /* avoid buffer overflow */
   if (clid_len > 100)
     clid_len = 100;
-  
+
   print_mac(daemon->namebuff, state->clid, clid_len);
 
-  if (addr)
-    {
-      inet_ntop(AF_INET6, addr, daemon->dhcp_buff2, DHCP_BUFF_SZ - 1);
-      strcat(daemon->dhcp_buff2, " ");
-    }
-  else
+  if (addr) {
+    inet_ntop(AF_INET6, addr, daemon->dhcp_buff2, DHCP_BUFF_SZ - 1);
+    strcat(daemon->dhcp_buff2, " ");
+  } else
     daemon->dhcp_buff2[0] = 0;
 
-  if(option_bool(OPT_LOG_OPTS))
+  if (option_bool(OPT_LOG_OPTS))
     my_syslog(MS_DHCP | LOG_INFO, "%u %s(%s) %s%s %s",
-	      state->xid, 
-	      type,
-	      state->iface_name, 
-	      daemon->dhcp_buff2,
-	      daemon->namebuff,
-	      string ? string : "");
+              state->xid,
+              type,
+              state->iface_name,
+              daemon->dhcp_buff2, daemon->namebuff, string ? string : "");
   else
     my_syslog(MS_DHCP | LOG_INFO, "%s(%s) %s%s %s",
-	      type,
-	      state->iface_name, 
-	      daemon->dhcp_buff2,
-	      daemon->namebuff,
-	      string ? string : "");
+              type,
+              state->iface_name,
+              daemon->dhcp_buff2, daemon->namebuff, string ? string : "");
 }
 
-static void *opt6_find (void *opts, void *end, unsigned int search, unsigned int minsize)
+static void *opt6_find(void *opts, void *end, unsigned int search,
+                       unsigned int minsize)
 {
   u16 opt, opt_len;
   void *start;
-  
+
   if (!opts)
     return NULL;
-    
-  while (1)
-    {
-      if (end - opts < 4) 
-	return NULL;
-      
-      start = opts;
-      GETSHORT(opt, opts);
-      GETSHORT(opt_len, opts);
-      
-      if (opt_len > (end - opts))
-	return NULL;
-      
-      if (opt == search && (opt_len >= minsize))
-	return start;
-      
-      opts += opt_len;
-    }
+
+  while (1) {
+    if (end - opts < 4)
+      return NULL;
+
+    start = opts;
+    GETSHORT(opt, opts);
+    GETSHORT(opt_len, opts);
+
+    if (opt_len > (end - opts))
+      return NULL;
+
+    if (opt == search && (opt_len >= minsize))
+      return start;
+
+    opts += opt_len;
+  }
 }
 
 static void *opt6_next(void *opts, void *end)
 {
   u16 opt_len;
-  
-  if (end - opts < 4) 
+
+  if (end - opts < 4)
     return NULL;
-  
+
   opts += 2;
   GETSHORT(opt_len, opts);
-  
+
   if (opt_len >= (end - opts))
     return NULL;
-  
+
   return opts + opt_len;
 }
 
@@ -2060,18 +2036,18 @@
   unsigned int ret = 0;
   int i;
   unsigned char *p = opt6_ptr(opt, offset);
-  
+
   for (i = 0; i < size; i++)
     ret = (ret << 8) | *p++;
-  
+
   return ret;
-} 
+}
 
-void relay_upstream6(struct dhcp_relay *relay, ssize_t sz, 
-		     struct in6_addr *peer_address, u32 scope_id, time_t now)
+void relay_upstream6(struct dhcp_relay *relay, ssize_t sz,
+                     struct in6_addr *peer_address, u32 scope_id, time_t now)
 {
   /* ->local is same value for all relays on ->current chain */
-  
+
   struct all_addr from;
   unsigned char *header;
   unsigned char *inbuff = daemon->dhcp_packet.iov_base;
@@ -2086,10 +2062,10 @@
 
   /* source address == relay address */
   from.addr.addr6 = relay->local.addr.addr6;
-    
-  /* Get hop count from nested relayed message */ 
+
+  /* Get hop count from nested relayed message */
   if (msg_type == DHCP6RELAYFORW)
-    hopcount = *((unsigned char *)inbuff+1) + 1;
+    hopcount = *((unsigned char *) inbuff + 1) + 1;
   else
     hopcount = 0;
 
@@ -2099,97 +2075,98 @@
 
   reset_counter();
 
-  if ((header = put_opt6(NULL, 34)))
-    {
-      int o;
+  if ((header = put_opt6(NULL, 34))) {
+    int o;
 
-      header[0] = DHCP6RELAYFORW;
-      header[1] = hopcount;
-      memcpy(&header[2],  &relay->local.addr.addr6, IN6ADDRSZ);
-      memcpy(&header[18], peer_address, IN6ADDRSZ);
- 
-      /* RFC-6939 */
-      if (maclen != 0)
-	{
-	  o = new_opt6(OPTION6_CLIENT_MAC);
-	  put_opt6_short(mactype);
-	  put_opt6(mac, maclen);
-	  end_opt6(o);
-	}
-      
-      o = new_opt6(OPTION6_RELAY_MSG);
-      put_opt6(inbuff, sz);
+    header[0] = DHCP6RELAYFORW;
+    header[1] = hopcount;
+    memcpy(&header[2], &relay->local.addr.addr6, IN6ADDRSZ);
+    memcpy(&header[18], peer_address, IN6ADDRSZ);
+
+    /* RFC-6939 */
+    if (maclen != 0) {
+      o = new_opt6(OPTION6_CLIENT_MAC);
+      put_opt6_short(mactype);
+      put_opt6(mac, maclen);
       end_opt6(o);
-      
-      for (; relay; relay = relay->current)
-	{
-	  union mysockaddr to;
-	  
-	  to.sa.sa_family = AF_INET6;
-	  to.in6.sin6_addr = relay->server.addr.addr6;
-	  to.in6.sin6_port = htons(DHCPV6_SERVER_PORT);
-	  to.in6.sin6_flowinfo = 0;
-	  to.in6.sin6_scope_id = 0;
-
-	  if (IN6_ARE_ADDR_EQUAL(&relay->server.addr.addr6, &multicast))
-	    {
-	      int multicast_iface;
-	      if (!relay->interface || strchr(relay->interface, '*') ||
-		  (multicast_iface = if_nametoindex(relay->interface)) == 0 ||
-		  setsockopt(daemon->dhcp6fd, IPPROTO_IPV6, IPV6_MULTICAST_IF, &multicast_iface, sizeof(multicast_iface)) == -1)
-		my_syslog(MS_DHCP | LOG_ERR, _("Cannot multicast to DHCPv6 server without correct interface"));
-	    }
-		
-	  send_from(daemon->dhcp6fd, 0, daemon->outpacket.iov_base, save_counter(-1), &to, &from, 0);
-	  
-	  if (option_bool(OPT_LOG_OPTS))
-	    {
-	      inet_ntop(AF_INET6, &relay->local, daemon->addrbuff, ADDRSTRLEN);
-	      inet_ntop(AF_INET6, &relay->server, daemon->namebuff, ADDRSTRLEN);
-	      my_syslog(MS_DHCP | LOG_INFO, _("DHCP relay %s -> %s"), daemon->addrbuff, daemon->namebuff);
-	    }
-
-	  /* Save this for replies */
-	  relay->iface_index = scope_id;
-	}
     }
+
+    o = new_opt6(OPTION6_RELAY_MSG);
+    put_opt6(inbuff, sz);
+    end_opt6(o);
+
+    for (; relay; relay = relay->current) {
+      union mysockaddr to;
+
+      to.sa.sa_family = AF_INET6;
+      to.in6.sin6_addr = relay->server.addr.addr6;
+      to.in6.sin6_port = htons(DHCPV6_SERVER_PORT);
+      to.in6.sin6_flowinfo = 0;
+      to.in6.sin6_scope_id = 0;
+
+      if (IN6_ARE_ADDR_EQUAL(&relay->server.addr.addr6, &multicast)) {
+        int multicast_iface;
+        if (!relay->interface || strchr(relay->interface, '*') ||
+            (multicast_iface = if_nametoindex(relay->interface)) == 0 ||
+            setsockopt(daemon->dhcp6fd, IPPROTO_IPV6, IPV6_MULTICAST_IF,
+                       &multicast_iface, sizeof(multicast_iface)) == -1)
+          my_syslog(MS_DHCP | LOG_ERR,
+                    _
+                    ("Cannot multicast to DHCPv6 server without correct interface"));
+      }
+
+      send_from(daemon->dhcp6fd, 0, daemon->outpacket.iov_base,
+                save_counter(-1), &to, &from, 0);
+
+      if (option_bool(OPT_LOG_OPTS)) {
+        inet_ntop(AF_INET6, &relay->local, daemon->addrbuff, ADDRSTRLEN);
+        inet_ntop(AF_INET6, &relay->server, daemon->namebuff, ADDRSTRLEN);
+        my_syslog(MS_DHCP | LOG_INFO, _("DHCP relay %s -> %s"),
+                  daemon->addrbuff, daemon->namebuff);
+      }
+
+      /* Save this for replies */
+      relay->iface_index = scope_id;
+    }
+  }
 }
 
-unsigned short relay_reply6(struct sockaddr_in6 *peer, ssize_t sz, char *arrival_interface)
+unsigned short relay_reply6(struct sockaddr_in6 *peer, ssize_t sz,
+                            char *arrival_interface)
 {
   struct dhcp_relay *relay;
   struct in6_addr link;
   unsigned char *inbuff = daemon->dhcp_packet.iov_base;
-  
+
   /* must have at least msg_type+hopcount+link_address+peer_address+minimal size option
      which is               1   +    1   +    16      +     16     + 2 + 2 = 38 */
-  
+
   if (sz < 38 || *inbuff != DHCP6RELAYREPL)
     return 0;
-  
-  memcpy(&link, &inbuff[2], IN6ADDRSZ); 
-  
+
+  memcpy(&link, &inbuff[2], IN6ADDRSZ);
+
   for (relay = daemon->relay6; relay; relay = relay->next)
     if (IN6_ARE_ADDR_EQUAL(&link, &relay->local.addr.addr6) &&
-	(!relay->interface || wildcard_match(relay->interface, arrival_interface)))
+        (!relay->interface
+         || wildcard_match(relay->interface, arrival_interface)))
       break;
-      
+
   reset_counter();
 
-  if (relay)
-    {
-      void *opt, *opts = inbuff + 34;
-      void *end = inbuff + sz;
-      for (opt = opts; opt; opt = opt6_next(opt, end))
-	if (opt6_type(opt) == OPTION6_RELAY_MSG && opt6_len(opt) > 0)
-	  {
-	    int encap_type = *((unsigned char *)opt6_ptr(opt, 0));
-	    put_opt6(opt6_ptr(opt, 0), opt6_len(opt));
-	    memcpy(&peer->sin6_addr, &inbuff[18], IN6ADDRSZ); 
-	    peer->sin6_scope_id = relay->iface_index;
-	    return encap_type == DHCP6RELAYREPL ? DHCPV6_SERVER_PORT : DHCPV6_CLIENT_PORT;
-	  }
-    }
+  if (relay) {
+    void *opt, *opts = inbuff + 34;
+    void *end = inbuff + sz;
+    for (opt = opts; opt; opt = opt6_next(opt, end))
+      if (opt6_type(opt) == OPTION6_RELAY_MSG && opt6_len(opt) > 0) {
+        int encap_type = *((unsigned char *) opt6_ptr(opt, 0));
+        put_opt6(opt6_ptr(opt, 0), opt6_len(opt));
+        memcpy(&peer->sin6_addr, &inbuff[18], IN6ADDRSZ);
+        peer->sin6_scope_id = relay->iface_index;
+        return encap_type ==
+            DHCP6RELAYREPL ? DHCPV6_SERVER_PORT : DHCPV6_CLIENT_PORT;
+      }
+  }
 
   return 0;
 }
Index: dnsmasq-2.78/src/rrfilter.c
===================================================================
--- dnsmasq-2.78.orig/src/rrfilter.c	2017-10-02 21:13:51.000000000 +0800
+++ dnsmasq-2.78/src/rrfilter.c	2018-10-29 16:14:19.501440028 +0800
@@ -14,91 +14,84 @@
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
 
-/* Code to safely remove RRs from an DNS answer */ 
+/* Code to safely remove RRs from an DNS answer */
 
 #include "dnsmasq.h"
 
 /* Go through a domain name, find "pointers" and fix them up based on how many bytes
    we've chopped out of the packet, or check they don't point into an elided part.  */
-static int check_name(unsigned char **namep, struct dns_header *header, size_t plen, int fixup, unsigned char **rrs, int rr_count)
+static int check_name(unsigned char **namep, struct dns_header *header,
+                      size_t plen, int fixup, unsigned char **rrs, int rr_count)
 {
   unsigned char *ansp = *namep;
 
-  while(1)
-    {
-      unsigned int label_type;
-      
-      if (!CHECK_LEN(header, ansp, plen, 1))
-	return 0;
-      
-      label_type = (*ansp) & 0xc0;
-
-      if (label_type == 0xc0)
-	{
-	  /* pointer for compression. */
-	  unsigned int offset;
-	  int i;
-	  unsigned char *p;
-	  
-	  if (!CHECK_LEN(header, ansp, plen, 2))
-	    return 0;
-
-	  offset = ((*ansp++) & 0x3f) << 8;
-	  offset |= *ansp++;
-
-	  p = offset + (unsigned char *)header;
-	  
-	  for (i = 0; i < rr_count; i++)
-	    if (p < rrs[i])
-	      break;
-	    else
-	      if (i & 1)
-		offset -= rrs[i] - rrs[i-1];
-
-	  /* does the pointer end up in an elided RR? */
-	  if (i & 1)
-	    return 0;
-
-	  /* No, scale the pointer */
-	  if (fixup)
-	    {
-	      ansp -= 2;
-	      *ansp++ = (offset >> 8) | 0xc0;
-	      *ansp++ = offset & 0xff;
-	    }
-	  break;
-	}
-      else if (label_type == 0x80)
-	return 0; /* reserved */
-      else if (label_type == 0x40)
-	{
-	  /* Extended label type */
-	  unsigned int count;
-	  
-	  if (!CHECK_LEN(header, ansp, plen, 2))
-	    return 0;
-	  
-	  if (((*ansp++) & 0x3f) != 1)
-	    return 0; /* we only understand bitstrings */
-	  
-	  count = *(ansp++); /* Bits in bitstring */
-	  
-	  if (count == 0) /* count == 0 means 256 bits */
-	    ansp += 32;
-	  else
-	    ansp += ((count-1)>>3)+1;
-	}
+  while (1) {
+    unsigned int label_type;
+
+    if (!CHECK_LEN(header, ansp, plen, 1))
+      return 0;
+
+    label_type = (*ansp) & 0xc0;
+
+    if (label_type == 0xc0) {
+      /* pointer for compression. */
+      unsigned int offset;
+      int i;
+      unsigned char *p;
+
+      if (!CHECK_LEN(header, ansp, plen, 2))
+        return 0;
+
+      offset = ((*ansp++) & 0x3f) << 8;
+      offset |= *ansp++;
+
+      p = offset + (unsigned char *) header;
+
+      for (i = 0; i < rr_count; i++)
+        if (p < rrs[i])
+          break;
+        else if (i & 1)
+          offset -= rrs[i] - rrs[i - 1];
+
+      /* does the pointer end up in an elided RR? */
+      if (i & 1)
+        return 0;
+
+      /* No, scale the pointer */
+      if (fixup) {
+        ansp -= 2;
+        *ansp++ = (offset >> 8) | 0xc0;
+        *ansp++ = offset & 0xff;
+      }
+      break;
+    } else if (label_type == 0x80)
+      return 0;                 /* reserved */
+    else if (label_type == 0x40) {
+      /* Extended label type */
+      unsigned int count;
+
+      if (!CHECK_LEN(header, ansp, plen, 2))
+        return 0;
+
+      if (((*ansp++) & 0x3f) != 1)
+        return 0;               /* we only understand bitstrings */
+
+      count = *(ansp++);        /* Bits in bitstring */
+
+      if (count == 0)           /* count == 0 means 256 bits */
+        ansp += 32;
       else
-	{ /* label type == 0 Bottom six bits is length */
-	  unsigned int len = (*ansp++) & 0x3f;
-	  
-	  if (!ADD_RDLEN(header, ansp, plen, len))
-	    return 0;
-
-	  if (len == 0)
-	    break; /* zero length label marks the end. */
-	}
+        ansp += ((count - 1) >> 3) + 1;
+    } else {                    /* label type == 0 Bottom six bits is length */
+      unsigned int len = (*ansp++) & 0x3f;
+
+      if (!ADD_RDLEN(header, ansp, plen, len))
+        return 0;
+
+      if (len == 0)
+        break;                  /* zero length label marks the end. */
     }
+  }
 
   *namep = ansp;
 
@@ -106,121 +99,119 @@
 }
 
 /* Go through RRs and check or fixup the domain names contained within */
-static int check_rrs(unsigned char *p, struct dns_header *header, size_t plen, int fixup, unsigned char **rrs, int rr_count)
+static int check_rrs(unsigned char *p, struct dns_header *header, size_t plen,
+                     int fixup, unsigned char **rrs, int rr_count)
 {
   int i, j, type, class, rdlen;
   unsigned char *pp;
-  
-  for (i = 0; i < ntohs(header->ancount) + ntohs(header->nscount) + ntohs(header->arcount); i++)
-    {
-      pp = p;
-
-      if (!(p = skip_name(p, header, plen, 10)))
-	return 0;
-      
-      GETSHORT(type, p); 
-      GETSHORT(class, p);
-      p += 4; /* TTL */
-      GETSHORT(rdlen, p);
-
-      /* If this RR is to be elided, don't fix up its contents */
-      for (j = 0; j < rr_count; j += 2)
-	if (rrs[j] == pp)
-	  break;
-
-      if (j >= rr_count)
-	{
-	  /* fixup name of RR */
-	  if (!check_name(&pp, header, plen, fixup, rrs, rr_count))
-	    return 0;
-	  
-	  if (class == C_IN)
-	    {
-	      u16 *d;
- 
-	      for (pp = p, d = rrfilter_desc(type); *d != (u16)-1; d++)
-		{
-		  if (*d != 0)
-		    pp += *d;
-		  else if (!check_name(&pp, header, plen, fixup, rrs, rr_count))
-		    return 0;
-		}
-	    }
-	}
-      
-      if (!ADD_RDLEN(header, p, plen, rdlen))
-	return 0;
+
+  for (i = 0;
+       i <
+       ntohs(header->ancount) + ntohs(header->nscount) + ntohs(header->arcount);
+       i++) {
+    pp = p;
+
+    if (!(p = skip_name(p, header, plen, 10)))
+      return 0;
+
+    GETSHORT(type, p);
+    GETSHORT(class, p);
+    p += 4;                     /* TTL */
+    GETSHORT(rdlen, p);
+
+    /* If this RR is to be elided, don't fix up its contents */
+    for (j = 0; j < rr_count; j += 2)
+      if (rrs[j] == pp)
+        break;
+
+    if (j >= rr_count) {
+      /* fixup name of RR */
+      if (!check_name(&pp, header, plen, fixup, rrs, rr_count))
+        return 0;
+
+      if (class == C_IN) {
+        u16 *d;
+
+        for (pp = p, d = rrfilter_desc(type); *d != (u16) - 1; d++) {
+          if (*d != 0)
+            pp += *d;
+          else if (!check_name(&pp, header, plen, fixup, rrs, rr_count))
+            return 0;
+        }
+      }
     }
-  
+
+    if (!ADD_RDLEN(header, p, plen, rdlen))
+      return 0;
+  }
+
   return 1;
 }
-	
+
 
 /* mode is 0 to remove EDNS0, 1 to filter DNSSEC RRs */
-size_t rrfilter(struct dns_header *header, size_t plen, int mode)
+size_t rrfilter(struct dns_header * header, size_t plen, int mode)
 {
   static unsigned char **rrs;
   static int rr_sz = 0;
 
-  unsigned char *p = (unsigned char *)(header+1);
+  unsigned char *p = (unsigned char *) (header + 1);
   int i, rdlen, qtype, qclass, rr_found, chop_an, chop_ns, chop_ar;
 
-  if (ntohs(header->qdcount) != 1 ||
-      !(p = skip_name(p, header, plen, 4)))
+  if (ntohs(header->qdcount) != 1 || !(p = skip_name(p, header, plen, 4)))
     return plen;
-  
+
   GETSHORT(qtype, p);
   GETSHORT(qclass, p);
 
   /* First pass, find pointers to start and end of all the records we wish to elide:
      records added for DNSSEC, unless explicitly queried for */
-  for (rr_found = 0, chop_ns = 0, chop_an = 0, chop_ar = 0, i = 0; 
-       i < ntohs(header->ancount) + ntohs(header->nscount) + ntohs(header->arcount);
-       i++)
-    {
-      unsigned char *pstart = p;
-      int type, class;
-
-      if (!(p = skip_name(p, header, plen, 10)))
-	return plen;
-      
-      GETSHORT(type, p); 
-      GETSHORT(class, p);
-      p += 4; /* TTL */
-      GETSHORT(rdlen, p);
-        
-      if (!ADD_RDLEN(header, p, plen, rdlen))
-	return plen;
-
-      /* Don't remove the answer. */
-      if (i < ntohs(header->ancount) && type == qtype && class == qclass)
-	continue;
-      
-      if (mode == 0) /* EDNS */
-	{
-	  /* EDNS mode, remove T_OPT from additional section only */
-	  if (i < (ntohs(header->nscount) + ntohs(header->ancount)) || type != T_OPT)
-	    continue;
-	}
-      else if (type != T_NSEC && type != T_NSEC3 && type != T_RRSIG)
-	/* DNSSEC mode, remove SIGs and NSECs from all three sections. */
-	continue;
-      
-      
-      if (!expand_workspace(&rrs, &rr_sz, rr_found + 1))
-	return plen; 
-      
-      rrs[rr_found++] = pstart;
-      rrs[rr_found++] = p;
-      
-      if (i < ntohs(header->ancount))
-	chop_an++;
-      else if (i < (ntohs(header->nscount) + ntohs(header->ancount)))
-	chop_ns++;
-      else
-	chop_ar++;
-    }
-  
+  for (rr_found = 0, chop_ns = 0, chop_an = 0, chop_ar = 0, i = 0;
+       i <
+       ntohs(header->ancount) + ntohs(header->nscount) + ntohs(header->arcount);
+       i++) {
+    unsigned char *pstart = p;
+    int type, class;
+
+    if (!(p = skip_name(p, header, plen, 10)))
+      return plen;
+
+    GETSHORT(type, p);
+    GETSHORT(class, p);
+    p += 4;                     /* TTL */
+    GETSHORT(rdlen, p);
+
+    if (!ADD_RDLEN(header, p, plen, rdlen))
+      return plen;
+
+    /* Don't remove the answer. */
+    if (i < ntohs(header->ancount) && type == qtype && class == qclass)
+      continue;
+
+    if (mode == 0) {            /* EDNS */
+      /* EDNS mode, remove T_OPT from additional section only */
+      if (i < (ntohs(header->nscount) + ntohs(header->ancount))
+          || type != T_OPT)
+        continue;
+    } else if (type != T_NSEC && type != T_NSEC3 && type != T_RRSIG)
+      /* DNSSEC mode, remove SIGs and NSECs from all three sections. */
+      continue;
+
+
+    if (!expand_workspace(&rrs, &rr_sz, rr_found + 1))
+      return plen;
+
+    rrs[rr_found++] = pstart;
+    rrs[rr_found++] = p;
+
+    if (i < ntohs(header->ancount))
+      chop_an++;
+    else if (i < (ntohs(header->nscount) + ntohs(header->ancount)))
+      chop_ns++;
+    else
+      chop_ar++;
+  }
+
   /* Nothing to do. */
   if (rr_found == 0)
     return plen;
@@ -228,36 +219,36 @@
   /* Second pass, look for pointers in names in the records we're keeping and make sure they don't
      point to records we're going to elide. This is theoretically possible, but unlikely. If
      it happens, we give up and leave the answer unchanged. */
-  p = (unsigned char *)(header+1);
-  
+  p = (unsigned char *) (header + 1);
+
   /* question first */
   if (!check_name(&p, header, plen, 0, rrs, rr_found))
     return plen;
-  p += 4; /* qclass, qtype */
-  
+  p += 4;                       /* qclass, qtype */
+
   /* Now answers and NS */
   if (!check_rrs(p, header, plen, 0, rrs, rr_found))
     return plen;
-  
+
   /* Third pass, actually fix up pointers in the records */
-  p = (unsigned char *)(header+1);
-  
+  p = (unsigned char *) (header + 1);
+
   check_name(&p, header, plen, 1, rrs, rr_found);
-  p += 4; /* qclass, qtype */
-  
+  p += 4;                       /* qclass, qtype */
+
   check_rrs(p, header, plen, 1, rrs, rr_found);
 
   /*  Fouth pass, elide records */
-  for (p = rrs[0], i = 1; i < rr_found; i += 2)
-    {
-      unsigned char *start = rrs[i];
-      unsigned char *end = (i != rr_found - 1) ? rrs[i+1] : ((unsigned char *)header) + plen;
-      
-      memmove(p, start, end-start);
-      p += end-start;
-    }
-     
-  plen = p - (unsigned char *)header;
+  for (p = rrs[0], i = 1; i < rr_found; i += 2) {
+    unsigned char *start = rrs[i];
+    unsigned char *end =
+        (i != rr_found - 1) ? rrs[i + 1] : ((unsigned char *) header) + plen;
+
+    memmove(p, start, end - start);
+    p += end - start;
+  }
+
+  plen = p - (unsigned char *) header;
   header->ancount = htons(ntohs(header->ancount) - chop_an);
   header->nscount = htons(ntohs(header->nscount) - chop_ns);
   header->arcount = htons(ntohs(header->arcount) - chop_ar);
@@ -275,39 +266,38 @@
 
      zero is not a valid RRtype, so the final entry is returned for
      anything which needs no mangling.
-  */
-  
-  static u16 rr_desc[] = 
-    { 
-      T_NS, 0, -1, 
-      T_MD, 0, -1,
-      T_MF, 0, -1,
-      T_CNAME, 0, -1,
-      T_SOA, 0, 0, -1,
-      T_MB, 0, -1,
-      T_MG, 0, -1,
-      T_MR, 0, -1,
-      T_PTR, 0, -1,
-      T_MINFO, 0, 0, -1,
-      T_MX, 2, 0, -1,
-      T_RP, 0, 0, -1,
-      T_AFSDB, 2, 0, -1,
-      T_RT, 2, 0, -1,
-      T_SIG, 18, 0, -1,
-      T_PX, 2, 0, 0, -1,
-      T_NXT, 0, -1,
-      T_KX, 2, 0, -1,
-      T_SRV, 6, 0, -1,
-      T_DNAME, 0, -1,
-      0, -1 /* wildcard/catchall */
-    }; 
-  
+   */
+
+  static u16 rr_desc[] = {
+    T_NS, 0, -1,
+    T_MD, 0, -1,
+    T_MF, 0, -1,
+    T_CNAME, 0, -1,
+    T_SOA, 0, 0, -1,
+    T_MB, 0, -1,
+    T_MG, 0, -1,
+    T_MR, 0, -1,
+    T_PTR, 0, -1,
+    T_MINFO, 0, 0, -1,
+    T_MX, 2, 0, -1,
+    T_RP, 0, 0, -1,
+    T_AFSDB, 2, 0, -1,
+    T_RT, 2, 0, -1,
+    T_SIG, 18, 0, -1,
+    T_PX, 2, 0, 0, -1,
+    T_NXT, 0, -1,
+    T_KX, 2, 0, -1,
+    T_SRV, 6, 0, -1,
+    T_DNAME, 0, -1,
+    0, -1                       /* wildcard/catchall */
+  };
+
   u16 *p = rr_desc;
-  
+
   while (*p != type && *p != 0)
-    while (*p++ != (u16)-1);
+    while (*p++ != (u16) - 1);
 
-  return p+1;
+  return p + 1;
 }
 
 int expand_workspace(unsigned char ***wkspc, int *szp, int new)
@@ -315,23 +305,22 @@
   unsigned char **p;
   int old = *szp;
 
-  if (old >= new+1)
+  if (old >= new + 1)
     return 1;
 
   if (new >= 100)
     return 0;
 
   new += 5;
-  
+
   if (!(p = whine_malloc(new * sizeof(unsigned char *))))
-    return 0;  
-  
-  if (old != 0 && *wkspc)
-    {
-      memcpy(p, *wkspc, old * sizeof(unsigned char *));
-      free(*wkspc);
-    }
-  
+    return 0;
+
+  if (old != 0 && *wkspc) {
+    memcpy(p, *wkspc, old * sizeof(unsigned char *));
+    free(*wkspc);
+  }
+
   *wkspc = p;
   *szp = new;
 
Index: dnsmasq-2.78/src/slaac.c
===================================================================
--- dnsmasq-2.78.orig/src/slaac.c	2017-10-02 21:13:51.000000000 +0800
+++ dnsmasq-2.78/src/slaac.c	2018-10-29 16:14:19.501440028 +0800
@@ -27,92 +27,83 @@
   struct slaac_address *slaac, *old, **up;
   struct dhcp_context *context;
   int dns_dirty = 0;
-  
-  if (!(lease->flags & LEASE_HAVE_HWADDR) || 
+
+  if (!(lease->flags & LEASE_HAVE_HWADDR) ||
       (lease->flags & (LEASE_TA | LEASE_NA)) ||
-      lease->last_interface == 0 ||
-      !lease->hostname)
-    return ;
-  
+      lease->last_interface == 0 || !lease->hostname)
+    return;
+
   old = lease->slaac_address;
   lease->slaac_address = NULL;
 
-  for (context = daemon->dhcp6; context; context = context->next) 
-    if ((context->flags & CONTEXT_RA_NAME) && 
-	!(context->flags & CONTEXT_OLD) &&
-	lease->last_interface == context->if_index)
-      {
-	struct in6_addr addr = context->start6;
-	if (lease->hwaddr_len == 6 &&
-	    (lease->hwaddr_type == ARPHRD_ETHER || lease->hwaddr_type == ARPHRD_IEEE802))
-	  {
-	    /* convert MAC address to EUI-64 */
-	    memcpy(&addr.s6_addr[8], lease->hwaddr, 3);
-	    memcpy(&addr.s6_addr[13], &lease->hwaddr[3], 3);
-	    addr.s6_addr[11] = 0xff;
-	    addr.s6_addr[12] = 0xfe;
-	  }
+  for (context = daemon->dhcp6; context; context = context->next)
+    if ((context->flags & CONTEXT_RA_NAME) &&
+        !(context->flags & CONTEXT_OLD) &&
+        lease->last_interface == context->if_index) {
+      struct in6_addr addr = context->start6;
+      if (lease->hwaddr_len == 6 &&
+          (lease->hwaddr_type == ARPHRD_ETHER
+           || lease->hwaddr_type == ARPHRD_IEEE802)) {
+        /* convert MAC address to EUI-64 */
+        memcpy(&addr.s6_addr[8], lease->hwaddr, 3);
+        memcpy(&addr.s6_addr[13], &lease->hwaddr[3], 3);
+        addr.s6_addr[11] = 0xff;
+        addr.s6_addr[12] = 0xfe;
+      }
 #if defined(ARPHRD_EUI64)
-	else if (lease->hwaddr_len == 8 &&
-		 lease->hwaddr_type == ARPHRD_EUI64)
-	  memcpy(&addr.s6_addr[8], lease->hwaddr, 8);
+      else if (lease->hwaddr_len == 8 && lease->hwaddr_type == ARPHRD_EUI64)
+        memcpy(&addr.s6_addr[8], lease->hwaddr, 8);
 #endif
 #if defined(ARPHRD_IEEE1394) && defined(ARPHRD_EUI64)
-	else if (lease->clid_len == 9 && 
-		 lease->clid[0] ==  ARPHRD_EUI64 &&
-		 lease->hwaddr_type == ARPHRD_IEEE1394)
-	  /* firewire has EUI-64 identifier as clid */
-	  memcpy(&addr.s6_addr[8], &lease->clid[1], 8);
+      else if (lease->clid_len == 9 &&
+               lease->clid[0] == ARPHRD_EUI64 &&
+               lease->hwaddr_type == ARPHRD_IEEE1394)
+        /* firewire has EUI-64 identifier as clid */
+        memcpy(&addr.s6_addr[8], &lease->clid[1], 8);
 #endif
-	else
-	  continue;
-	
-	addr.s6_addr[8] ^= 0x02;
-	
-	/* check if we already have this one */
-	for (up = &old, slaac = old; slaac; slaac = slaac->next)
-	  {
-	    if (IN6_ARE_ADDR_EQUAL(&addr, &slaac->addr))
-	      {
-		*up = slaac->next;
-		/* recheck when DHCPv4 goes through init-reboot */
-		if (force)
-		  {
-		    slaac->ping_time = now;
-		    slaac->backoff = 1;
-		    dns_dirty = 1;
-		  }
-		break;
-	      }
-	    up = &slaac->next;
-	  }
-	    
-	/* No, make new one */
-	if (!slaac && (slaac = whine_malloc(sizeof(struct slaac_address))))
-	  {
-	    slaac->ping_time = now;
-	    slaac->backoff = 1;
-	    slaac->addr = addr;
-	    /* Do RA's to prod it */
-	    ra_start_unsolicited(now, context);
-	  }
-	
-	if (slaac)
-	  {
-	    slaac->next = lease->slaac_address;
-	    lease->slaac_address = slaac;
-	  }
+      else
+        continue;
+
+      addr.s6_addr[8] ^= 0x02;
+
+      /* check if we already have this one */
+      for (up = &old, slaac = old; slaac; slaac = slaac->next) {
+        if (IN6_ARE_ADDR_EQUAL(&addr, &slaac->addr)) {
+          *up = slaac->next;
+          /* recheck when DHCPv4 goes through init-reboot */
+          if (force) {
+            slaac->ping_time = now;
+            slaac->backoff = 1;
+            dns_dirty = 1;
+          }
+          break;
+        }
+        up = &slaac->next;
       }
-  
+
+      /* No, make new one */
+      if (!slaac && (slaac = whine_malloc(sizeof(struct slaac_address)))) {
+        slaac->ping_time = now;
+        slaac->backoff = 1;
+        slaac->addr = addr;
+        /* Do RA's to prod it */
+        ra_start_unsolicited(now, context);
+      }
+
+      if (slaac) {
+        slaac->next = lease->slaac_address;
+        lease->slaac_address = slaac;
+      }
+    }
+
   if (old || dns_dirty)
     lease_update_dns(1);
-  
+
   /* Free any no reused */
-  for (; old; old = slaac)
-    {
-      slaac = old->next;
-      free(old);
-    }
+  for (; old; old = slaac) {
+    slaac = old->next;
+    free(old);
+  }
 }
 
 
@@ -122,7 +113,7 @@
   struct dhcp_lease *lease;
   struct slaac_address *slaac;
   time_t next_event = 0;
-  
+
   for (context = daemon->dhcp6; context; context = context->next)
     if ((context->flags & CONTEXT_RA_NAME) && !(context->flags & CONTEXT_OLD))
       break;
@@ -135,78 +126,77 @@
     ping_id = rand16();
 
   for (lease = leases; lease; lease = lease->next)
-    for (slaac = lease->slaac_address; slaac; slaac = slaac->next)
-      {
-	/* confirmed or given up? */
-	if (slaac->backoff == 0 || slaac->ping_time == 0)
-	  continue;
-	
-	if (difftime(slaac->ping_time, now) <= 0.0)
-	  {
-	    struct ping_packet *ping;
-	    struct sockaddr_in6 addr;
- 
-	    reset_counter();
-
-	    if (!(ping = expand(sizeof(struct ping_packet))))
-	      continue;
-
-	    ping->type = ICMP6_ECHO_REQUEST;
-	    ping->code = 0;
-	    ping->identifier = ping_id;
-	    ping->sequence_no = slaac->backoff;
-	    
-	    memset(&addr, 0, sizeof(addr));
+    for (slaac = lease->slaac_address; slaac; slaac = slaac->next) {
+      /* confirmed or given up? */
+      if (slaac->backoff == 0 || slaac->ping_time == 0)
+        continue;
+
+      if (difftime(slaac->ping_time, now) <= 0.0) {
+        struct ping_packet *ping;
+        struct sockaddr_in6 addr;
+
+        reset_counter();
+
+        if (!(ping = expand(sizeof(struct ping_packet))))
+          continue;
+
+        ping->type = ICMP6_ECHO_REQUEST;
+        ping->code = 0;
+        ping->identifier = ping_id;
+        ping->sequence_no = slaac->backoff;
+
+        memset(&addr, 0, sizeof(addr));
 #ifdef HAVE_SOCKADDR_SA_LEN
-	    addr.sin6_len = sizeof(struct sockaddr_in6);
+        addr.sin6_len = sizeof(struct sockaddr_in6);
 #endif
-	    addr.sin6_family = AF_INET6;
-	    addr.sin6_port = htons(IPPROTO_ICMPV6);
-	    addr.sin6_addr = slaac->addr;
-	    
-	    if (sendto(daemon->icmp6fd, daemon->outpacket.iov_base, save_counter(-1), 0,
-		       (struct sockaddr *)&addr,  sizeof(addr)) == -1 &&
-		errno == EHOSTUNREACH)
-	      slaac->ping_time = 0; /* Give up */ 
-	    else
-	      {
-		slaac->ping_time += (1 << (slaac->backoff - 1)) + (rand16()/21785); /* 0 - 3 */
-		if (slaac->backoff > 4)
-		  slaac->ping_time += rand16()/4000; /* 0 - 15 */
-		if (slaac->backoff < 12)
-		  slaac->backoff++;
-	      }
-	  }
-	
-	if (slaac->ping_time != 0 &&
-	    (next_event == 0 || difftime(next_event, slaac->ping_time) >= 0.0))
-	  next_event = slaac->ping_time;
+        addr.sin6_family = AF_INET6;
+        addr.sin6_port = htons(IPPROTO_ICMPV6);
+        addr.sin6_addr = slaac->addr;
+
+        if (sendto
+            (daemon->icmp6fd, daemon->outpacket.iov_base, save_counter(-1), 0,
+             (struct sockaddr *) &addr, sizeof(addr)) == -1
+            && errno == EHOSTUNREACH)
+          slaac->ping_time = 0; /* Give up */
+        else {
+          slaac->ping_time += (1 << (slaac->backoff - 1)) + (rand16() / 21785); /* 0 - 3 */
+          if (slaac->backoff > 4)
+            slaac->ping_time += rand16() / 4000;        /* 0 - 15 */
+          if (slaac->backoff < 12)
+            slaac->backoff++;
+        }
       }
 
+      if (slaac->ping_time != 0 &&
+          (next_event == 0 || difftime(next_event, slaac->ping_time) >= 0.0))
+        next_event = slaac->ping_time;
+    }
+
   return next_event;
 }
 
 
-void slaac_ping_reply(struct in6_addr *sender, unsigned char *packet, char *interface, struct dhcp_lease *leases)
+void slaac_ping_reply(struct in6_addr *sender, unsigned char *packet,
+                      char *interface, struct dhcp_lease *leases)
 {
   struct dhcp_lease *lease;
   struct slaac_address *slaac;
-  struct ping_packet *ping = (struct ping_packet *)packet;
+  struct ping_packet *ping = (struct ping_packet *) packet;
   int gotone = 0;
-  
+
   if (ping->identifier == ping_id)
     for (lease = leases; lease; lease = lease->next)
       for (slaac = lease->slaac_address; slaac; slaac = slaac->next)
-	if (slaac->backoff != 0 && IN6_ARE_ADDR_EQUAL(sender, &slaac->addr))
-	  {
-	    slaac->backoff = 0;
-	    gotone = 1;
-	    inet_ntop(AF_INET6, sender, daemon->addrbuff, ADDRSTRLEN);
-	    if (!option_bool(OPT_QUIET_DHCP6))
-	      my_syslog(MS_DHCP | LOG_INFO, "SLAAC-CONFIRM(%s) %s %s", interface, daemon->addrbuff, lease->hostname); 
-	  }
-  
+        if (slaac->backoff != 0 && IN6_ARE_ADDR_EQUAL(sender, &slaac->addr)) {
+          slaac->backoff = 0;
+          gotone = 1;
+          inet_ntop(AF_INET6, sender, daemon->addrbuff, ADDRSTRLEN);
+          if (!option_bool(OPT_QUIET_DHCP6))
+            my_syslog(MS_DHCP | LOG_INFO, "SLAAC-CONFIRM(%s) %s %s", interface,
+                      daemon->addrbuff, lease->hostname);
+        }
+
   lease_update_dns(gotone);
 }
-	
+
 #endif
Index: dnsmasq-2.78/src/tables.c
===================================================================
--- dnsmasq-2.78.orig/src/tables.c	2017-10-02 21:13:51.000000000 +0800
+++ dnsmasq-2.78/src/tables.c	2018-10-29 16:14:19.505440028 +0800
@@ -40,88 +40,80 @@
 
 static char *pfr_strerror(int errnum)
 {
-  switch (errnum) 
-    {
-    case ESRCH:
-      return "Table does not exist";
-    case ENOENT:
-      return "Anchor or Ruleset does not exist";
-    default:
-      return strerror(errnum);
-    }
+  switch (errnum) {
+  case ESRCH:
+    return "Table does not exist";
+  case ENOENT:
+    return "Anchor or Ruleset does not exist";
+  default:
+    return strerror(errnum);
+  }
 }
 
 
-void ipset_init(void) 
+void ipset_init(void)
 {
-  dev = open( pf_device, O_RDWR);
-  if (dev == -1)
-    {
-      err(1, "%s", pf_device);
-      die (_("failed to access pf devices: %s"), NULL, EC_MISC);
-    }
+  dev = open(pf_device, O_RDWR);
+  if (dev == -1) {
+    err(1, "%s", pf_device);
+    die(_("failed to access pf devices: %s"), NULL, EC_MISC);
+  }
 }
 
 int add_to_ipset(const char *setname, const struct all_addr *ipaddr,
-		 int flags, int remove)
+                 int flags, int remove)
 {
   struct pfr_addr addr;
   struct pfioc_table io;
   struct pfr_table table;
 
-  if (dev == -1) 
-    {
-      my_syslog(LOG_ERR, _("warning: no opened pf devices %s"), pf_device);
-      return -1;
-    }
+  if (dev == -1) {
+    my_syslog(LOG_ERR, _("warning: no opened pf devices %s"), pf_device);
+    return -1;
+  }
 
   bzero(&table, sizeof(struct pfr_table));
   table.pfrt_flags |= PFR_TFLAG_PERSIST;
-  if (strlen(setname) >= PF_TABLE_NAME_SIZE)
-    {
-      my_syslog(LOG_ERR, _("error: cannot use table name %s"), setname);
-      errno = ENAMETOOLONG;
-      return -1;
-    }
-  
+  if (strlen(setname) >= PF_TABLE_NAME_SIZE) {
+    my_syslog(LOG_ERR, _("error: cannot use table name %s"), setname);
+    errno = ENAMETOOLONG;
+    return -1;
+  }
+
   if (strlcpy(table.pfrt_name, setname,
-	      sizeof(table.pfrt_name)) >= sizeof(table.pfrt_name)) 
-    {
-      my_syslog(LOG_ERR, _("error: cannot strlcpy table name %s"), setname);
-      return -1;
-    }
-  
+              sizeof(table.pfrt_name)) >= sizeof(table.pfrt_name)) {
+    my_syslog(LOG_ERR, _("error: cannot strlcpy table name %s"), setname);
+    return -1;
+  }
+
   bzero(&io, sizeof io);
   io.pfrio_flags = 0;
   io.pfrio_buffer = &table;
   io.pfrio_esize = sizeof(table);
   io.pfrio_size = 1;
-  if (ioctl(dev, DIOCRADDTABLES, &io))
-    {
-      my_syslog(LOG_WARNING, _("IPset: error:%s"), pfr_strerror(errno));
-      
-      return -1;
-    }
-  
+  if (ioctl(dev, DIOCRADDTABLES, &io)) {
+    my_syslog(LOG_WARNING, _("IPset: error:%s"), pfr_strerror(errno));
+
+    return -1;
+  }
+
   table.pfrt_flags &= ~PFR_TFLAG_PERSIST;
   if (io.pfrio_nadd)
     my_syslog(LOG_INFO, _("info: table created"));
- 
+
   bzero(&addr, sizeof(addr));
 #ifdef HAVE_IPV6
-  if (flags & F_IPV6) 
-    {
-      addr.pfra_af = AF_INET6;
-      addr.pfra_net = 0x80;
-      memcpy(&(addr.pfra_ip6addr), &(ipaddr->addr), sizeof(struct in6_addr));
-    } 
-  else 
+  if (flags & F_IPV6) {
+    addr.pfra_af = AF_INET6;
+    addr.pfra_net = 0x80;
+    memcpy(&(addr.pfra_ip6addr), &(ipaddr->addr), sizeof(struct in6_addr));
+  } else
 #endif
-    {
-      addr.pfra_af = AF_INET;
-      addr.pfra_net = 0x20;
-      addr.pfra_ip4addr.s_addr = ipaddr->addr.addr4.s_addr;
-    }
+  {
+    addr.pfra_af = AF_INET;
+    addr.pfra_net = 0x20;
+    addr.pfra_ip4addr.s_addr = ipaddr->addr.addr4.s_addr;
+  }
 
   bzero(&io, sizeof(io));
   io.pfrio_flags = 0;
@@ -129,15 +121,15 @@
   io.pfrio_buffer = &addr;
   io.pfrio_esize = sizeof(addr);
   io.pfrio_size = 1;
-  if (ioctl(dev, ( remove ? DIOCRDELADDRS : DIOCRADDADDRS ), &io)) 
-    {
-      my_syslog(LOG_WARNING, _("warning: DIOCR%sADDRS: %s"), ( remove ? "DEL" : "ADD" ), pfr_strerror(errno));
-      return -1;
-    }
-  
+  if (ioctl(dev, (remove ? DIOCRDELADDRS : DIOCRADDADDRS), &io)) {
+    my_syslog(LOG_WARNING, _("warning: DIOCR%sADDRS: %s"),
+              (remove ? "DEL" : "ADD"), pfr_strerror(errno));
+    return -1;
+  }
+
   my_syslog(LOG_INFO, _("%d addresses %s"),
-            io.pfrio_nadd, ( remove ? "removed" : "added" ));
-  
+            io.pfrio_nadd, (remove ? "removed" : "added"));
+
   return io.pfrio_nadd;
 }
 
Index: dnsmasq-2.78/src/tftp.c
===================================================================
--- dnsmasq-2.78.orig/src/tftp.c	2017-10-02 21:13:51.000000000 +0800
+++ dnsmasq-2.78/src/tftp.c	2018-10-29 16:14:19.505440028 +0800
@@ -18,7 +18,7 @@
 
 #ifdef HAVE_TFTP
 
-static struct tftp_file *check_tftp_fileperm(ssize_t *len, char *prefix);
+static struct tftp_file *check_tftp_fileperm(ssize_t * len, char *prefix);
 static void free_transfer(struct tftp_transfer *transfer);
 static ssize_t tftp_err(int err, char *packet, char *message, char *file);
 static ssize_t tftp_err_oops(char *packet, char *file);
@@ -51,7 +51,7 @@
   int is_err = 1, if_index = 0, mtu = 0;
   struct iname *tmp;
   struct tftp_transfer *transfer;
-  int port = daemon->start_tftp_port; /* may be zero to use ephemeral port */
+  int port = daemon->start_tftp_port;   /* may be zero to use ephemeral port */
 #if defined(IP_MTU_DISCOVER) && defined(IP_PMTUDISC_DONT)
   int mtuflag = IP_PMTUDISC_DONT;
 #endif
@@ -67,7 +67,7 @@
   int check_dest = !option_bool(OPT_NOWILD);
 #endif
   union {
-    struct cmsghdr align; /* this ensures alignment */
+    struct cmsghdr align;       /* this ensures alignment */
 #ifdef HAVE_IPV6
     char control6[CMSG_SPACE(sizeof(struct in6_pktinfo))];
 #endif
@@ -78,7 +78,7 @@
 #elif defined(IP_RECVDSTADDR) && defined(IP_RECVIF)
     char control[CMSG_SPACE(sizeof(struct sockaddr_dl))];
 #endif
-  } control_u; 
+  } control_u;
 
   msg.msg_controllen = sizeof(control_u);
   msg.msg_control = control_u.control;
@@ -98,191 +98,173 @@
     return;
 
   /* Can always get recvd interface for IPv6 */
-  if (!check_dest)
-    {
-      if (listen->iface)
-	{
-	  addr = listen->iface->addr;
-	  name = listen->iface->name;
-	  mtu = listen->iface->mtu;
-	  if (daemon->tftp_mtu != 0 && daemon->tftp_mtu < mtu)
-	    mtu = daemon->tftp_mtu;
-	}
-      else
-	{
-	  /* we're listening on an address that doesn't appear on an interface,
-	     ask the kernel what the socket is bound to */
-	  socklen_t tcp_len = sizeof(union mysockaddr);
-	  if (getsockname(listen->tftpfd, (struct sockaddr *)&addr, &tcp_len) == -1)
-	    return;
-	}
-    }
-  else
-    {
-      struct cmsghdr *cmptr;
-
-      if (msg.msg_controllen < sizeof(struct cmsghdr))
+  if (!check_dest) {
+    if (listen->iface) {
+      addr = listen->iface->addr;
+      name = listen->iface->name;
+      mtu = listen->iface->mtu;
+      if (daemon->tftp_mtu != 0 && daemon->tftp_mtu < mtu)
+        mtu = daemon->tftp_mtu;
+    } else {
+      /* we're listening on an address that doesn't appear on an interface,
+         ask the kernel what the socket is bound to */
+      socklen_t tcp_len = sizeof(union mysockaddr);
+      if (getsockname(listen->tftpfd, (struct sockaddr *) &addr, &tcp_len) ==
+          -1)
         return;
-      
-      addr.sa.sa_family = listen->family;
-      
+    }
+  } else {
+    struct cmsghdr *cmptr;
+
+    if (msg.msg_controllen < sizeof(struct cmsghdr))
+      return;
+
+    addr.sa.sa_family = listen->family;
+
 #if defined(HAVE_LINUX_NETWORK)
-      if (listen->family == AF_INET)
-	for (cmptr = CMSG_FIRSTHDR(&msg); cmptr; cmptr = CMSG_NXTHDR(&msg, cmptr))
-	  if (cmptr->cmsg_level == IPPROTO_IP && cmptr->cmsg_type == IP_PKTINFO)
-	    {
-	      union {
-		unsigned char *c;
-		struct in_pktinfo *p;
-	      } p;
-	      p.c = CMSG_DATA(cmptr);
-	      addr.in.sin_addr = p.p->ipi_spec_dst;
-	      if_index = p.p->ipi_ifindex;
-	    }
-      
+    if (listen->family == AF_INET)
+      for (cmptr = CMSG_FIRSTHDR(&msg); cmptr; cmptr = CMSG_NXTHDR(&msg, cmptr))
+        if (cmptr->cmsg_level == IPPROTO_IP && cmptr->cmsg_type == IP_PKTINFO) {
+          union {
+            unsigned char *c;
+            struct in_pktinfo *p;
+          } p;
+          p.c = CMSG_DATA(cmptr);
+          addr.in.sin_addr = p.p->ipi_spec_dst;
+          if_index = p.p->ipi_ifindex;
+        }
 #elif defined(HAVE_SOLARIS_NETWORK)
-      if (listen->family == AF_INET)
-	for (cmptr = CMSG_FIRSTHDR(&msg); cmptr; cmptr = CMSG_NXTHDR(&msg, cmptr))
-	  {
-	    union {
-	      unsigned char *c;
-	      struct in_addr *a;
-	      unsigned int *i;
-	    } p;
-	    p.c = CMSG_DATA(cmptr);
-	    if (cmptr->cmsg_level == IPPROTO_IP && cmptr->cmsg_type == IP_RECVDSTADDR)
-	    addr.in.sin_addr = *(p.a);
-	    else if (cmptr->cmsg_level == IPPROTO_IP && cmptr->cmsg_type == IP_RECVIF)
-	    if_index = *(p.i);
-	  }
-      
+    if (listen->family == AF_INET)
+      for (cmptr = CMSG_FIRSTHDR(&msg); cmptr; cmptr = CMSG_NXTHDR(&msg, cmptr)) {
+        union {
+          unsigned char *c;
+          struct in_addr *a;
+          unsigned int *i;
+        } p;
+        p.c = CMSG_DATA(cmptr);
+        if (cmptr->cmsg_level == IPPROTO_IP
+            && cmptr->cmsg_type == IP_RECVDSTADDR)
+          addr.in.sin_addr = *(p.a);
+        else if (cmptr->cmsg_level == IPPROTO_IP
+                 && cmptr->cmsg_type == IP_RECVIF)
+          if_index = *(p.i);
+      }
 #elif defined(IP_RECVDSTADDR) && defined(IP_RECVIF)
-      if (listen->family == AF_INET)
-	for (cmptr = CMSG_FIRSTHDR(&msg); cmptr; cmptr = CMSG_NXTHDR(&msg, cmptr))
-	  {
-	    union {
-	      unsigned char *c;
-	      struct in_addr *a;
-	      struct sockaddr_dl *s;
-	    } p;
-	    p.c = CMSG_DATA(cmptr);
-	    if (cmptr->cmsg_level == IPPROTO_IP && cmptr->cmsg_type == IP_RECVDSTADDR)
-	      addr.in.sin_addr = *(p.a);
-	    else if (cmptr->cmsg_level == IPPROTO_IP && cmptr->cmsg_type == IP_RECVIF)
-	      if_index = p.s->sdl_index;
-	  }
-	  
+    if (listen->family == AF_INET)
+      for (cmptr = CMSG_FIRSTHDR(&msg); cmptr; cmptr = CMSG_NXTHDR(&msg, cmptr)) {
+        union {
+          unsigned char *c;
+          struct in_addr *a;
+          struct sockaddr_dl *s;
+        } p;
+        p.c = CMSG_DATA(cmptr);
+        if (cmptr->cmsg_level == IPPROTO_IP
+            && cmptr->cmsg_type == IP_RECVDSTADDR)
+          addr.in.sin_addr = *(p.a);
+        else if (cmptr->cmsg_level == IPPROTO_IP
+                 && cmptr->cmsg_type == IP_RECVIF)
+          if_index = p.s->sdl_index;
+      }
 #endif
 
 #ifdef HAVE_IPV6
-      if (listen->family == AF_INET6)
-        {
-          for (cmptr = CMSG_FIRSTHDR(&msg); cmptr; cmptr = CMSG_NXTHDR(&msg, cmptr))
-            if (cmptr->cmsg_level == IPPROTO_IPV6 && cmptr->cmsg_type == daemon->v6pktinfo)
-              {
-                union {
-                  unsigned char *c;
-                  struct in6_pktinfo *p;
-                } p;
-                p.c = CMSG_DATA(cmptr);
-                  
-                addr.in6.sin6_addr = p.p->ipi6_addr;
-                if_index = p.p->ipi6_ifindex;
-              }
+    if (listen->family == AF_INET6) {
+      for (cmptr = CMSG_FIRSTHDR(&msg); cmptr; cmptr = CMSG_NXTHDR(&msg, cmptr))
+        if (cmptr->cmsg_level == IPPROTO_IPV6
+            && cmptr->cmsg_type == daemon->v6pktinfo) {
+          union {
+            unsigned char *c;
+            struct in6_pktinfo *p;
+          } p;
+          p.c = CMSG_DATA(cmptr);
+
+          addr.in6.sin6_addr = p.p->ipi6_addr;
+          if_index = p.p->ipi6_ifindex;
         }
+    }
 #endif
-      
-      if (!indextoname(listen->tftpfd, if_index, namebuff))
-	return;
-
-      name = namebuff;
-      
-      addra.addr.addr4 = addr.in.sin_addr;
+
+    if (!indextoname(listen->tftpfd, if_index, namebuff))
+      return;
+
+    name = namebuff;
+
+    addra.addr.addr4 = addr.in.sin_addr;
 
 #ifdef HAVE_IPV6
-      if (listen->family == AF_INET6)
-	addra.addr.addr6 = addr.in6.sin6_addr;
+    if (listen->family == AF_INET6)
+      addra.addr.addr6 = addr.in6.sin6_addr;
 #endif
 
-      if (daemon->tftp_interfaces)
-	{
-	  /* dedicated tftp interface list */
-	  for (tmp = daemon->tftp_interfaces; tmp; tmp = tmp->next)
-	    if (tmp->name && wildcard_match(tmp->name, name))
-	      break;
-
-	  if (!tmp)
-	    return;
-	}
-      else
-	{
-	  /* Do the same as DHCP */
-	  if (!iface_check(listen->family, &addra, name, NULL))
-	    {
-	      if (!option_bool(OPT_CLEVERBIND))
-		enumerate_interfaces(0); 
-	      if (!loopback_exception(listen->tftpfd, listen->family, &addra, name) &&
-		  !label_exception(if_index, listen->family, &addra) )
-		return;
-	    }
-	  
-#ifdef HAVE_DHCP      
-	  /* allowed interfaces are the same as for DHCP */
-	  for (tmp = daemon->dhcp_except; tmp; tmp = tmp->next)
-	    if (tmp->name && wildcard_match(tmp->name, name))
-	      return;
-#endif
-	}
-
-      strncpy(ifr.ifr_name, name, IF_NAMESIZE);
-      if (ioctl(listen->tftpfd, SIOCGIFMTU, &ifr) != -1)
-	{
-	  mtu = ifr.ifr_mtu;  
-	  if (daemon->tftp_mtu != 0 && daemon->tftp_mtu < mtu)
-	    mtu = daemon->tftp_mtu;    
-	}
+    if (daemon->tftp_interfaces) {
+      /* dedicated tftp interface list */
+      for (tmp = daemon->tftp_interfaces; tmp; tmp = tmp->next)
+        if (tmp->name && wildcard_match(tmp->name, name))
+          break;
+
+      if (!tmp)
+        return;
+    } else {
+      /* Do the same as DHCP */
+      if (!iface_check(listen->family, &addra, name, NULL)) {
+        if (!option_bool(OPT_CLEVERBIND))
+          enumerate_interfaces(0);
+        if (!loopback_exception(listen->tftpfd, listen->family, &addra, name) &&
+            !label_exception(if_index, listen->family, &addra))
+          return;
+      }
+#ifdef HAVE_DHCP
+      /* allowed interfaces are the same as for DHCP */
+      for (tmp = daemon->dhcp_except; tmp; tmp = tmp->next)
+        if (tmp->name && wildcard_match(tmp->name, name))
+          return;
+#endif
     }
 
+    strncpy(ifr.ifr_name, name, IF_NAMESIZE);
+    if (ioctl(listen->tftpfd, SIOCGIFMTU, &ifr) != -1) {
+      mtu = ifr.ifr_mtu;
+      if (daemon->tftp_mtu != 0 && daemon->tftp_mtu < mtu)
+        mtu = daemon->tftp_mtu;
+    }
+  }
+
   /* Failed to get interface mtu - can use configured value. */
   if (mtu == 0)
     mtu = daemon->tftp_mtu;
 
-  if (name)
-    {
-      /* check for per-interface prefix */ 
-      for (pref = daemon->if_prefix; pref; pref = pref->next)
-	if (strcmp(pref->interface, name) == 0)
-	  prefix = pref->prefix;  
-    }
+  if (name) {
+    /* check for per-interface prefix */
+    for (pref = daemon->if_prefix; pref; pref = pref->next)
+      if (strcmp(pref->interface, name) == 0)
+        prefix = pref->prefix;
+  }
 
-  if (listen->family == AF_INET)
-    {
-      addr.in.sin_port = htons(port);
+  if (listen->family == AF_INET) {
+    addr.in.sin_port = htons(port);
 #ifdef HAVE_SOCKADDR_SA_LEN
-      addr.in.sin_len = sizeof(addr.in);
+    addr.in.sin_len = sizeof(addr.in);
 #endif
-    }
+  }
 #ifdef HAVE_IPV6
-  else
-    {
-      addr.in6.sin6_port = htons(port);
-      addr.in6.sin6_flowinfo = 0;
-      addr.in6.sin6_scope_id = 0;
+  else {
+    addr.in6.sin6_port = htons(port);
+    addr.in6.sin6_flowinfo = 0;
+    addr.in6.sin6_scope_id = 0;
 #ifdef HAVE_SOCKADDR_SA_LEN
-      addr.in6.sin6_len = sizeof(addr.in6);
+    addr.in6.sin6_len = sizeof(addr.in6);
 #endif
-    }
+  }
 #endif
 
   if (!(transfer = whine_malloc(sizeof(struct tftp_transfer))))
     return;
-  
-  if ((transfer->sockfd = socket(listen->family, SOCK_DGRAM, 0)) == -1)
-    {
-      free(transfer);
-      return;
-    }
-  
+
+  if ((transfer->sockfd = socket(listen->family, SOCK_DGRAM, 0)) == -1) {
+    free(transfer);
+    return;
+  }
+
   transfer->peer = peer;
   transfer->timeout = now + 2;
   transfer->backoff = 1;
@@ -292,178 +274,170 @@
   transfer->file = NULL;
   transfer->opt_blocksize = transfer->opt_transize = 0;
   transfer->netascii = transfer->carrylf = 0;
- 
+
   prettyprint_addr(&peer, daemon->addrbuff);
-  
+
   /* if we have a nailed-down range, iterate until we find a free one. */
-  while (1)
-    {
-      if (bind(transfer->sockfd, &addr.sa, sa_len(&addr)) == -1 ||
+  while (1) {
+    if (bind(transfer->sockfd, &addr.sa, sa_len(&addr)) == -1 ||
 #if defined(IP_MTU_DISCOVER) && defined(IP_PMTUDISC_DONT)
-	  setsockopt(transfer->sockfd, IPPROTO_IP, IP_MTU_DISCOVER, &mtuflag, sizeof(mtuflag)) == -1 ||
+        setsockopt(transfer->sockfd, IPPROTO_IP, IP_MTU_DISCOVER, &mtuflag,
+                   sizeof(mtuflag)) == -1 ||
 #endif
-	  !fix_fd(transfer->sockfd))
-	{
-	  if (errno == EADDRINUSE && daemon->start_tftp_port != 0)
-	    {
-	      if (++port <= daemon->end_tftp_port)
-		{ 
-		  if (listen->family == AF_INET)
-		    addr.in.sin_port = htons(port);
+        !fix_fd(transfer->sockfd)) {
+      if (errno == EADDRINUSE && daemon->start_tftp_port != 0) {
+        if (++port <= daemon->end_tftp_port) {
+          if (listen->family == AF_INET)
+            addr.in.sin_port = htons(port);
 #ifdef HAVE_IPV6
-		  else
-		     addr.in6.sin6_port = htons(port);
+          else
+            addr.in6.sin6_port = htons(port);
 #endif
-		  continue;
-		}
-	      my_syslog(MS_TFTP | LOG_ERR, _("unable to get free port for TFTP"));
-	    }
-	  free_transfer(transfer);
-	  return;
-	}
-      break;
+          continue;
+        }
+        my_syslog(MS_TFTP | LOG_ERR, _("unable to get free port for TFTP"));
+      }
+      free_transfer(transfer);
+      return;
     }
-  
+    break;
+  }
+
   p = packet + 2;
   end = packet + len;
 
-  if (ntohs(*((unsigned short *)packet)) != OP_RRQ ||
+  if (ntohs(*((unsigned short *) packet)) != OP_RRQ ||
       !(filename = next(&p, end)) ||
       !(mode = next(&p, end)) ||
-      (strcasecmp(mode, "octet") != 0 && strcasecmp(mode, "netascii") != 0))
-    {
-      len = tftp_err(ERR_ILL, packet, _("unsupported request from %s"), daemon->addrbuff);
-      is_err = 1;
-    }
-  else
-    {
-      if (strcasecmp(mode, "netascii") == 0)
-	transfer->netascii = 1;
-      
-      while ((opt = next(&p, end)))
-	{
-	  if (strcasecmp(opt, "blksize") == 0)
-	    {
-	      if ((opt = next(&p, end)) && !option_bool(OPT_TFTP_NOBLOCK))
-		{
-		  /* 32 bytes for IP, UDP and TFTP headers, 52 bytes for IPv6 */
-		  int overhead = (listen->family == AF_INET) ? 32 : 52;
-		  transfer->blocksize = atoi(opt);
-		  if (transfer->blocksize < 1)
-		    transfer->blocksize = 1;
-		  if (transfer->blocksize > (unsigned)daemon->packet_buff_sz - 4)
-		    transfer->blocksize = (unsigned)daemon->packet_buff_sz - 4;
-		  if (mtu != 0 && transfer->blocksize > (unsigned)mtu - overhead)
-		    transfer->blocksize = (unsigned)mtu - overhead;
-		  transfer->opt_blocksize = 1;
-		  transfer->block = 0;
-		}
-	    }
-	  else if (strcasecmp(opt, "tsize") == 0 && next(&p, end) && !transfer->netascii)
-	    {
-	      transfer->opt_transize = 1;
-	      transfer->block = 0;
-	    }
-	}
-
-      /* cope with backslashes from windows boxen. */
-      for (p = filename; *p; p++)
-	if (*p == '\\')
-	  *p = '/';
-	else if (option_bool(OPT_TFTP_LC))
-	  *p = tolower(*p);
-		
-      strcpy(daemon->namebuff, "/");
-      if (prefix)
-	{
-	  if (prefix[0] == '/')
-	    daemon->namebuff[0] = 0;
-	  strncat(daemon->namebuff, prefix, (MAXDNAME-1) - strlen(daemon->namebuff));
-	  if (prefix[strlen(prefix)-1] != '/')
-	    strncat(daemon->namebuff, "/", (MAXDNAME-1) - strlen(daemon->namebuff));
-
-	  if (option_bool(OPT_TFTP_APREF_IP))
-	    {
-	      size_t oldlen = strlen(daemon->namebuff);
-	      struct stat statbuf;
-	      
-	      strncat(daemon->namebuff, daemon->addrbuff, (MAXDNAME-1) - strlen(daemon->namebuff));
-	      strncat(daemon->namebuff, "/", (MAXDNAME-1) - strlen(daemon->namebuff));
-	      
-	      /* remove unique-directory if it doesn't exist */
-	      if (stat(daemon->namebuff, &statbuf) == -1 || !S_ISDIR(statbuf.st_mode))
-		daemon->namebuff[oldlen] = 0;
-	    }
-	  
-	  if (option_bool(OPT_TFTP_APREF_MAC))
-	    {
-	      unsigned char *macaddr = NULL;
-	      unsigned char macbuf[DHCP_CHADDR_MAX];
-	      
+      (strcasecmp(mode, "octet") != 0 && strcasecmp(mode, "netascii") != 0)) {
+    len =
+        tftp_err(ERR_ILL, packet, _("unsupported request from %s"),
+                 daemon->addrbuff);
+    is_err = 1;
+  } else {
+    if (strcasecmp(mode, "netascii") == 0)
+      transfer->netascii = 1;
+
+    while ((opt = next(&p, end))) {
+      if (strcasecmp(opt, "blksize") == 0) {
+        if ((opt = next(&p, end)) && !option_bool(OPT_TFTP_NOBLOCK)) {
+          /* 32 bytes for IP, UDP and TFTP headers, 52 bytes for IPv6 */
+          int overhead = (listen->family == AF_INET) ? 32 : 52;
+          transfer->blocksize = atoi(opt);
+          if (transfer->blocksize < 1)
+            transfer->blocksize = 1;
+          if (transfer->blocksize > (unsigned) daemon->packet_buff_sz - 4)
+            transfer->blocksize = (unsigned) daemon->packet_buff_sz - 4;
+          if (mtu != 0 && transfer->blocksize > (unsigned) mtu - overhead)
+            transfer->blocksize = (unsigned) mtu - overhead;
+          transfer->opt_blocksize = 1;
+          transfer->block = 0;
+        }
+      } else if (strcasecmp(opt, "tsize") == 0 && next(&p, end)
+                 && !transfer->netascii) {
+        transfer->opt_transize = 1;
+        transfer->block = 0;
+      }
+    }
+
+    /* cope with backslashes from windows boxen. */
+    for (p = filename; *p; p++)
+      if (*p == '\\')
+        *p = '/';
+      else if (option_bool(OPT_TFTP_LC))
+        *p = tolower(*p);
+
+    strcpy(daemon->namebuff, "/");
+    if (prefix) {
+      if (prefix[0] == '/')
+        daemon->namebuff[0] = 0;
+      strncat(daemon->namebuff, prefix,
+              (MAXDNAME - 1) - strlen(daemon->namebuff));
+      if (prefix[strlen(prefix) - 1] != '/')
+        strncat(daemon->namebuff, "/",
+                (MAXDNAME - 1) - strlen(daemon->namebuff));
+
+      if (option_bool(OPT_TFTP_APREF_IP)) {
+        size_t oldlen = strlen(daemon->namebuff);
+        struct stat statbuf;
+
+        strncat(daemon->namebuff, daemon->addrbuff,
+                (MAXDNAME - 1) - strlen(daemon->namebuff));
+        strncat(daemon->namebuff, "/",
+                (MAXDNAME - 1) - strlen(daemon->namebuff));
+
+        /* remove unique-directory if it doesn't exist */
+        if (stat(daemon->namebuff, &statbuf) == -1 || !S_ISDIR(statbuf.st_mode))
+          daemon->namebuff[oldlen] = 0;
+      }
+
+      if (option_bool(OPT_TFTP_APREF_MAC)) {
+        unsigned char *macaddr = NULL;
+        unsigned char macbuf[DHCP_CHADDR_MAX];
+
 #ifdef HAVE_DHCP
-	      if (daemon->dhcp && peer.sa.sa_family == AF_INET)
-	        {
-		  /* Check if the client IP is in our lease database */
-		  struct dhcp_lease *lease = lease_find_by_addr(peer.in.sin_addr);
-		  if (lease && lease->hwaddr_type == ARPHRD_ETHER && lease->hwaddr_len == ETHER_ADDR_LEN)
-		    macaddr = lease->hwaddr;
-		}
-#endif
-	      
-	      /* If no luck, try to find in ARP table. This only works if client is in same (V)LAN */
-	      if (!macaddr && find_mac(&peer, macbuf, 1, now) > 0)
-		macaddr = macbuf;
-	      
-	      if (macaddr)
-	        {
-		  size_t oldlen = strlen(daemon->namebuff);
-		  struct stat statbuf;
-
-		  snprintf(daemon->namebuff + oldlen, (MAXDNAME-1) - oldlen, "%.2x-%.2x-%.2x-%.2x-%.2x-%.2x/",
-			   macaddr[0], macaddr[1], macaddr[2], macaddr[3], macaddr[4], macaddr[5]);
-		  
-		  /* remove unique-directory if it doesn't exist */
-		  if (stat(daemon->namebuff, &statbuf) == -1 || !S_ISDIR(statbuf.st_mode))
-		    daemon->namebuff[oldlen] = 0;
-		}
-	    }
-	  
-	  /* Absolute pathnames OK if they match prefix */
-	  if (filename[0] == '/')
-	    {
-	      if (strstr(filename, daemon->namebuff) == filename)
-		daemon->namebuff[0] = 0;
-	      else
-		filename++;
-	    }
-	}
-      else if (filename[0] == '/')
-	daemon->namebuff[0] = 0;
-      strncat(daemon->namebuff, filename, (MAXDNAME-1) - strlen(daemon->namebuff));
-      
-      /* check permissions and open file */
-      if ((transfer->file = check_tftp_fileperm(&len, prefix)))
-	{
-	  if ((len = get_block(packet, transfer)) == -1)
-	    len = tftp_err_oops(packet, daemon->namebuff);
-	  else
-	    is_err = 0;
-	}
-    }
-  
-  while (sendto(transfer->sockfd, packet, len, 0, 
-		(struct sockaddr *)&peer, sa_len(&peer)) == -1 && errno == EINTR);
-  
+        if (daemon->dhcp && peer.sa.sa_family == AF_INET) {
+          /* Check if the client IP is in our lease database */
+          struct dhcp_lease *lease = lease_find_by_addr(peer.in.sin_addr);
+          if (lease && lease->hwaddr_type == ARPHRD_ETHER
+              && lease->hwaddr_len == ETHER_ADDR_LEN)
+            macaddr = lease->hwaddr;
+        }
+#endif
+
+        /* If no luck, try to find in ARP table. This only works if client is in same (V)LAN */
+        if (!macaddr && find_mac(&peer, macbuf, 1, now) > 0)
+          macaddr = macbuf;
+
+        if (macaddr) {
+          size_t oldlen = strlen(daemon->namebuff);
+          struct stat statbuf;
+
+          snprintf(daemon->namebuff + oldlen, (MAXDNAME - 1) - oldlen,
+                   "%.2x-%.2x-%.2x-%.2x-%.2x-%.2x/", macaddr[0], macaddr[1],
+                   macaddr[2], macaddr[3], macaddr[4], macaddr[5]);
+
+          /* remove unique-directory if it doesn't exist */
+          if (stat(daemon->namebuff, &statbuf) == -1
+              || !S_ISDIR(statbuf.st_mode))
+            daemon->namebuff[oldlen] = 0;
+        }
+      }
+
+      /* Absolute pathnames OK if they match prefix */
+      if (filename[0] == '/') {
+        if (strstr(filename, daemon->namebuff) == filename)
+          daemon->namebuff[0] = 0;
+        else
+          filename++;
+      }
+    } else if (filename[0] == '/')
+      daemon->namebuff[0] = 0;
+    strncat(daemon->namebuff, filename,
+            (MAXDNAME - 1) - strlen(daemon->namebuff));
+
+    /* check permissions and open file */
+    if ((transfer->file = check_tftp_fileperm(&len, prefix))) {
+      if ((len = get_block(packet, transfer)) == -1)
+        len = tftp_err_oops(packet, daemon->namebuff);
+      else
+        is_err = 0;
+    }
+  }
+
+  while (sendto(transfer->sockfd, packet, len, 0,
+                (struct sockaddr *) &peer, sa_len(&peer)) == -1
+         && errno == EINTR);
+
   if (is_err)
     free_transfer(transfer);
-  else
-    {
-      transfer->next = daemon->tftp_trans;
-      daemon->tftp_trans = transfer;
-    }
+  else {
+    transfer->next = daemon->tftp_trans;
+    daemon->tftp_trans = transfer;
+  }
 }
- 
-static struct tftp_file *check_tftp_fileperm(ssize_t *len, char *prefix)
+
+static struct tftp_file *check_tftp_fileperm(ssize_t * len, char *prefix)
 {
   char *packet = daemon->packet, *namebuff = daemon->namebuff;
   struct tftp_file *file;
@@ -475,55 +449,49 @@
   /* trick to ban moving out of the subtree */
   if (prefix && strstr(namebuff, "/../"))
     goto perm;
-  
-  if ((fd = open(namebuff, O_RDONLY)) == -1)
-    {
-      if (errno == ENOENT)
-	{
-	  *len = tftp_err(ERR_FNF, packet, _("file %s not found"), namebuff);
-	  return NULL;
-	}
-      else if (errno == EACCES)
-	goto perm;
-      else
-	goto oops;
-    }
-  
+
+  if ((fd = open(namebuff, O_RDONLY)) == -1) {
+    if (errno == ENOENT) {
+      *len = tftp_err(ERR_FNF, packet, _("file %s not found"), namebuff);
+      return NULL;
+    } else if (errno == EACCES)
+      goto perm;
+    else
+      goto oops;
+  }
+
   /* stat the file descriptor to avoid stat->open races */
   if (fstat(fd, &statbuf) == -1)
     goto oops;
-  
+
   /* running as root, must be world-readable */
-  if (uid == 0)
-    {
-      if (!(statbuf.st_mode & S_IROTH))
-	goto perm;
-    }
+  if (uid == 0) {
+    if (!(statbuf.st_mode & S_IROTH))
+      goto perm;
+  }
   /* in secure mode, must be owned by user running dnsmasq */
   else if (option_bool(OPT_TFTP_SECURE) && uid != statbuf.st_uid)
     goto perm;
-      
+
   /* If we're doing many transfers from the same file, only 
      open it once this saves lots of file descriptors 
      when mass-booting a big cluster, for instance. 
      Be conservative and only share when inode and name match
      this keeps error messages sane. */
   for (t = daemon->tftp_trans; t; t = t->next)
-    if (t->file->dev == statbuf.st_dev && 
-	t->file->inode == statbuf.st_ino &&
-	strcmp(t->file->filename, namebuff) == 0)
-      {
-	close(fd);
-	t->file->refcount++;
-	return t->file;
-      }
-  
-  if (!(file = whine_malloc(sizeof(struct tftp_file) + strlen(namebuff) + 1)))
-    {
-      errno = ENOMEM;
-      goto oops;
+    if (t->file->dev == statbuf.st_dev &&
+        t->file->inode == statbuf.st_ino &&
+        strcmp(t->file->filename, namebuff) == 0) {
+      close(fd);
+      t->file->refcount++;
+      return t->file;
     }
 
+  if (!(file = whine_malloc(sizeof(struct tftp_file) + strlen(namebuff) + 1))) {
+    errno = ENOMEM;
+    goto oops;
+  }
+
   file->fd = fd;
   file->size = statbuf.st_size;
   file->dev = statbuf.st_dev;
@@ -531,16 +499,16 @@
   file->refcount = 1;
   strcpy(file->filename, namebuff);
   return file;
-  
- perm:
+
+perm:
   errno = EACCES;
-  *len =  tftp_err(ERR_PERM, packet, _("cannot access %s: %s"), namebuff);
+  *len = tftp_err(ERR_PERM, packet, _("cannot access %s: %s"), namebuff);
   if (fd != -1)
     close(fd);
   return NULL;
 
- oops:
-  *len =  tftp_err_oops(packet, namebuff);
+oops:
+  *len = tftp_err_oops(packet, namebuff);
   if (fd != -1)
     close(fd);
   return NULL;
@@ -550,114 +518,108 @@
 {
   struct tftp_transfer *transfer, *tmp, **up;
   ssize_t len;
-  
+
   struct ack {
     unsigned short op, block;
-  } *mess = (struct ack *)daemon->packet;
-  
+  } *mess = (struct ack *) daemon->packet;
+
   /* Check for activity on any existing transfers */
-  for (transfer = daemon->tftp_trans, up = &daemon->tftp_trans; transfer; transfer = tmp)
-    {
-      tmp = transfer->next;
-      
-      prettyprint_addr(&transfer->peer, daemon->addrbuff);
-     
-      if (poll_check(transfer->sockfd, POLLIN))
-	{
-	  /* we overwrote the buffer... */
-	  daemon->srv_save = NULL;
-	  
-	  if ((len = recv(transfer->sockfd, daemon->packet, daemon->packet_buff_sz, 0)) >= (ssize_t)sizeof(struct ack))
-	    {
-	      if (ntohs(mess->op) == OP_ACK && ntohs(mess->block) == (unsigned short)transfer->block) 
-		{
-		  /* Got ack, ensure we take the (re)transmit path */
-		  transfer->timeout = now;
-		  transfer->backoff = 0;
-		  if (transfer->block++ != 0)
-		    transfer->offset += transfer->blocksize - transfer->expansion;
-		}
-	      else if (ntohs(mess->op) == OP_ERR)
-		{
-		  char *p = daemon->packet + sizeof(struct ack);
-		  char *end = daemon->packet + len;
-		  char *err = next(&p, end);
-		  
-		  /* Sanitise error message */
-		  if (!err)
-		    err = "";
-		  else
-		    sanitise(err);
-		  
-		  my_syslog(MS_TFTP | LOG_ERR, _("error %d %s received from %s"),
-			    (int)ntohs(mess->block), err, 
-			    daemon->addrbuff);	
-		  
-		  /* Got err, ensure we take abort */
-		  transfer->timeout = now;
-		  transfer->backoff = 100;
-		}
-	    }
-	}
-      
-      if (difftime(now, transfer->timeout) >= 0.0)
-	{
-	  int endcon = 0;
-
-	  /* timeout, retransmit */
-	  transfer->timeout += 1 + (1<<transfer->backoff);
-	  	  
-	  /* we overwrote the buffer... */
-	  daemon->srv_save = NULL;
-	 
-	  if ((len = get_block(daemon->packet, transfer)) == -1)
-	    {
-	      len = tftp_err_oops(daemon->packet, transfer->file->filename);
-	      endcon = 1;
-	    }
-	  /* don't complain about timeout when we're awaiting the last
-	     ACK, some clients never send it */
-	  else if (++transfer->backoff > 7 && len != 0)
-	    {
-	      endcon = 1;
-	      len = 0;
-	    }
-
-	  if (len != 0)
-	    while(sendto(transfer->sockfd, daemon->packet, len, 0, 
-			 (struct sockaddr *)&transfer->peer, sa_len(&transfer->peer)) == -1 && errno == EINTR);
-	  
-	  if (endcon || len == 0)
-	    {
-	      strcpy(daemon->namebuff, transfer->file->filename);
-	      sanitise(daemon->namebuff);
-	      my_syslog(MS_TFTP | LOG_INFO, endcon ? _("failed sending %s to %s") : _("sent %s to %s"), daemon->namebuff, daemon->addrbuff);
-	      /* unlink */
-	      *up = tmp;
-	      if (endcon)
-		free_transfer(transfer);
-	      else
-		{
-		  /* put on queue to be sent to script and deleted */
-		  transfer->next = daemon->tftp_done_trans;
-		  daemon->tftp_done_trans = transfer;
-		}
-	      continue;
-	    }
-	}
+  for (transfer = daemon->tftp_trans, up = &daemon->tftp_trans; transfer;
+       transfer = tmp) {
+    tmp = transfer->next;
+
+    prettyprint_addr(&transfer->peer, daemon->addrbuff);
+
+    if (poll_check(transfer->sockfd, POLLIN)) {
+      /* we overwrote the buffer... */
+      daemon->srv_save = NULL;
+
+      if ((len =
+           recv(transfer->sockfd, daemon->packet, daemon->packet_buff_sz,
+                0)) >= (ssize_t) sizeof(struct ack)) {
+        if (ntohs(mess->op) == OP_ACK
+            && ntohs(mess->block) == (unsigned short) transfer->block) {
+          /* Got ack, ensure we take the (re)transmit path */
+          transfer->timeout = now;
+          transfer->backoff = 0;
+          if (transfer->block++ != 0)
+            transfer->offset += transfer->blocksize - transfer->expansion;
+        } else if (ntohs(mess->op) == OP_ERR) {
+          char *p = daemon->packet + sizeof(struct ack);
+          char *end = daemon->packet + len;
+          char *err = next(&p, end);
+
+          /* Sanitise error message */
+          if (!err)
+            err = "";
+          else
+            sanitise(err);
+
+          my_syslog(MS_TFTP | LOG_ERR, _("error %d %s received from %s"),
+                    (int) ntohs(mess->block), err, daemon->addrbuff);
+
+          /* Got err, ensure we take abort */
+          transfer->timeout = now;
+          transfer->backoff = 100;
+        }
+      }
+    }
+
+    if (difftime(now, transfer->timeout) >= 0.0) {
+      int endcon = 0;
+
+      /* timeout, retransmit */
+      transfer->timeout += 1 + (1 << transfer->backoff);
+
+      /* we overwrote the buffer... */
+      daemon->srv_save = NULL;
+
+      if ((len = get_block(daemon->packet, transfer)) == -1) {
+        len = tftp_err_oops(daemon->packet, transfer->file->filename);
+        endcon = 1;
+      }
+      /* don't complain about timeout when we're awaiting the last
+         ACK, some clients never send it */
+      else if (++transfer->backoff > 7 && len != 0) {
+        endcon = 1;
+        len = 0;
+      }
+
+      if (len != 0)
+        while (sendto(transfer->sockfd, daemon->packet, len, 0,
+                      (struct sockaddr *) &transfer->peer,
+                      sa_len(&transfer->peer)) == -1 && errno == EINTR);
+
+      if (endcon || len == 0) {
+        strcpy(daemon->namebuff, transfer->file->filename);
+        sanitise(daemon->namebuff);
+        my_syslog(MS_TFTP | LOG_INFO,
+                  endcon ? _("failed sending %s to %s") : _("sent %s to %s"),
+                  daemon->namebuff, daemon->addrbuff);
+        /* unlink */
+        *up = tmp;
+        if (endcon)
+          free_transfer(transfer);
+        else {
+          /* put on queue to be sent to script and deleted */
+          transfer->next = daemon->tftp_done_trans;
+          daemon->tftp_done_trans = transfer;
+        }
+        continue;
+      }
+    }
 
-      up = &transfer->next;
-    }    
+    up = &transfer->next;
+  }
 }
 
 static void free_transfer(struct tftp_transfer *transfer)
 {
   close(transfer->sockfd);
-  if (transfer->file && (--transfer->file->refcount) == 0)
-    {
-      close(transfer->file->fd);
-      free(transfer->file);
-    }
+  if (transfer->file && (--transfer->file->refcount) == 0) {
+    close(transfer->file->fd);
+    free(transfer->file);
+  }
   free(transfer);
 }
 
@@ -666,9 +628,7 @@
   char *ret = *p;
   size_t len;
 
-  if (*(end-1) != 0 || 
-      *p == end ||
-      (len = strlen(ret)) == 0)
+  if (*(end - 1) != 0 || *p == end || (len = strlen(ret)) == 0)
     return NULL;
 
   *p += len + 1;
@@ -678,125 +638,119 @@
 static void sanitise(char *buf)
 {
   unsigned char *q, *r;
-  for (q = r = (unsigned char *)buf; *r; r++)
-    if (isprint((int)*r))
+  for (q = r = (unsigned char *) buf; *r; r++)
+    if (isprint((int) *r))
       *(q++) = *r;
   *q = 0;
 
 }
 
-#define MAXMESSAGE 500 /* limit to make packet < 512 bytes and definitely smaller than buffer */ 
+#define MAXMESSAGE 500          /* limit to make packet < 512 bytes and definitely smaller than buffer */
 static ssize_t tftp_err(int err, char *packet, char *message, char *file)
 {
   struct errmess {
     unsigned short op, err;
     char message[];
-  } *mess = (struct errmess *)packet;
+  } *mess = (struct errmess *) packet;
   ssize_t len, ret = 4;
   char *errstr = strerror(errno);
-  
+
   memset(packet, 0, daemon->packet_buff_sz);
   sanitise(file);
-  
+
   mess->op = htons(OP_ERR);
   mess->err = htons(err);
-  len = snprintf(mess->message, MAXMESSAGE,  message, file, errstr);
-  ret += (len < MAXMESSAGE) ? len + 1 : MAXMESSAGE; /* include terminating zero */
-  
+  len = snprintf(mess->message, MAXMESSAGE, message, file, errstr);
+  ret += (len < MAXMESSAGE) ? len + 1 : MAXMESSAGE;     /* include terminating zero */
+
   my_syslog(MS_TFTP | LOG_ERR, "%s", mess->message);
-  
-  return  ret;
+
+  return ret;
 }
 
 static ssize_t tftp_err_oops(char *packet, char *file)
 {
   /* May have >1 refs to file, so potentially mangle a copy of the name */
   strcpy(daemon->namebuff, file);
-  return tftp_err(ERR_NOTDEF, packet, _("cannot read %s: %s"), daemon->namebuff);
+  return tftp_err(ERR_NOTDEF, packet, _("cannot read %s: %s"),
+                  daemon->namebuff);
 }
 
 /* return -1 for error, zero for done. */
 static ssize_t get_block(char *packet, struct tftp_transfer *transfer)
 {
   memset(packet, 0, daemon->packet_buff_sz);
-  
-  if (transfer->block == 0)
-    {
-      /* send OACK */
-      char *p;
-      struct oackmess {
-	unsigned short op;
-	char data[];
-      } *mess = (struct oackmess *)packet;
-      
-      p = mess->data;
-      mess->op = htons(OP_OACK);
-      if (transfer->opt_blocksize)
-	{
-	  p += (sprintf(p, "blksize") + 1);
-	  p += (sprintf(p, "%u", transfer->blocksize) + 1);
-	}
-      if (transfer->opt_transize)
-	{
-	  p += (sprintf(p,"tsize") + 1);
-	  p += (sprintf(p, "%u", (unsigned int)transfer->file->size) + 1);
-	}
-
-      return p - packet;
-    }
-  else
-    {
-      /* send data packet */
-      struct datamess {
-	unsigned short op, block;
-	unsigned char data[];
-      } *mess = (struct datamess *)packet;
-      
-      size_t size = transfer->file->size - transfer->offset; 
-      
-      if (transfer->offset > transfer->file->size)
-	return 0; /* finished */
-      
-      if (size > transfer->blocksize)
-	size = transfer->blocksize;
-      
-      mess->op = htons(OP_DATA);
-      mess->block = htons((unsigned short)(transfer->block));
-      
-      if (lseek(transfer->file->fd, transfer->offset, SEEK_SET) == (off_t)-1 ||
-	  !read_write(transfer->file->fd, mess->data, size, 1))
-	return -1;
-      
-      transfer->expansion = 0;
-      
-      /* Map '\n' to CR-LF in netascii mode */
-      if (transfer->netascii)
-	{
-	  size_t i;
-	  int newcarrylf;
-
-	  for (i = 0, newcarrylf = 0; i < size; i++)
-	    if (mess->data[i] == '\n' && ( i != 0 || !transfer->carrylf))
-	      {
-		transfer->expansion++;
-
-		if (size != transfer->blocksize)
-		  size++; /* room in this block */
-		else  if (i == size - 1)
-		  newcarrylf = 1; /* don't expand LF again if it moves to the next block */
-		  
-		/* make space and insert CR */
-		memmove(&mess->data[i+1], &mess->data[i], size - (i + 1));
-		mess->data[i] = '\r';
-		
-		i++;
-	      }
-	  transfer->carrylf = newcarrylf;
-	  
-	}
 
-      return size + 4;
+  if (transfer->block == 0) {
+    /* send OACK */
+    char *p;
+    struct oackmess {
+      unsigned short op;
+      char data[];
+    } *mess = (struct oackmess *) packet;
+
+    p = mess->data;
+    mess->op = htons(OP_OACK);
+    if (transfer->opt_blocksize) {
+      p += (sprintf(p, "blksize") + 1);
+      p += (sprintf(p, "%u", transfer->blocksize) + 1);
+    }
+    if (transfer->opt_transize) {
+      p += (sprintf(p, "tsize") + 1);
+      p += (sprintf(p, "%u", (unsigned int) transfer->file->size) + 1);
+    }
+
+    return p - packet;
+  } else {
+    /* send data packet */
+    struct datamess {
+      unsigned short op, block;
+      unsigned char data[];
+    } *mess = (struct datamess *) packet;
+
+    size_t size = transfer->file->size - transfer->offset;
+
+    if (transfer->offset > transfer->file->size)
+      return 0;                 /* finished */
+
+    if (size > transfer->blocksize)
+      size = transfer->blocksize;
+
+    mess->op = htons(OP_DATA);
+    mess->block = htons((unsigned short) (transfer->block));
+
+    if (lseek(transfer->file->fd, transfer->offset, SEEK_SET) == (off_t) - 1 ||
+        !read_write(transfer->file->fd, mess->data, size, 1))
+      return -1;
+
+    transfer->expansion = 0;
+
+    /* Map '\n' to CR-LF in netascii mode */
+    if (transfer->netascii) {
+      size_t i;
+      int newcarrylf;
+
+      for (i = 0, newcarrylf = 0; i < size; i++)
+        if (mess->data[i] == '\n' && (i != 0 || !transfer->carrylf)) {
+          transfer->expansion++;
+
+          if (size != transfer->blocksize)
+            size++;             /* room in this block */
+          else if (i == size - 1)
+            newcarrylf = 1;     /* don't expand LF again if it moves to the next block */
+
+          /* make space and insert CR */
+          memmove(&mess->data[i + 1], &mess->data[i], size - (i + 1));
+          mess->data[i] = '\r';
+
+          i++;
+        }
+      transfer->carrylf = newcarrylf;
+
     }
+
+    return size + 4;
+  }
 }
 
 
@@ -804,15 +758,14 @@
 {
   struct tftp_transfer *transfer;
 
-  if ((transfer = daemon->tftp_done_trans))
-    {
-      daemon->tftp_done_trans = transfer->next;
+  if ((transfer = daemon->tftp_done_trans)) {
+    daemon->tftp_done_trans = transfer->next;
 #ifdef HAVE_SCRIPT
-      queue_tftp(transfer->file->size, transfer->file->filename, &transfer->peer);
+    queue_tftp(transfer->file->size, transfer->file->filename, &transfer->peer);
 #endif
-      free_transfer(transfer);
-      return 1;
-    }
+    free_transfer(transfer);
+    return 1;
+  }
 
   return 0;
 }
Index: dnsmasq-2.78/src/util.c
===================================================================
--- dnsmasq-2.78.orig/src/util.c	2017-10-02 21:13:51.000000000 +0800
+++ dnsmasq-2.78/src/util.c	2018-10-29 16:14:19.509440028 +0800
@@ -40,12 +40,12 @@
 void rand_init()
 {
   int fd = open(RANDFILE, O_RDONLY);
-  
+
   if (fd == -1 ||
-      !read_write(fd, (unsigned char *)&seed, sizeof(seed), 1) ||
-      !read_write(fd, (unsigned char *)&in, sizeof(in), 1))
+      !read_write(fd, (unsigned char *) &seed, sizeof(seed), 1) ||
+      !read_write(fd, (unsigned char *) &in, sizeof(in), 1))
     die(_("failed to seed the random number generator: %s"), NULL, EC_MISC);
-  
+
   close(fd);
 }
 
@@ -54,61 +54,74 @@
 
 static void surf(void)
 {
-  u32 t[12]; u32 x; u32 sum = 0;
-  int r; int i; int loop;
+  u32 t[12];
+  u32 x;
+  u32 sum = 0;
+  int r;
+  int i;
+  int loop;
 
-  for (i = 0;i < 12;++i) t[i] = in[i] ^ seed[12 + i];
-  for (i = 0;i < 8;++i) out[i] = seed[24 + i];
+  for (i = 0; i < 12; ++i)
+    t[i] = in[i] ^ seed[12 + i];
+  for (i = 0; i < 8; ++i)
+    out[i] = seed[24 + i];
   x = t[11];
-  for (loop = 0;loop < 2;++loop) {
-    for (r = 0;r < 16;++r) {
+  for (loop = 0; loop < 2; ++loop) {
+    for (r = 0; r < 16; ++r) {
       sum += 0x9e3779b9;
-      MUSH(0,5) MUSH(1,7) MUSH(2,9) MUSH(3,13)
-      MUSH(4,5) MUSH(5,7) MUSH(6,9) MUSH(7,13)
-      MUSH(8,5) MUSH(9,7) MUSH(10,9) MUSH(11,13)
+      MUSH(0, 5) MUSH(1, 7) MUSH(2, 9) MUSH(3, 13)
+          MUSH(4, 5) MUSH(5, 7) MUSH(6, 9) MUSH(7, 13)
+          MUSH(8, 5) MUSH(9, 7) MUSH(10, 9) MUSH(11, 13)
     }
-    for (i = 0;i < 8;++i) out[i] ^= t[i + 4];
+    for (i = 0; i < 8; ++i)
+      out[i] ^= t[i + 4];
   }
 }
 
 unsigned short rand16(void)
 {
-  if (!outleft) 
-    {
-      if (!++in[0]) if (!++in[1]) if (!++in[2]) ++in[3];
-      surf();
-      outleft = 8;
-    }
-  
+  if (!outleft) {
+    if (!++in[0])
+      if (!++in[1])
+        if (!++in[2])
+          ++in[3];
+    surf();
+    outleft = 8;
+  }
+
   return (unsigned short) out[--outleft];
 }
 
 u32 rand32(void)
 {
- if (!outleft) 
-    {
-      if (!++in[0]) if (!++in[1]) if (!++in[2]) ++in[3];
-      surf();
-      outleft = 8;
-    }
-  
-  return out[--outleft]; 
+  if (!outleft) {
+    if (!++in[0])
+      if (!++in[1])
+        if (!++in[2])
+          ++in[3];
+    surf();
+    outleft = 8;
+  }
+
+  return out[--outleft];
 }
 
 u64 rand64(void)
 {
   static int outleft = 0;
 
-  if (outleft < 2)
-    {
-      if (!++in[0]) if (!++in[1]) if (!++in[2]) ++in[3];
-      surf();
-      outleft = 8;
-    }
-  
+  if (outleft < 2) {
+    if (!++in[0])
+      if (!++in[1])
+        if (!++in[2])
+          ++in[3];
+    surf();
+    outleft = 8;
+  }
+
   outleft -= 2;
 
-  return (u64)out[outleft+1] + (((u64)out[outleft]) << 32);
+  return (u64) out[outleft + 1] + (((u64) out[outleft]) << 32);
 }
 
 /* returns 2 if names is OK but contains one or more underscores */
@@ -120,35 +133,33 @@
   char c;
   int nowhite = 0;
   int hasuscore = 0;
-  
-  if (l == 0 || l > MAXDNAME) return 0;
-  
-  if (in[l-1] == '.')
-    {
-      in[l-1] = 0;
-      nowhite = 1;
-    }
 
-  for (; (c = *in); in++)
-    {
-      if (c == '.')
-	dotgap = 0;
-      else if (++dotgap > MAXLABEL)
-	return 0;
-      else if (isascii((unsigned char)c) && iscntrl((unsigned char)c)) 
-	/* iscntrl only gives expected results for ascii */
-	return 0;
+  if (l == 0 || l > MAXDNAME)
+    return 0;
+
+  if (in[l - 1] == '.') {
+    in[l - 1] = 0;
+    nowhite = 1;
+  }
+
+  for (; (c = *in); in++) {
+    if (c == '.')
+      dotgap = 0;
+    else if (++dotgap > MAXLABEL)
+      return 0;
+    else if (isascii((unsigned char) c) && iscntrl((unsigned char) c))
+      /* iscntrl only gives expected results for ascii */
+      return 0;
 #if !defined(HAVE_IDN) && !defined(HAVE_LIBIDN2)
-      else if (!isascii((unsigned char)c))
-	return 0;
+    else if (!isascii((unsigned char) c))
+      return 0;
 #endif
-      else if (c != ' ')
-	{
-	  nowhite = 1;
-	  if (c == '_')
-	    hasuscore = 1;
-	}
+    else if (c != ' ') {
+      nowhite = 1;
+      if (c == '_')
+        hasuscore = 1;
     }
+  }
 
   if (!nowhite)
     return 0;
@@ -170,72 +181,69 @@
 
   for (first = 1; (c = *name); name++, first = 0)
     /* check for legal char a-z A-Z 0-9 - _ . */
-    {
-      if ((c >= 'A' && c <= 'Z') ||
-	  (c >= 'a' && c <= 'z') ||
-	  (c >= '0' && c <= '9'))
-	continue;
-
-      if (!first && (c == '-' || c == '_'))
-	continue;
-      
-      /* end of hostname part */
-      if (c == '.')
-	return 1;
-      
-      return 0;
-    }
-  
+  {
+    if ((c >= 'A' && c <= 'Z') ||
+        (c >= 'a' && c <= 'z') || (c >= '0' && c <= '9'))
+      continue;
+
+    if (!first && (c == '-' || c == '_'))
+      continue;
+
+    /* end of hostname part */
+    if (c == '.')
+      return 1;
+
+    return 0;
+  }
+
   return 1;
 }
-  
+
 char *canonicalise(char *in, int *nomem)
 {
   char *ret = NULL;
   int rc;
-  
+
   if (nomem)
     *nomem = 0;
-  
+
   if (!(rc = check_name(in)))
     return NULL;
-  
+
 #if defined(HAVE_LIBIDN2) && (!defined(IDN2_VERSION_NUMBER) || IDN2_VERSION_NUMBER < 0x02000003)
   /* older libidn2 strips underscores, so don't do IDN processing
      if the name has an underscore (check_name() returned 2) */
   if (rc != 2)
 #endif
 #if defined(HAVE_IDN) || defined(HAVE_LIBIDN2)
-    {
-#  ifdef HAVE_LIBIDN2
-      rc = idn2_to_ascii_lz(in, &ret, IDN2_NONTRANSITIONAL);
-      if (rc == IDN2_DISALLOWED)
-	rc = idn2_to_ascii_lz(in, &ret, IDN2_TRANSITIONAL);
-#  else
-      rc = idna_to_ascii_lz(in, &ret, 0);
-#  endif
-      if (rc != IDNA_SUCCESS)
-	{
-	  if (ret)
-	    free(ret);
-	  
-	  if (nomem && (rc == IDNA_MALLOC_ERROR || rc == IDNA_DLOPEN_ERROR))
-	    {
-	      my_syslog(LOG_ERR, _("failed to allocate memory"));
-	      *nomem = 1;
-	    }
-	  
-	  return NULL;
-	}
-      
-      return ret;
+  {
+#ifdef HAVE_LIBIDN2
+    rc = idn2_to_ascii_lz(in, &ret, IDN2_NONTRANSITIONAL);
+    if (rc == IDN2_DISALLOWED)
+      rc = idn2_to_ascii_lz(in, &ret, IDN2_TRANSITIONAL);
+#else
+    rc = idna_to_ascii_lz(in, &ret, 0);
+#endif
+    if (rc != IDNA_SUCCESS) {
+      if (ret)
+        free(ret);
+
+      if (nomem && (rc == IDNA_MALLOC_ERROR || rc == IDNA_DLOPEN_ERROR)) {
+        my_syslog(LOG_ERR, _("failed to allocate memory"));
+        *nomem = 1;
+      }
+
+      return NULL;
     }
+
+    return ret;
+  }
 #endif
-  
-  if ((ret = whine_malloc(strlen(in)+1)))
+
+  if ((ret = whine_malloc(strlen(in) + 1)))
     strcpy(ret, in);
   else if (nomem)
-    *nomem = 1;    
+    *nomem = 1;
 
   return ret;
 }
@@ -243,28 +251,26 @@
 unsigned char *do_rfc1035_name(unsigned char *p, char *sval, char *limit)
 {
   int j;
-  
-  while (sval && *sval)
-    {
-      if (limit && p + 1 > (unsigned char*)limit)
-        return p;
 
-      unsigned char *cp = p++;
-      for (j = 0; *sval && (*sval != '.'); sval++, j++)
-	{
-          if (limit && p + 1 > (unsigned char*)limit)
-            return p;
+  while (sval && *sval) {
+    if (limit && p + 1 > (unsigned char *) limit)
+      return p;
+
+    unsigned char *cp = p++;
+    for (j = 0; *sval && (*sval != '.'); sval++, j++) {
+      if (limit && p + 1 > (unsigned char *) limit)
+        return p;
 #ifdef HAVE_DNSSEC
-	  if (option_bool(OPT_DNSSEC_VALID) && *sval == NAME_ESCAPE)
-	    *p++ = (*(++sval))-1;
-	  else
-#endif		
-	    *p++ = *sval;
-	}
-      *cp  = j;
-      if (*sval)
-	sval++;
+      if (option_bool(OPT_DNSSEC_VALID) && *sval == NAME_ESCAPE)
+        *p++ = (*(++sval)) - 1;
+      else
+#endif
+        *p++ = *sval;
     }
+    *cp = j;
+    if (*sval)
+      sval++;
+  }
   return p;
 }
 
@@ -272,18 +278,16 @@
 void *safe_malloc(size_t size)
 {
   void *ret = calloc(1, size);
-  
+
   if (!ret)
     die(_("could not get memory"), NULL, EC_NOMEM);
-      
+
   return ret;
-}    
+}
 
 void safe_pipe(int *fd, int read_noblock)
 {
-  if (pipe(fd) == -1 || 
-      !fix_fd(fd[1]) ||
-      (read_noblock && !fix_fd(fd[0])))
+  if (pipe(fd) == -1 || !fix_fd(fd[1]) || (read_noblock && !fix_fd(fd[0])))
     die(_("cannot create pipe: %s"), NULL, EC_MISC);
 }
 
@@ -293,26 +297,25 @@
 
   if (!ret)
     my_syslog(LOG_ERR, _("failed to allocate %d bytes"), (int) size);
-  
+
   return ret;
 }
 
 int sockaddr_isequal(union mysockaddr *s1, union mysockaddr *s2)
 {
-  if (s1->sa.sa_family == s2->sa.sa_family)
-    { 
-      if (s1->sa.sa_family == AF_INET &&
-	  s1->in.sin_port == s2->in.sin_port &&
-	  s1->in.sin_addr.s_addr == s2->in.sin_addr.s_addr)
-	return 1;
-#ifdef HAVE_IPV6      
-      if (s1->sa.sa_family == AF_INET6 &&
-	  s1->in6.sin6_port == s2->in6.sin6_port &&
-	  s1->in6.sin6_scope_id == s2->in6.sin6_scope_id &&
-	  IN6_ARE_ADDR_EQUAL(&s1->in6.sin6_addr, &s2->in6.sin6_addr))
-	return 1;
+  if (s1->sa.sa_family == s2->sa.sa_family) {
+    if (s1->sa.sa_family == AF_INET &&
+        s1->in.sin_port == s2->in.sin_port &&
+        s1->in.sin_addr.s_addr == s2->in.sin_addr.s_addr)
+      return 1;
+#ifdef HAVE_IPV6
+    if (s1->sa.sa_family == AF_INET6 &&
+        s1->in6.sin6_port == s2->in6.sin6_port &&
+        s1->in6.sin6_scope_id == s2->in6.sin6_scope_id &&
+        IN6_ARE_ADDR_EQUAL(&s1->in6.sin6_addr, &s2->in6.sin6_addr))
+      return 1;
 #endif
-    }
+  }
   return 0;
 }
 
@@ -326,7 +329,7 @@
     return sizeof(addr->in6);
   else
 #endif
-    return sizeof(addr->in); 
+    return sizeof(addr->in);
 #endif
 }
 
@@ -334,20 +337,20 @@
 int hostname_isequal(const char *a, const char *b)
 {
   unsigned int c1, c2;
-  
+
   do {
     c1 = (unsigned char) *a++;
     c2 = (unsigned char) *b++;
-    
+
     if (c1 >= 'A' && c1 <= 'Z')
       c1 += 'a' - 'A';
     if (c2 >= 'A' && c2 <= 'Z')
       c2 += 'a' - 'A';
-    
+
     if (c1 != c2)
       return 0;
   } while (c1);
-  
+
   return 1;
 }
 
@@ -360,7 +363,7 @@
   if (tps == 0)
     tps = sysconf(_SC_CLK_TCK);
 
-  return (time_t)(times(&dummy)/tps);
+  return (time_t) (times(&dummy) / tps);
 #else
   return time(NULL);
 #endif
@@ -370,19 +373,18 @@
 {
   int zero_count = 0;
 
-  while (0x0 == (mask.s_addr & 0x1) && zero_count < 32) 
-    {
-      mask.s_addr >>= 1;
-      zero_count++;
-    }
-  
+  while (0x0 == (mask.s_addr & 0x1) && zero_count < 32) {
+    mask.s_addr >>= 1;
+    zero_count++;
+  }
+
   return 32 - zero_count;
 }
 
 int is_same_net(struct in_addr a, struct in_addr b, struct in_addr mask)
 {
   return (a.s_addr & mask.s_addr) == (b.s_addr & mask.s_addr);
-} 
+}
 
 #ifdef HAVE_IPV6
 int is_same_net6(struct in6_addr *a, struct in6_addr *b, int prefixlen)
@@ -394,14 +396,15 @@
     return 0;
 
   if (pfbits == 0 ||
-      (a->s6_addr[pfbytes] >> (8 - pfbits) == b->s6_addr[pfbytes] >> (8 - pfbits)))
+      (a->s6_addr[pfbytes] >> (8 - pfbits) ==
+       b->s6_addr[pfbytes] >> (8 - pfbits)))
     return 1;
 
   return 0;
 }
 
 /* return least significant 64 bits if IPv6 address */
-u64 addr6part(struct in6_addr *addr)
+u64 addr6part(struct in6_addr * addr)
 {
   int i;
   u64 ret = 0;
@@ -416,45 +419,40 @@
 {
   int i;
 
-  for (i = 15; i >= 8; i--)
-    {
-      addr->s6_addr[i] = host;
-      host = host >> 8;
-    }
+  for (i = 15; i >= 8; i--) {
+    addr->s6_addr[i] = host;
+    host = host >> 8;
+  }
 }
 
 #endif
- 
+
 
 /* returns port number from address */
 int prettyprint_addr(union mysockaddr *addr, char *buf)
 {
   int port = 0;
-  
+
 #ifdef HAVE_IPV6
-  if (addr->sa.sa_family == AF_INET)
-    {
-      inet_ntop(AF_INET, &addr->in.sin_addr, buf, ADDRSTRLEN);
-      port = ntohs(addr->in.sin_port);
-    }
-  else if (addr->sa.sa_family == AF_INET6)
-    {
-      char name[IF_NAMESIZE];
-      inet_ntop(AF_INET6, &addr->in6.sin6_addr, buf, ADDRSTRLEN);
-      if (addr->in6.sin6_scope_id != 0 &&
-	  if_indextoname(addr->in6.sin6_scope_id, name) &&
-	  strlen(buf) + strlen(name) + 2 <= ADDRSTRLEN)
-	{
-	  strcat(buf, "%");
-	  strcat(buf, name);
-	}
-      port = ntohs(addr->in6.sin6_port);
+  if (addr->sa.sa_family == AF_INET) {
+    inet_ntop(AF_INET, &addr->in.sin_addr, buf, ADDRSTRLEN);
+    port = ntohs(addr->in.sin_port);
+  } else if (addr->sa.sa_family == AF_INET6) {
+    char name[IF_NAMESIZE];
+    inet_ntop(AF_INET6, &addr->in6.sin6_addr, buf, ADDRSTRLEN);
+    if (addr->in6.sin6_scope_id != 0 &&
+        if_indextoname(addr->in6.sin6_scope_id, name) &&
+        strlen(buf) + strlen(name) + 2 <= ADDRSTRLEN) {
+      strcat(buf, "%");
+      strcat(buf, name);
     }
+    port = ntohs(addr->in6.sin6_port);
+  }
 #else
   strcpy(buf, inet_ntoa(addr->in.sin_addr));
-  port = ntohs(addr->in.sin_port); 
+  port = ntohs(addr->in.sin_port);
 #endif
-  
+
   return port;
 }
 
@@ -462,85 +460,74 @@
 {
   if (t == 0xffffffff)
     sprintf(buf, _("infinite"));
-  else
-    {
-      unsigned int x, p = 0;
-       if ((x = t/86400))
-	p += sprintf(&buf[p], "%ud", x);
-       if ((x = (t/3600)%24))
-	p += sprintf(&buf[p], "%uh", x);
-      if ((x = (t/60)%60))
-	p += sprintf(&buf[p], "%um", x);
-      if ((x = t%60))
-	p += sprintf(&buf[p], "%us", x);
-    }
+  else {
+    unsigned int x, p = 0;
+    if ((x = t / 86400))
+      p += sprintf(&buf[p], "%ud", x);
+    if ((x = (t / 3600) % 24))
+      p += sprintf(&buf[p], "%uh", x);
+    if ((x = (t / 60) % 60))
+      p += sprintf(&buf[p], "%um", x);
+    if ((x = t % 60))
+      p += sprintf(&buf[p], "%us", x);
+  }
 }
 
 
 /* in may equal out, when maxlen may be -1 (No max len). 
    Return -1 for extraneous no-hex chars found. */
-int parse_hex(char *in, unsigned char *out, int maxlen, 
-	      unsigned int *wildcard_mask, int *mac_type)
+int parse_hex(char *in, unsigned char *out, int maxlen,
+              unsigned int *wildcard_mask, int *mac_type)
 {
   int mask = 0, i = 0;
   char *r;
-    
+
   if (mac_type)
     *mac_type = 0;
-  
-  while (maxlen == -1 || i < maxlen)
-    {
-      for (r = in; *r != 0 && *r != ':' && *r != '-' && *r != ' '; r++)
-	if (*r != '*' && !isxdigit((unsigned char)*r))
-	  return -1;
-      
-      if (*r == 0)
-	maxlen = i;
-      
-      if (r != in )
-	{
-	  if (*r == '-' && i == 0 && mac_type)
-	   {
-	      *r = 0;
-	      *mac_type = strtol(in, NULL, 16);
-	      mac_type = NULL;
-	   }
-	  else
-	    {
-	      *r = 0;
-	      if (strcmp(in, "*") == 0)
-		{
-		  mask = (mask << 1) | 1;
-		  i++;
-		}
-	      else
-		{
-		  int j, bytes = (1 + (r - in))/2;
-		  for (j = 0; j < bytes; j++)
-		    { 
-		      char sav = sav;
-		      if (j < bytes - 1)
-			{
-			  sav = in[(j+1)*2];
-			  in[(j+1)*2] = 0;
-			}
-		      /* checks above allow mix of hexdigit and *, which
-			 is illegal. */
-		      if (strchr(&in[j*2], '*'))
-			return -1;
-		      out[i] = strtol(&in[j*2], NULL, 16);
-		      mask = mask << 1;
-		      if (++i == maxlen)
-			break; 
-		      if (j < bytes - 1)
-			in[(j+1)*2] = sav;
-		    }
-		}
-	    }
-	}
-      in = r+1;
+
+  while (maxlen == -1 || i < maxlen) {
+    for (r = in; *r != 0 && *r != ':' && *r != '-' && *r != ' '; r++)
+      if (*r != '*' && !isxdigit((unsigned char) *r))
+        return -1;
+
+    if (*r == 0)
+      maxlen = i;
+
+    if (r != in) {
+      if (*r == '-' && i == 0 && mac_type) {
+        *r = 0;
+        *mac_type = strtol(in, NULL, 16);
+        mac_type = NULL;
+      } else {
+        *r = 0;
+        if (strcmp(in, "*") == 0) {
+          mask = (mask << 1) | 1;
+          i++;
+        } else {
+          int j, bytes = (1 + (r - in)) / 2;
+          for (j = 0; j < bytes; j++) {
+            char sav = sav;
+            if (j < bytes - 1) {
+              sav = in[(j + 1) * 2];
+              in[(j + 1) * 2] = 0;
+            }
+            /* checks above allow mix of hexdigit and *, which
+               is illegal. */
+            if (strchr(&in[j * 2], '*'))
+              return -1;
+            out[i] = strtol(&in[j * 2], NULL, 16);
+            mask = mask << 1;
+            if (++i == maxlen)
+              break;
+            if (j < bytes - 1)
+              in[(j + 1) * 2] = sav;
+          }
+        }
+      }
     }
-  
+    in = r + 1;
+  }
+
   if (wildcard_mask)
     *wildcard_mask = mask;
 
@@ -548,17 +535,17 @@
 }
 
 /* return 0 for no match, or (no matched octets) + 1 */
-int memcmp_masked(unsigned char *a, unsigned char *b, int len, unsigned int mask)
+int memcmp_masked(unsigned char *a, unsigned char *b, int len,
+                  unsigned int mask)
 {
   int i, count;
   for (count = 1, i = len - 1; i >= 0; i--, mask = mask >> 1)
-    if (!(mask & 1))
-      {
-	if (a[i] == b[i])
-	  count++;
-	else
-	  return 0;
-      }
+    if (!(mask & 1)) {
+      if (a[i] == b[i])
+        count++;
+      else
+        return 0;
+    }
   return count;
 }
 
@@ -567,20 +554,18 @@
 {
   void *new;
 
-  if (size <= (size_t)iov->iov_len)
+  if (size <= (size_t) iov->iov_len)
     return 1;
 
-  if (!(new = whine_malloc(size)))
-    {
-      errno = ENOMEM;
-      return 0;
-    }
+  if (!(new = whine_malloc(size))) {
+    errno = ENOMEM;
+    return 0;
+  }
 
-  if (iov->iov_base)
-    {
-      memcpy(new, iov->iov_base, iov->iov_len);
-      free(iov->iov_base);
-    }
+  if (iov->iov_base) {
+    memcpy(new, iov->iov_base, iov->iov_len);
+    free(iov->iov_base);
+  }
 
   iov->iov_base = new;
   iov->iov_len = size;
@@ -592,13 +577,13 @@
 {
   char *p = buff;
   int i;
-   
+
   if (len == 0)
     sprintf(p, "<null>");
   else
     for (i = 0; i < len; i++)
       p += sprintf(p, "%.2x%s", mac[i], (i == len - 1) ? "" : ":");
-  
+
   return buff;
 }
 
@@ -609,93 +594,88 @@
 {
   static int retries = 0;
   struct timespec waiter;
-  
-  if (rc != -1)
-    {
-      retries = 0;
-      errno = 0;
-      return 0;
-    }
-  
+
+  if (rc != -1) {
+    retries = 0;
+    errno = 0;
+    return 0;
+  }
+
   /* Linux kernels can return EAGAIN in perpetuity when calling
      sendmsg() and the relevant interface has gone. Here we loop
      retrying in EAGAIN for 1 second max, to avoid this hanging 
      dnsmasq. */
 
-  if (errno == EAGAIN || errno == EWOULDBLOCK)
-     {
-       waiter.tv_sec = 0;
-       waiter.tv_nsec = 10000;
-       nanosleep(&waiter, NULL);
-       if (retries++ < 1000)
-	 return 1;
-     }
-  
+  if (errno == EAGAIN || errno == EWOULDBLOCK) {
+    waiter.tv_sec = 0;
+    waiter.tv_nsec = 10000;
+    nanosleep(&waiter, NULL);
+    if (retries++ < 1000)
+      return 1;
+  }
+
   retries = 0;
-  
+
   if (errno == EINTR)
     return 1;
-  
+
   return 0;
 }
 
 int read_write(int fd, unsigned char *packet, int size, int rw)
 {
   ssize_t n, done;
-  
-  for (done = 0; done < size; done += n)
-    {
-      do { 
-	if (rw)
-	  n = read(fd, &packet[done], (size_t)(size - done));
-	else
-	  n = write(fd, &packet[done], (size_t)(size - done));
-	
-	if (n == 0)
-	  return 0;
-	
-      } while (retry_send(n) || errno == ENOMEM || errno == ENOBUFS);
 
-      if (errno != 0)
-	return 0;
-    }
-     
+  for (done = 0; done < size; done += n) {
+    do {
+      if (rw)
+        n = read(fd, &packet[done], (size_t) (size - done));
+      else
+        n = write(fd, &packet[done], (size_t) (size - done));
+
+      if (n == 0)
+        return 0;
+
+    } while (retry_send(n) || errno == ENOMEM || errno == ENOBUFS);
+
+    if (errno != 0)
+      return 0;
+  }
+
   return 1;
 }
 
 /* Basically match a string value against a wildcard pattern.  */
-int wildcard_match(const char* wildcard, const char* match)
+int wildcard_match(const char *wildcard, const char *match)
 {
-  while (*wildcard && *match)
-    {
-      if (*wildcard == '*')
-        return 1;
+  while (*wildcard && *match) {
+    if (*wildcard == '*')
+      return 1;
 
-      if (*wildcard != *match)
-        return 0; 
+    if (*wildcard != *match)
+      return 0;
 
-      ++wildcard;
-      ++match;
-    }
+    ++wildcard;
+    ++match;
+  }
 
   return *wildcard == *match;
 }
 
 /* The same but comparing a maximum of NUM characters, like strncmp.  */
-int wildcard_matchn(const char* wildcard, const char* match, int num)
+int wildcard_matchn(const char *wildcard, const char *match, int num)
 {
-  while (*wildcard && *match && num)
-    {
-      if (*wildcard == '*')
-        return 1;
-
-      if (*wildcard != *match)
-        return 0; 
-
-      ++wildcard;
-      ++match;
-      --num;
-    }
+  while (*wildcard && *match && num) {
+    if (*wildcard == '*')
+      return 1;
+
+    if (*wildcard != *match)
+      return 0;
+
+    ++wildcard;
+    ++match;
+    --num;
+  }
 
   return (!num) || (*wildcard == *match);
 }
